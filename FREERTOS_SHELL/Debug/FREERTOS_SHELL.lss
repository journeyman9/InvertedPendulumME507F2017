
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003a98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000092  00802000  00003a98  00003b2c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010aa  00802092  00802092  00003bbe  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003bbe  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003bf0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000620  00000000  00000000  00003c30  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000ffcb  00000000  00000000  00004250  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006e0c  00000000  00000000  0001421b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004821  00000000  00000000  0001b027  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000011a0  00000000  00000000  0001f848  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000069e7  00000000  00000000  000209e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005568  00000000  00000000  000273cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000518  00000000  00000000  0002c937  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a3 02 	jmp	0x546	; 0x546 <__ctors_end>
       4:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
       8:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
       c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      10:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      14:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      18:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      1c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      20:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      24:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      28:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      2c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      30:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      34:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      38:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      3c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      40:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      44:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      48:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      4c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      50:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      54:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      58:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      5c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      60:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      64:	0c 94 01 19 	jmp	0x3202	; 0x3202 <__vector_25>
      68:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      6c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      70:	0c 94 5f 19 	jmp	0x32be	; 0x32be <__vector_28>
      74:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      78:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      7c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      80:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      84:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      88:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      8c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      90:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      94:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      98:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      9c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      a0:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      a4:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      a8:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      ac:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      b0:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      b4:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      b8:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      bc:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      c0:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      c4:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      c8:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      cc:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      d0:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      d4:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      d8:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      dc:	0c 94 df 08 	jmp	0x11be	; 0x11be <__vector_55>
      e0:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      e4:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      e8:	0c 94 79 1a 	jmp	0x34f2	; 0x34f2 <__vector_58>
      ec:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      f0:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      f4:	0c 94 d7 1a 	jmp	0x35ae	; 0x35ae <__vector_61>
      f8:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
      fc:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     100:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     104:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     108:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     10c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     110:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     114:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     118:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     11c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     120:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     124:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     128:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     12c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     130:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     134:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     138:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     13c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     140:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     144:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     148:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     14c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     150:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     154:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     158:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     15c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     160:	0c 94 bd 19 	jmp	0x337a	; 0x337a <__vector_88>
     164:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     168:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     16c:	0c 94 1b 1a 	jmp	0x3436	; 0x3436 <__vector_91>
     170:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     174:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     178:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     17c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     180:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     184:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     188:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     18c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     190:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     194:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     198:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     19c:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1a0:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1a4:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1a8:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1ac:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1b0:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1b4:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1b8:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1bc:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1c0:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1c4:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1c8:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1cc:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1d0:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1d4:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1d8:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1dc:	0c 94 35 1b 	jmp	0x366a	; 0x366a <__vector_119>
     1e0:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1e4:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1e8:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1ec:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1f0:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1f4:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1f8:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <__bad_interrupt>
     1fc:	cb 16       	cp	r12, r27
     1fe:	ce 16       	cp	r12, r30
     200:	d1 16       	cp	r13, r17
     202:	d4 16       	cp	r13, r20
     204:	d7 16       	cp	r13, r23
     206:	da 16       	cp	r13, r26
     208:	dc 16       	cp	r13, r28
     20a:	ed 16       	cp	r14, r29
     20c:	f5 16       	cp	r15, r21
     20e:	ff 16       	cp	r15, r31
     210:	fd 16       	cp	r15, r29

00000212 <__trampolines_start>:
     212:	0c 94 dc 13 	jmp	0x27b8	; 0x27b8 <_ZN14frt_text_queue7getcharEv>
     216:	0c 94 cb 16 	jmp	0x2d96	; 0x2d96 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     21a:	0c 94 ed 16 	jmp	0x2dda	; 0x2dda <_ZN8emstreamlsE15ser_manipulator+0x62>
     21e:	0c 94 ff 16 	jmp	0x2dfe	; 0x2dfe <_ZN8emstreamlsE15ser_manipulator+0x86>
     222:	0c 94 1d 18 	jmp	0x303a	; 0x303a <_ZN5rs2327getcharEv>
     226:	0c 94 63 0b 	jmp	0x16c6	; 0x16c6 <prvIdleTask>
     22a:	0c 94 fa 13 	jmp	0x27f4	; 0x27f4 <_ZN14frt_text_queue14check_for_charEv>
     22e:	0c 94 f9 17 	jmp	0x2ff2	; 0x2ff2 <_ZN5rs2327putcharEc>
     232:	0c 94 43 18 	jmp	0x3086	; 0x3086 <_ZN5rs23214check_for_charEv>
     236:	0c 94 a0 02 	jmp	0x540	; 0x540 <_call_static_run_method>
     23a:	0c 94 bd 15 	jmp	0x2b7a	; 0x2b7a <__cxa_pure_virtual>
     23e:	0c 94 fd 16 	jmp	0x2dfa	; 0x2dfa <_ZN8emstreamlsE15ser_manipulator+0x82>
     242:	0c 94 f5 16 	jmp	0x2dea	; 0x2dea <_ZN8emstreamlsE15ser_manipulator+0x72>
     246:	0c 94 d1 16 	jmp	0x2da2	; 0x2da2 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     24a:	0c 94 92 12 	jmp	0x2524	; 0x2524 <_ZN8frt_task12print_statusER8emstream>
     24e:	0c 94 56 18 	jmp	0x30ac	; 0x30ac <_ZN5rs23212clear_screenEv>
     252:	0c 94 d7 16 	jmp	0x2dae	; 0x2dae <_ZN8emstreamlsE15ser_manipulator+0x36>
     256:	0c 94 70 16 	jmp	0x2ce0	; 0x2ce0 <_ZN8emstream7getcharEv>
     25a:	0c 94 73 16 	jmp	0x2ce6	; 0x2ce6 <_ZN8emstream14check_for_charEv>
     25e:	0c 94 b9 04 	jmp	0x972	; 0x972 <_ZN9task_user3runEv>
     262:	0c 94 75 16 	jmp	0x2cea	; 0x2cea <_ZN8emstream12transmit_nowEv>
     266:	0c 94 ce 16 	jmp	0x2d9c	; 0x2d9c <_ZN8emstreamlsE15ser_manipulator+0x24>
     26a:	0c 94 1c 1c 	jmp	0x3838	; 0x3838 <_GLOBAL__sub_I_counter>
     26e:	0c 94 76 16 	jmp	0x2cec	; 0x2cec <_ZN8emstream12clear_screenEv>
     272:	0c 94 db 02 	jmp	0x5b6	; 0x5b6 <_ZN12EncoderMotor3runEv>
     276:	0c 94 dc 16 	jmp	0x2db8	; 0x2db8 <_ZN8emstreamlsE15ser_manipulator+0x40>
     27a:	0c 94 da 16 	jmp	0x2db4	; 0x2db4 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     27e:	0c 94 44 03 	jmp	0x688	; 0x688 <_ZN13LimitSwitches3runEv>
     282:	0c 94 6e 16 	jmp	0x2cdc	; 0x2cdc <_ZN8emstream13ready_to_sendEv>
     286:	0c 94 05 14 	jmp	0x280a	; 0x280a <_ZN14frt_text_queue7putcharEc>
     28a:	0c 94 d4 16 	jmp	0x2da8	; 0x2da8 <_ZN8emstreamlsE15ser_manipulator+0x30>

0000028e <__trampolines_end>:
     28e:	2c 20       	and	r2, r12
     290:	54 43       	sbci	r21, 0x34	; 52
     292:	43 30       	cpi	r20, 0x03	; 3
     294:	43 43       	sbci	r20, 0x33	; 51
     296:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000299 <_ZZN9task_user11show_statusEvE3__c_3>:
     299:	2f 00                                               /.

0000029b <_ZZN9task_user11show_statusEvE3__c_2>:
     29b:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002a9 <_ZZN9task_user11show_statusEvE3__c_1>:
     2a9:	54 69 6d 65 3a 20 00                                Time: .

000002b0 <_ZZN9task_user11show_statusEvE3__c_0>:
     2b0:	4e 6f 76 20 32 35 20 32 30 31 37 00                 Nov 25 2017.

000002bc <_ZZN9task_user11show_statusEvE3__c>:
     2bc:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2cc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002db <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2db:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002ea <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2ea:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     2fa:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000305 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     305:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     315:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000323 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     323:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     333:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     343:	6d 61 74 69 6f 6e 00                                mation.

0000034a <_ZZN9task_user18print_help_messageEvE3__c_6>:
     34a:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     35a:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000036b <_ZZN9task_user18print_help_messageEvE3__c_5>:
     36b:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     37b:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000383 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     383:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     393:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

0000039f <_ZZN9task_user18print_help_messageEvE3__c_3>:
     39f:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3af:	68 65 20 41 56 52 00                                he AVR.

000003b6 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3b6:	20 68 65 6c 70 00                                    help.

000003bc <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3bc:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3cc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003db <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3db:	1b 5b 33 30 6d 00                                   .[30m.

000003e1 <_ZZN9task_user18print_help_messageEvE3__c>:
     3e1:	1b 5b 34 36 6d 00                                   .[46m.

000003e7 <_ZZN9task_user3runEvE3__c_3>:
     3e7:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     3f7:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000404 <_ZZN9task_user3runEvE3__c_2>:
     404:	3a 57 54 46 3f 00                                   :WTF?.

0000040a <_ZZN9task_user3runEvE3__c_1>:
     40a:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     41a:	65 00                                               e.

0000041c <_ZZN9task_user3runEvE3__c_0>:
     41c:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000042a <_ZZN9task_user3runEvE3__c>:
     42a:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     43a:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000448 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     448:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000452 <_ZZN8frt_task15emergency_resetEvE3__c>:
     452:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000461 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     461:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     471:	61 73 6b 20 00                                      ask .

00000476 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     476:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000484 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     484:	20 63 72 65 61 74 65 64 00                           created.

0000048d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     48d:	54 61 73 6b 20 00                                   Task .

00000493 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     493:	1b 5b 32 32 6d 00                                   .[22m.

00000499 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     499:	54 61 73 6b 3a 20 00                                Task: .

000004a0 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4a0:	1b 5b 31 6d 00                                      .[1m.

000004a5 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4a5:	1b 5b 32 32 6d 00                                   .[22m.

000004ab <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4ab:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004b6 <_ZZ17print_task_stacksP8emstreamE3__c>:
     4b6:	1b 5b 31 6d 00                                      .[1m.

000004bb <_ZZ15print_task_listP8emstreamE3__c_9>:
     4bb:	09 09 00                                            ...

000004be <_ZZ15print_task_listP8emstreamE3__c_8>:
     4be:	2f 00                                               /.

000004c0 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4c0:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004cb <_ZZ15print_task_listP8emstreamE3__c_6>:
     4cb:	09 2d 2d 2d 2d 00                                   .----.

000004d1 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4d1:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004dd <_ZZ15print_task_listP8emstreamE3__c_4>:
     4dd:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004ee <_ZZ15print_task_listP8emstreamE3__c_3>:
     4ee:	09 52 75 6e 73 00                                   .Runs.

000004f4 <_ZZ15print_task_listP8emstreamE3__c_2>:
     4f4:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000500 <_ZZ15print_task_listP8emstreamE3__c_1>:
     500:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000511 <_ZZ15print_task_listP8emstreamE3__c_0>:
     511:	09 53 74 61 63 6b 00                                .Stack.

00000518 <_ZZ15print_task_listP8emstreamE3__c>:
     518:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000523 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     523:	09 00                                               ..

00000525 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     525:	09 00                                               ..

00000527 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     527:	2f 00                                               /.

00000529 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     529:	09 00                                               ..

0000052b <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     52b:	09 00                                               ..

0000052d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     52d:	1b 5b 32 32 6d 00                                   .[22m.

00000533 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     533:	1b 5b 31 6d 00                                      .[1m.

00000538 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     538:	1b 5b 31 6d 00                                      .[1m.

0000053d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     53d:	20 20 00                                              .

00000540 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     540:	0e 94 2a 11 	call	0x2254	; 0x2254 <_ZN8frt_task22_call_users_run_methodEPS_>

00000544 <__ctors_start>:
     544:	1c 1c       	adc	r1, r12

00000546 <__ctors_end>:
     546:	11 24       	eor	r1, r1
     548:	1f be       	out	0x3f, r1	; 63
     54a:	cf ef       	ldi	r28, 0xFF	; 255
     54c:	cd bf       	out	0x3d, r28	; 61
     54e:	df e3       	ldi	r29, 0x3F	; 63
     550:	de bf       	out	0x3e, r29	; 62
     552:	00 e0       	ldi	r16, 0x00	; 0
     554:	0c bf       	out	0x3c, r16	; 60
     556:	18 be       	out	0x38, r1	; 56
     558:	19 be       	out	0x39, r1	; 57
     55a:	1a be       	out	0x3a, r1	; 58
     55c:	1b be       	out	0x3b, r1	; 59

0000055e <__do_copy_data>:
     55e:	10 e2       	ldi	r17, 0x20	; 32
     560:	a0 e0       	ldi	r26, 0x00	; 0
     562:	b0 e2       	ldi	r27, 0x20	; 32
     564:	e8 e9       	ldi	r30, 0x98	; 152
     566:	fa e3       	ldi	r31, 0x3A	; 58
     568:	00 e0       	ldi	r16, 0x00	; 0
     56a:	0b bf       	out	0x3b, r16	; 59
     56c:	02 c0       	rjmp	.+4      	; 0x572 <__do_copy_data+0x14>
     56e:	07 90       	elpm	r0, Z+
     570:	0d 92       	st	X+, r0
     572:	a2 39       	cpi	r26, 0x92	; 146
     574:	b1 07       	cpc	r27, r17
     576:	d9 f7       	brne	.-10     	; 0x56e <__do_copy_data+0x10>
     578:	1b be       	out	0x3b, r1	; 59

0000057a <__do_clear_bss>:
     57a:	21 e3       	ldi	r18, 0x31	; 49
     57c:	a2 e9       	ldi	r26, 0x92	; 146
     57e:	b0 e2       	ldi	r27, 0x20	; 32
     580:	01 c0       	rjmp	.+2      	; 0x584 <.do_clear_bss_start>

00000582 <.do_clear_bss_loop>:
     582:	1d 92       	st	X+, r1

00000584 <.do_clear_bss_start>:
     584:	ac 33       	cpi	r26, 0x3C	; 60
     586:	b2 07       	cpc	r27, r18
     588:	e1 f7       	brne	.-8      	; 0x582 <.do_clear_bss_loop>

0000058a <__do_global_ctors>:
     58a:	12 e0       	ldi	r17, 0x02	; 2
     58c:	c3 ea       	ldi	r28, 0xA3	; 163
     58e:	d2 e0       	ldi	r29, 0x02	; 2
     590:	00 e0       	ldi	r16, 0x00	; 0
     592:	06 c0       	rjmp	.+12     	; 0x5a0 <__do_global_ctors+0x16>
     594:	21 97       	sbiw	r28, 0x01	; 1
     596:	01 09       	sbc	r16, r1
     598:	80 2f       	mov	r24, r16
     59a:	fe 01       	movw	r30, r28
     59c:	0e 94 92 1c 	call	0x3924	; 0x3924 <__tablejump2__>
     5a0:	c2 3a       	cpi	r28, 0xA2	; 162
     5a2:	d1 07       	cpc	r29, r17
     5a4:	80 e0       	ldi	r24, 0x00	; 0
     5a6:	08 07       	cpc	r16, r24
     5a8:	a9 f7       	brne	.-22     	; 0x594 <__do_global_ctors+0xa>
     5aa:	0e 94 a8 1b 	call	0x3750	; 0x3750 <main>
     5ae:	0c 94 4a 1d 	jmp	0x3a94	; 0x3a94 <_exit>

000005b2 <__bad_interrupt>:
     5b2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005b6 <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5b6:	cf 93       	push	r28
     5b8:	df 93       	push	r29
     5ba:	00 d0       	rcall	.+0      	; 0x5bc <_ZN12EncoderMotor3runEv+0x6>
     5bc:	1f 92       	push	r1
     5be:	cd b7       	in	r28, 0x3d	; 61
     5c0:	de b7       	in	r29, 0x3e	; 62
     5c2:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5c4:	0e 94 02 0d 	call	0x1a04	; 0x1a04 <xTaskGetTickCount>
     5c8:	69 83       	std	Y+1, r22	; 0x01
     5ca:	7a 83       	std	Y+2, r23	; 0x02
     5cc:	8b 83       	std	Y+3, r24	; 0x03
     5ce:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTC.DIRCLR = PIN0_bm | PIN1_bm;										// Set both CHa and CHb for input
     5d0:	e0 e4       	ldi	r30, 0x40	; 64
     5d2:	f6 e0       	ldi	r31, 0x06	; 6
     5d4:	83 e0       	ldi	r24, 0x03	; 3
     5d6:	82 83       	std	Z+2, r24	; 0x02
	PORTC.PIN0CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5d8:	80 89       	ldd	r24, Z+16	; 0x10
     5da:	83 60       	ori	r24, 0x03	; 3
     5dc:	80 8b       	std	Z+16, r24	; 0x10
	PORTC.PIN1CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5de:	81 89       	ldd	r24, Z+17	; 0x11
     5e0:	83 60       	ori	r24, 0x03	; 3
     5e2:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTC_PIN0_gc;								// Configure CHa as a multiplexer input for event channel 0
     5e4:	e0 e8       	ldi	r30, 0x80	; 128
     5e6:	f1 e0       	ldi	r31, 0x01	; 1
     5e8:	80 e6       	ldi	r24, 0x60	; 96
     5ea:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5ec:	89 e0       	ldi	r24, 0x09	; 9
     5ee:	80 87       	std	Z+8, r24	; 0x08
	
	TCC0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5f0:	e0 e0       	ldi	r30, 0x00	; 0
     5f2:	f8 e0       	ldi	r31, 0x08	; 8
     5f4:	88 e6       	ldi	r24, 0x68	; 104
     5f6:	83 83       	std	Z+3, r24	; 0x03
	TCC0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     5f8:	8f ef       	ldi	r24, 0xFF	; 255
     5fa:	9f ef       	ldi	r25, 0xFF	; 255
     5fc:	86 a3       	std	Z+38, r24	; 0x26
     5fe:	97 a3       	std	Z+39, r25	; 0x27
	TCC0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     600:	81 e0       	ldi	r24, 0x01	; 1
     602:	80 83       	st	Z, r24
	int16_t AngularVelocity;
	float x_calc;
	int16_t x;

	while(1){
		encoder_count = TCC0.CNT;											// get count
     604:	c1 2c       	mov	r12, r1
     606:	68 94       	set
     608:	dd 24       	eor	r13, r13
     60a:	d3 f8       	bld	r13, 3
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     60c:	0f 2e       	mov	r0, r31
     60e:	f4 e6       	ldi	r31, 0x64	; 100
     610:	ef 2e       	mov	r14, r31
     612:	f1 2c       	mov	r15, r1
     614:	f0 2d       	mov	r31, r0
     616:	f6 01       	movw	r30, r12
     618:	80 a1       	ldd	r24, Z+32	; 0x20
     61a:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     61c:	0f b6       	in	r0, 0x3f	; 63
     61e:	f8 94       	cli
     620:	0f 92       	push	r0
			the_data = new_data;
     622:	9c 01       	movw	r18, r24
     624:	22 0f       	add	r18, r18
     626:	33 1f       	adc	r19, r19
     628:	82 0f       	add	r24, r18
     62a:	93 1f       	adc	r25, r19
     62c:	b7 01       	movw	r22, r14
     62e:	0e 94 3d 1c 	call	0x387a	; 0x387a <__divmodhi4>
     632:	60 93 28 31 	sts	0x3128, r22	; 0x803128 <linear_position>
     636:	70 93 29 31 	sts	0x3129, r23	; 0x803129 <linear_position+0x1>
			portEXIT_CRITICAL ();
     63a:	0f 90       	pop	r0
     63c:	0f be       	out	0x3f, r0	; 63
			motor_enc_zero = false;
		}
		*/
		
		// Increment counter for debugging
		runs++;
     63e:	f8 01       	movw	r30, r16
     640:	86 85       	ldd	r24, Z+14	; 0x0e
     642:	97 85       	ldd	r25, Z+15	; 0x0f
     644:	a0 89       	ldd	r26, Z+16	; 0x10
     646:	b1 89       	ldd	r27, Z+17	; 0x11
     648:	01 96       	adiw	r24, 0x01	; 1
     64a:	a1 1d       	adc	r26, r1
     64c:	b1 1d       	adc	r27, r1
     64e:	86 87       	std	Z+14, r24	; 0x0e
     650:	97 87       	std	Z+15, r25	; 0x0f
     652:	a0 8b       	std	Z+16, r26	; 0x10
     654:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     656:	41 e0       	ldi	r20, 0x01	; 1
     658:	50 e0       	ldi	r21, 0x00	; 0
     65a:	60 e0       	ldi	r22, 0x00	; 0
     65c:	70 e0       	ldi	r23, 0x00	; 0
     65e:	ce 01       	movw	r24, r28
     660:	01 96       	adiw	r24, 0x01	; 1
     662:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <vTaskDelayUntil>
     666:	d7 cf       	rjmp	.-82     	; 0x616 <_ZN12EncoderMotor3runEv+0x60>

00000668 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "UserInterface.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
*/


EncoderMotor::EncoderMotor(const char* a_name,
     668:	0f 93       	push	r16
     66a:	1f 93       	push	r17
     66c:	cf 93       	push	r28
     66e:	df 93       	push	r29
     670:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     672:	0e 94 3d 11 	call	0x227a	; 0x227a <_ZN8frt_taskC1EPKchjP8emstream>
     676:	8a e0       	ldi	r24, 0x0A	; 10
     678:	90 e2       	ldi	r25, 0x20	; 32
     67a:	88 83       	st	Y, r24
     67c:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     67e:	df 91       	pop	r29
     680:	cf 91       	pop	r28
     682:	1f 91       	pop	r17
     684:	0f 91       	pop	r16
     686:	08 95       	ret

00000688 <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     688:	cf 93       	push	r28
     68a:	df 93       	push	r29
     68c:	00 d0       	rcall	.+0      	; 0x68e <_ZN13LimitSwitches3runEv+0x6>
     68e:	1f 92       	push	r1
     690:	cd b7       	in	r28, 0x3d	; 61
     692:	de b7       	in	r29, 0x3e	; 62
     694:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     696:	0e 94 02 0d 	call	0x1a04	; 0x1a04 <xTaskGetTickCount>
     69a:	69 83       	std	Y+1, r22	; 0x01
     69c:	7a 83       	std	Y+2, r23	; 0x02
     69e:	8b 83       	std	Y+3, r24	; 0x03
     6a0:	9c 83       	std	Y+4, r25	; 0x04

	while(1){
		// Increment counter for debugging
		runs++;
     6a2:	f8 01       	movw	r30, r16
     6a4:	86 85       	ldd	r24, Z+14	; 0x0e
     6a6:	97 85       	ldd	r25, Z+15	; 0x0f
     6a8:	a0 89       	ldd	r26, Z+16	; 0x10
     6aa:	b1 89       	ldd	r27, Z+17	; 0x11
     6ac:	01 96       	adiw	r24, 0x01	; 1
     6ae:	a1 1d       	adc	r26, r1
     6b0:	b1 1d       	adc	r27, r1
     6b2:	86 87       	std	Z+14, r24	; 0x0e
     6b4:	97 87       	std	Z+15, r25	; 0x0f
     6b6:	a0 8b       	std	Z+16, r26	; 0x10
     6b8:	b1 8b       	std	Z+17, r27	; 0x11
     6ba:	41 e0       	ldi	r20, 0x01	; 1
     6bc:	50 e0       	ldi	r21, 0x00	; 0
     6be:	60 e0       	ldi	r22, 0x00	; 0
     6c0:	70 e0       	ldi	r23, 0x00	; 0
     6c2:	ce 01       	movw	r24, r28
     6c4:	01 96       	adiw	r24, 0x01	; 1
     6c6:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <vTaskDelayUntil>
     6ca:	eb cf       	rjmp	.-42     	; 0x6a2 <_ZN13LimitSwitches3runEv+0x1a>

000006cc <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "UserInterface.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
*/


LimitSwitches::LimitSwitches(const char* a_name,
     6cc:	0f 93       	push	r16
     6ce:	1f 93       	push	r17
     6d0:	cf 93       	push	r28
     6d2:	df 93       	push	r29
     6d4:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     6d6:	0e 94 3d 11 	call	0x227a	; 0x227a <_ZN8frt_taskC1EPKchjP8emstream>
     6da:	82 e1       	ldi	r24, 0x12	; 18
     6dc:	90 e2       	ldi	r25, 0x20	; 32
     6de:	88 83       	st	Y, r24
     6e0:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     6e2:	df 91       	pop	r29
     6e4:	cf 91       	pop	r28
     6e6:	1f 91       	pop	r17
     6e8:	0f 91       	pop	r16
     6ea:	08 95       	ret

000006ec <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     6ec:	0f 93       	push	r16
     6ee:	1f 93       	push	r17
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     6f6:	0e 94 3d 11 	call	0x227a	; 0x227a <_ZN8frt_taskC1EPKchjP8emstream>
     6fa:	8a e1       	ldi	r24, 0x1A	; 26
     6fc:	90 e2       	ldi	r25, 0x20	; 32
     6fe:	88 83       	st	Y, r24
     700:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     702:	df 91       	pop	r29
     704:	cf 91       	pop	r28
     706:	1f 91       	pop	r17
     708:	0f 91       	pop	r16
     70a:	08 95       	ret

0000070c <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     70c:	0f 93       	push	r16
     70e:	1f 93       	push	r17
     710:	cf 93       	push	r28
     712:	df 93       	push	r29
     714:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     716:	6a e0       	ldi	r22, 0x0A	; 10
     718:	8e 81       	ldd	r24, Y+6	; 0x06
     71a:	9f 81       	ldd	r25, Y+7	; 0x07
     71c:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     720:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     722:	61 ee       	ldi	r22, 0xE1	; 225
     724:	73 e0       	ldi	r23, 0x03	; 3
     726:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     72a:	6a e0       	ldi	r22, 0x0A	; 10
     72c:	c8 01       	movw	r24, r16
     72e:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     732:	8c 01       	movw	r16, r24
     734:	6b ed       	ldi	r22, 0xDB	; 219
     736:	73 e0       	ldi	r23, 0x03	; 3
     738:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     73c:	67 e0       	ldi	r22, 0x07	; 7
     73e:	c8 01       	movw	r24, r16
     740:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     744:	6a e0       	ldi	r22, 0x0A	; 10
     746:	8e 81       	ldd	r24, Y+6	; 0x06
     748:	9f 81       	ldd	r25, Y+7	; 0x07
     74a:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     74e:	8c 01       	movw	r16, r24
     750:	6c eb       	ldi	r22, 0xBC	; 188
     752:	73 e0       	ldi	r23, 0x03	; 3
     754:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     758:	6a e0       	ldi	r22, 0x0A	; 10
     75a:	c8 01       	movw	r24, r16
     75c:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     760:	8c 01       	movw	r16, r24
     762:	66 eb       	ldi	r22, 0xB6	; 182
     764:	73 e0       	ldi	r23, 0x03	; 3
     766:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     76a:	66 e0       	ldi	r22, 0x06	; 6
     76c:	c8 01       	movw	r24, r16
     76e:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     772:	6a e0       	ldi	r22, 0x0A	; 10
     774:	8e 81       	ldd	r24, Y+6	; 0x06
     776:	9f 81       	ldd	r25, Y+7	; 0x07
     778:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     77c:	8c 01       	movw	r16, r24
     77e:	6f e9       	ldi	r22, 0x9F	; 159
     780:	73 e0       	ldi	r23, 0x03	; 3
     782:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     786:	66 e0       	ldi	r22, 0x06	; 6
     788:	c8 01       	movw	r24, r16
     78a:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     78e:	6a e0       	ldi	r22, 0x0A	; 10
     790:	8e 81       	ldd	r24, Y+6	; 0x06
     792:	9f 81       	ldd	r25, Y+7	; 0x07
     794:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     798:	8c 01       	movw	r16, r24
     79a:	63 e8       	ldi	r22, 0x83	; 131
     79c:	73 e0       	ldi	r23, 0x03	; 3
     79e:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     7a2:	66 e0       	ldi	r22, 0x06	; 6
     7a4:	c8 01       	movw	r24, r16
     7a6:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     7aa:	6a e0       	ldi	r22, 0x0A	; 10
     7ac:	8e 81       	ldd	r24, Y+6	; 0x06
     7ae:	9f 81       	ldd	r25, Y+7	; 0x07
     7b0:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     7b4:	8c 01       	movw	r16, r24
     7b6:	6b e6       	ldi	r22, 0x6B	; 107
     7b8:	73 e0       	ldi	r23, 0x03	; 3
     7ba:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     7be:	66 e0       	ldi	r22, 0x06	; 6
     7c0:	c8 01       	movw	r24, r16
     7c2:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     7c6:	6a e0       	ldi	r22, 0x0A	; 10
     7c8:	8e 81       	ldd	r24, Y+6	; 0x06
     7ca:	9f 81       	ldd	r25, Y+7	; 0x07
     7cc:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     7d0:	8c 01       	movw	r16, r24
     7d2:	6a e4       	ldi	r22, 0x4A	; 74
     7d4:	73 e0       	ldi	r23, 0x03	; 3
     7d6:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     7da:	66 e0       	ldi	r22, 0x06	; 6
     7dc:	c8 01       	movw	r24, r16
     7de:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     7e2:	6a e0       	ldi	r22, 0x0A	; 10
     7e4:	8e 81       	ldd	r24, Y+6	; 0x06
     7e6:	9f 81       	ldd	r25, Y+7	; 0x07
     7e8:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     7ec:	8c 01       	movw	r16, r24
     7ee:	63 e2       	ldi	r22, 0x23	; 35
     7f0:	73 e0       	ldi	r23, 0x03	; 3
     7f2:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     7f6:	66 e0       	ldi	r22, 0x06	; 6
     7f8:	c8 01       	movw	r24, r16
     7fa:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     7fe:	6a e0       	ldi	r22, 0x0A	; 10
     800:	8e 81       	ldd	r24, Y+6	; 0x06
     802:	9f 81       	ldd	r25, Y+7	; 0x07
     804:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     808:	8c 01       	movw	r16, r24
     80a:	65 e0       	ldi	r22, 0x05	; 5
     80c:	73 e0       	ldi	r23, 0x03	; 3
     80e:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     812:	66 e0       	ldi	r22, 0x06	; 6
     814:	c8 01       	movw	r24, r16
     816:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     81a:	6a e0       	ldi	r22, 0x0A	; 10
     81c:	8e 81       	ldd	r24, Y+6	; 0x06
     81e:	9f 81       	ldd	r25, Y+7	; 0x07
     820:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     824:	8c 01       	movw	r16, r24
     826:	6a ee       	ldi	r22, 0xEA	; 234
     828:	72 e0       	ldi	r23, 0x02	; 2
     82a:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     82e:	66 e0       	ldi	r22, 0x06	; 6
     830:	c8 01       	movw	r24, r16
     832:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     836:	6a e0       	ldi	r22, 0x0A	; 10
     838:	8e 81       	ldd	r24, Y+6	; 0x06
     83a:	9f 81       	ldd	r25, Y+7	; 0x07
     83c:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     840:	ec 01       	movw	r28, r24
     842:	6b ed       	ldi	r22, 0xDB	; 219
     844:	72 e0       	ldi	r23, 0x02	; 2
     846:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     84a:	66 e0       	ldi	r22, 0x06	; 6
     84c:	ce 01       	movw	r24, r28
     84e:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
}
     852:	df 91       	pop	r29
     854:	cf 91       	pop	r28
     856:	1f 91       	pop	r17
     858:	0f 91       	pop	r16
     85a:	08 95       	ret

0000085c <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     85c:	af 92       	push	r10
     85e:	bf 92       	push	r11
     860:	cf 92       	push	r12
     862:	df 92       	push	r13
     864:	ef 92       	push	r14
     866:	ff 92       	push	r15
     868:	0f 93       	push	r16
     86a:	1f 93       	push	r17
     86c:	cf 93       	push	r28
     86e:	df 93       	push	r29
     870:	00 d0       	rcall	.+0      	; 0x872 <_ZN9task_user11show_statusEv+0x16>
     872:	00 d0       	rcall	.+0      	; 0x874 <_ZN9task_user11show_statusEv+0x18>
     874:	cd b7       	in	r28, 0x3d	; 61
     876:	de b7       	in	r29, 0x3e	; 62
     878:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     87a:	19 82       	std	Y+1, r1	; 0x01
     87c:	1a 82       	std	Y+2, r1	; 0x02
     87e:	1b 82       	std	Y+3, r1	; 0x03
     880:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     882:	1d 82       	std	Y+5, r1	; 0x05
     884:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     886:	0e 94 b3 06 	call	0xd66	; 0xd66 <xPortGetFreeHeapSize>
     88a:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     88c:	ce 01       	movw	r24, r28
     88e:	01 96       	adiw	r24, 0x01	; 1
     890:	0e 94 ee 14 	call	0x29dc	; 0x29dc <_ZN10time_stamp10set_to_nowEv>
     894:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     896:	66 e0       	ldi	r22, 0x06	; 6
     898:	f8 01       	movw	r30, r16
     89a:	86 81       	ldd	r24, Z+6	; 0x06
     89c:	97 81       	ldd	r25, Z+7	; 0x07
     89e:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     8a2:	6a e0       	ldi	r22, 0x0A	; 10
     8a4:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     8a8:	7c 01       	movw	r14, r24
     8aa:	6c eb       	ldi	r22, 0xBC	; 188
     8ac:	72 e0       	ldi	r23, 0x02	; 2
     8ae:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     8b2:	6a e0       	ldi	r22, 0x0A	; 10
     8b4:	c7 01       	movw	r24, r14
     8b6:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     8ba:	7c 01       	movw	r14, r24
     8bc:	60 eb       	ldi	r22, 0xB0	; 176
     8be:	72 e0       	ldi	r23, 0x02	; 2
     8c0:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     8c4:	66 e0       	ldi	r22, 0x06	; 6
     8c6:	c7 01       	movw	r24, r14
     8c8:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     8cc:	6a e0       	ldi	r22, 0x0A	; 10
     8ce:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     8d2:	7c 01       	movw	r14, r24
     8d4:	69 ea       	ldi	r22, 0xA9	; 169
     8d6:	72 e0       	ldi	r23, 0x02	; 2
     8d8:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     8dc:	b5 01       	movw	r22, r10
     8de:	c7 01       	movw	r24, r14
     8e0:	0e 94 92 14 	call	0x2924	; 0x2924 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     8e4:	6a e0       	ldi	r22, 0x0A	; 10
     8e6:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     8ea:	7c 01       	movw	r14, r24
     8ec:	6b e9       	ldi	r22, 0x9B	; 155
     8ee:	72 e0       	ldi	r23, 0x02	; 2
     8f0:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     8f4:	b6 01       	movw	r22, r12
     8f6:	c7 01       	movw	r24, r14
     8f8:	0e 94 03 17 	call	0x2e06	; 0x2e06 <_ZN8emstreamlsEj>
     8fc:	6a e0       	ldi	r22, 0x0A	; 10
     8fe:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     902:	7c 01       	movw	r14, r24
     904:	69 e9       	ldi	r22, 0x99	; 153
     906:	72 e0       	ldi	r23, 0x02	; 2
     908:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     90c:	4f ef       	ldi	r20, 0xFF	; 255
     90e:	5f e0       	ldi	r21, 0x0F	; 15
     910:	60 e0       	ldi	r22, 0x00	; 0
     912:	70 e0       	ldi	r23, 0x00	; 0
     914:	c7 01       	movw	r24, r14
     916:	0e 94 37 17 	call	0x2e6e	; 0x2e6e <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     91a:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     91e:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     922:	6a e0       	ldi	r22, 0x0A	; 10
     924:	f8 01       	movw	r30, r16
     926:	86 81       	ldd	r24, Z+6	; 0x06
     928:	97 81       	ldd	r25, Z+7	; 0x07
     92a:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     92e:	7c 01       	movw	r14, r24
     930:	6e e8       	ldi	r22, 0x8E	; 142
     932:	72 e0       	ldi	r23, 0x02	; 2
     934:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     938:	b6 01       	movw	r22, r12
     93a:	c7 01       	movw	r24, r14
     93c:	0e 94 03 17 	call	0x2e06	; 0x2e06 <_ZN8emstreamlsEj>
     940:	66 e0       	ldi	r22, 0x06	; 6
     942:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     946:	66 e0       	ldi	r22, 0x06	; 6
     948:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     94c:	f8 01       	movw	r30, r16
     94e:	86 81       	ldd	r24, Z+6	; 0x06
     950:	97 81       	ldd	r25, Z+7	; 0x07
     952:	0e 94 4b 13 	call	0x2696	; 0x2696 <_Z15print_task_listP8emstream>
}
     956:	26 96       	adiw	r28, 0x06	; 6
     958:	cd bf       	out	0x3d, r28	; 61
     95a:	de bf       	out	0x3e, r29	; 62
     95c:	df 91       	pop	r29
     95e:	cf 91       	pop	r28
     960:	1f 91       	pop	r17
     962:	0f 91       	pop	r16
     964:	ff 90       	pop	r15
     966:	ef 90       	pop	r14
     968:	df 90       	pop	r13
     96a:	cf 90       	pop	r12
     96c:	bf 90       	pop	r11
     96e:	af 90       	pop	r10
     970:	08 95       	ret

00000972 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     972:	cf 93       	push	r28
     974:	df 93       	push	r29
     976:	00 d0       	rcall	.+0      	; 0x978 <_ZN9task_user3runEv+0x6>
     978:	00 d0       	rcall	.+0      	; 0x97a <_ZN9task_user3runEv+0x8>
     97a:	cd b7       	in	r28, 0x3d	; 61
     97c:	de b7       	in	r29, 0x3e	; 62
     97e:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     980:	19 82       	std	Y+1, r1	; 0x01
     982:	1a 82       	std	Y+2, r1	; 0x02
     984:	1b 82       	std	Y+3, r1	; 0x03
     986:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     988:	1d 82       	std	Y+5, r1	; 0x05
     98a:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     98c:	6a e0       	ldi	r22, 0x0A	; 10
     98e:	dc 01       	movw	r26, r24
     990:	16 96       	adiw	r26, 0x06	; 6
     992:	8d 91       	ld	r24, X+
     994:	9c 91       	ld	r25, X
     996:	17 97       	sbiw	r26, 0x07	; 7
     998:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     99c:	7c 01       	movw	r14, r24
     99e:	6a e2       	ldi	r22, 0x2A	; 42
     9a0:	74 e0       	ldi	r23, 0x04	; 4
     9a2:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     9a6:	66 e0       	ldi	r22, 0x06	; 6
     9a8:	c7 01       	movw	r24, r14
     9aa:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     9ae:	f8 01       	movw	r30, r16
     9b0:	84 85       	ldd	r24, Z+12	; 0x0c
     9b2:	88 23       	and	r24, r24
     9b4:	21 f0       	breq	.+8      	; 0x9be <_ZN9task_user3runEv+0x4c>
     9b6:	81 30       	cpi	r24, 0x01	; 1
     9b8:	09 f4       	brne	.+2      	; 0x9bc <_ZN9task_user3runEv+0x4a>
     9ba:	5d c0       	rjmp	.+186    	; 0xa76 <_ZN9task_user3runEv+0x104>
     9bc:	d8 c0       	rjmp	.+432    	; 0xb6e <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     9be:	86 81       	ldd	r24, Z+6	; 0x06
     9c0:	97 81       	ldd	r25, Z+7	; 0x07
     9c2:	dc 01       	movw	r26, r24
     9c4:	ed 91       	ld	r30, X+
     9c6:	fc 91       	ld	r31, X
     9c8:	04 80       	ldd	r0, Z+4	; 0x04
     9ca:	f5 81       	ldd	r31, Z+5	; 0x05
     9cc:	e0 2d       	mov	r30, r0
     9ce:	19 95       	eicall
     9d0:	88 23       	and	r24, r24
     9d2:	a9 f1       	breq	.+106    	; 0xa3e <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     9d4:	f8 01       	movw	r30, r16
     9d6:	86 81       	ldd	r24, Z+6	; 0x06
     9d8:	97 81       	ldd	r25, Z+7	; 0x07
     9da:	dc 01       	movw	r26, r24
     9dc:	ed 91       	ld	r30, X+
     9de:	fc 91       	ld	r31, X
     9e0:	06 80       	ldd	r0, Z+6	; 0x06
     9e2:	f7 81       	ldd	r31, Z+7	; 0x07
     9e4:	e0 2d       	mov	r30, r0
     9e6:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     9e8:	99 27       	eor	r25, r25
     9ea:	81 30       	cpi	r24, 0x01	; 1
     9ec:	91 05       	cpc	r25, r1
     9ee:	f9 f0       	breq	.+62     	; 0xa2e <_ZN9task_user3runEv+0xbc>
     9f0:	03 97       	sbiw	r24, 0x03	; 3
     9f2:	09 f0       	breq	.+2      	; 0x9f6 <_ZN9task_user3runEv+0x84>
     9f4:	d8 c0       	rjmp	.+432    	; 0xba6 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     9f6:	6a e0       	ldi	r22, 0x0A	; 10
     9f8:	f8 01       	movw	r30, r16
     9fa:	86 81       	ldd	r24, Z+6	; 0x06
     9fc:	97 81       	ldd	r25, Z+7	; 0x07
     9fe:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     a02:	8c 01       	movw	r16, r24
     a04:	6c e1       	ldi	r22, 0x1C	; 28
     a06:	74 e0       	ldi	r23, 0x04	; 4
     a08:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     a0c:	66 e0       	ldi	r22, 0x06	; 6
     a0e:	c8 01       	movw	r24, r16
     a10:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     a14:	93 e0       	ldi	r25, 0x03	; 3
     a16:	88 ed       	ldi	r24, 0xD8	; 216
     a18:	08 b6       	in	r0, 0x38	; 56
     a1a:	18 be       	out	0x38, r1	; 56
     a1c:	84 bf       	out	0x34, r24	; 52
     a1e:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     a22:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     a26:	81 fd       	sbrc	r24, 1
     a28:	fc cf       	rjmp	.-8      	; 0xa22 <_ZN9task_user3runEv+0xb0>
     a2a:	08 be       	out	0x38, r0	; 56
     a2c:	ff cf       	rjmp	.-2      	; 0xa2c <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     a2e:	c8 01       	movw	r24, r16
     a30:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     a34:	61 e0       	ldi	r22, 0x01	; 1
     a36:	c8 01       	movw	r24, r16
     a38:	0e 94 39 11 	call	0x2272	; 0x2272 <_ZN8frt_task13transition_toEh>
							break;
     a3c:	b4 c0       	rjmp	.+360    	; 0xba6 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     a3e:	8a e2       	ldi	r24, 0x2A	; 42
     a40:	91 e3       	ldi	r25, 0x31	; 49
     a42:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <_ZN14frt_text_queue14check_for_charEv>
     a46:	88 23       	and	r24, r24
     a48:	09 f4       	brne	.+2      	; 0xa4c <_ZN9task_user3runEv+0xda>
     a4a:	ad c0       	rjmp	.+346    	; 0xba6 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     a4c:	d8 01       	movw	r26, r16
     a4e:	16 96       	adiw	r26, 0x06	; 6
     a50:	ed 91       	ld	r30, X+
     a52:	fc 91       	ld	r31, X
     a54:	17 97       	sbiw	r26, 0x07	; 7
     a56:	01 90       	ld	r0, Z+
     a58:	f0 81       	ld	r31, Z
     a5a:	e0 2d       	mov	r30, r0
     a5c:	e2 80       	ldd	r14, Z+2	; 0x02
     a5e:	f3 80       	ldd	r15, Z+3	; 0x03
     a60:	8a e2       	ldi	r24, 0x2A	; 42
     a62:	91 e3       	ldi	r25, 0x31	; 49
     a64:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <_ZN14frt_text_queue7getcharEv>
     a68:	68 2f       	mov	r22, r24
     a6a:	f8 01       	movw	r30, r16
     a6c:	86 81       	ldd	r24, Z+6	; 0x06
     a6e:	97 81       	ldd	r25, Z+7	; 0x07
     a70:	f7 01       	movw	r30, r14
     a72:	19 95       	eicall
     a74:	98 c0       	rjmp	.+304    	; 0xba6 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     a76:	86 81       	ldd	r24, Z+6	; 0x06
     a78:	97 81       	ldd	r25, Z+7	; 0x07
     a7a:	dc 01       	movw	r26, r24
     a7c:	ed 91       	ld	r30, X+
     a7e:	fc 91       	ld	r31, X
     a80:	04 80       	ldd	r0, Z+4	; 0x04
     a82:	f5 81       	ldd	r31, Z+5	; 0x05
     a84:	e0 2d       	mov	r30, r0
     a86:	19 95       	eicall
     a88:	88 23       	and	r24, r24
     a8a:	09 f4       	brne	.+2      	; 0xa8e <_ZN9task_user3runEv+0x11c>
     a8c:	8c c0       	rjmp	.+280    	; 0xba6 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     a8e:	f8 01       	movw	r30, r16
     a90:	86 81       	ldd	r24, Z+6	; 0x06
     a92:	97 81       	ldd	r25, Z+7	; 0x07
     a94:	dc 01       	movw	r26, r24
     a96:	ed 91       	ld	r30, X+
     a98:	fc 91       	ld	r31, X
     a9a:	06 80       	ldd	r0, Z+6	; 0x06
     a9c:	f7 81       	ldd	r31, Z+7	; 0x07
     a9e:	e0 2d       	mov	r30, r0
     aa0:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     aa2:	9c 01       	movw	r18, r24
     aa4:	33 27       	eor	r19, r19
     aa6:	28 36       	cpi	r18, 0x68	; 104
     aa8:	31 05       	cpc	r19, r1
     aaa:	59 f1       	breq	.+86     	; 0xb02 <_ZN9task_user3runEv+0x190>
     aac:	3c f4       	brge	.+14     	; 0xabc <_ZN9task_user3runEv+0x14a>
     aae:	2b 31       	cpi	r18, 0x1B	; 27
     ab0:	31 05       	cpc	r19, r1
     ab2:	59 f1       	breq	.+86     	; 0xb0a <_ZN9task_user3runEv+0x198>
     ab4:	25 36       	cpi	r18, 0x65	; 101
     ab6:	31 05       	cpc	r19, r1
     ab8:	41 f1       	breq	.+80     	; 0xb0a <_ZN9task_user3runEv+0x198>
     aba:	3b c0       	rjmp	.+118    	; 0xb32 <_ZN9task_user3runEv+0x1c0>
     abc:	23 37       	cpi	r18, 0x73	; 115
     abe:	31 05       	cpc	r19, r1
     ac0:	c1 f0       	breq	.+48     	; 0xaf2 <_ZN9task_user3runEv+0x180>
     ac2:	26 37       	cpi	r18, 0x76	; 118
     ac4:	31 05       	cpc	r19, r1
     ac6:	89 f0       	breq	.+34     	; 0xaea <_ZN9task_user3runEv+0x178>
     ac8:	2e 36       	cpi	r18, 0x6E	; 110
     aca:	31 05       	cpc	r19, r1
     acc:	91 f5       	brne	.+100    	; 0xb32 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     ace:	ce 01       	movw	r24, r28
     ad0:	01 96       	adiw	r24, 0x01	; 1
     ad2:	0e 94 ee 14 	call	0x29dc	; 0x29dc <_ZN10time_stamp10set_to_nowEv>
     ad6:	bc 01       	movw	r22, r24
     ad8:	f8 01       	movw	r30, r16
     ada:	86 81       	ldd	r24, Z+6	; 0x06
     adc:	97 81       	ldd	r25, Z+7	; 0x07
     ade:	0e 94 92 14 	call	0x2924	; 0x2924 <_ZlsR8emstreamR10time_stamp>
     ae2:	66 e0       	ldi	r22, 0x06	; 6
     ae4:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
							break;
     ae8:	5e c0       	rjmp	.+188    	; 0xba6 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     aea:	c8 01       	movw	r24, r16
     aec:	0e 94 2e 04 	call	0x85c	; 0x85c <_ZN9task_user11show_statusEv>
							break;
     af0:	5a c0       	rjmp	.+180    	; 0xba6 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     af2:	d8 01       	movw	r26, r16
     af4:	16 96       	adiw	r26, 0x06	; 6
     af6:	8d 91       	ld	r24, X+
     af8:	9c 91       	ld	r25, X
     afa:	17 97       	sbiw	r26, 0x07	; 7
     afc:	0e 94 52 12 	call	0x24a4	; 0x24a4 <_Z17print_task_stacksP8emstream>
							break;
     b00:	52 c0       	rjmp	.+164    	; 0xba6 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     b02:	c8 01       	movw	r24, r16
     b04:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN9task_user18print_help_messageEv>
							break;
     b08:	4e c0       	rjmp	.+156    	; 0xba6 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     b0a:	6a e0       	ldi	r22, 0x0A	; 10
     b0c:	f8 01       	movw	r30, r16
     b0e:	86 81       	ldd	r24, Z+6	; 0x06
     b10:	97 81       	ldd	r25, Z+7	; 0x07
     b12:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     b16:	7c 01       	movw	r14, r24
     b18:	6a e0       	ldi	r22, 0x0A	; 10
     b1a:	74 e0       	ldi	r23, 0x04	; 4
     b1c:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     b20:	66 e0       	ldi	r22, 0x06	; 6
     b22:	c7 01       	movw	r24, r14
     b24:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     b28:	60 e0       	ldi	r22, 0x00	; 0
     b2a:	c8 01       	movw	r24, r16
     b2c:	0e 94 39 11 	call	0x2272	; 0x2272 <_ZN8frt_task13transition_toEh>
							break;
     b30:	3a c0       	rjmp	.+116    	; 0xba6 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     b32:	f8 01       	movw	r30, r16
     b34:	a6 81       	ldd	r26, Z+6	; 0x06
     b36:	b7 81       	ldd	r27, Z+7	; 0x07
     b38:	ed 91       	ld	r30, X+
     b3a:	fc 91       	ld	r31, X
     b3c:	11 97       	sbiw	r26, 0x01	; 1
     b3e:	02 80       	ldd	r0, Z+2	; 0x02
     b40:	f3 81       	ldd	r31, Z+3	; 0x03
     b42:	e0 2d       	mov	r30, r0
     b44:	68 2f       	mov	r22, r24
     b46:	cd 01       	movw	r24, r26
     b48:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     b4a:	6a e0       	ldi	r22, 0x0A	; 10
     b4c:	d8 01       	movw	r26, r16
     b4e:	16 96       	adiw	r26, 0x06	; 6
     b50:	8d 91       	ld	r24, X+
     b52:	9c 91       	ld	r25, X
     b54:	17 97       	sbiw	r26, 0x07	; 7
     b56:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     b5a:	7c 01       	movw	r14, r24
     b5c:	64 e0       	ldi	r22, 0x04	; 4
     b5e:	74 e0       	ldi	r23, 0x04	; 4
     b60:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     b64:	66 e0       	ldi	r22, 0x06	; 6
     b66:	c7 01       	movw	r24, r14
     b68:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
							break;
     b6c:	1c c0       	rjmp	.+56     	; 0xba6 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     b6e:	6a e0       	ldi	r22, 0x0A	; 10
     b70:	f8 01       	movw	r30, r16
     b72:	86 81       	ldd	r24, Z+6	; 0x06
     b74:	97 81       	ldd	r25, Z+7	; 0x07
     b76:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
     b7a:	8c 01       	movw	r16, r24
     b7c:	67 ee       	ldi	r22, 0xE7	; 231
     b7e:	73 e0       	ldi	r23, 0x03	; 3
     b80:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
     b84:	66 e0       	ldi	r22, 0x06	; 6
     b86:	c8 01       	movw	r24, r16
     b88:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     b8c:	93 e0       	ldi	r25, 0x03	; 3
     b8e:	88 ed       	ldi	r24, 0xD8	; 216
     b90:	08 b6       	in	r0, 0x38	; 56
     b92:	18 be       	out	0x38, r1	; 56
     b94:	84 bf       	out	0x34, r24	; 52
     b96:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     b9a:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     b9e:	81 fd       	sbrc	r24, 1
     ba0:	fc cf       	rjmp	.-8      	; 0xb9a <_ZN9task_user3runEv+0x228>
     ba2:	08 be       	out	0x38, r0	; 56
     ba4:	ff cf       	rjmp	.-2      	; 0xba4 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     ba6:	f8 01       	movw	r30, r16
     ba8:	86 85       	ldd	r24, Z+14	; 0x0e
     baa:	97 85       	ldd	r25, Z+15	; 0x0f
     bac:	a0 89       	ldd	r26, Z+16	; 0x10
     bae:	b1 89       	ldd	r27, Z+17	; 0x11
     bb0:	01 96       	adiw	r24, 0x01	; 1
     bb2:	a1 1d       	adc	r26, r1
     bb4:	b1 1d       	adc	r27, r1
     bb6:	86 87       	std	Z+14, r24	; 0x0e
     bb8:	97 87       	std	Z+15, r25	; 0x0f
     bba:	a0 8b       	std	Z+16, r26	; 0x10
     bbc:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     bbe:	61 e0       	ldi	r22, 0x01	; 1
     bc0:	70 e0       	ldi	r23, 0x00	; 0
     bc2:	80 e0       	ldi	r24, 0x00	; 0
     bc4:	90 e0       	ldi	r25, 0x00	; 0
     bc6:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     bca:	f1 ce       	rjmp	.-542    	; 0x9ae <_ZN9task_user3runEv+0x3c>

00000bcc <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     bcc:	0f 93       	push	r16
     bce:	1f 93       	push	r17
     bd0:	cf 93       	push	r28
     bd2:	df 93       	push	r29
     bd4:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     bd6:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     bda:	80 91 92 20 	lds	r24, 0x2092	; 0x802092 <__data_end>
     bde:	81 11       	cpse	r24, r1
     be0:	1d c0       	rjmp	.+58     	; 0xc1c <pvPortMalloc+0x50>
		{
			prvHeapInit();
     be2:	a7 e9       	ldi	r26, 0x97	; 151
     be4:	b0 e2       	ldi	r27, 0x20	; 32
     be6:	eb e9       	ldi	r30, 0x9B	; 155
     be8:	f0 e2       	ldi	r31, 0x20	; 32
     bea:	ed 93       	st	X+, r30
     bec:	fc 93       	st	X, r31
     bee:	11 97       	sbiw	r26, 0x01	; 1
     bf0:	12 96       	adiw	r26, 0x02	; 2
     bf2:	1d 92       	st	X+, r1
     bf4:	1c 92       	st	X, r1
     bf6:	13 97       	sbiw	r26, 0x03	; 3
     bf8:	a3 e9       	ldi	r26, 0x93	; 147
     bfa:	b0 e2       	ldi	r27, 0x20	; 32
     bfc:	8f ef       	ldi	r24, 0xFF	; 255
     bfe:	9f e0       	ldi	r25, 0x0F	; 15
     c00:	12 96       	adiw	r26, 0x02	; 2
     c02:	8d 93       	st	X+, r24
     c04:	9c 93       	st	X, r25
     c06:	13 97       	sbiw	r26, 0x03	; 3
     c08:	1d 92       	st	X+, r1
     c0a:	1c 92       	st	X, r1
     c0c:	11 97       	sbiw	r26, 0x01	; 1
     c0e:	82 83       	std	Z+2, r24	; 0x02
     c10:	93 83       	std	Z+3, r25	; 0x03
     c12:	a0 83       	st	Z, r26
     c14:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	80 93 92 20 	sts	0x2092, r24	; 0x802092 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     c1c:	20 97       	sbiw	r28, 0x00	; 0
     c1e:	09 f4       	brne	.+2      	; 0xc22 <pvPortMalloc+0x56>
     c20:	5f c0       	rjmp	.+190    	; 0xce0 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     c22:	9e 01       	movw	r18, r28
     c24:	2b 5f       	subi	r18, 0xFB	; 251
     c26:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
     c28:	24 96       	adiw	r28, 0x04	; 4
     c2a:	ce 3f       	cpi	r28, 0xFE	; 254
     c2c:	df 40       	sbci	r29, 0x0F	; 15
     c2e:	08 f0       	brcs	.+2      	; 0xc32 <pvPortMalloc+0x66>
     c30:	5a c0       	rjmp	.+180    	; 0xce6 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     c32:	e0 91 97 20 	lds	r30, 0x2097	; 0x802097 <xStart>
     c36:	f0 91 98 20 	lds	r31, 0x2098	; 0x802098 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     c3a:	a7 e9       	ldi	r26, 0x97	; 151
     c3c:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     c3e:	02 c0       	rjmp	.+4      	; 0xc44 <pvPortMalloc+0x78>
     c40:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     c42:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     c44:	82 81       	ldd	r24, Z+2	; 0x02
     c46:	93 81       	ldd	r25, Z+3	; 0x03
     c48:	82 17       	cp	r24, r18
     c4a:	93 07       	cpc	r25, r19
     c4c:	20 f4       	brcc	.+8      	; 0xc56 <pvPortMalloc+0x8a>
     c4e:	80 81       	ld	r24, Z
     c50:	91 81       	ldd	r25, Z+1	; 0x01
     c52:	00 97       	sbiw	r24, 0x00	; 0
     c54:	a9 f7       	brne	.-22     	; 0xc40 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     c56:	c0 e2       	ldi	r28, 0x20	; 32
     c58:	e3 39       	cpi	r30, 0x93	; 147
     c5a:	fc 07       	cpc	r31, r28
     c5c:	09 f4       	brne	.+2      	; 0xc60 <pvPortMalloc+0x94>
     c5e:	46 c0       	rjmp	.+140    	; 0xcec <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     c60:	cd 91       	ld	r28, X+
     c62:	dc 91       	ld	r29, X
     c64:	11 97       	sbiw	r26, 0x01	; 1
     c66:	8e 01       	movw	r16, r28
     c68:	0b 5f       	subi	r16, 0xFB	; 251
     c6a:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     c6c:	80 81       	ld	r24, Z
     c6e:	91 81       	ldd	r25, Z+1	; 0x01
     c70:	8d 93       	st	X+, r24
     c72:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     c74:	82 81       	ldd	r24, Z+2	; 0x02
     c76:	93 81       	ldd	r25, Z+3	; 0x03
     c78:	82 1b       	sub	r24, r18
     c7a:	93 0b       	sbc	r25, r19
     c7c:	8b 30       	cpi	r24, 0x0B	; 11
     c7e:	91 05       	cpc	r25, r1
     c80:	10 f1       	brcs	.+68     	; 0xcc6 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
     c82:	bf 01       	movw	r22, r30
     c84:	62 0f       	add	r22, r18
     c86:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     c88:	db 01       	movw	r26, r22
     c8a:	12 96       	adiw	r26, 0x02	; 2
     c8c:	8d 93       	st	X+, r24
     c8e:	9c 93       	st	X, r25
     c90:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
     c92:	22 83       	std	Z+2, r18	; 0x02
     c94:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     c96:	12 96       	adiw	r26, 0x02	; 2
     c98:	4d 91       	ld	r20, X+
     c9a:	5c 91       	ld	r21, X
     c9c:	13 97       	sbiw	r26, 0x03	; 3
     c9e:	87 e9       	ldi	r24, 0x97	; 151
     ca0:	90 e2       	ldi	r25, 0x20	; 32
     ca2:	01 c0       	rjmp	.+2      	; 0xca6 <pvPortMalloc+0xda>
     ca4:	cd 01       	movw	r24, r26
     ca6:	ec 01       	movw	r28, r24
     ca8:	a8 81       	ld	r26, Y
     caa:	b9 81       	ldd	r27, Y+1	; 0x01
     cac:	12 96       	adiw	r26, 0x02	; 2
     cae:	2d 91       	ld	r18, X+
     cb0:	3c 91       	ld	r19, X
     cb2:	13 97       	sbiw	r26, 0x03	; 3
     cb4:	24 17       	cp	r18, r20
     cb6:	35 07       	cpc	r19, r21
     cb8:	a8 f3       	brcs	.-22     	; 0xca4 <pvPortMalloc+0xd8>
     cba:	eb 01       	movw	r28, r22
     cbc:	a8 83       	st	Y, r26
     cbe:	b9 83       	std	Y+1, r27	; 0x01
     cc0:	dc 01       	movw	r26, r24
     cc2:	6d 93       	st	X+, r22
     cc4:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     cc6:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     cca:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     cce:	22 81       	ldd	r18, Z+2	; 0x02
     cd0:	33 81       	ldd	r19, Z+3	; 0x03
     cd2:	82 1b       	sub	r24, r18
     cd4:	93 0b       	sbc	r25, r19
     cd6:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     cda:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
     cde:	08 c0       	rjmp	.+16     	; 0xcf0 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     ce0:	00 e0       	ldi	r16, 0x00	; 0
     ce2:	10 e0       	ldi	r17, 0x00	; 0
     ce4:	05 c0       	rjmp	.+10     	; 0xcf0 <pvPortMalloc+0x124>
     ce6:	00 e0       	ldi	r16, 0x00	; 0
     ce8:	10 e0       	ldi	r17, 0x00	; 0
     cea:	02 c0       	rjmp	.+4      	; 0xcf0 <pvPortMalloc+0x124>
     cec:	00 e0       	ldi	r16, 0x00	; 0
     cee:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
     cf0:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     cf4:	c8 01       	movw	r24, r16
     cf6:	df 91       	pop	r29
     cf8:	cf 91       	pop	r28
     cfa:	1f 91       	pop	r17
     cfc:	0f 91       	pop	r16
     cfe:	08 95       	ret

00000d00 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     d00:	0f 93       	push	r16
     d02:	1f 93       	push	r17
     d04:	cf 93       	push	r28
     d06:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
     d08:	00 97       	sbiw	r24, 0x00	; 0
     d0a:	41 f1       	breq	.+80     	; 0xd5c <vPortFree+0x5c>
     d0c:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     d0e:	8c 01       	movw	r16, r24
     d10:	05 50       	subi	r16, 0x05	; 5
     d12:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     d14:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
     d18:	f8 01       	movw	r30, r16
     d1a:	42 81       	ldd	r20, Z+2	; 0x02
     d1c:	53 81       	ldd	r21, Z+3	; 0x03
     d1e:	a7 e9       	ldi	r26, 0x97	; 151
     d20:	b0 e2       	ldi	r27, 0x20	; 32
     d22:	01 c0       	rjmp	.+2      	; 0xd26 <vPortFree+0x26>
     d24:	df 01       	movw	r26, r30
     d26:	ed 91       	ld	r30, X+
     d28:	fc 91       	ld	r31, X
     d2a:	11 97       	sbiw	r26, 0x01	; 1
     d2c:	22 81       	ldd	r18, Z+2	; 0x02
     d2e:	33 81       	ldd	r19, Z+3	; 0x03
     d30:	24 17       	cp	r18, r20
     d32:	35 07       	cpc	r19, r21
     d34:	b8 f3       	brcs	.-18     	; 0xd24 <vPortFree+0x24>
     d36:	25 97       	sbiw	r28, 0x05	; 5
     d38:	e8 83       	st	Y, r30
     d3a:	f9 83       	std	Y+1, r31	; 0x01
     d3c:	0d 93       	st	X+, r16
     d3e:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     d40:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
     d44:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
     d48:	8a 81       	ldd	r24, Y+2	; 0x02
     d4a:	9b 81       	ldd	r25, Y+3	; 0x03
     d4c:	82 0f       	add	r24, r18
     d4e:	93 1f       	adc	r25, r19
     d50:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     d54:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
     d58:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <xTaskResumeAll>
	}
}
     d5c:	df 91       	pop	r29
     d5e:	cf 91       	pop	r28
     d60:	1f 91       	pop	r17
     d62:	0f 91       	pop	r16
     d64:	08 95       	ret

00000d66 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     d66:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     d6a:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     d6e:	08 95       	ret

00000d70 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     d70:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     d72:	03 96       	adiw	r24, 0x03	; 3
     d74:	81 83       	std	Z+1, r24	; 0x01
     d76:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     d78:	4f ef       	ldi	r20, 0xFF	; 255
     d7a:	5f ef       	ldi	r21, 0xFF	; 255
     d7c:	ba 01       	movw	r22, r20
     d7e:	43 83       	std	Z+3, r20	; 0x03
     d80:	54 83       	std	Z+4, r21	; 0x04
     d82:	65 83       	std	Z+5, r22	; 0x05
     d84:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     d86:	87 83       	std	Z+7, r24	; 0x07
     d88:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     d8a:	81 87       	std	Z+9, r24	; 0x09
     d8c:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     d8e:	10 82       	st	Z, r1
     d90:	08 95       	ret

00000d92 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     d92:	fc 01       	movw	r30, r24
     d94:	12 86       	std	Z+10, r1	; 0x0a
     d96:	13 86       	std	Z+11, r1	; 0x0b
     d98:	08 95       	ret

00000d9a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     d9a:	cf 93       	push	r28
     d9c:	df 93       	push	r29
     d9e:	fc 01       	movw	r30, r24
     da0:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     da2:	21 81       	ldd	r18, Z+1	; 0x01
     da4:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     da6:	e9 01       	movw	r28, r18
     da8:	8c 81       	ldd	r24, Y+4	; 0x04
     daa:	9d 81       	ldd	r25, Y+5	; 0x05
     dac:	14 96       	adiw	r26, 0x04	; 4
     dae:	8d 93       	st	X+, r24
     db0:	9c 93       	st	X, r25
     db2:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
     db4:	81 81       	ldd	r24, Z+1	; 0x01
     db6:	92 81       	ldd	r25, Z+2	; 0x02
     db8:	16 96       	adiw	r26, 0x06	; 6
     dba:	8d 93       	st	X+, r24
     dbc:	9c 93       	st	X, r25
     dbe:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     dc0:	8c 81       	ldd	r24, Y+4	; 0x04
     dc2:	9d 81       	ldd	r25, Y+5	; 0x05
     dc4:	ec 01       	movw	r28, r24
     dc6:	6e 83       	std	Y+6, r22	; 0x06
     dc8:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     dca:	e9 01       	movw	r28, r18
     dcc:	6c 83       	std	Y+4, r22	; 0x04
     dce:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     dd0:	61 83       	std	Z+1, r22	; 0x01
     dd2:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     dd4:	1a 96       	adiw	r26, 0x0a	; 10
     dd6:	ed 93       	st	X+, r30
     dd8:	fc 93       	st	X, r31
     dda:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
     ddc:	80 81       	ld	r24, Z
     dde:	8f 5f       	subi	r24, 0xFF	; 255
     de0:	80 83       	st	Z, r24
}
     de2:	df 91       	pop	r29
     de4:	cf 91       	pop	r28
     de6:	08 95       	ret

00000de8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     de8:	0f 93       	push	r16
     dea:	1f 93       	push	r17
     dec:	cf 93       	push	r28
     dee:	df 93       	push	r29
     df0:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     df2:	08 81       	ld	r16, Y
     df4:	19 81       	ldd	r17, Y+1	; 0x01
     df6:	2a 81       	ldd	r18, Y+2	; 0x02
     df8:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     dfa:	0f 3f       	cpi	r16, 0xFF	; 255
     dfc:	4f ef       	ldi	r20, 0xFF	; 255
     dfe:	14 07       	cpc	r17, r20
     e00:	24 07       	cpc	r18, r20
     e02:	34 07       	cpc	r19, r20
     e04:	31 f4       	brne	.+12     	; 0xe12 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     e06:	dc 01       	movw	r26, r24
     e08:	19 96       	adiw	r26, 0x09	; 9
     e0a:	ed 91       	ld	r30, X+
     e0c:	fc 91       	ld	r31, X
     e0e:	1a 97       	sbiw	r26, 0x0a	; 10
     e10:	1f c0       	rjmp	.+62     	; 0xe50 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     e12:	fc 01       	movw	r30, r24
     e14:	33 96       	adiw	r30, 0x03	; 3
     e16:	dc 01       	movw	r26, r24
     e18:	17 96       	adiw	r26, 0x07	; 7
     e1a:	4d 91       	ld	r20, X+
     e1c:	5c 91       	ld	r21, X
     e1e:	18 97       	sbiw	r26, 0x08	; 8
     e20:	da 01       	movw	r26, r20
     e22:	4d 91       	ld	r20, X+
     e24:	5d 91       	ld	r21, X+
     e26:	6d 91       	ld	r22, X+
     e28:	7c 91       	ld	r23, X
     e2a:	04 17       	cp	r16, r20
     e2c:	15 07       	cpc	r17, r21
     e2e:	26 07       	cpc	r18, r22
     e30:	37 07       	cpc	r19, r23
     e32:	70 f0       	brcs	.+28     	; 0xe50 <vListInsert+0x68>
     e34:	04 80       	ldd	r0, Z+4	; 0x04
     e36:	f5 81       	ldd	r31, Z+5	; 0x05
     e38:	e0 2d       	mov	r30, r0
     e3a:	a4 81       	ldd	r26, Z+4	; 0x04
     e3c:	b5 81       	ldd	r27, Z+5	; 0x05
     e3e:	4d 91       	ld	r20, X+
     e40:	5d 91       	ld	r21, X+
     e42:	6d 91       	ld	r22, X+
     e44:	7c 91       	ld	r23, X
     e46:	04 17       	cp	r16, r20
     e48:	15 07       	cpc	r17, r21
     e4a:	26 07       	cpc	r18, r22
     e4c:	37 07       	cpc	r19, r23
     e4e:	90 f7       	brcc	.-28     	; 0xe34 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     e50:	a4 81       	ldd	r26, Z+4	; 0x04
     e52:	b5 81       	ldd	r27, Z+5	; 0x05
     e54:	ac 83       	std	Y+4, r26	; 0x04
     e56:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     e58:	16 96       	adiw	r26, 0x06	; 6
     e5a:	cd 93       	st	X+, r28
     e5c:	dc 93       	st	X, r29
     e5e:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
     e60:	ee 83       	std	Y+6, r30	; 0x06
     e62:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     e64:	c4 83       	std	Z+4, r28	; 0x04
     e66:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e68:	8a 87       	std	Y+10, r24	; 0x0a
     e6a:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
     e6c:	fc 01       	movw	r30, r24
     e6e:	20 81       	ld	r18, Z
     e70:	2f 5f       	subi	r18, 0xFF	; 255
     e72:	20 83       	st	Z, r18
}
     e74:	df 91       	pop	r29
     e76:	cf 91       	pop	r28
     e78:	1f 91       	pop	r17
     e7a:	0f 91       	pop	r16
     e7c:	08 95       	ret

00000e7e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     e7e:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     e80:	a4 81       	ldd	r26, Z+4	; 0x04
     e82:	b5 81       	ldd	r27, Z+5	; 0x05
     e84:	86 81       	ldd	r24, Z+6	; 0x06
     e86:	97 81       	ldd	r25, Z+7	; 0x07
     e88:	16 96       	adiw	r26, 0x06	; 6
     e8a:	8d 93       	st	X+, r24
     e8c:	9c 93       	st	X, r25
     e8e:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     e90:	a6 81       	ldd	r26, Z+6	; 0x06
     e92:	b7 81       	ldd	r27, Z+7	; 0x07
     e94:	84 81       	ldd	r24, Z+4	; 0x04
     e96:	95 81       	ldd	r25, Z+5	; 0x05
     e98:	14 96       	adiw	r26, 0x04	; 4
     e9a:	8d 93       	st	X+, r24
     e9c:	9c 93       	st	X, r25
     e9e:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     ea0:	a2 85       	ldd	r26, Z+10	; 0x0a
     ea2:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ea4:	11 96       	adiw	r26, 0x01	; 1
     ea6:	8d 91       	ld	r24, X+
     ea8:	9c 91       	ld	r25, X
     eaa:	12 97       	sbiw	r26, 0x02	; 2
     eac:	e8 17       	cp	r30, r24
     eae:	f9 07       	cpc	r31, r25
     eb0:	31 f4       	brne	.+12     	; 0xebe <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     eb2:	86 81       	ldd	r24, Z+6	; 0x06
     eb4:	97 81       	ldd	r25, Z+7	; 0x07
     eb6:	11 96       	adiw	r26, 0x01	; 1
     eb8:	8d 93       	st	X+, r24
     eba:	9c 93       	st	X, r25
     ebc:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
     ebe:	12 86       	std	Z+10, r1	; 0x0a
     ec0:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     ec2:	8c 91       	ld	r24, X
     ec4:	81 50       	subi	r24, 0x01	; 1
     ec6:	8c 93       	st	X, r24
     ec8:	08 95       	ret

00000eca <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     eca:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <portStackTopForTask>
     ece:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <portStackTopForTask+0x1>
     ed2:	31 e1       	ldi	r19, 0x11	; 17
     ed4:	fc 01       	movw	r30, r24
     ed6:	30 83       	st	Z, r19
     ed8:	31 97       	sbiw	r30, 0x01	; 1
     eda:	22 e2       	ldi	r18, 0x22	; 34
     edc:	20 83       	st	Z, r18
     ede:	31 97       	sbiw	r30, 0x01	; 1
     ee0:	a3 e3       	ldi	r26, 0x33	; 51
     ee2:	a0 83       	st	Z, r26
     ee4:	31 97       	sbiw	r30, 0x01	; 1
     ee6:	60 83       	st	Z, r22
     ee8:	31 97       	sbiw	r30, 0x01	; 1
     eea:	70 83       	st	Z, r23
     eec:	31 97       	sbiw	r30, 0x01	; 1
     eee:	10 82       	st	Z, r1
     ef0:	31 97       	sbiw	r30, 0x01	; 1
     ef2:	10 82       	st	Z, r1
     ef4:	31 97       	sbiw	r30, 0x01	; 1
     ef6:	60 e8       	ldi	r22, 0x80	; 128
     ef8:	60 83       	st	Z, r22
     efa:	31 97       	sbiw	r30, 0x01	; 1
     efc:	10 82       	st	Z, r1
     efe:	31 97       	sbiw	r30, 0x01	; 1
     f00:	10 82       	st	Z, r1
     f02:	31 97       	sbiw	r30, 0x01	; 1
     f04:	10 82       	st	Z, r1
     f06:	31 97       	sbiw	r30, 0x01	; 1
     f08:	62 e0       	ldi	r22, 0x02	; 2
     f0a:	60 83       	st	Z, r22
     f0c:	31 97       	sbiw	r30, 0x01	; 1
     f0e:	63 e0       	ldi	r22, 0x03	; 3
     f10:	60 83       	st	Z, r22
     f12:	31 97       	sbiw	r30, 0x01	; 1
     f14:	64 e0       	ldi	r22, 0x04	; 4
     f16:	60 83       	st	Z, r22
     f18:	31 97       	sbiw	r30, 0x01	; 1
     f1a:	65 e0       	ldi	r22, 0x05	; 5
     f1c:	60 83       	st	Z, r22
     f1e:	31 97       	sbiw	r30, 0x01	; 1
     f20:	66 e0       	ldi	r22, 0x06	; 6
     f22:	60 83       	st	Z, r22
     f24:	31 97       	sbiw	r30, 0x01	; 1
     f26:	67 e0       	ldi	r22, 0x07	; 7
     f28:	60 83       	st	Z, r22
     f2a:	31 97       	sbiw	r30, 0x01	; 1
     f2c:	68 e0       	ldi	r22, 0x08	; 8
     f2e:	60 83       	st	Z, r22
     f30:	31 97       	sbiw	r30, 0x01	; 1
     f32:	69 e0       	ldi	r22, 0x09	; 9
     f34:	60 83       	st	Z, r22
     f36:	31 97       	sbiw	r30, 0x01	; 1
     f38:	60 e1       	ldi	r22, 0x10	; 16
     f3a:	60 83       	st	Z, r22
     f3c:	31 97       	sbiw	r30, 0x01	; 1
     f3e:	30 83       	st	Z, r19
     f40:	31 97       	sbiw	r30, 0x01	; 1
     f42:	32 e1       	ldi	r19, 0x12	; 18
     f44:	30 83       	st	Z, r19
     f46:	31 97       	sbiw	r30, 0x01	; 1
     f48:	33 e1       	ldi	r19, 0x13	; 19
     f4a:	30 83       	st	Z, r19
     f4c:	31 97       	sbiw	r30, 0x01	; 1
     f4e:	34 e1       	ldi	r19, 0x14	; 20
     f50:	30 83       	st	Z, r19
     f52:	31 97       	sbiw	r30, 0x01	; 1
     f54:	35 e1       	ldi	r19, 0x15	; 21
     f56:	30 83       	st	Z, r19
     f58:	31 97       	sbiw	r30, 0x01	; 1
     f5a:	36 e1       	ldi	r19, 0x16	; 22
     f5c:	30 83       	st	Z, r19
     f5e:	31 97       	sbiw	r30, 0x01	; 1
     f60:	37 e1       	ldi	r19, 0x17	; 23
     f62:	30 83       	st	Z, r19
     f64:	31 97       	sbiw	r30, 0x01	; 1
     f66:	38 e1       	ldi	r19, 0x18	; 24
     f68:	30 83       	st	Z, r19
     f6a:	31 97       	sbiw	r30, 0x01	; 1
     f6c:	39 e1       	ldi	r19, 0x19	; 25
     f6e:	30 83       	st	Z, r19
     f70:	31 97       	sbiw	r30, 0x01	; 1
     f72:	30 e2       	ldi	r19, 0x20	; 32
     f74:	30 83       	st	Z, r19
     f76:	31 97       	sbiw	r30, 0x01	; 1
     f78:	31 e2       	ldi	r19, 0x21	; 33
     f7a:	30 83       	st	Z, r19
     f7c:	31 97       	sbiw	r30, 0x01	; 1
     f7e:	20 83       	st	Z, r18
     f80:	31 97       	sbiw	r30, 0x01	; 1
     f82:	23 e2       	ldi	r18, 0x23	; 35
     f84:	20 83       	st	Z, r18
     f86:	31 97       	sbiw	r30, 0x01	; 1
     f88:	40 83       	st	Z, r20
     f8a:	31 97       	sbiw	r30, 0x01	; 1
     f8c:	50 83       	st	Z, r21
     f8e:	31 97       	sbiw	r30, 0x01	; 1
     f90:	26 e2       	ldi	r18, 0x26	; 38
     f92:	20 83       	st	Z, r18
     f94:	31 97       	sbiw	r30, 0x01	; 1
     f96:	27 e2       	ldi	r18, 0x27	; 39
     f98:	20 83       	st	Z, r18
     f9a:	31 97       	sbiw	r30, 0x01	; 1
     f9c:	28 e2       	ldi	r18, 0x28	; 40
     f9e:	20 83       	st	Z, r18
     fa0:	31 97       	sbiw	r30, 0x01	; 1
     fa2:	29 e2       	ldi	r18, 0x29	; 41
     fa4:	20 83       	st	Z, r18
     fa6:	31 97       	sbiw	r30, 0x01	; 1
     fa8:	20 e3       	ldi	r18, 0x30	; 48
     faa:	20 83       	st	Z, r18
     fac:	31 97       	sbiw	r30, 0x01	; 1
     fae:	21 e3       	ldi	r18, 0x31	; 49
     fb0:	20 83       	st	Z, r18
     fb2:	89 97       	sbiw	r24, 0x29	; 41
     fb4:	08 95       	ret

00000fb6 <xPortStartScheduler>:
     fb6:	8c e7       	ldi	r24, 0x7C	; 124
     fb8:	80 93 69 0a 	sts	0x0A69, r24	; 0x800a69 <__TEXT_REGION_LENGTH__+0x700a69>
     fbc:	8f ef       	ldi	r24, 0xFF	; 255
     fbe:	80 93 68 0a 	sts	0x0A68, r24	; 0x800a68 <__TEXT_REGION_LENGTH__+0x700a68>
     fc2:	81 e0       	ldi	r24, 0x01	; 1
     fc4:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <__TEXT_REGION_LENGTH__+0x700a40>
     fc8:	81 e1       	ldi	r24, 0x11	; 17
     fca:	80 93 41 0a 	sts	0x0A41, r24	; 0x800a41 <__TEXT_REGION_LENGTH__+0x700a41>
     fce:	83 e0       	ldi	r24, 0x03	; 3
     fd0:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <__TEXT_REGION_LENGTH__+0x700a47>
     fd4:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <pxCurrentTCB>
     fd8:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
     fdc:	cd 91       	ld	r28, X+
     fde:	cd bf       	out	0x3d, r28	; 61
     fe0:	dd 91       	ld	r29, X+
     fe2:	de bf       	out	0x3e, r29	; 62
     fe4:	ff 91       	pop	r31
     fe6:	ef 91       	pop	r30
     fe8:	df 91       	pop	r29
     fea:	cf 91       	pop	r28
     fec:	bf 91       	pop	r27
     fee:	af 91       	pop	r26
     ff0:	9f 91       	pop	r25
     ff2:	8f 91       	pop	r24
     ff4:	7f 91       	pop	r23
     ff6:	6f 91       	pop	r22
     ff8:	5f 91       	pop	r21
     ffa:	4f 91       	pop	r20
     ffc:	3f 91       	pop	r19
     ffe:	2f 91       	pop	r18
    1000:	1f 91       	pop	r17
    1002:	0f 91       	pop	r16
    1004:	ff 90       	pop	r15
    1006:	ef 90       	pop	r14
    1008:	df 90       	pop	r13
    100a:	cf 90       	pop	r12
    100c:	bf 90       	pop	r11
    100e:	af 90       	pop	r10
    1010:	9f 90       	pop	r9
    1012:	8f 90       	pop	r8
    1014:	7f 90       	pop	r7
    1016:	6f 90       	pop	r6
    1018:	5f 90       	pop	r5
    101a:	4f 90       	pop	r4
    101c:	3f 90       	pop	r3
    101e:	2f 90       	pop	r2
    1020:	1f 90       	pop	r1
    1022:	0f 90       	pop	r0
    1024:	0c be       	out	0x3c, r0	; 60
    1026:	0f 90       	pop	r0
    1028:	0b be       	out	0x3b, r0	; 59
    102a:	0f 90       	pop	r0
    102c:	0f be       	out	0x3f, r0	; 63
    102e:	0f 90       	pop	r0
    1030:	08 95       	ret
    1032:	81 e0       	ldi	r24, 0x01	; 1
    1034:	08 95       	ret

00001036 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1036:	0f 92       	push	r0
    1038:	0f b6       	in	r0, 0x3f	; 63
    103a:	f8 94       	cli
    103c:	0f 92       	push	r0
    103e:	0b b6       	in	r0, 0x3b	; 59
    1040:	0f 92       	push	r0
    1042:	0c b6       	in	r0, 0x3c	; 60
    1044:	0f 92       	push	r0
    1046:	1f 92       	push	r1
    1048:	11 24       	eor	r1, r1
    104a:	2f 92       	push	r2
    104c:	3f 92       	push	r3
    104e:	4f 92       	push	r4
    1050:	5f 92       	push	r5
    1052:	6f 92       	push	r6
    1054:	7f 92       	push	r7
    1056:	8f 92       	push	r8
    1058:	9f 92       	push	r9
    105a:	af 92       	push	r10
    105c:	bf 92       	push	r11
    105e:	cf 92       	push	r12
    1060:	df 92       	push	r13
    1062:	ef 92       	push	r14
    1064:	ff 92       	push	r15
    1066:	0f 93       	push	r16
    1068:	1f 93       	push	r17
    106a:	2f 93       	push	r18
    106c:	3f 93       	push	r19
    106e:	4f 93       	push	r20
    1070:	5f 93       	push	r21
    1072:	6f 93       	push	r22
    1074:	7f 93       	push	r23
    1076:	8f 93       	push	r24
    1078:	9f 93       	push	r25
    107a:	af 93       	push	r26
    107c:	bf 93       	push	r27
    107e:	cf 93       	push	r28
    1080:	df 93       	push	r29
    1082:	ef 93       	push	r30
    1084:	ff 93       	push	r31
    1086:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <pxCurrentTCB>
    108a:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    108e:	0d b6       	in	r0, 0x3d	; 61
    1090:	0d 92       	st	X+, r0
    1092:	0e b6       	in	r0, 0x3e	; 62
    1094:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1096:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    109a:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <pxCurrentTCB>
    109e:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    10a2:	cd 91       	ld	r28, X+
    10a4:	cd bf       	out	0x3d, r28	; 61
    10a6:	dd 91       	ld	r29, X+
    10a8:	de bf       	out	0x3e, r29	; 62
    10aa:	ff 91       	pop	r31
    10ac:	ef 91       	pop	r30
    10ae:	df 91       	pop	r29
    10b0:	cf 91       	pop	r28
    10b2:	bf 91       	pop	r27
    10b4:	af 91       	pop	r26
    10b6:	9f 91       	pop	r25
    10b8:	8f 91       	pop	r24
    10ba:	7f 91       	pop	r23
    10bc:	6f 91       	pop	r22
    10be:	5f 91       	pop	r21
    10c0:	4f 91       	pop	r20
    10c2:	3f 91       	pop	r19
    10c4:	2f 91       	pop	r18
    10c6:	1f 91       	pop	r17
    10c8:	0f 91       	pop	r16
    10ca:	ff 90       	pop	r15
    10cc:	ef 90       	pop	r14
    10ce:	df 90       	pop	r13
    10d0:	cf 90       	pop	r12
    10d2:	bf 90       	pop	r11
    10d4:	af 90       	pop	r10
    10d6:	9f 90       	pop	r9
    10d8:	8f 90       	pop	r8
    10da:	7f 90       	pop	r7
    10dc:	6f 90       	pop	r6
    10de:	5f 90       	pop	r5
    10e0:	4f 90       	pop	r4
    10e2:	3f 90       	pop	r3
    10e4:	2f 90       	pop	r2
    10e6:	1f 90       	pop	r1
    10e8:	0f 90       	pop	r0
    10ea:	0c be       	out	0x3c, r0	; 60
    10ec:	0f 90       	pop	r0
    10ee:	0b be       	out	0x3b, r0	; 59
    10f0:	0f 90       	pop	r0
    10f2:	0f be       	out	0x3f, r0	; 63
    10f4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    10f6:	08 95       	ret

000010f8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    10f8:	0f 92       	push	r0
    10fa:	0f b6       	in	r0, 0x3f	; 63
    10fc:	f8 94       	cli
    10fe:	0f 92       	push	r0
    1100:	0b b6       	in	r0, 0x3b	; 59
    1102:	0f 92       	push	r0
    1104:	0c b6       	in	r0, 0x3c	; 60
    1106:	0f 92       	push	r0
    1108:	1f 92       	push	r1
    110a:	11 24       	eor	r1, r1
    110c:	2f 92       	push	r2
    110e:	3f 92       	push	r3
    1110:	4f 92       	push	r4
    1112:	5f 92       	push	r5
    1114:	6f 92       	push	r6
    1116:	7f 92       	push	r7
    1118:	8f 92       	push	r8
    111a:	9f 92       	push	r9
    111c:	af 92       	push	r10
    111e:	bf 92       	push	r11
    1120:	cf 92       	push	r12
    1122:	df 92       	push	r13
    1124:	ef 92       	push	r14
    1126:	ff 92       	push	r15
    1128:	0f 93       	push	r16
    112a:	1f 93       	push	r17
    112c:	2f 93       	push	r18
    112e:	3f 93       	push	r19
    1130:	4f 93       	push	r20
    1132:	5f 93       	push	r21
    1134:	6f 93       	push	r22
    1136:	7f 93       	push	r23
    1138:	8f 93       	push	r24
    113a:	9f 93       	push	r25
    113c:	af 93       	push	r26
    113e:	bf 93       	push	r27
    1140:	cf 93       	push	r28
    1142:	df 93       	push	r29
    1144:	ef 93       	push	r30
    1146:	ff 93       	push	r31
    1148:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <pxCurrentTCB>
    114c:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    1150:	0d b6       	in	r0, 0x3d	; 61
    1152:	0d 92       	st	X+, r0
    1154:	0e b6       	in	r0, 0x3e	; 62
    1156:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1158:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <vTaskIncrementTick>
	vTaskSwitchContext();
    115c:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1160:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <pxCurrentTCB>
    1164:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    1168:	cd 91       	ld	r28, X+
    116a:	cd bf       	out	0x3d, r28	; 61
    116c:	dd 91       	ld	r29, X+
    116e:	de bf       	out	0x3e, r29	; 62
    1170:	ff 91       	pop	r31
    1172:	ef 91       	pop	r30
    1174:	df 91       	pop	r29
    1176:	cf 91       	pop	r28
    1178:	bf 91       	pop	r27
    117a:	af 91       	pop	r26
    117c:	9f 91       	pop	r25
    117e:	8f 91       	pop	r24
    1180:	7f 91       	pop	r23
    1182:	6f 91       	pop	r22
    1184:	5f 91       	pop	r21
    1186:	4f 91       	pop	r20
    1188:	3f 91       	pop	r19
    118a:	2f 91       	pop	r18
    118c:	1f 91       	pop	r17
    118e:	0f 91       	pop	r16
    1190:	ff 90       	pop	r15
    1192:	ef 90       	pop	r14
    1194:	df 90       	pop	r13
    1196:	cf 90       	pop	r12
    1198:	bf 90       	pop	r11
    119a:	af 90       	pop	r10
    119c:	9f 90       	pop	r9
    119e:	8f 90       	pop	r8
    11a0:	7f 90       	pop	r7
    11a2:	6f 90       	pop	r6
    11a4:	5f 90       	pop	r5
    11a6:	4f 90       	pop	r4
    11a8:	3f 90       	pop	r3
    11aa:	2f 90       	pop	r2
    11ac:	1f 90       	pop	r1
    11ae:	0f 90       	pop	r0
    11b0:	0c be       	out	0x3c, r0	; 60
    11b2:	0f 90       	pop	r0
    11b4:	0b be       	out	0x3b, r0	; 59
    11b6:	0f 90       	pop	r0
    11b8:	0f be       	out	0x3f, r0	; 63
    11ba:	0f 90       	pop	r0

	asm volatile ( "ret" );
    11bc:	08 95       	ret

000011be <__vector_55>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    11be:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    11c2:	18 95       	reti

000011c4 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    11c4:	cf 93       	push	r28
    11c6:	df 93       	push	r29
    11c8:	ec 01       	movw	r28, r24
    11ca:	88 a1       	ldd	r24, Y+32	; 0x20
    11cc:	81 11       	cpse	r24, r1
    11ce:	0b c0       	rjmp	.+22     	; 0x11e6 <prvCopyDataToQueue+0x22>
    11d0:	88 81       	ld	r24, Y
    11d2:	99 81       	ldd	r25, Y+1	; 0x01
    11d4:	89 2b       	or	r24, r25
    11d6:	e1 f5       	brne	.+120    	; 0x1250 <prvCopyDataToQueue+0x8c>
    11d8:	8a 81       	ldd	r24, Y+2	; 0x02
    11da:	9b 81       	ldd	r25, Y+3	; 0x03
    11dc:	0e 94 f6 10 	call	0x21ec	; 0x21ec <vTaskPriorityDisinherit>
    11e0:	1a 82       	std	Y+2, r1	; 0x02
    11e2:	1b 82       	std	Y+3, r1	; 0x03
    11e4:	35 c0       	rjmp	.+106    	; 0x1250 <prvCopyDataToQueue+0x8c>
    11e6:	41 11       	cpse	r20, r1
    11e8:	17 c0       	rjmp	.+46     	; 0x1218 <prvCopyDataToQueue+0x54>
    11ea:	48 2f       	mov	r20, r24
    11ec:	50 e0       	ldi	r21, 0x00	; 0
    11ee:	8c 81       	ldd	r24, Y+4	; 0x04
    11f0:	9d 81       	ldd	r25, Y+5	; 0x05
    11f2:	0e 94 c9 1c 	call	0x3992	; 0x3992 <memcpy>
    11f6:	28 a1       	ldd	r18, Y+32	; 0x20
    11f8:	8c 81       	ldd	r24, Y+4	; 0x04
    11fa:	9d 81       	ldd	r25, Y+5	; 0x05
    11fc:	82 0f       	add	r24, r18
    11fe:	91 1d       	adc	r25, r1
    1200:	8c 83       	std	Y+4, r24	; 0x04
    1202:	9d 83       	std	Y+5, r25	; 0x05
    1204:	2a 81       	ldd	r18, Y+2	; 0x02
    1206:	3b 81       	ldd	r19, Y+3	; 0x03
    1208:	82 17       	cp	r24, r18
    120a:	93 07       	cpc	r25, r19
    120c:	08 f1       	brcs	.+66     	; 0x1250 <prvCopyDataToQueue+0x8c>
    120e:	88 81       	ld	r24, Y
    1210:	99 81       	ldd	r25, Y+1	; 0x01
    1212:	8c 83       	std	Y+4, r24	; 0x04
    1214:	9d 83       	std	Y+5, r25	; 0x05
    1216:	1c c0       	rjmp	.+56     	; 0x1250 <prvCopyDataToQueue+0x8c>
    1218:	48 2f       	mov	r20, r24
    121a:	50 e0       	ldi	r21, 0x00	; 0
    121c:	8e 81       	ldd	r24, Y+6	; 0x06
    121e:	9f 81       	ldd	r25, Y+7	; 0x07
    1220:	0e 94 c9 1c 	call	0x3992	; 0x3992 <memcpy>
    1224:	88 a1       	ldd	r24, Y+32	; 0x20
    1226:	90 e0       	ldi	r25, 0x00	; 0
    1228:	91 95       	neg	r25
    122a:	81 95       	neg	r24
    122c:	91 09       	sbc	r25, r1
    122e:	2e 81       	ldd	r18, Y+6	; 0x06
    1230:	3f 81       	ldd	r19, Y+7	; 0x07
    1232:	28 0f       	add	r18, r24
    1234:	39 1f       	adc	r19, r25
    1236:	2e 83       	std	Y+6, r18	; 0x06
    1238:	3f 83       	std	Y+7, r19	; 0x07
    123a:	48 81       	ld	r20, Y
    123c:	59 81       	ldd	r21, Y+1	; 0x01
    123e:	24 17       	cp	r18, r20
    1240:	35 07       	cpc	r19, r21
    1242:	30 f4       	brcc	.+12     	; 0x1250 <prvCopyDataToQueue+0x8c>
    1244:	2a 81       	ldd	r18, Y+2	; 0x02
    1246:	3b 81       	ldd	r19, Y+3	; 0x03
    1248:	82 0f       	add	r24, r18
    124a:	93 1f       	adc	r25, r19
    124c:	8e 83       	std	Y+6, r24	; 0x06
    124e:	9f 83       	std	Y+7, r25	; 0x07
    1250:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1252:	8f 5f       	subi	r24, 0xFF	; 255
    1254:	8e 8f       	std	Y+30, r24	; 0x1e
    1256:	df 91       	pop	r29
    1258:	cf 91       	pop	r28
    125a:	08 95       	ret

0000125c <prvCopyDataFromQueue>:
    125c:	fc 01       	movw	r30, r24
    125e:	80 81       	ld	r24, Z
    1260:	91 81       	ldd	r25, Z+1	; 0x01
    1262:	00 97       	sbiw	r24, 0x00	; 0
    1264:	a1 f0       	breq	.+40     	; 0x128e <prvCopyDataFromQueue+0x32>
    1266:	40 a1       	ldd	r20, Z+32	; 0x20
    1268:	50 e0       	ldi	r21, 0x00	; 0
    126a:	26 81       	ldd	r18, Z+6	; 0x06
    126c:	37 81       	ldd	r19, Z+7	; 0x07
    126e:	24 0f       	add	r18, r20
    1270:	35 1f       	adc	r19, r21
    1272:	26 83       	std	Z+6, r18	; 0x06
    1274:	37 83       	std	Z+7, r19	; 0x07
    1276:	a2 81       	ldd	r26, Z+2	; 0x02
    1278:	b3 81       	ldd	r27, Z+3	; 0x03
    127a:	2a 17       	cp	r18, r26
    127c:	3b 07       	cpc	r19, r27
    127e:	10 f0       	brcs	.+4      	; 0x1284 <prvCopyDataFromQueue+0x28>
    1280:	86 83       	std	Z+6, r24	; 0x06
    1282:	97 83       	std	Z+7, r25	; 0x07
    1284:	cb 01       	movw	r24, r22
    1286:	66 81       	ldd	r22, Z+6	; 0x06
    1288:	77 81       	ldd	r23, Z+7	; 0x07
    128a:	0e 94 c9 1c 	call	0x3992	; 0x3992 <memcpy>
    128e:	08 95       	ret

00001290 <prvUnlockQueue>:
    1290:	0f 93       	push	r16
    1292:	1f 93       	push	r17
    1294:	cf 93       	push	r28
    1296:	df 93       	push	r29
    1298:	ec 01       	movw	r28, r24
    129a:	0f b6       	in	r0, 0x3f	; 63
    129c:	f8 94       	cli
    129e:	0f 92       	push	r0
    12a0:	8a a1       	ldd	r24, Y+34	; 0x22
    12a2:	18 16       	cp	r1, r24
    12a4:	b4 f4       	brge	.+44     	; 0x12d2 <prvUnlockQueue+0x42>
    12a6:	8b 89       	ldd	r24, Y+19	; 0x13
    12a8:	81 11       	cpse	r24, r1
    12aa:	05 c0       	rjmp	.+10     	; 0x12b6 <prvUnlockQueue+0x26>
    12ac:	12 c0       	rjmp	.+36     	; 0x12d2 <prvUnlockQueue+0x42>
    12ae:	8b 89       	ldd	r24, Y+19	; 0x13
    12b0:	81 11       	cpse	r24, r1
    12b2:	04 c0       	rjmp	.+8      	; 0x12bc <prvUnlockQueue+0x2c>
    12b4:	0e c0       	rjmp	.+28     	; 0x12d2 <prvUnlockQueue+0x42>
    12b6:	8e 01       	movw	r16, r28
    12b8:	0d 5e       	subi	r16, 0xED	; 237
    12ba:	1f 4f       	sbci	r17, 0xFF	; 255
    12bc:	c8 01       	movw	r24, r16
    12be:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <xTaskRemoveFromEventList>
    12c2:	81 11       	cpse	r24, r1
    12c4:	0e 94 7f 10 	call	0x20fe	; 0x20fe <vTaskMissedYield>
    12c8:	8a a1       	ldd	r24, Y+34	; 0x22
    12ca:	81 50       	subi	r24, 0x01	; 1
    12cc:	8a a3       	std	Y+34, r24	; 0x22
    12ce:	18 16       	cp	r1, r24
    12d0:	74 f3       	brlt	.-36     	; 0x12ae <prvUnlockQueue+0x1e>
    12d2:	8f ef       	ldi	r24, 0xFF	; 255
    12d4:	8a a3       	std	Y+34, r24	; 0x22
    12d6:	0f 90       	pop	r0
    12d8:	0f be       	out	0x3f, r0	; 63
    12da:	0f b6       	in	r0, 0x3f	; 63
    12dc:	f8 94       	cli
    12de:	0f 92       	push	r0
    12e0:	89 a1       	ldd	r24, Y+33	; 0x21
    12e2:	18 16       	cp	r1, r24
    12e4:	b4 f4       	brge	.+44     	; 0x1312 <prvUnlockQueue+0x82>
    12e6:	88 85       	ldd	r24, Y+8	; 0x08
    12e8:	81 11       	cpse	r24, r1
    12ea:	05 c0       	rjmp	.+10     	; 0x12f6 <prvUnlockQueue+0x66>
    12ec:	12 c0       	rjmp	.+36     	; 0x1312 <prvUnlockQueue+0x82>
    12ee:	88 85       	ldd	r24, Y+8	; 0x08
    12f0:	81 11       	cpse	r24, r1
    12f2:	04 c0       	rjmp	.+8      	; 0x12fc <prvUnlockQueue+0x6c>
    12f4:	0e c0       	rjmp	.+28     	; 0x1312 <prvUnlockQueue+0x82>
    12f6:	8e 01       	movw	r16, r28
    12f8:	08 5f       	subi	r16, 0xF8	; 248
    12fa:	1f 4f       	sbci	r17, 0xFF	; 255
    12fc:	c8 01       	movw	r24, r16
    12fe:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <xTaskRemoveFromEventList>
    1302:	81 11       	cpse	r24, r1
    1304:	0e 94 7f 10 	call	0x20fe	; 0x20fe <vTaskMissedYield>
    1308:	89 a1       	ldd	r24, Y+33	; 0x21
    130a:	81 50       	subi	r24, 0x01	; 1
    130c:	89 a3       	std	Y+33, r24	; 0x21
    130e:	18 16       	cp	r1, r24
    1310:	74 f3       	brlt	.-36     	; 0x12ee <prvUnlockQueue+0x5e>
    1312:	8f ef       	ldi	r24, 0xFF	; 255
    1314:	89 a3       	std	Y+33, r24	; 0x21
    1316:	0f 90       	pop	r0
    1318:	0f be       	out	0x3f, r0	; 63
    131a:	df 91       	pop	r29
    131c:	cf 91       	pop	r28
    131e:	1f 91       	pop	r17
    1320:	0f 91       	pop	r16
    1322:	08 95       	ret

00001324 <xQueueGenericReset>:
    1324:	1f 93       	push	r17
    1326:	cf 93       	push	r28
    1328:	df 93       	push	r29
    132a:	61 30       	cpi	r22, 0x01	; 1
    132c:	59 f0       	breq	.+22     	; 0x1344 <xQueueGenericReset+0x20>
    132e:	fc 01       	movw	r30, r24
    1330:	23 89       	ldd	r18, Z+19	; 0x13
    1332:	30 85       	ldd	r19, Z+8	; 0x08
    1334:	31 11       	cpse	r19, r1
    1336:	2c c0       	rjmp	.+88     	; 0x1390 <xQueueGenericReset+0x6c>
    1338:	11 e0       	ldi	r17, 0x01	; 1
    133a:	21 11       	cpse	r18, r1
    133c:	10 e0       	ldi	r17, 0x00	; 0
    133e:	21 11       	cpse	r18, r1
    1340:	28 c0       	rjmp	.+80     	; 0x1392 <xQueueGenericReset+0x6e>
    1342:	01 c0       	rjmp	.+2      	; 0x1346 <xQueueGenericReset+0x22>
    1344:	11 e0       	ldi	r17, 0x01	; 1
    1346:	ec 01       	movw	r28, r24
    1348:	48 81       	ld	r20, Y
    134a:	59 81       	ldd	r21, Y+1	; 0x01
    134c:	28 a1       	ldd	r18, Y+32	; 0x20
    134e:	30 e0       	ldi	r19, 0x00	; 0
    1350:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1352:	62 9f       	mul	r22, r18
    1354:	c0 01       	movw	r24, r0
    1356:	63 9f       	mul	r22, r19
    1358:	90 0d       	add	r25, r0
    135a:	11 24       	eor	r1, r1
    135c:	ba 01       	movw	r22, r20
    135e:	68 0f       	add	r22, r24
    1360:	79 1f       	adc	r23, r25
    1362:	6a 83       	std	Y+2, r22	; 0x02
    1364:	7b 83       	std	Y+3, r23	; 0x03
    1366:	1e 8e       	std	Y+30, r1	; 0x1e
    1368:	4c 83       	std	Y+4, r20	; 0x04
    136a:	5d 83       	std	Y+5, r21	; 0x05
    136c:	82 1b       	sub	r24, r18
    136e:	93 0b       	sbc	r25, r19
    1370:	84 0f       	add	r24, r20
    1372:	95 1f       	adc	r25, r21
    1374:	8e 83       	std	Y+6, r24	; 0x06
    1376:	9f 83       	std	Y+7, r25	; 0x07
    1378:	8f ef       	ldi	r24, 0xFF	; 255
    137a:	89 a3       	std	Y+33, r24	; 0x21
    137c:	8a a3       	std	Y+34, r24	; 0x22
    137e:	ce 01       	movw	r24, r28
    1380:	08 96       	adiw	r24, 0x08	; 8
    1382:	0e 94 b8 06 	call	0xd70	; 0xd70 <vListInitialise>
    1386:	ce 01       	movw	r24, r28
    1388:	43 96       	adiw	r24, 0x13	; 19
    138a:	0e 94 b8 06 	call	0xd70	; 0xd70 <vListInitialise>
    138e:	01 c0       	rjmp	.+2      	; 0x1392 <xQueueGenericReset+0x6e>
    1390:	10 e0       	ldi	r17, 0x00	; 0
    1392:	81 2f       	mov	r24, r17
    1394:	df 91       	pop	r29
    1396:	cf 91       	pop	r28
    1398:	1f 91       	pop	r17
    139a:	08 95       	ret

0000139c <xQueueGenericCreate>:
    139c:	0f 93       	push	r16
    139e:	1f 93       	push	r17
    13a0:	cf 93       	push	r28
    13a2:	df 93       	push	r29
    13a4:	88 23       	and	r24, r24
    13a6:	01 f1       	breq	.+64     	; 0x13e8 <xQueueGenericCreate+0x4c>
    13a8:	06 2f       	mov	r16, r22
    13aa:	18 2f       	mov	r17, r24
    13ac:	83 e2       	ldi	r24, 0x23	; 35
    13ae:	90 e0       	ldi	r25, 0x00	; 0
    13b0:	0e 94 e6 05 	call	0xbcc	; 0xbcc <pvPortMalloc>
    13b4:	ec 01       	movw	r28, r24
    13b6:	89 2b       	or	r24, r25
    13b8:	c9 f0       	breq	.+50     	; 0x13ec <xQueueGenericCreate+0x50>
    13ba:	10 9f       	mul	r17, r16
    13bc:	c0 01       	movw	r24, r0
    13be:	11 24       	eor	r1, r1
    13c0:	01 96       	adiw	r24, 0x01	; 1
    13c2:	0e 94 e6 05 	call	0xbcc	; 0xbcc <pvPortMalloc>
    13c6:	88 83       	st	Y, r24
    13c8:	99 83       	std	Y+1, r25	; 0x01
    13ca:	89 2b       	or	r24, r25
    13cc:	39 f0       	breq	.+14     	; 0x13dc <xQueueGenericCreate+0x40>
    13ce:	1f 8f       	std	Y+31, r17	; 0x1f
    13d0:	08 a3       	std	Y+32, r16	; 0x20
    13d2:	61 e0       	ldi	r22, 0x01	; 1
    13d4:	ce 01       	movw	r24, r28
    13d6:	0e 94 92 09 	call	0x1324	; 0x1324 <xQueueGenericReset>
    13da:	08 c0       	rjmp	.+16     	; 0x13ec <xQueueGenericCreate+0x50>
    13dc:	ce 01       	movw	r24, r28
    13de:	0e 94 80 06 	call	0xd00	; 0xd00 <vPortFree>
    13e2:	c0 e0       	ldi	r28, 0x00	; 0
    13e4:	d0 e0       	ldi	r29, 0x00	; 0
    13e6:	02 c0       	rjmp	.+4      	; 0x13ec <xQueueGenericCreate+0x50>
    13e8:	c0 e0       	ldi	r28, 0x00	; 0
    13ea:	d0 e0       	ldi	r29, 0x00	; 0
    13ec:	ce 01       	movw	r24, r28
    13ee:	df 91       	pop	r29
    13f0:	cf 91       	pop	r28
    13f2:	1f 91       	pop	r17
    13f4:	0f 91       	pop	r16
    13f6:	08 95       	ret

000013f8 <xQueueGenericSend>:
    13f8:	af 92       	push	r10
    13fa:	bf 92       	push	r11
    13fc:	cf 92       	push	r12
    13fe:	df 92       	push	r13
    1400:	ef 92       	push	r14
    1402:	ff 92       	push	r15
    1404:	0f 93       	push	r16
    1406:	1f 93       	push	r17
    1408:	cf 93       	push	r28
    140a:	df 93       	push	r29
    140c:	cd b7       	in	r28, 0x3d	; 61
    140e:	de b7       	in	r29, 0x3e	; 62
    1410:	29 97       	sbiw	r28, 0x09	; 9
    1412:	cd bf       	out	0x3d, r28	; 61
    1414:	de bf       	out	0x3e, r29	; 62
    1416:	7c 01       	movw	r14, r24
    1418:	5b 01       	movw	r10, r22
    141a:	2e 83       	std	Y+6, r18	; 0x06
    141c:	3f 83       	std	Y+7, r19	; 0x07
    141e:	48 87       	std	Y+8, r20	; 0x08
    1420:	59 87       	std	Y+9, r21	; 0x09
    1422:	10 e0       	ldi	r17, 0x00	; 0
    1424:	6c 01       	movw	r12, r24
    1426:	88 e0       	ldi	r24, 0x08	; 8
    1428:	c8 0e       	add	r12, r24
    142a:	d1 1c       	adc	r13, r1
    142c:	0f b6       	in	r0, 0x3f	; 63
    142e:	f8 94       	cli
    1430:	0f 92       	push	r0
    1432:	f7 01       	movw	r30, r14
    1434:	96 8d       	ldd	r25, Z+30	; 0x1e
    1436:	87 8d       	ldd	r24, Z+31	; 0x1f
    1438:	98 17       	cp	r25, r24
    143a:	a8 f4       	brcc	.+42     	; 0x1466 <xQueueGenericSend+0x6e>
    143c:	40 2f       	mov	r20, r16
    143e:	b5 01       	movw	r22, r10
    1440:	c7 01       	movw	r24, r14
    1442:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <prvCopyDataToQueue>
    1446:	f7 01       	movw	r30, r14
    1448:	83 89       	ldd	r24, Z+19	; 0x13
    144a:	88 23       	and	r24, r24
    144c:	41 f0       	breq	.+16     	; 0x145e <xQueueGenericSend+0x66>
    144e:	c7 01       	movw	r24, r14
    1450:	43 96       	adiw	r24, 0x13	; 19
    1452:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <xTaskRemoveFromEventList>
    1456:	81 30       	cpi	r24, 0x01	; 1
    1458:	11 f4       	brne	.+4      	; 0x145e <xQueueGenericSend+0x66>
    145a:	0e 94 1b 08 	call	0x1036	; 0x1036 <vPortYield>
    145e:	0f 90       	pop	r0
    1460:	0f be       	out	0x3f, r0	; 63
    1462:	81 e0       	ldi	r24, 0x01	; 1
    1464:	56 c0       	rjmp	.+172    	; 0x1512 <xQueueGenericSend+0x11a>
    1466:	8e 81       	ldd	r24, Y+6	; 0x06
    1468:	9f 81       	ldd	r25, Y+7	; 0x07
    146a:	a8 85       	ldd	r26, Y+8	; 0x08
    146c:	b9 85       	ldd	r27, Y+9	; 0x09
    146e:	89 2b       	or	r24, r25
    1470:	8a 2b       	or	r24, r26
    1472:	8b 2b       	or	r24, r27
    1474:	21 f4       	brne	.+8      	; 0x147e <xQueueGenericSend+0x86>
    1476:	0f 90       	pop	r0
    1478:	0f be       	out	0x3f, r0	; 63
    147a:	80 e0       	ldi	r24, 0x00	; 0
    147c:	4a c0       	rjmp	.+148    	; 0x1512 <xQueueGenericSend+0x11a>
    147e:	11 11       	cpse	r17, r1
    1480:	05 c0       	rjmp	.+10     	; 0x148c <xQueueGenericSend+0x94>
    1482:	ce 01       	movw	r24, r28
    1484:	01 96       	adiw	r24, 0x01	; 1
    1486:	0e 94 01 10 	call	0x2002	; 0x2002 <vTaskSetTimeOutState>
    148a:	11 e0       	ldi	r17, 0x01	; 1
    148c:	0f 90       	pop	r0
    148e:	0f be       	out	0x3f, r0	; 63
    1490:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <vTaskSuspendAll>
    1494:	0f b6       	in	r0, 0x3f	; 63
    1496:	f8 94       	cli
    1498:	0f 92       	push	r0
    149a:	f7 01       	movw	r30, r14
    149c:	81 a1       	ldd	r24, Z+33	; 0x21
    149e:	8f 3f       	cpi	r24, 0xFF	; 255
    14a0:	09 f4       	brne	.+2      	; 0x14a4 <xQueueGenericSend+0xac>
    14a2:	11 a2       	std	Z+33, r1	; 0x21
    14a4:	f7 01       	movw	r30, r14
    14a6:	82 a1       	ldd	r24, Z+34	; 0x22
    14a8:	8f 3f       	cpi	r24, 0xFF	; 255
    14aa:	09 f4       	brne	.+2      	; 0x14ae <xQueueGenericSend+0xb6>
    14ac:	12 a2       	std	Z+34, r1	; 0x22
    14ae:	0f 90       	pop	r0
    14b0:	0f be       	out	0x3f, r0	; 63
    14b2:	be 01       	movw	r22, r28
    14b4:	6a 5f       	subi	r22, 0xFA	; 250
    14b6:	7f 4f       	sbci	r23, 0xFF	; 255
    14b8:	ce 01       	movw	r24, r28
    14ba:	01 96       	adiw	r24, 0x01	; 1
    14bc:	0e 94 12 10 	call	0x2024	; 0x2024 <xTaskCheckForTimeOut>
    14c0:	81 11       	cpse	r24, r1
    14c2:	21 c0       	rjmp	.+66     	; 0x1506 <xQueueGenericSend+0x10e>
    14c4:	0f b6       	in	r0, 0x3f	; 63
    14c6:	f8 94       	cli
    14c8:	0f 92       	push	r0
    14ca:	f7 01       	movw	r30, r14
    14cc:	96 8d       	ldd	r25, Z+30	; 0x1e
    14ce:	0f 90       	pop	r0
    14d0:	0f be       	out	0x3f, r0	; 63
    14d2:	87 8d       	ldd	r24, Z+31	; 0x1f
    14d4:	98 13       	cpse	r25, r24
    14d6:	11 c0       	rjmp	.+34     	; 0x14fa <xQueueGenericSend+0x102>
    14d8:	4e 81       	ldd	r20, Y+6	; 0x06
    14da:	5f 81       	ldd	r21, Y+7	; 0x07
    14dc:	68 85       	ldd	r22, Y+8	; 0x08
    14de:	79 85       	ldd	r23, Y+9	; 0x09
    14e0:	c6 01       	movw	r24, r12
    14e2:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <vTaskPlaceOnEventList>
    14e6:	c7 01       	movw	r24, r14
    14e8:	0e 94 48 09 	call	0x1290	; 0x1290 <prvUnlockQueue>
    14ec:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <xTaskResumeAll>
    14f0:	81 11       	cpse	r24, r1
    14f2:	9c cf       	rjmp	.-200    	; 0x142c <xQueueGenericSend+0x34>
    14f4:	0e 94 1b 08 	call	0x1036	; 0x1036 <vPortYield>
    14f8:	99 cf       	rjmp	.-206    	; 0x142c <xQueueGenericSend+0x34>
    14fa:	c7 01       	movw	r24, r14
    14fc:	0e 94 48 09 	call	0x1290	; 0x1290 <prvUnlockQueue>
    1500:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <xTaskResumeAll>
    1504:	93 cf       	rjmp	.-218    	; 0x142c <xQueueGenericSend+0x34>
    1506:	c7 01       	movw	r24, r14
    1508:	0e 94 48 09 	call	0x1290	; 0x1290 <prvUnlockQueue>
    150c:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <xTaskResumeAll>
    1510:	80 e0       	ldi	r24, 0x00	; 0
    1512:	29 96       	adiw	r28, 0x09	; 9
    1514:	cd bf       	out	0x3d, r28	; 61
    1516:	de bf       	out	0x3e, r29	; 62
    1518:	df 91       	pop	r29
    151a:	cf 91       	pop	r28
    151c:	1f 91       	pop	r17
    151e:	0f 91       	pop	r16
    1520:	ff 90       	pop	r15
    1522:	ef 90       	pop	r14
    1524:	df 90       	pop	r13
    1526:	cf 90       	pop	r12
    1528:	bf 90       	pop	r11
    152a:	af 90       	pop	r10
    152c:	08 95       	ret

0000152e <xQueueGenericReceive>:
    152e:	af 92       	push	r10
    1530:	bf 92       	push	r11
    1532:	cf 92       	push	r12
    1534:	df 92       	push	r13
    1536:	ef 92       	push	r14
    1538:	ff 92       	push	r15
    153a:	0f 93       	push	r16
    153c:	1f 93       	push	r17
    153e:	cf 93       	push	r28
    1540:	df 93       	push	r29
    1542:	cd b7       	in	r28, 0x3d	; 61
    1544:	de b7       	in	r29, 0x3e	; 62
    1546:	29 97       	sbiw	r28, 0x09	; 9
    1548:	cd bf       	out	0x3d, r28	; 61
    154a:	de bf       	out	0x3e, r29	; 62
    154c:	7c 01       	movw	r14, r24
    154e:	5b 01       	movw	r10, r22
    1550:	2e 83       	std	Y+6, r18	; 0x06
    1552:	3f 83       	std	Y+7, r19	; 0x07
    1554:	48 87       	std	Y+8, r20	; 0x08
    1556:	59 87       	std	Y+9, r21	; 0x09
    1558:	10 e0       	ldi	r17, 0x00	; 0
    155a:	6c 01       	movw	r12, r24
    155c:	83 e1       	ldi	r24, 0x13	; 19
    155e:	c8 0e       	add	r12, r24
    1560:	d1 1c       	adc	r13, r1
    1562:	0f b6       	in	r0, 0x3f	; 63
    1564:	f8 94       	cli
    1566:	0f 92       	push	r0
    1568:	f7 01       	movw	r30, r14
    156a:	86 8d       	ldd	r24, Z+30	; 0x1e
    156c:	88 23       	and	r24, r24
    156e:	99 f1       	breq	.+102    	; 0x15d6 <xQueueGenericReceive+0xa8>
    1570:	c6 80       	ldd	r12, Z+6	; 0x06
    1572:	d7 80       	ldd	r13, Z+7	; 0x07
    1574:	b5 01       	movw	r22, r10
    1576:	c7 01       	movw	r24, r14
    1578:	0e 94 2e 09 	call	0x125c	; 0x125c <prvCopyDataFromQueue>
    157c:	01 11       	cpse	r16, r1
    157e:	1a c0       	rjmp	.+52     	; 0x15b4 <xQueueGenericReceive+0x86>
    1580:	f7 01       	movw	r30, r14
    1582:	86 8d       	ldd	r24, Z+30	; 0x1e
    1584:	81 50       	subi	r24, 0x01	; 1
    1586:	86 8f       	std	Z+30, r24	; 0x1e
    1588:	80 81       	ld	r24, Z
    158a:	91 81       	ldd	r25, Z+1	; 0x01
    158c:	89 2b       	or	r24, r25
    158e:	29 f4       	brne	.+10     	; 0x159a <xQueueGenericReceive+0x6c>
    1590:	0e 94 9c 10 	call	0x2138	; 0x2138 <xTaskGetCurrentTaskHandle>
    1594:	f7 01       	movw	r30, r14
    1596:	82 83       	std	Z+2, r24	; 0x02
    1598:	93 83       	std	Z+3, r25	; 0x03
    159a:	f7 01       	movw	r30, r14
    159c:	80 85       	ldd	r24, Z+8	; 0x08
    159e:	88 23       	and	r24, r24
    15a0:	b1 f0       	breq	.+44     	; 0x15ce <xQueueGenericReceive+0xa0>
    15a2:	c7 01       	movw	r24, r14
    15a4:	08 96       	adiw	r24, 0x08	; 8
    15a6:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <xTaskRemoveFromEventList>
    15aa:	81 30       	cpi	r24, 0x01	; 1
    15ac:	81 f4       	brne	.+32     	; 0x15ce <xQueueGenericReceive+0xa0>
    15ae:	0e 94 1b 08 	call	0x1036	; 0x1036 <vPortYield>
    15b2:	0d c0       	rjmp	.+26     	; 0x15ce <xQueueGenericReceive+0xa0>
    15b4:	f7 01       	movw	r30, r14
    15b6:	c6 82       	std	Z+6, r12	; 0x06
    15b8:	d7 82       	std	Z+7, r13	; 0x07
    15ba:	83 89       	ldd	r24, Z+19	; 0x13
    15bc:	88 23       	and	r24, r24
    15be:	39 f0       	breq	.+14     	; 0x15ce <xQueueGenericReceive+0xa0>
    15c0:	c7 01       	movw	r24, r14
    15c2:	43 96       	adiw	r24, 0x13	; 19
    15c4:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <xTaskRemoveFromEventList>
    15c8:	81 11       	cpse	r24, r1
    15ca:	0e 94 1b 08 	call	0x1036	; 0x1036 <vPortYield>
    15ce:	0f 90       	pop	r0
    15d0:	0f be       	out	0x3f, r0	; 63
    15d2:	81 e0       	ldi	r24, 0x01	; 1
    15d4:	62 c0       	rjmp	.+196    	; 0x169a <xQueueGenericReceive+0x16c>
    15d6:	8e 81       	ldd	r24, Y+6	; 0x06
    15d8:	9f 81       	ldd	r25, Y+7	; 0x07
    15da:	a8 85       	ldd	r26, Y+8	; 0x08
    15dc:	b9 85       	ldd	r27, Y+9	; 0x09
    15de:	89 2b       	or	r24, r25
    15e0:	8a 2b       	or	r24, r26
    15e2:	8b 2b       	or	r24, r27
    15e4:	21 f4       	brne	.+8      	; 0x15ee <xQueueGenericReceive+0xc0>
    15e6:	0f 90       	pop	r0
    15e8:	0f be       	out	0x3f, r0	; 63
    15ea:	80 e0       	ldi	r24, 0x00	; 0
    15ec:	56 c0       	rjmp	.+172    	; 0x169a <xQueueGenericReceive+0x16c>
    15ee:	11 11       	cpse	r17, r1
    15f0:	05 c0       	rjmp	.+10     	; 0x15fc <xQueueGenericReceive+0xce>
    15f2:	ce 01       	movw	r24, r28
    15f4:	01 96       	adiw	r24, 0x01	; 1
    15f6:	0e 94 01 10 	call	0x2002	; 0x2002 <vTaskSetTimeOutState>
    15fa:	11 e0       	ldi	r17, 0x01	; 1
    15fc:	0f 90       	pop	r0
    15fe:	0f be       	out	0x3f, r0	; 63
    1600:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <vTaskSuspendAll>
    1604:	0f b6       	in	r0, 0x3f	; 63
    1606:	f8 94       	cli
    1608:	0f 92       	push	r0
    160a:	f7 01       	movw	r30, r14
    160c:	81 a1       	ldd	r24, Z+33	; 0x21
    160e:	8f 3f       	cpi	r24, 0xFF	; 255
    1610:	09 f4       	brne	.+2      	; 0x1614 <xQueueGenericReceive+0xe6>
    1612:	11 a2       	std	Z+33, r1	; 0x21
    1614:	f7 01       	movw	r30, r14
    1616:	82 a1       	ldd	r24, Z+34	; 0x22
    1618:	8f 3f       	cpi	r24, 0xFF	; 255
    161a:	09 f4       	brne	.+2      	; 0x161e <xQueueGenericReceive+0xf0>
    161c:	12 a2       	std	Z+34, r1	; 0x22
    161e:	0f 90       	pop	r0
    1620:	0f be       	out	0x3f, r0	; 63
    1622:	be 01       	movw	r22, r28
    1624:	6a 5f       	subi	r22, 0xFA	; 250
    1626:	7f 4f       	sbci	r23, 0xFF	; 255
    1628:	ce 01       	movw	r24, r28
    162a:	01 96       	adiw	r24, 0x01	; 1
    162c:	0e 94 12 10 	call	0x2024	; 0x2024 <xTaskCheckForTimeOut>
    1630:	81 11       	cpse	r24, r1
    1632:	2d c0       	rjmp	.+90     	; 0x168e <xQueueGenericReceive+0x160>
    1634:	0f b6       	in	r0, 0x3f	; 63
    1636:	f8 94       	cli
    1638:	0f 92       	push	r0
    163a:	f7 01       	movw	r30, r14
    163c:	86 8d       	ldd	r24, Z+30	; 0x1e
    163e:	0f 90       	pop	r0
    1640:	0f be       	out	0x3f, r0	; 63
    1642:	81 11       	cpse	r24, r1
    1644:	1e c0       	rjmp	.+60     	; 0x1682 <xQueueGenericReceive+0x154>
    1646:	80 81       	ld	r24, Z
    1648:	91 81       	ldd	r25, Z+1	; 0x01
    164a:	89 2b       	or	r24, r25
    164c:	49 f4       	brne	.+18     	; 0x1660 <xQueueGenericReceive+0x132>
    164e:	0f b6       	in	r0, 0x3f	; 63
    1650:	f8 94       	cli
    1652:	0f 92       	push	r0
    1654:	82 81       	ldd	r24, Z+2	; 0x02
    1656:	93 81       	ldd	r25, Z+3	; 0x03
    1658:	0e 94 a1 10 	call	0x2142	; 0x2142 <vTaskPriorityInherit>
    165c:	0f 90       	pop	r0
    165e:	0f be       	out	0x3f, r0	; 63
    1660:	4e 81       	ldd	r20, Y+6	; 0x06
    1662:	5f 81       	ldd	r21, Y+7	; 0x07
    1664:	68 85       	ldd	r22, Y+8	; 0x08
    1666:	79 85       	ldd	r23, Y+9	; 0x09
    1668:	c6 01       	movw	r24, r12
    166a:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <vTaskPlaceOnEventList>
    166e:	c7 01       	movw	r24, r14
    1670:	0e 94 48 09 	call	0x1290	; 0x1290 <prvUnlockQueue>
    1674:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <xTaskResumeAll>
    1678:	81 11       	cpse	r24, r1
    167a:	73 cf       	rjmp	.-282    	; 0x1562 <xQueueGenericReceive+0x34>
    167c:	0e 94 1b 08 	call	0x1036	; 0x1036 <vPortYield>
    1680:	70 cf       	rjmp	.-288    	; 0x1562 <xQueueGenericReceive+0x34>
    1682:	c7 01       	movw	r24, r14
    1684:	0e 94 48 09 	call	0x1290	; 0x1290 <prvUnlockQueue>
    1688:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <xTaskResumeAll>
    168c:	6a cf       	rjmp	.-300    	; 0x1562 <xQueueGenericReceive+0x34>
    168e:	c7 01       	movw	r24, r14
    1690:	0e 94 48 09 	call	0x1290	; 0x1290 <prvUnlockQueue>
    1694:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <xTaskResumeAll>
    1698:	80 e0       	ldi	r24, 0x00	; 0
    169a:	29 96       	adiw	r28, 0x09	; 9
    169c:	cd bf       	out	0x3d, r28	; 61
    169e:	de bf       	out	0x3e, r29	; 62
    16a0:	df 91       	pop	r29
    16a2:	cf 91       	pop	r28
    16a4:	1f 91       	pop	r17
    16a6:	0f 91       	pop	r16
    16a8:	ff 90       	pop	r15
    16aa:	ef 90       	pop	r14
    16ac:	df 90       	pop	r13
    16ae:	cf 90       	pop	r12
    16b0:	bf 90       	pop	r11
    16b2:	af 90       	pop	r10
    16b4:	08 95       	ret

000016b6 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    16b6:	0f b6       	in	r0, 0x3f	; 63
    16b8:	f8 94       	cli
    16ba:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    16bc:	fc 01       	movw	r30, r24
    16be:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    16c0:	0f 90       	pop	r0
    16c2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    16c4:	08 95       	ret

000016c6 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    16c6:	ce ec       	ldi	r28, 0xCE	; 206
    16c8:	d0 e3       	ldi	r29, 0x30	; 48
    16ca:	88 81       	ld	r24, Y
    16cc:	82 30       	cpi	r24, 0x02	; 2
    16ce:	e8 f3       	brcs	.-6      	; 0x16ca <prvIdleTask+0x4>
    16d0:	0e 94 1b 08 	call	0x1036	; 0x1036 <vPortYield>
    16d4:	fa cf       	rjmp	.-12     	; 0x16ca <prvIdleTask+0x4>

000016d6 <prvAddCurrentTaskToDelayedList>:
    16d6:	cf 92       	push	r12
    16d8:	df 92       	push	r13
    16da:	ef 92       	push	r14
    16dc:	ff 92       	push	r15
    16de:	6b 01       	movw	r12, r22
    16e0:	7c 01       	movw	r14, r24
    16e2:	e0 91 fa 30 	lds	r30, 0x30FA	; 0x8030fa <pxCurrentTCB>
    16e6:	f0 91 fb 30 	lds	r31, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    16ea:	62 83       	std	Z+2, r22	; 0x02
    16ec:	73 83       	std	Z+3, r23	; 0x03
    16ee:	84 83       	std	Z+4, r24	; 0x04
    16f0:	95 83       	std	Z+5, r25	; 0x05
    16f2:	80 91 a2 30 	lds	r24, 0x30A2	; 0x8030a2 <xTickCount>
    16f6:	90 91 a3 30 	lds	r25, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    16fa:	a0 91 a4 30 	lds	r26, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    16fe:	b0 91 a5 30 	lds	r27, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    1702:	c8 16       	cp	r12, r24
    1704:	d9 06       	cpc	r13, r25
    1706:	ea 06       	cpc	r14, r26
    1708:	fb 06       	cpc	r15, r27
    170a:	68 f4       	brcc	.+26     	; 0x1726 <prvAddCurrentTaskToDelayedList+0x50>
    170c:	60 91 fa 30 	lds	r22, 0x30FA	; 0x8030fa <pxCurrentTCB>
    1710:	70 91 fb 30 	lds	r23, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    1714:	80 91 b4 30 	lds	r24, 0x30B4	; 0x8030b4 <pxOverflowDelayedTaskList>
    1718:	90 91 b5 30 	lds	r25, 0x30B5	; 0x8030b5 <pxOverflowDelayedTaskList+0x1>
    171c:	6e 5f       	subi	r22, 0xFE	; 254
    171e:	7f 4f       	sbci	r23, 0xFF	; 255
    1720:	0e 94 f4 06 	call	0xde8	; 0xde8 <vListInsert>
    1724:	21 c0       	rjmp	.+66     	; 0x1768 <prvAddCurrentTaskToDelayedList+0x92>
    1726:	60 91 fa 30 	lds	r22, 0x30FA	; 0x8030fa <pxCurrentTCB>
    172a:	70 91 fb 30 	lds	r23, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    172e:	80 91 b6 30 	lds	r24, 0x30B6	; 0x8030b6 <pxDelayedTaskList>
    1732:	90 91 b7 30 	lds	r25, 0x30B7	; 0x8030b7 <pxDelayedTaskList+0x1>
    1736:	6e 5f       	subi	r22, 0xFE	; 254
    1738:	7f 4f       	sbci	r23, 0xFF	; 255
    173a:	0e 94 f4 06 	call	0xde8	; 0xde8 <vListInsert>
    173e:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1742:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1746:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    174a:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    174e:	c8 16       	cp	r12, r24
    1750:	d9 06       	cpc	r13, r25
    1752:	ea 06       	cpc	r14, r26
    1754:	fb 06       	cpc	r15, r27
    1756:	40 f4       	brcc	.+16     	; 0x1768 <prvAddCurrentTaskToDelayedList+0x92>
    1758:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    175c:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1760:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1764:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1768:	ff 90       	pop	r15
    176a:	ef 90       	pop	r14
    176c:	df 90       	pop	r13
    176e:	cf 90       	pop	r12
    1770:	08 95       	ret

00001772 <xTaskGenericCreate>:
    1772:	4f 92       	push	r4
    1774:	5f 92       	push	r5
    1776:	6f 92       	push	r6
    1778:	7f 92       	push	r7
    177a:	8f 92       	push	r8
    177c:	9f 92       	push	r9
    177e:	af 92       	push	r10
    1780:	bf 92       	push	r11
    1782:	cf 92       	push	r12
    1784:	df 92       	push	r13
    1786:	ef 92       	push	r14
    1788:	ff 92       	push	r15
    178a:	0f 93       	push	r16
    178c:	1f 93       	push	r17
    178e:	cf 93       	push	r28
    1790:	df 93       	push	r29
    1792:	5c 01       	movw	r10, r24
    1794:	4b 01       	movw	r8, r22
    1796:	3a 01       	movw	r6, r20
    1798:	29 01       	movw	r4, r18
    179a:	88 e2       	ldi	r24, 0x28	; 40
    179c:	90 e0       	ldi	r25, 0x00	; 0
    179e:	0e 94 e6 05 	call	0xbcc	; 0xbcc <pvPortMalloc>
    17a2:	ec 01       	movw	r28, r24
    17a4:	89 2b       	or	r24, r25
    17a6:	09 f4       	brne	.+2      	; 0x17aa <xTaskGenericCreate+0x38>
    17a8:	d4 c0       	rjmp	.+424    	; 0x1952 <xTaskGenericCreate+0x1e0>
    17aa:	c1 14       	cp	r12, r1
    17ac:	d1 04       	cpc	r13, r1
    17ae:	09 f0       	breq	.+2      	; 0x17b2 <xTaskGenericCreate+0x40>
    17b0:	cc c0       	rjmp	.+408    	; 0x194a <xTaskGenericCreate+0x1d8>
    17b2:	c3 01       	movw	r24, r6
    17b4:	0e 94 e6 05 	call	0xbcc	; 0xbcc <pvPortMalloc>
    17b8:	8b 8f       	std	Y+27, r24	; 0x1b
    17ba:	9c 8f       	std	Y+28, r25	; 0x1c
    17bc:	00 97       	sbiw	r24, 0x00	; 0
    17be:	21 f4       	brne	.+8      	; 0x17c8 <xTaskGenericCreate+0x56>
    17c0:	ce 01       	movw	r24, r28
    17c2:	0e 94 80 06 	call	0xd00	; 0xd00 <vPortFree>
    17c6:	c5 c0       	rjmp	.+394    	; 0x1952 <xTaskGenericCreate+0x1e0>
    17c8:	a3 01       	movw	r20, r6
    17ca:	61 e1       	ldi	r22, 0x11	; 17
    17cc:	70 e0       	ldi	r23, 0x00	; 0
    17ce:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <memset>
    17d2:	93 01       	movw	r18, r6
    17d4:	21 50       	subi	r18, 0x01	; 1
    17d6:	31 09       	sbc	r19, r1
    17d8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    17da:	9c 8d       	ldd	r25, Y+28	; 0x1c
    17dc:	3c 01       	movw	r6, r24
    17de:	62 0e       	add	r6, r18
    17e0:	73 1e       	adc	r7, r19
    17e2:	4a e0       	ldi	r20, 0x0A	; 10
    17e4:	50 e0       	ldi	r21, 0x00	; 0
    17e6:	b4 01       	movw	r22, r8
    17e8:	ce 01       	movw	r24, r28
    17ea:	4d 96       	adiw	r24, 0x1d	; 29
    17ec:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <strncpy>
    17f0:	1e a2       	std	Y+38, r1	; 0x26
    17f2:	10 2f       	mov	r17, r16
    17f4:	04 30       	cpi	r16, 0x04	; 4
    17f6:	08 f0       	brcs	.+2      	; 0x17fa <xTaskGenericCreate+0x88>
    17f8:	13 e0       	ldi	r17, 0x03	; 3
    17fa:	1a 8f       	std	Y+26, r17	; 0x1a
    17fc:	1f a3       	std	Y+39, r17	; 0x27
    17fe:	6e 01       	movw	r12, r28
    1800:	22 e0       	ldi	r18, 0x02	; 2
    1802:	c2 0e       	add	r12, r18
    1804:	d1 1c       	adc	r13, r1
    1806:	c6 01       	movw	r24, r12
    1808:	0e 94 c9 06 	call	0xd92	; 0xd92 <vListInitialiseItem>
    180c:	ce 01       	movw	r24, r28
    180e:	0e 96       	adiw	r24, 0x0e	; 14
    1810:	0e 94 c9 06 	call	0xd92	; 0xd92 <vListInitialiseItem>
    1814:	ca 87       	std	Y+10, r28	; 0x0a
    1816:	db 87       	std	Y+11, r29	; 0x0b
    1818:	84 e0       	ldi	r24, 0x04	; 4
    181a:	90 e0       	ldi	r25, 0x00	; 0
    181c:	a0 e0       	ldi	r26, 0x00	; 0
    181e:	b0 e0       	ldi	r27, 0x00	; 0
    1820:	81 1b       	sub	r24, r17
    1822:	91 09       	sbc	r25, r1
    1824:	a1 09       	sbc	r26, r1
    1826:	b1 09       	sbc	r27, r1
    1828:	8e 87       	std	Y+14, r24	; 0x0e
    182a:	9f 87       	std	Y+15, r25	; 0x0f
    182c:	a8 8b       	std	Y+16, r26	; 0x10
    182e:	b9 8b       	std	Y+17, r27	; 0x11
    1830:	ce 8b       	std	Y+22, r28	; 0x16
    1832:	df 8b       	std	Y+23, r29	; 0x17
    1834:	a2 01       	movw	r20, r4
    1836:	b5 01       	movw	r22, r10
    1838:	c3 01       	movw	r24, r6
    183a:	0e 94 65 07 	call	0xeca	; 0xeca <pxPortInitialiseStack>
    183e:	88 83       	st	Y, r24
    1840:	99 83       	std	Y+1, r25	; 0x01
    1842:	e1 14       	cp	r14, r1
    1844:	f1 04       	cpc	r15, r1
    1846:	19 f0       	breq	.+6      	; 0x184e <xTaskGenericCreate+0xdc>
    1848:	f7 01       	movw	r30, r14
    184a:	c0 83       	st	Z, r28
    184c:	d1 83       	std	Z+1, r29	; 0x01
    184e:	0f b6       	in	r0, 0x3f	; 63
    1850:	f8 94       	cli
    1852:	0f 92       	push	r0
    1854:	80 91 a6 30 	lds	r24, 0x30A6	; 0x8030a6 <uxCurrentNumberOfTasks>
    1858:	8f 5f       	subi	r24, 0xFF	; 255
    185a:	80 93 a6 30 	sts	0x30A6, r24	; 0x8030a6 <uxCurrentNumberOfTasks>
    185e:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <pxCurrentTCB>
    1862:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    1866:	89 2b       	or	r24, r25
    1868:	89 f5       	brne	.+98     	; 0x18cc <xTaskGenericCreate+0x15a>
    186a:	c0 93 fa 30 	sts	0x30FA, r28	; 0x8030fa <pxCurrentTCB>
    186e:	d0 93 fb 30 	sts	0x30FB, r29	; 0x8030fb <pxCurrentTCB+0x1>
    1872:	80 91 a6 30 	lds	r24, 0x30A6	; 0x8030a6 <uxCurrentNumberOfTasks>
    1876:	81 30       	cpi	r24, 0x01	; 1
    1878:	c1 f5       	brne	.+112    	; 0x18ea <xTaskGenericCreate+0x178>
    187a:	8e ec       	ldi	r24, 0xCE	; 206
    187c:	90 e3       	ldi	r25, 0x30	; 48
    187e:	0e 94 b8 06 	call	0xd70	; 0xd70 <vListInitialise>
    1882:	89 ed       	ldi	r24, 0xD9	; 217
    1884:	90 e3       	ldi	r25, 0x30	; 48
    1886:	0e 94 b8 06 	call	0xd70	; 0xd70 <vListInitialise>
    188a:	84 ee       	ldi	r24, 0xE4	; 228
    188c:	90 e3       	ldi	r25, 0x30	; 48
    188e:	0e 94 b8 06 	call	0xd70	; 0xd70 <vListInitialise>
    1892:	8f ee       	ldi	r24, 0xEF	; 239
    1894:	90 e3       	ldi	r25, 0x30	; 48
    1896:	0e 94 b8 06 	call	0xd70	; 0xd70 <vListInitialise>
    189a:	83 ec       	ldi	r24, 0xC3	; 195
    189c:	90 e3       	ldi	r25, 0x30	; 48
    189e:	0e 94 b8 06 	call	0xd70	; 0xd70 <vListInitialise>
    18a2:	88 eb       	ldi	r24, 0xB8	; 184
    18a4:	90 e3       	ldi	r25, 0x30	; 48
    18a6:	0e 94 b8 06 	call	0xd70	; 0xd70 <vListInitialise>
    18aa:	89 ea       	ldi	r24, 0xA9	; 169
    18ac:	90 e3       	ldi	r25, 0x30	; 48
    18ae:	0e 94 b8 06 	call	0xd70	; 0xd70 <vListInitialise>
    18b2:	83 ec       	ldi	r24, 0xC3	; 195
    18b4:	90 e3       	ldi	r25, 0x30	; 48
    18b6:	80 93 b6 30 	sts	0x30B6, r24	; 0x8030b6 <pxDelayedTaskList>
    18ba:	90 93 b7 30 	sts	0x30B7, r25	; 0x8030b7 <pxDelayedTaskList+0x1>
    18be:	88 eb       	ldi	r24, 0xB8	; 184
    18c0:	90 e3       	ldi	r25, 0x30	; 48
    18c2:	80 93 b4 30 	sts	0x30B4, r24	; 0x8030b4 <pxOverflowDelayedTaskList>
    18c6:	90 93 b5 30 	sts	0x30B5, r25	; 0x8030b5 <pxOverflowDelayedTaskList+0x1>
    18ca:	0f c0       	rjmp	.+30     	; 0x18ea <xTaskGenericCreate+0x178>
    18cc:	80 91 9f 30 	lds	r24, 0x309F	; 0x80309f <xSchedulerRunning>
    18d0:	81 11       	cpse	r24, r1
    18d2:	0b c0       	rjmp	.+22     	; 0x18ea <xTaskGenericCreate+0x178>
    18d4:	e0 91 fa 30 	lds	r30, 0x30FA	; 0x8030fa <pxCurrentTCB>
    18d8:	f0 91 fb 30 	lds	r31, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    18dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    18de:	08 17       	cp	r16, r24
    18e0:	20 f0       	brcs	.+8      	; 0x18ea <xTaskGenericCreate+0x178>
    18e2:	c0 93 fa 30 	sts	0x30FA, r28	; 0x8030fa <pxCurrentTCB>
    18e6:	d0 93 fb 30 	sts	0x30FB, r29	; 0x8030fb <pxCurrentTCB+0x1>
    18ea:	8a 8d       	ldd	r24, Y+26	; 0x1a
    18ec:	90 91 a1 30 	lds	r25, 0x30A1	; 0x8030a1 <uxTopUsedPriority>
    18f0:	98 17       	cp	r25, r24
    18f2:	10 f4       	brcc	.+4      	; 0x18f8 <xTaskGenericCreate+0x186>
    18f4:	80 93 a1 30 	sts	0x30A1, r24	; 0x8030a1 <uxTopUsedPriority>
    18f8:	90 91 9a 30 	lds	r25, 0x309A	; 0x80309a <uxTaskNumber>
    18fc:	9f 5f       	subi	r25, 0xFF	; 255
    18fe:	90 93 9a 30 	sts	0x309A, r25	; 0x80309a <uxTaskNumber>
    1902:	90 91 a0 30 	lds	r25, 0x30A0	; 0x8030a0 <uxTopReadyPriority>
    1906:	98 17       	cp	r25, r24
    1908:	10 f4       	brcc	.+4      	; 0x190e <xTaskGenericCreate+0x19c>
    190a:	80 93 a0 30 	sts	0x30A0, r24	; 0x8030a0 <uxTopReadyPriority>
    190e:	fb e0       	ldi	r31, 0x0B	; 11
    1910:	8f 9f       	mul	r24, r31
    1912:	c0 01       	movw	r24, r0
    1914:	11 24       	eor	r1, r1
    1916:	b6 01       	movw	r22, r12
    1918:	82 53       	subi	r24, 0x32	; 50
    191a:	9f 4c       	sbci	r25, 0xCF	; 207
    191c:	0e 94 cd 06 	call	0xd9a	; 0xd9a <vListInsertEnd>
    1920:	0f 90       	pop	r0
    1922:	0f be       	out	0x3f, r0	; 63
    1924:	80 91 9f 30 	lds	r24, 0x309F	; 0x80309f <xSchedulerRunning>
    1928:	88 23       	and	r24, r24
    192a:	59 f0       	breq	.+22     	; 0x1942 <xTaskGenericCreate+0x1d0>
    192c:	e0 91 fa 30 	lds	r30, 0x30FA	; 0x8030fa <pxCurrentTCB>
    1930:	f0 91 fb 30 	lds	r31, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    1934:	82 8d       	ldd	r24, Z+26	; 0x1a
    1936:	80 17       	cp	r24, r16
    1938:	30 f4       	brcc	.+12     	; 0x1946 <xTaskGenericCreate+0x1d4>
    193a:	0e 94 1b 08 	call	0x1036	; 0x1036 <vPortYield>
    193e:	81 e0       	ldi	r24, 0x01	; 1
    1940:	09 c0       	rjmp	.+18     	; 0x1954 <xTaskGenericCreate+0x1e2>
    1942:	81 e0       	ldi	r24, 0x01	; 1
    1944:	07 c0       	rjmp	.+14     	; 0x1954 <xTaskGenericCreate+0x1e2>
    1946:	81 e0       	ldi	r24, 0x01	; 1
    1948:	05 c0       	rjmp	.+10     	; 0x1954 <xTaskGenericCreate+0x1e2>
    194a:	cb 8e       	std	Y+27, r12	; 0x1b
    194c:	dc 8e       	std	Y+28, r13	; 0x1c
    194e:	c6 01       	movw	r24, r12
    1950:	3b cf       	rjmp	.-394    	; 0x17c8 <xTaskGenericCreate+0x56>
    1952:	8f ef       	ldi	r24, 0xFF	; 255
    1954:	df 91       	pop	r29
    1956:	cf 91       	pop	r28
    1958:	1f 91       	pop	r17
    195a:	0f 91       	pop	r16
    195c:	ff 90       	pop	r15
    195e:	ef 90       	pop	r14
    1960:	df 90       	pop	r13
    1962:	cf 90       	pop	r12
    1964:	bf 90       	pop	r11
    1966:	af 90       	pop	r10
    1968:	9f 90       	pop	r9
    196a:	8f 90       	pop	r8
    196c:	7f 90       	pop	r7
    196e:	6f 90       	pop	r6
    1970:	5f 90       	pop	r5
    1972:	4f 90       	pop	r4
    1974:	08 95       	ret

00001976 <uxTaskPriorityGet>:
    1976:	0f b6       	in	r0, 0x3f	; 63
    1978:	f8 94       	cli
    197a:	0f 92       	push	r0
    197c:	00 97       	sbiw	r24, 0x00	; 0
    197e:	21 f4       	brne	.+8      	; 0x1988 <uxTaskPriorityGet+0x12>
    1980:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <pxCurrentTCB>
    1984:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    1988:	0f 90       	pop	r0
    198a:	0f be       	out	0x3f, r0	; 63
    198c:	fc 01       	movw	r30, r24
    198e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1990:	08 95       	ret

00001992 <vTaskStartScheduler>:
    1992:	af 92       	push	r10
    1994:	bf 92       	push	r11
    1996:	cf 92       	push	r12
    1998:	df 92       	push	r13
    199a:	ef 92       	push	r14
    199c:	ff 92       	push	r15
    199e:	0f 93       	push	r16
    19a0:	a1 2c       	mov	r10, r1
    19a2:	b1 2c       	mov	r11, r1
    19a4:	c1 2c       	mov	r12, r1
    19a6:	d1 2c       	mov	r13, r1
    19a8:	0f 2e       	mov	r0, r31
    19aa:	f7 ea       	ldi	r31, 0xA7	; 167
    19ac:	ef 2e       	mov	r14, r31
    19ae:	f0 e3       	ldi	r31, 0x30	; 48
    19b0:	ff 2e       	mov	r15, r31
    19b2:	f0 2d       	mov	r31, r0
    19b4:	00 e0       	ldi	r16, 0x00	; 0
    19b6:	20 e0       	ldi	r18, 0x00	; 0
    19b8:	30 e0       	ldi	r19, 0x00	; 0
    19ba:	44 e6       	ldi	r20, 0x64	; 100
    19bc:	50 e0       	ldi	r21, 0x00	; 0
    19be:	6e e1       	ldi	r22, 0x1E	; 30
    19c0:	70 e2       	ldi	r23, 0x20	; 32
    19c2:	83 e6       	ldi	r24, 0x63	; 99
    19c4:	9b e0       	ldi	r25, 0x0B	; 11
    19c6:	0e 94 b9 0b 	call	0x1772	; 0x1772 <xTaskGenericCreate>
    19ca:	81 30       	cpi	r24, 0x01	; 1
    19cc:	69 f4       	brne	.+26     	; 0x19e8 <vTaskStartScheduler+0x56>
    19ce:	f8 94       	cli
    19d0:	80 93 9f 30 	sts	0x309F, r24	; 0x80309f <xSchedulerRunning>
    19d4:	10 92 a2 30 	sts	0x30A2, r1	; 0x8030a2 <xTickCount>
    19d8:	10 92 a3 30 	sts	0x30A3, r1	; 0x8030a3 <xTickCount+0x1>
    19dc:	10 92 a4 30 	sts	0x30A4, r1	; 0x8030a4 <xTickCount+0x2>
    19e0:	10 92 a5 30 	sts	0x30A5, r1	; 0x8030a5 <xTickCount+0x3>
    19e4:	0e 94 db 07 	call	0xfb6	; 0xfb6 <xPortStartScheduler>
    19e8:	0f 91       	pop	r16
    19ea:	ff 90       	pop	r15
    19ec:	ef 90       	pop	r14
    19ee:	df 90       	pop	r13
    19f0:	cf 90       	pop	r12
    19f2:	bf 90       	pop	r11
    19f4:	af 90       	pop	r10
    19f6:	08 95       	ret

000019f8 <vTaskSuspendAll>:
    19f8:	80 91 9e 30 	lds	r24, 0x309E	; 0x80309e <uxSchedulerSuspended>
    19fc:	8f 5f       	subi	r24, 0xFF	; 255
    19fe:	80 93 9e 30 	sts	0x309E, r24	; 0x80309e <uxSchedulerSuspended>
    1a02:	08 95       	ret

00001a04 <xTaskGetTickCount>:
    1a04:	0f b6       	in	r0, 0x3f	; 63
    1a06:	f8 94       	cli
    1a08:	0f 92       	push	r0
    1a0a:	60 91 a2 30 	lds	r22, 0x30A2	; 0x8030a2 <xTickCount>
    1a0e:	70 91 a3 30 	lds	r23, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    1a12:	80 91 a4 30 	lds	r24, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    1a16:	90 91 a5 30 	lds	r25, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    1a1a:	0f 90       	pop	r0
    1a1c:	0f be       	out	0x3f, r0	; 63
    1a1e:	08 95       	ret

00001a20 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1a20:	00 97       	sbiw	r24, 0x00	; 0
    1a22:	21 f4       	brne	.+8      	; 0x1a2c <pcTaskGetTaskName+0xc>
    1a24:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <pxCurrentTCB>
    1a28:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    1a2c:	4d 96       	adiw	r24, 0x1d	; 29
    1a2e:	08 95       	ret

00001a30 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    1a30:	80 91 a7 30 	lds	r24, 0x30A7	; 0x8030a7 <xIdleTaskHandle>
    1a34:	90 91 a8 30 	lds	r25, 0x30A8	; 0x8030a8 <xIdleTaskHandle+0x1>
    1a38:	08 95       	ret

00001a3a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1a3a:	ff 92       	push	r15
    1a3c:	0f 93       	push	r16
    1a3e:	1f 93       	push	r17
    1a40:	cf 93       	push	r28
    1a42:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1a44:	80 91 9e 30 	lds	r24, 0x309E	; 0x80309e <uxSchedulerSuspended>
    1a48:	81 11       	cpse	r24, r1
    1a4a:	ed c0       	rjmp	.+474    	; 0x1c26 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    1a4c:	80 91 a2 30 	lds	r24, 0x30A2	; 0x8030a2 <xTickCount>
    1a50:	90 91 a3 30 	lds	r25, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    1a54:	a0 91 a4 30 	lds	r26, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    1a58:	b0 91 a5 30 	lds	r27, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    1a5c:	01 96       	adiw	r24, 0x01	; 1
    1a5e:	a1 1d       	adc	r26, r1
    1a60:	b1 1d       	adc	r27, r1
    1a62:	80 93 a2 30 	sts	0x30A2, r24	; 0x8030a2 <xTickCount>
    1a66:	90 93 a3 30 	sts	0x30A3, r25	; 0x8030a3 <xTickCount+0x1>
    1a6a:	a0 93 a4 30 	sts	0x30A4, r26	; 0x8030a4 <xTickCount+0x2>
    1a6e:	b0 93 a5 30 	sts	0x30A5, r27	; 0x8030a5 <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    1a72:	80 91 a2 30 	lds	r24, 0x30A2	; 0x8030a2 <xTickCount>
    1a76:	90 91 a3 30 	lds	r25, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    1a7a:	a0 91 a4 30 	lds	r26, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    1a7e:	b0 91 a5 30 	lds	r27, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    1a82:	89 2b       	or	r24, r25
    1a84:	8a 2b       	or	r24, r26
    1a86:	8b 2b       	or	r24, r27
    1a88:	f1 f5       	brne	.+124    	; 0x1b06 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1a8a:	80 91 b6 30 	lds	r24, 0x30B6	; 0x8030b6 <pxDelayedTaskList>
    1a8e:	90 91 b7 30 	lds	r25, 0x30B7	; 0x8030b7 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1a92:	20 91 b4 30 	lds	r18, 0x30B4	; 0x8030b4 <pxOverflowDelayedTaskList>
    1a96:	30 91 b5 30 	lds	r19, 0x30B5	; 0x8030b5 <pxOverflowDelayedTaskList+0x1>
    1a9a:	20 93 b6 30 	sts	0x30B6, r18	; 0x8030b6 <pxDelayedTaskList>
    1a9e:	30 93 b7 30 	sts	0x30B7, r19	; 0x8030b7 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    1aa2:	80 93 b4 30 	sts	0x30B4, r24	; 0x8030b4 <pxOverflowDelayedTaskList>
    1aa6:	90 93 b5 30 	sts	0x30B5, r25	; 0x8030b5 <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    1aaa:	80 91 9b 30 	lds	r24, 0x309B	; 0x80309b <xNumOfOverflows>
    1aae:	8f 5f       	subi	r24, 0xFF	; 255
    1ab0:	80 93 9b 30 	sts	0x309B, r24	; 0x80309b <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1ab4:	e0 91 b6 30 	lds	r30, 0x30B6	; 0x8030b6 <pxDelayedTaskList>
    1ab8:	f0 91 b7 30 	lds	r31, 0x30B7	; 0x8030b7 <pxDelayedTaskList+0x1>
    1abc:	80 81       	ld	r24, Z
    1abe:	81 11       	cpse	r24, r1
    1ac0:	0c c0       	rjmp	.+24     	; 0x1ada <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1ac2:	8f ef       	ldi	r24, 0xFF	; 255
    1ac4:	9f ef       	ldi	r25, 0xFF	; 255
    1ac6:	dc 01       	movw	r26, r24
    1ac8:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1acc:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1ad0:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1ad4:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1ad8:	16 c0       	rjmp	.+44     	; 0x1b06 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1ada:	e0 91 b6 30 	lds	r30, 0x30B6	; 0x8030b6 <pxDelayedTaskList>
    1ade:	f0 91 b7 30 	lds	r31, 0x30B7	; 0x8030b7 <pxDelayedTaskList+0x1>
    1ae2:	07 80       	ldd	r0, Z+7	; 0x07
    1ae4:	f0 85       	ldd	r31, Z+8	; 0x08
    1ae6:	e0 2d       	mov	r30, r0
    1ae8:	00 84       	ldd	r0, Z+8	; 0x08
    1aea:	f1 85       	ldd	r31, Z+9	; 0x09
    1aec:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1aee:	82 81       	ldd	r24, Z+2	; 0x02
    1af0:	93 81       	ldd	r25, Z+3	; 0x03
    1af2:	a4 81       	ldd	r26, Z+4	; 0x04
    1af4:	b5 81       	ldd	r27, Z+5	; 0x05
    1af6:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1afa:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1afe:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1b02:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1b06:	40 91 a2 30 	lds	r20, 0x30A2	; 0x8030a2 <xTickCount>
    1b0a:	50 91 a3 30 	lds	r21, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    1b0e:	60 91 a4 30 	lds	r22, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    1b12:	70 91 a5 30 	lds	r23, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    1b16:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1b1a:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1b1e:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1b22:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1b26:	48 17       	cp	r20, r24
    1b28:	59 07       	cpc	r21, r25
    1b2a:	6a 07       	cpc	r22, r26
    1b2c:	7b 07       	cpc	r23, r27
    1b2e:	08 f4       	brcc	.+2      	; 0x1b32 <vTaskIncrementTick+0xf8>
    1b30:	7f c0       	rjmp	.+254    	; 0x1c30 <vTaskIncrementTick+0x1f6>
    1b32:	e0 91 b6 30 	lds	r30, 0x30B6	; 0x8030b6 <pxDelayedTaskList>
    1b36:	f0 91 b7 30 	lds	r31, 0x30B7	; 0x8030b7 <pxDelayedTaskList+0x1>
    1b3a:	80 81       	ld	r24, Z
    1b3c:	88 23       	and	r24, r24
    1b3e:	f9 f0       	breq	.+62     	; 0x1b7e <vTaskIncrementTick+0x144>
    1b40:	e0 91 b6 30 	lds	r30, 0x30B6	; 0x8030b6 <pxDelayedTaskList>
    1b44:	f0 91 b7 30 	lds	r31, 0x30B7	; 0x8030b7 <pxDelayedTaskList+0x1>
    1b48:	07 80       	ldd	r0, Z+7	; 0x07
    1b4a:	f0 85       	ldd	r31, Z+8	; 0x08
    1b4c:	e0 2d       	mov	r30, r0
    1b4e:	c0 85       	ldd	r28, Z+8	; 0x08
    1b50:	d1 85       	ldd	r29, Z+9	; 0x09
    1b52:	8a 81       	ldd	r24, Y+2	; 0x02
    1b54:	9b 81       	ldd	r25, Y+3	; 0x03
    1b56:	ac 81       	ldd	r26, Y+4	; 0x04
    1b58:	bd 81       	ldd	r27, Y+5	; 0x05
    1b5a:	40 91 a2 30 	lds	r20, 0x30A2	; 0x8030a2 <xTickCount>
    1b5e:	50 91 a3 30 	lds	r21, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    1b62:	60 91 a4 30 	lds	r22, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    1b66:	70 91 a5 30 	lds	r23, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    1b6a:	48 17       	cp	r20, r24
    1b6c:	59 07       	cpc	r21, r25
    1b6e:	6a 07       	cpc	r22, r26
    1b70:	7b 07       	cpc	r23, r27
    1b72:	58 f1       	brcs	.+86     	; 0x1bca <vTaskIncrementTick+0x190>
    1b74:	0f 2e       	mov	r0, r31
    1b76:	fb e0       	ldi	r31, 0x0B	; 11
    1b78:	ff 2e       	mov	r15, r31
    1b7a:	f0 2d       	mov	r31, r0
    1b7c:	2f c0       	rjmp	.+94     	; 0x1bdc <vTaskIncrementTick+0x1a2>
    1b7e:	8f ef       	ldi	r24, 0xFF	; 255
    1b80:	9f ef       	ldi	r25, 0xFF	; 255
    1b82:	dc 01       	movw	r26, r24
    1b84:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1b88:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1b8c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1b90:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1b94:	4d c0       	rjmp	.+154    	; 0x1c30 <vTaskIncrementTick+0x1f6>
    1b96:	e0 91 b6 30 	lds	r30, 0x30B6	; 0x8030b6 <pxDelayedTaskList>
    1b9a:	f0 91 b7 30 	lds	r31, 0x30B7	; 0x8030b7 <pxDelayedTaskList+0x1>
    1b9e:	07 80       	ldd	r0, Z+7	; 0x07
    1ba0:	f0 85       	ldd	r31, Z+8	; 0x08
    1ba2:	e0 2d       	mov	r30, r0
    1ba4:	c0 85       	ldd	r28, Z+8	; 0x08
    1ba6:	d1 85       	ldd	r29, Z+9	; 0x09
    1ba8:	8a 81       	ldd	r24, Y+2	; 0x02
    1baa:	9b 81       	ldd	r25, Y+3	; 0x03
    1bac:	ac 81       	ldd	r26, Y+4	; 0x04
    1bae:	bd 81       	ldd	r27, Y+5	; 0x05
    1bb0:	40 91 a2 30 	lds	r20, 0x30A2	; 0x8030a2 <xTickCount>
    1bb4:	50 91 a3 30 	lds	r21, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    1bb8:	60 91 a4 30 	lds	r22, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    1bbc:	70 91 a5 30 	lds	r23, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    1bc0:	48 17       	cp	r20, r24
    1bc2:	59 07       	cpc	r21, r25
    1bc4:	6a 07       	cpc	r22, r26
    1bc6:	7b 07       	cpc	r23, r27
    1bc8:	48 f4       	brcc	.+18     	; 0x1bdc <vTaskIncrementTick+0x1a2>
    1bca:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1bce:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1bd2:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1bd6:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1bda:	2a c0       	rjmp	.+84     	; 0x1c30 <vTaskIncrementTick+0x1f6>
    1bdc:	8e 01       	movw	r16, r28
    1bde:	0e 5f       	subi	r16, 0xFE	; 254
    1be0:	1f 4f       	sbci	r17, 0xFF	; 255
    1be2:	c8 01       	movw	r24, r16
    1be4:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vListRemove>
    1be8:	88 8d       	ldd	r24, Y+24	; 0x18
    1bea:	99 8d       	ldd	r25, Y+25	; 0x19
    1bec:	89 2b       	or	r24, r25
    1bee:	21 f0       	breq	.+8      	; 0x1bf8 <vTaskIncrementTick+0x1be>
    1bf0:	ce 01       	movw	r24, r28
    1bf2:	0e 96       	adiw	r24, 0x0e	; 14
    1bf4:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vListRemove>
    1bf8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1bfa:	90 91 a0 30 	lds	r25, 0x30A0	; 0x8030a0 <uxTopReadyPriority>
    1bfe:	98 17       	cp	r25, r24
    1c00:	10 f4       	brcc	.+4      	; 0x1c06 <vTaskIncrementTick+0x1cc>
    1c02:	80 93 a0 30 	sts	0x30A0, r24	; 0x8030a0 <uxTopReadyPriority>
    1c06:	f8 9e       	mul	r15, r24
    1c08:	c0 01       	movw	r24, r0
    1c0a:	11 24       	eor	r1, r1
    1c0c:	b8 01       	movw	r22, r16
    1c0e:	82 53       	subi	r24, 0x32	; 50
    1c10:	9f 4c       	sbci	r25, 0xCF	; 207
    1c12:	0e 94 cd 06 	call	0xd9a	; 0xd9a <vListInsertEnd>
    1c16:	e0 91 b6 30 	lds	r30, 0x30B6	; 0x8030b6 <pxDelayedTaskList>
    1c1a:	f0 91 b7 30 	lds	r31, 0x30B7	; 0x8030b7 <pxDelayedTaskList+0x1>
    1c1e:	80 81       	ld	r24, Z
    1c20:	81 11       	cpse	r24, r1
    1c22:	b9 cf       	rjmp	.-142    	; 0x1b96 <vTaskIncrementTick+0x15c>
    1c24:	ac cf       	rjmp	.-168    	; 0x1b7e <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    1c26:	80 91 9d 30 	lds	r24, 0x309D	; 0x80309d <uxMissedTicks>
    1c2a:	8f 5f       	subi	r24, 0xFF	; 255
    1c2c:	80 93 9d 30 	sts	0x309D, r24	; 0x80309d <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1c30:	df 91       	pop	r29
    1c32:	cf 91       	pop	r28
    1c34:	1f 91       	pop	r17
    1c36:	0f 91       	pop	r16
    1c38:	ff 90       	pop	r15
    1c3a:	08 95       	ret

00001c3c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1c3c:	cf 92       	push	r12
    1c3e:	df 92       	push	r13
    1c40:	ef 92       	push	r14
    1c42:	ff 92       	push	r15
    1c44:	0f 93       	push	r16
    1c46:	1f 93       	push	r17
    1c48:	cf 93       	push	r28
    1c4a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1c4c:	0f b6       	in	r0, 0x3f	; 63
    1c4e:	f8 94       	cli
    1c50:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1c52:	80 91 9e 30 	lds	r24, 0x309E	; 0x80309e <uxSchedulerSuspended>
    1c56:	81 50       	subi	r24, 0x01	; 1
    1c58:	80 93 9e 30 	sts	0x309E, r24	; 0x80309e <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1c5c:	80 91 9e 30 	lds	r24, 0x309E	; 0x80309e <uxSchedulerSuspended>
    1c60:	81 11       	cpse	r24, r1
    1c62:	60 c0       	rjmp	.+192    	; 0x1d24 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1c64:	80 91 a6 30 	lds	r24, 0x30A6	; 0x8030a6 <uxCurrentNumberOfTasks>
    1c68:	81 11       	cpse	r24, r1
    1c6a:	2c c0       	rjmp	.+88     	; 0x1cc4 <xTaskResumeAll+0x88>
    1c6c:	5e c0       	rjmp	.+188    	; 0x1d2a <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1c6e:	d7 01       	movw	r26, r14
    1c70:	17 96       	adiw	r26, 0x07	; 7
    1c72:	ed 91       	ld	r30, X+
    1c74:	fc 91       	ld	r31, X
    1c76:	18 97       	sbiw	r26, 0x08	; 8
    1c78:	c0 85       	ldd	r28, Z+8	; 0x08
    1c7a:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    1c7c:	ce 01       	movw	r24, r28
    1c7e:	0e 96       	adiw	r24, 0x0e	; 14
    1c80:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1c84:	8e 01       	movw	r16, r28
    1c86:	0e 5f       	subi	r16, 0xFE	; 254
    1c88:	1f 4f       	sbci	r17, 0xFF	; 255
    1c8a:	c8 01       	movw	r24, r16
    1c8c:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1c90:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c92:	90 91 a0 30 	lds	r25, 0x30A0	; 0x8030a0 <uxTopReadyPriority>
    1c96:	98 17       	cp	r25, r24
    1c98:	10 f4       	brcc	.+4      	; 0x1c9e <xTaskResumeAll+0x62>
    1c9a:	80 93 a0 30 	sts	0x30A0, r24	; 0x8030a0 <uxTopReadyPriority>
    1c9e:	d8 9e       	mul	r13, r24
    1ca0:	c0 01       	movw	r24, r0
    1ca2:	11 24       	eor	r1, r1
    1ca4:	b8 01       	movw	r22, r16
    1ca6:	82 53       	subi	r24, 0x32	; 50
    1ca8:	9f 4c       	sbci	r25, 0xCF	; 207
    1caa:	0e 94 cd 06 	call	0xd9a	; 0xd9a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1cae:	e0 91 fa 30 	lds	r30, 0x30FA	; 0x8030fa <pxCurrentTCB>
    1cb2:	f0 91 fb 30 	lds	r31, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    1cb6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1cb8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cba:	98 17       	cp	r25, r24
    1cbc:	70 f0       	brcs	.+28     	; 0x1cda <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    1cbe:	cc 24       	eor	r12, r12
    1cc0:	c3 94       	inc	r12
    1cc2:	0b c0       	rjmp	.+22     	; 0x1cda <xTaskResumeAll+0x9e>
    1cc4:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1cc6:	0f 2e       	mov	r0, r31
    1cc8:	f9 ea       	ldi	r31, 0xA9	; 169
    1cca:	ef 2e       	mov	r14, r31
    1ccc:	f0 e3       	ldi	r31, 0x30	; 48
    1cce:	ff 2e       	mov	r15, r31
    1cd0:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    1cd2:	0f 2e       	mov	r0, r31
    1cd4:	fb e0       	ldi	r31, 0x0B	; 11
    1cd6:	df 2e       	mov	r13, r31
    1cd8:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1cda:	f7 01       	movw	r30, r14
    1cdc:	80 81       	ld	r24, Z
    1cde:	81 11       	cpse	r24, r1
    1ce0:	c6 cf       	rjmp	.-116    	; 0x1c6e <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ce2:	80 91 9d 30 	lds	r24, 0x309D	; 0x80309d <uxMissedTicks>
    1ce6:	88 23       	and	r24, r24
    1ce8:	81 f0       	breq	.+32     	; 0x1d0a <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1cea:	80 91 9d 30 	lds	r24, 0x309D	; 0x80309d <uxMissedTicks>
    1cee:	88 23       	and	r24, r24
    1cf0:	99 f0       	breq	.+38     	; 0x1d18 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    1cf2:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <vTaskIncrementTick>
						--uxMissedTicks;
    1cf6:	80 91 9d 30 	lds	r24, 0x309D	; 0x80309d <uxMissedTicks>
    1cfa:	81 50       	subi	r24, 0x01	; 1
    1cfc:	80 93 9d 30 	sts	0x309D, r24	; 0x80309d <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1d00:	80 91 9d 30 	lds	r24, 0x309D	; 0x80309d <uxMissedTicks>
    1d04:	81 11       	cpse	r24, r1
    1d06:	f5 cf       	rjmp	.-22     	; 0x1cf2 <xTaskResumeAll+0xb6>
    1d08:	07 c0       	rjmp	.+14     	; 0x1d18 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1d0a:	f1 e0       	ldi	r31, 0x01	; 1
    1d0c:	cf 16       	cp	r12, r31
    1d0e:	21 f0       	breq	.+8      	; 0x1d18 <xTaskResumeAll+0xdc>
    1d10:	80 91 9c 30 	lds	r24, 0x309C	; 0x80309c <xMissedYield>
    1d14:	81 30       	cpi	r24, 0x01	; 1
    1d16:	41 f4       	brne	.+16     	; 0x1d28 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1d18:	10 92 9c 30 	sts	0x309C, r1	; 0x80309c <xMissedYield>
					portYIELD_WITHIN_API();
    1d1c:	0e 94 1b 08 	call	0x1036	; 0x1036 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    1d20:	81 e0       	ldi	r24, 0x01	; 1
    1d22:	03 c0       	rjmp	.+6      	; 0x1d2a <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1d24:	80 e0       	ldi	r24, 0x00	; 0
    1d26:	01 c0       	rjmp	.+2      	; 0x1d2a <xTaskResumeAll+0xee>
    1d28:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1d2a:	0f 90       	pop	r0
    1d2c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1d2e:	df 91       	pop	r29
    1d30:	cf 91       	pop	r28
    1d32:	1f 91       	pop	r17
    1d34:	0f 91       	pop	r16
    1d36:	ff 90       	pop	r15
    1d38:	ef 90       	pop	r14
    1d3a:	df 90       	pop	r13
    1d3c:	cf 90       	pop	r12
    1d3e:	08 95       	ret

00001d40 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1d40:	cf 92       	push	r12
    1d42:	df 92       	push	r13
    1d44:	ef 92       	push	r14
    1d46:	ff 92       	push	r15
    1d48:	cf 93       	push	r28
    1d4a:	df 93       	push	r29
    1d4c:	ec 01       	movw	r28, r24
    1d4e:	6a 01       	movw	r12, r20
    1d50:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1d52:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1d56:	88 81       	ld	r24, Y
    1d58:	99 81       	ldd	r25, Y+1	; 0x01
    1d5a:	aa 81       	ldd	r26, Y+2	; 0x02
    1d5c:	bb 81       	ldd	r27, Y+3	; 0x03
    1d5e:	c8 0e       	add	r12, r24
    1d60:	d9 1e       	adc	r13, r25
    1d62:	ea 1e       	adc	r14, r26
    1d64:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    1d66:	40 91 a2 30 	lds	r20, 0x30A2	; 0x8030a2 <xTickCount>
    1d6a:	50 91 a3 30 	lds	r21, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    1d6e:	60 91 a4 30 	lds	r22, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    1d72:	70 91 a5 30 	lds	r23, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    1d76:	48 17       	cp	r20, r24
    1d78:	59 07       	cpc	r21, r25
    1d7a:	6a 07       	cpc	r22, r26
    1d7c:	7b 07       	cpc	r23, r27
    1d7e:	b8 f4       	brcc	.+46     	; 0x1dae <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1d80:	c8 16       	cp	r12, r24
    1d82:	d9 06       	cpc	r13, r25
    1d84:	ea 06       	cpc	r14, r26
    1d86:	fb 06       	cpc	r15, r27
    1d88:	e0 f5       	brcc	.+120    	; 0x1e02 <vTaskDelayUntil+0xc2>
    1d8a:	80 91 a2 30 	lds	r24, 0x30A2	; 0x8030a2 <xTickCount>
    1d8e:	90 91 a3 30 	lds	r25, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    1d92:	a0 91 a4 30 	lds	r26, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    1d96:	b0 91 a5 30 	lds	r27, 0x30A5	; 0x8030a5 <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1d9a:	c8 82       	st	Y, r12
    1d9c:	d9 82       	std	Y+1, r13	; 0x01
    1d9e:	ea 82       	std	Y+2, r14	; 0x02
    1da0:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    1da2:	8c 15       	cp	r24, r12
    1da4:	9d 05       	cpc	r25, r13
    1da6:	ae 05       	cpc	r26, r14
    1da8:	bf 05       	cpc	r27, r15
    1daa:	f8 f4       	brcc	.+62     	; 0x1dea <vTaskDelayUntil+0xaa>
    1dac:	13 c0       	rjmp	.+38     	; 0x1dd4 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1dae:	c8 16       	cp	r12, r24
    1db0:	d9 06       	cpc	r13, r25
    1db2:	ea 06       	cpc	r14, r26
    1db4:	fb 06       	cpc	r15, r27
    1db6:	00 f1       	brcs	.+64     	; 0x1df8 <vTaskDelayUntil+0xb8>
    1db8:	80 91 a2 30 	lds	r24, 0x30A2	; 0x8030a2 <xTickCount>
    1dbc:	90 91 a3 30 	lds	r25, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    1dc0:	a0 91 a4 30 	lds	r26, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    1dc4:	b0 91 a5 30 	lds	r27, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    1dc8:	8c 15       	cp	r24, r12
    1dca:	9d 05       	cpc	r25, r13
    1dcc:	ae 05       	cpc	r26, r14
    1dce:	bf 05       	cpc	r27, r15
    1dd0:	98 f0       	brcs	.+38     	; 0x1df8 <vTaskDelayUntil+0xb8>
    1dd2:	17 c0       	rjmp	.+46     	; 0x1e02 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1dd4:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <pxCurrentTCB>
    1dd8:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    1ddc:	02 96       	adiw	r24, 0x02	; 2
    1dde:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1de2:	c7 01       	movw	r24, r14
    1de4:	b6 01       	movw	r22, r12
    1de6:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1dea:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1dee:	81 11       	cpse	r24, r1
    1df0:	0d c0       	rjmp	.+26     	; 0x1e0c <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    1df2:	0e 94 1b 08 	call	0x1036	; 0x1036 <vPortYield>
		}
	}
    1df6:	0a c0       	rjmp	.+20     	; 0x1e0c <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1df8:	c8 82       	st	Y, r12
    1dfa:	d9 82       	std	Y+1, r13	; 0x01
    1dfc:	ea 82       	std	Y+2, r14	; 0x02
    1dfe:	fb 82       	std	Y+3, r15	; 0x03
    1e00:	e9 cf       	rjmp	.-46     	; 0x1dd4 <vTaskDelayUntil+0x94>
    1e02:	c8 82       	st	Y, r12
    1e04:	d9 82       	std	Y+1, r13	; 0x01
    1e06:	ea 82       	std	Y+2, r14	; 0x02
    1e08:	fb 82       	std	Y+3, r15	; 0x03
    1e0a:	ef cf       	rjmp	.-34     	; 0x1dea <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1e0c:	df 91       	pop	r29
    1e0e:	cf 91       	pop	r28
    1e10:	ff 90       	pop	r15
    1e12:	ef 90       	pop	r14
    1e14:	df 90       	pop	r13
    1e16:	cf 90       	pop	r12
    1e18:	08 95       	ret

00001e1a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1e1a:	cf 92       	push	r12
    1e1c:	df 92       	push	r13
    1e1e:	ef 92       	push	r14
    1e20:	ff 92       	push	r15
    1e22:	6b 01       	movw	r12, r22
    1e24:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1e26:	67 2b       	or	r22, r23
    1e28:	68 2b       	or	r22, r24
    1e2a:	69 2b       	or	r22, r25
    1e2c:	e9 f0       	breq	.+58     	; 0x1e68 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    1e2e:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1e32:	80 91 a2 30 	lds	r24, 0x30A2	; 0x8030a2 <xTickCount>
    1e36:	90 91 a3 30 	lds	r25, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    1e3a:	a0 91 a4 30 	lds	r26, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    1e3e:	b0 91 a5 30 	lds	r27, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    1e42:	c8 0e       	add	r12, r24
    1e44:	d9 1e       	adc	r13, r25
    1e46:	ea 1e       	adc	r14, r26
    1e48:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e4a:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <pxCurrentTCB>
    1e4e:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    1e52:	02 96       	adiw	r24, 0x02	; 2
    1e54:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1e58:	c7 01       	movw	r24, r14
    1e5a:	b6 01       	movw	r22, r12
    1e5c:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1e60:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1e64:	81 11       	cpse	r24, r1
    1e66:	02 c0       	rjmp	.+4      	; 0x1e6c <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    1e68:	0e 94 1b 08 	call	0x1036	; 0x1036 <vPortYield>
		}
	}
    1e6c:	ff 90       	pop	r15
    1e6e:	ef 90       	pop	r14
    1e70:	df 90       	pop	r13
    1e72:	cf 90       	pop	r12
    1e74:	08 95       	ret

00001e76 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1e76:	80 91 9e 30 	lds	r24, 0x309E	; 0x80309e <uxSchedulerSuspended>
    1e7a:	81 11       	cpse	r24, r1
    1e7c:	0c c0       	rjmp	.+24     	; 0x1e96 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1e7e:	e0 91 a0 30 	lds	r30, 0x30A0	; 0x8030a0 <uxTopReadyPriority>
    1e82:	4b e0       	ldi	r20, 0x0B	; 11
    1e84:	e4 9f       	mul	r30, r20
    1e86:	f0 01       	movw	r30, r0
    1e88:	11 24       	eor	r1, r1
    1e8a:	e2 53       	subi	r30, 0x32	; 50
    1e8c:	ff 4c       	sbci	r31, 0xCF	; 207
    1e8e:	80 81       	ld	r24, Z
    1e90:	88 23       	and	r24, r24
    1e92:	29 f0       	breq	.+10     	; 0x1e9e <vTaskSwitchContext+0x28>
    1e94:	14 c0       	rjmp	.+40     	; 0x1ebe <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1e96:	81 e0       	ldi	r24, 0x01	; 1
    1e98:	80 93 9c 30 	sts	0x309C, r24	; 0x80309c <xMissedYield>
    1e9c:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1e9e:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1ea0:	80 91 a0 30 	lds	r24, 0x30A0	; 0x8030a0 <uxTopReadyPriority>
    1ea4:	81 50       	subi	r24, 0x01	; 1
    1ea6:	80 93 a0 30 	sts	0x30A0, r24	; 0x8030a0 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1eaa:	e0 91 a0 30 	lds	r30, 0x30A0	; 0x8030a0 <uxTopReadyPriority>
    1eae:	9e 9f       	mul	r25, r30
    1eb0:	f0 01       	movw	r30, r0
    1eb2:	11 24       	eor	r1, r1
    1eb4:	e2 53       	subi	r30, 0x32	; 50
    1eb6:	ff 4c       	sbci	r31, 0xCF	; 207
    1eb8:	80 81       	ld	r24, Z
    1eba:	88 23       	and	r24, r24
    1ebc:	89 f3       	breq	.-30     	; 0x1ea0 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1ebe:	80 91 a0 30 	lds	r24, 0x30A0	; 0x8030a0 <uxTopReadyPriority>
    1ec2:	28 2f       	mov	r18, r24
    1ec4:	30 e0       	ldi	r19, 0x00	; 0
    1ec6:	4b e0       	ldi	r20, 0x0B	; 11
    1ec8:	84 9f       	mul	r24, r20
    1eca:	c0 01       	movw	r24, r0
    1ecc:	11 24       	eor	r1, r1
    1ece:	dc 01       	movw	r26, r24
    1ed0:	a2 53       	subi	r26, 0x32	; 50
    1ed2:	bf 4c       	sbci	r27, 0xCF	; 207
    1ed4:	11 96       	adiw	r26, 0x01	; 1
    1ed6:	ed 91       	ld	r30, X+
    1ed8:	fc 91       	ld	r31, X
    1eda:	12 97       	sbiw	r26, 0x02	; 2
    1edc:	04 80       	ldd	r0, Z+4	; 0x04
    1ede:	f5 81       	ldd	r31, Z+5	; 0x05
    1ee0:	e0 2d       	mov	r30, r0
    1ee2:	11 96       	adiw	r26, 0x01	; 1
    1ee4:	ed 93       	st	X+, r30
    1ee6:	fc 93       	st	X, r31
    1ee8:	12 97       	sbiw	r26, 0x02	; 2
    1eea:	8f 52       	subi	r24, 0x2F	; 47
    1eec:	9f 4c       	sbci	r25, 0xCF	; 207
    1eee:	e8 17       	cp	r30, r24
    1ef0:	f9 07       	cpc	r31, r25
    1ef2:	61 f4       	brne	.+24     	; 0x1f0c <vTaskSwitchContext+0x96>
    1ef4:	84 81       	ldd	r24, Z+4	; 0x04
    1ef6:	95 81       	ldd	r25, Z+5	; 0x05
    1ef8:	4b e0       	ldi	r20, 0x0B	; 11
    1efa:	42 9f       	mul	r20, r18
    1efc:	f0 01       	movw	r30, r0
    1efe:	43 9f       	mul	r20, r19
    1f00:	f0 0d       	add	r31, r0
    1f02:	11 24       	eor	r1, r1
    1f04:	e2 53       	subi	r30, 0x32	; 50
    1f06:	ff 4c       	sbci	r31, 0xCF	; 207
    1f08:	81 83       	std	Z+1, r24	; 0x01
    1f0a:	92 83       	std	Z+2, r25	; 0x02
    1f0c:	8b e0       	ldi	r24, 0x0B	; 11
    1f0e:	82 9f       	mul	r24, r18
    1f10:	f0 01       	movw	r30, r0
    1f12:	83 9f       	mul	r24, r19
    1f14:	f0 0d       	add	r31, r0
    1f16:	11 24       	eor	r1, r1
    1f18:	e2 53       	subi	r30, 0x32	; 50
    1f1a:	ff 4c       	sbci	r31, 0xCF	; 207
    1f1c:	01 80       	ldd	r0, Z+1	; 0x01
    1f1e:	f2 81       	ldd	r31, Z+2	; 0x02
    1f20:	e0 2d       	mov	r30, r0
    1f22:	80 85       	ldd	r24, Z+8	; 0x08
    1f24:	91 85       	ldd	r25, Z+9	; 0x09
    1f26:	80 93 fa 30 	sts	0x30FA, r24	; 0x8030fa <pxCurrentTCB>
    1f2a:	90 93 fb 30 	sts	0x30FB, r25	; 0x8030fb <pxCurrentTCB+0x1>
    1f2e:	08 95       	ret

00001f30 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1f30:	cf 92       	push	r12
    1f32:	df 92       	push	r13
    1f34:	ef 92       	push	r14
    1f36:	ff 92       	push	r15
    1f38:	6a 01       	movw	r12, r20
    1f3a:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1f3c:	60 91 fa 30 	lds	r22, 0x30FA	; 0x8030fa <pxCurrentTCB>
    1f40:	70 91 fb 30 	lds	r23, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    1f44:	62 5f       	subi	r22, 0xF2	; 242
    1f46:	7f 4f       	sbci	r23, 0xFF	; 255
    1f48:	0e 94 f4 06 	call	0xde8	; 0xde8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1f4c:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <pxCurrentTCB>
    1f50:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    1f54:	02 96       	adiw	r24, 0x02	; 2
    1f56:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1f5a:	80 91 a2 30 	lds	r24, 0x30A2	; 0x8030a2 <xTickCount>
    1f5e:	90 91 a3 30 	lds	r25, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    1f62:	a0 91 a4 30 	lds	r26, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    1f66:	b0 91 a5 30 	lds	r27, 0x30A5	; 0x8030a5 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1f6a:	bc 01       	movw	r22, r24
    1f6c:	cd 01       	movw	r24, r26
    1f6e:	6c 0d       	add	r22, r12
    1f70:	7d 1d       	adc	r23, r13
    1f72:	8e 1d       	adc	r24, r14
    1f74:	9f 1d       	adc	r25, r15
    1f76:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    1f7a:	ff 90       	pop	r15
    1f7c:	ef 90       	pop	r14
    1f7e:	df 90       	pop	r13
    1f80:	cf 90       	pop	r12
    1f82:	08 95       	ret

00001f84 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1f84:	0f 93       	push	r16
    1f86:	1f 93       	push	r17
    1f88:	cf 93       	push	r28
    1f8a:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1f8c:	dc 01       	movw	r26, r24
    1f8e:	17 96       	adiw	r26, 0x07	; 7
    1f90:	ed 91       	ld	r30, X+
    1f92:	fc 91       	ld	r31, X
    1f94:	18 97       	sbiw	r26, 0x08	; 8
    1f96:	c0 85       	ldd	r28, Z+8	; 0x08
    1f98:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1f9a:	8e 01       	movw	r16, r28
    1f9c:	02 5f       	subi	r16, 0xF2	; 242
    1f9e:	1f 4f       	sbci	r17, 0xFF	; 255
    1fa0:	c8 01       	movw	r24, r16
    1fa2:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1fa6:	80 91 9e 30 	lds	r24, 0x309E	; 0x80309e <uxSchedulerSuspended>
    1faa:	81 11       	cpse	r24, r1
    1fac:	16 c0       	rjmp	.+44     	; 0x1fda <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1fae:	0c 50       	subi	r16, 0x0C	; 12
    1fb0:	11 09       	sbc	r17, r1
    1fb2:	c8 01       	movw	r24, r16
    1fb4:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1fb8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fba:	90 91 a0 30 	lds	r25, 0x30A0	; 0x8030a0 <uxTopReadyPriority>
    1fbe:	98 17       	cp	r25, r24
    1fc0:	10 f4       	brcc	.+4      	; 0x1fc6 <xTaskRemoveFromEventList+0x42>
    1fc2:	80 93 a0 30 	sts	0x30A0, r24	; 0x8030a0 <uxTopReadyPriority>
    1fc6:	bb e0       	ldi	r27, 0x0B	; 11
    1fc8:	8b 9f       	mul	r24, r27
    1fca:	c0 01       	movw	r24, r0
    1fcc:	11 24       	eor	r1, r1
    1fce:	b8 01       	movw	r22, r16
    1fd0:	82 53       	subi	r24, 0x32	; 50
    1fd2:	9f 4c       	sbci	r25, 0xCF	; 207
    1fd4:	0e 94 cd 06 	call	0xd9a	; 0xd9a <vListInsertEnd>
    1fd8:	05 c0       	rjmp	.+10     	; 0x1fe4 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1fda:	b8 01       	movw	r22, r16
    1fdc:	89 ea       	ldi	r24, 0xA9	; 169
    1fde:	90 e3       	ldi	r25, 0x30	; 48
    1fe0:	0e 94 cd 06 	call	0xd9a	; 0xd9a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1fe4:	e0 91 fa 30 	lds	r30, 0x30FA	; 0x8030fa <pxCurrentTCB>
    1fe8:	f0 91 fb 30 	lds	r31, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1fec:	81 e0       	ldi	r24, 0x01	; 1
    1fee:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1ff0:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ff2:	29 17       	cp	r18, r25
    1ff4:	08 f4       	brcc	.+2      	; 0x1ff8 <xTaskRemoveFromEventList+0x74>
    1ff6:	80 e0       	ldi	r24, 0x00	; 0
}
    1ff8:	df 91       	pop	r29
    1ffa:	cf 91       	pop	r28
    1ffc:	1f 91       	pop	r17
    1ffe:	0f 91       	pop	r16
    2000:	08 95       	ret

00002002 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2002:	20 91 9b 30 	lds	r18, 0x309B	; 0x80309b <xNumOfOverflows>
    2006:	fc 01       	movw	r30, r24
    2008:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    200a:	40 91 a2 30 	lds	r20, 0x30A2	; 0x8030a2 <xTickCount>
    200e:	50 91 a3 30 	lds	r21, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    2012:	60 91 a4 30 	lds	r22, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    2016:	70 91 a5 30 	lds	r23, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    201a:	41 83       	std	Z+1, r20	; 0x01
    201c:	52 83       	std	Z+2, r21	; 0x02
    201e:	63 83       	std	Z+3, r22	; 0x03
    2020:	74 83       	std	Z+4, r23	; 0x04
    2022:	08 95       	ret

00002024 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2024:	8f 92       	push	r8
    2026:	9f 92       	push	r9
    2028:	af 92       	push	r10
    202a:	bf 92       	push	r11
    202c:	cf 92       	push	r12
    202e:	df 92       	push	r13
    2030:	ef 92       	push	r14
    2032:	ff 92       	push	r15
    2034:	0f 93       	push	r16
    2036:	1f 93       	push	r17
    2038:	cf 93       	push	r28
    203a:	df 93       	push	r29
    203c:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    203e:	0f b6       	in	r0, 0x3f	; 63
    2040:	f8 94       	cli
    2042:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2044:	80 91 9b 30 	lds	r24, 0x309B	; 0x80309b <xNumOfOverflows>
    2048:	90 81       	ld	r25, Z
    204a:	98 17       	cp	r25, r24
    204c:	89 f0       	breq	.+34     	; 0x2070 <xTaskCheckForTimeOut+0x4c>
    204e:	80 91 a2 30 	lds	r24, 0x30A2	; 0x8030a2 <xTickCount>
    2052:	90 91 a3 30 	lds	r25, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    2056:	a0 91 a4 30 	lds	r26, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    205a:	b0 91 a5 30 	lds	r27, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    205e:	01 81       	ldd	r16, Z+1	; 0x01
    2060:	12 81       	ldd	r17, Z+2	; 0x02
    2062:	23 81       	ldd	r18, Z+3	; 0x03
    2064:	34 81       	ldd	r19, Z+4	; 0x04
    2066:	80 17       	cp	r24, r16
    2068:	91 07       	cpc	r25, r17
    206a:	a2 07       	cpc	r26, r18
    206c:	b3 07       	cpc	r27, r19
    206e:	a8 f5       	brcc	.+106    	; 0x20da <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2070:	80 91 a2 30 	lds	r24, 0x30A2	; 0x8030a2 <xTickCount>
    2074:	90 91 a3 30 	lds	r25, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    2078:	a0 91 a4 30 	lds	r26, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    207c:	b0 91 a5 30 	lds	r27, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    2080:	c1 80       	ldd	r12, Z+1	; 0x01
    2082:	d2 80       	ldd	r13, Z+2	; 0x02
    2084:	e3 80       	ldd	r14, Z+3	; 0x03
    2086:	f4 80       	ldd	r15, Z+4	; 0x04
    2088:	eb 01       	movw	r28, r22
    208a:	08 81       	ld	r16, Y
    208c:	19 81       	ldd	r17, Y+1	; 0x01
    208e:	2a 81       	ldd	r18, Y+2	; 0x02
    2090:	3b 81       	ldd	r19, Y+3	; 0x03
    2092:	8c 19       	sub	r24, r12
    2094:	9d 09       	sbc	r25, r13
    2096:	ae 09       	sbc	r26, r14
    2098:	bf 09       	sbc	r27, r15
    209a:	80 17       	cp	r24, r16
    209c:	91 07       	cpc	r25, r17
    209e:	a2 07       	cpc	r26, r18
    20a0:	b3 07       	cpc	r27, r19
    20a2:	e8 f4       	brcc	.+58     	; 0x20de <xTaskCheckForTimeOut+0xba>
    20a4:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    20a6:	80 90 a2 30 	lds	r8, 0x30A2	; 0x8030a2 <xTickCount>
    20aa:	90 90 a3 30 	lds	r9, 0x30A3	; 0x8030a3 <xTickCount+0x1>
    20ae:	a0 90 a4 30 	lds	r10, 0x30A4	; 0x8030a4 <xTickCount+0x2>
    20b2:	b0 90 a5 30 	lds	r11, 0x30A5	; 0x8030a5 <xTickCount+0x3>
    20b6:	b5 01       	movw	r22, r10
    20b8:	a4 01       	movw	r20, r8
    20ba:	4c 19       	sub	r20, r12
    20bc:	5d 09       	sbc	r21, r13
    20be:	6e 09       	sbc	r22, r14
    20c0:	7f 09       	sbc	r23, r15
    20c2:	04 1b       	sub	r16, r20
    20c4:	15 0b       	sbc	r17, r21
    20c6:	26 0b       	sbc	r18, r22
    20c8:	37 0b       	sbc	r19, r23
    20ca:	08 83       	st	Y, r16
    20cc:	19 83       	std	Y+1, r17	; 0x01
    20ce:	2a 83       	std	Y+2, r18	; 0x02
    20d0:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    20d2:	0e 94 01 10 	call	0x2002	; 0x2002 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    20d6:	80 e0       	ldi	r24, 0x00	; 0
    20d8:	03 c0       	rjmp	.+6      	; 0x20e0 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    20da:	81 e0       	ldi	r24, 0x01	; 1
    20dc:	01 c0       	rjmp	.+2      	; 0x20e0 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    20de:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    20e0:	0f 90       	pop	r0
    20e2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    20e4:	df 91       	pop	r29
    20e6:	cf 91       	pop	r28
    20e8:	1f 91       	pop	r17
    20ea:	0f 91       	pop	r16
    20ec:	ff 90       	pop	r15
    20ee:	ef 90       	pop	r14
    20f0:	df 90       	pop	r13
    20f2:	cf 90       	pop	r12
    20f4:	bf 90       	pop	r11
    20f6:	af 90       	pop	r10
    20f8:	9f 90       	pop	r9
    20fa:	8f 90       	pop	r8
    20fc:	08 95       	ret

000020fe <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    20fe:	81 e0       	ldi	r24, 0x01	; 1
    2100:	80 93 9c 30 	sts	0x309C, r24	; 0x80309c <xMissedYield>
    2104:	08 95       	ret

00002106 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2106:	00 97       	sbiw	r24, 0x00	; 0
    2108:	21 f4       	brne	.+8      	; 0x2112 <uxTaskGetStackHighWaterMark+0xc>
    210a:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <pxCurrentTCB>
    210e:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2112:	dc 01       	movw	r26, r24
    2114:	5b 96       	adiw	r26, 0x1b	; 27
    2116:	ed 91       	ld	r30, X+
    2118:	fc 91       	ld	r31, X
    211a:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    211c:	80 81       	ld	r24, Z
    211e:	81 31       	cpi	r24, 0x11	; 17
    2120:	41 f4       	brne	.+16     	; 0x2132 <uxTaskGetStackHighWaterMark+0x2c>
    2122:	31 96       	adiw	r30, 0x01	; 1
    2124:	80 e0       	ldi	r24, 0x00	; 0
    2126:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2128:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    212a:	21 91       	ld	r18, Z+
    212c:	21 31       	cpi	r18, 0x11	; 17
    212e:	e1 f3       	breq	.-8      	; 0x2128 <uxTaskGetStackHighWaterMark+0x22>
    2130:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2132:	80 e0       	ldi	r24, 0x00	; 0
    2134:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2136:	08 95       	ret

00002138 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2138:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <pxCurrentTCB>
    213c:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>

		return xReturn;
	}
    2140:	08 95       	ret

00002142 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2142:	0f 93       	push	r16
    2144:	1f 93       	push	r17
    2146:	cf 93       	push	r28
    2148:	df 93       	push	r29
    214a:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    214c:	22 8d       	ldd	r18, Z+26	; 0x1a
    214e:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <pxCurrentTCB>
    2152:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    2156:	5a 96       	adiw	r26, 0x1a	; 26
    2158:	8c 91       	ld	r24, X
    215a:	28 17       	cp	r18, r24
    215c:	08 f0       	brcs	.+2      	; 0x2160 <vTaskPriorityInherit+0x1e>
    215e:	41 c0       	rjmp	.+130    	; 0x21e2 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2160:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <pxCurrentTCB>
    2164:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    2168:	5a 96       	adiw	r26, 0x1a	; 26
    216a:	3c 91       	ld	r19, X
    216c:	84 e0       	ldi	r24, 0x04	; 4
    216e:	90 e0       	ldi	r25, 0x00	; 0
    2170:	a0 e0       	ldi	r26, 0x00	; 0
    2172:	b0 e0       	ldi	r27, 0x00	; 0
    2174:	83 1b       	sub	r24, r19
    2176:	91 09       	sbc	r25, r1
    2178:	a1 09       	sbc	r26, r1
    217a:	b1 09       	sbc	r27, r1
    217c:	86 87       	std	Z+14, r24	; 0x0e
    217e:	97 87       	std	Z+15, r25	; 0x0f
    2180:	a0 8b       	std	Z+16, r26	; 0x10
    2182:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2184:	8b e0       	ldi	r24, 0x0B	; 11
    2186:	28 9f       	mul	r18, r24
    2188:	90 01       	movw	r18, r0
    218a:	11 24       	eor	r1, r1
    218c:	22 53       	subi	r18, 0x32	; 50
    218e:	3f 4c       	sbci	r19, 0xCF	; 207
    2190:	84 85       	ldd	r24, Z+12	; 0x0c
    2192:	95 85       	ldd	r25, Z+13	; 0x0d
    2194:	82 17       	cp	r24, r18
    2196:	93 07       	cpc	r25, r19
    2198:	e9 f4       	brne	.+58     	; 0x21d4 <vTaskPriorityInherit+0x92>
    219a:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    219c:	ef 01       	movw	r28, r30
    219e:	22 96       	adiw	r28, 0x02	; 2
    21a0:	ce 01       	movw	r24, r28
    21a2:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    21a6:	e0 91 fa 30 	lds	r30, 0x30FA	; 0x8030fa <pxCurrentTCB>
    21aa:	f0 91 fb 30 	lds	r31, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    21ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    21b0:	f8 01       	movw	r30, r16
    21b2:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    21b4:	90 91 a0 30 	lds	r25, 0x30A0	; 0x8030a0 <uxTopReadyPriority>
    21b8:	98 17       	cp	r25, r24
    21ba:	10 f4       	brcc	.+4      	; 0x21c0 <vTaskPriorityInherit+0x7e>
    21bc:	80 93 a0 30 	sts	0x30A0, r24	; 0x8030a0 <uxTopReadyPriority>
    21c0:	fb e0       	ldi	r31, 0x0B	; 11
    21c2:	8f 9f       	mul	r24, r31
    21c4:	c0 01       	movw	r24, r0
    21c6:	11 24       	eor	r1, r1
    21c8:	be 01       	movw	r22, r28
    21ca:	82 53       	subi	r24, 0x32	; 50
    21cc:	9f 4c       	sbci	r25, 0xCF	; 207
    21ce:	0e 94 cd 06 	call	0xd9a	; 0xd9a <vListInsertEnd>
    21d2:	07 c0       	rjmp	.+14     	; 0x21e2 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    21d4:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <pxCurrentTCB>
    21d8:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <pxCurrentTCB+0x1>
    21dc:	5a 96       	adiw	r26, 0x1a	; 26
    21de:	8c 91       	ld	r24, X
    21e0:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    21e2:	df 91       	pop	r29
    21e4:	cf 91       	pop	r28
    21e6:	1f 91       	pop	r17
    21e8:	0f 91       	pop	r16
    21ea:	08 95       	ret

000021ec <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    21ec:	0f 93       	push	r16
    21ee:	1f 93       	push	r17
    21f0:	cf 93       	push	r28
    21f2:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    21f4:	00 97       	sbiw	r24, 0x00	; 0
    21f6:	49 f1       	breq	.+82     	; 0x224a <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    21f8:	fc 01       	movw	r30, r24
    21fa:	32 8d       	ldd	r19, Z+26	; 0x1a
    21fc:	27 a1       	ldd	r18, Z+39	; 0x27
    21fe:	32 17       	cp	r19, r18
    2200:	21 f1       	breq	.+72     	; 0x224a <vTaskPriorityDisinherit+0x5e>
    2202:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2204:	8c 01       	movw	r16, r24
    2206:	0e 5f       	subi	r16, 0xFE	; 254
    2208:	1f 4f       	sbci	r17, 0xFF	; 255
    220a:	c8 01       	movw	r24, r16
    220c:	0e 94 3f 07 	call	0xe7e	; 0xe7e <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2210:	8f a1       	ldd	r24, Y+39	; 0x27
    2212:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2214:	44 e0       	ldi	r20, 0x04	; 4
    2216:	50 e0       	ldi	r21, 0x00	; 0
    2218:	60 e0       	ldi	r22, 0x00	; 0
    221a:	70 e0       	ldi	r23, 0x00	; 0
    221c:	48 1b       	sub	r20, r24
    221e:	51 09       	sbc	r21, r1
    2220:	61 09       	sbc	r22, r1
    2222:	71 09       	sbc	r23, r1
    2224:	4e 87       	std	Y+14, r20	; 0x0e
    2226:	5f 87       	std	Y+15, r21	; 0x0f
    2228:	68 8b       	std	Y+16, r22	; 0x10
    222a:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    222c:	90 91 a0 30 	lds	r25, 0x30A0	; 0x8030a0 <uxTopReadyPriority>
    2230:	98 17       	cp	r25, r24
    2232:	10 f4       	brcc	.+4      	; 0x2238 <vTaskPriorityDisinherit+0x4c>
    2234:	80 93 a0 30 	sts	0x30A0, r24	; 0x8030a0 <uxTopReadyPriority>
    2238:	fb e0       	ldi	r31, 0x0B	; 11
    223a:	8f 9f       	mul	r24, r31
    223c:	c0 01       	movw	r24, r0
    223e:	11 24       	eor	r1, r1
    2240:	b8 01       	movw	r22, r16
    2242:	82 53       	subi	r24, 0x32	; 50
    2244:	9f 4c       	sbci	r25, 0xCF	; 207
    2246:	0e 94 cd 06 	call	0xd9a	; 0xd9a <vListInsertEnd>
			}
		}
	}
    224a:	df 91       	pop	r29
    224c:	cf 91       	pop	r28
    224e:	1f 91       	pop	r17
    2250:	0f 91       	pop	r16
    2252:	08 95       	ret

00002254 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2254:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2256:	e8 81       	ld	r30, Y
    2258:	f9 81       	ldd	r31, Y+1	; 0x01
    225a:	01 90       	ld	r0, Z+
    225c:	f0 81       	ld	r31, Z
    225e:	e0 2d       	mov	r30, r0
    2260:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2262:	1a 82       	std	Y+2, r1	; 0x02
    2264:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2266:	6f ef       	ldi	r22, 0xFF	; 255
    2268:	7f ef       	ldi	r23, 0xFF	; 255
    226a:	cb 01       	movw	r24, r22
    226c:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <vTaskDelay>
    2270:	fa cf       	rjmp	.-12     	; 0x2266 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002272 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2272:	fc 01       	movw	r30, r24
    2274:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2276:	65 87       	std	Z+13, r22	; 0x0d
    2278:	08 95       	ret

0000227a <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    227a:	4f 92       	push	r4
    227c:	5f 92       	push	r5
    227e:	6f 92       	push	r6
    2280:	7f 92       	push	r7
    2282:	8f 92       	push	r8
    2284:	9f 92       	push	r9
    2286:	af 92       	push	r10
    2288:	bf 92       	push	r11
    228a:	cf 92       	push	r12
    228c:	df 92       	push	r13
    228e:	ef 92       	push	r14
    2290:	ff 92       	push	r15
    2292:	0f 93       	push	r16
    2294:	1f 93       	push	r17
    2296:	cf 93       	push	r28
    2298:	df 93       	push	r29
    229a:	cd b7       	in	r28, 0x3d	; 61
    229c:	de b7       	in	r29, 0x3e	; 62
    229e:	2a 97       	sbiw	r28, 0x0a	; 10
    22a0:	cd bf       	out	0x3d, r28	; 61
    22a2:	de bf       	out	0x3e, r29	; 62
    22a4:	4c 01       	movw	r8, r24
    22a6:	29 01       	movw	r4, r18
    22a8:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    22aa:	87 e2       	ldi	r24, 0x27	; 39
    22ac:	90 e2       	ldi	r25, 0x20	; 32
    22ae:	f4 01       	movw	r30, r8
    22b0:	80 83       	st	Z, r24
    22b2:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    22b4:	fb 01       	movw	r30, r22
    22b6:	80 81       	ld	r24, Z
    22b8:	88 23       	and	r24, r24
    22ba:	69 f0       	breq	.+26     	; 0x22d6 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    22bc:	de 01       	movw	r26, r28
    22be:	11 96       	adiw	r26, 0x01	; 1
    22c0:	31 96       	adiw	r30, 0x01	; 1
    22c2:	90 e0       	ldi	r25, 0x00	; 0
    22c4:	02 c0       	rjmp	.+4      	; 0x22ca <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    22c6:	99 30       	cpi	r25, 0x09	; 9
    22c8:	39 f0       	breq	.+14     	; 0x22d8 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    22ca:	9f 5f       	subi	r25, 0xFF	; 255
    22cc:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    22ce:	81 91       	ld	r24, Z+
    22d0:	81 11       	cpse	r24, r1
    22d2:	f9 cf       	rjmp	.-14     	; 0x22c6 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    22d4:	01 c0       	rjmp	.+2      	; 0x22d8 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    22d6:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    22d8:	e1 e0       	ldi	r30, 0x01	; 1
    22da:	f0 e0       	ldi	r31, 0x00	; 0
    22dc:	ec 0f       	add	r30, r28
    22de:	fd 1f       	adc	r31, r29
    22e0:	e9 0f       	add	r30, r25
    22e2:	f1 1d       	adc	r31, r1
    22e4:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    22e6:	74 01       	movw	r14, r8
    22e8:	f2 e0       	ldi	r31, 0x02	; 2
    22ea:	ef 0e       	add	r14, r31
    22ec:	f1 1c       	adc	r15, r1
    22ee:	a1 2c       	mov	r10, r1
    22f0:	b1 2c       	mov	r11, r1
    22f2:	c1 2c       	mov	r12, r1
    22f4:	d1 2c       	mov	r13, r1
    22f6:	04 2f       	mov	r16, r20
    22f8:	94 01       	movw	r18, r8
    22fa:	a2 01       	movw	r20, r4
    22fc:	be 01       	movw	r22, r28
    22fe:	6f 5f       	subi	r22, 0xFF	; 255
    2300:	7f 4f       	sbci	r23, 0xFF	; 255
    2302:	80 ea       	ldi	r24, 0xA0	; 160
    2304:	92 e0       	ldi	r25, 0x02	; 2
    2306:	0e 94 b9 0b 	call	0x1772	; 0x1772 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    230a:	f4 01       	movw	r30, r8
    230c:	66 82       	std	Z+6, r6	; 0x06
    230e:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2310:	40 86       	std	Z+8, r4	; 0x08
    2312:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2314:	20 91 fc 30 	lds	r18, 0x30FC	; 0x8030fc <last_created_task_pointer>
    2318:	30 91 fd 30 	lds	r19, 0x30FD	; 0x8030fd <last_created_task_pointer+0x1>
    231c:	24 83       	std	Z+4, r18	; 0x04
    231e:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2320:	80 92 fc 30 	sts	0x30FC, r8	; 0x8030fc <last_created_task_pointer>
    2324:	90 92 fd 30 	sts	0x30FD, r9	; 0x8030fd <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2328:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    232a:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    232c:	40 90 3a 31 	lds	r4, 0x313A	; 0x80313a <portStackTopForTask>
    2330:	50 90 3b 31 	lds	r5, 0x313B	; 0x80313b <portStackTopForTask+0x1>
    2334:	ff ef       	ldi	r31, 0xFF	; 255
    2336:	4f 1a       	sub	r4, r31
    2338:	5f 0a       	sbc	r5, r31
    233a:	40 92 3a 31 	sts	0x313A, r4	; 0x80313a <portStackTopForTask>
    233e:	50 92 3b 31 	sts	0x313B, r5	; 0x80313b <portStackTopForTask+0x1>
    2342:	f4 01       	movw	r30, r8
    2344:	42 86       	std	Z+10, r4	; 0x0a
    2346:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2348:	16 86       	std	Z+14, r1	; 0x0e
    234a:	17 86       	std	Z+15, r1	; 0x0f
    234c:	10 8a       	std	Z+16, r1	; 0x10
    234e:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2350:	61 14       	cp	r6, r1
    2352:	71 04       	cpc	r7, r1
    2354:	09 f4       	brne	.+2      	; 0x2358 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2356:	44 c0       	rjmp	.+136    	; 0x23e0 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2358:	81 30       	cpi	r24, 0x01	; 1
    235a:	79 f5       	brne	.+94     	; 0x23ba <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    235c:	6a e0       	ldi	r22, 0x0A	; 10
    235e:	c3 01       	movw	r24, r6
    2360:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2364:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2366:	6d e8       	ldi	r22, 0x8D	; 141
    2368:	74 e0       	ldi	r23, 0x04	; 4
    236a:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    236e:	be 01       	movw	r22, r28
    2370:	6f 5f       	subi	r22, 0xFF	; 255
    2372:	7f 4f       	sbci	r23, 0xFF	; 255
    2374:	c7 01       	movw	r24, r14
    2376:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    237a:	6a e0       	ldi	r22, 0x0A	; 10
    237c:	c7 01       	movw	r24, r14
    237e:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2382:	7c 01       	movw	r14, r24
    2384:	64 e8       	ldi	r22, 0x84	; 132
    2386:	74 e0       	ldi	r23, 0x04	; 4
    2388:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    238c:	6a e0       	ldi	r22, 0x0A	; 10
    238e:	c7 01       	movw	r24, r14
    2390:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2394:	7c 01       	movw	r14, r24
    2396:	66 e7       	ldi	r22, 0x76	; 118
    2398:	74 e0       	ldi	r23, 0x04	; 4
    239a:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    239e:	63 e0       	ldi	r22, 0x03	; 3
    23a0:	c7 01       	movw	r24, r14
    23a2:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    23a6:	b2 01       	movw	r22, r4
    23a8:	0e 94 03 17 	call	0x2e06	; 0x2e06 <_ZN8emstreamlsEj>
    23ac:	62 e0       	ldi	r22, 0x02	; 2
    23ae:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    23b2:	66 e0       	ldi	r22, 0x06	; 6
    23b4:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    23b8:	13 c0       	rjmp	.+38     	; 0x23e0 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    23ba:	6a e0       	ldi	r22, 0x0A	; 10
    23bc:	c3 01       	movw	r24, r6
    23be:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    23c2:	4c 01       	movw	r8, r24
    23c4:	61 e6       	ldi	r22, 0x61	; 97
    23c6:	74 e0       	ldi	r23, 0x04	; 4
    23c8:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    23cc:	be 01       	movw	r22, r28
    23ce:	6f 5f       	subi	r22, 0xFF	; 255
    23d0:	7f 4f       	sbci	r23, 0xFF	; 255
    23d2:	c4 01       	movw	r24, r8
    23d4:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    23d8:	66 e0       	ldi	r22, 0x06	; 6
    23da:	c4 01       	movw	r24, r8
    23dc:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    23e0:	2a 96       	adiw	r28, 0x0a	; 10
    23e2:	cd bf       	out	0x3d, r28	; 61
    23e4:	de bf       	out	0x3e, r29	; 62
    23e6:	df 91       	pop	r29
    23e8:	cf 91       	pop	r28
    23ea:	1f 91       	pop	r17
    23ec:	0f 91       	pop	r16
    23ee:	ff 90       	pop	r15
    23f0:	ef 90       	pop	r14
    23f2:	df 90       	pop	r13
    23f4:	cf 90       	pop	r12
    23f6:	bf 90       	pop	r11
    23f8:	af 90       	pop	r10
    23fa:	9f 90       	pop	r9
    23fc:	8f 90       	pop	r8
    23fe:	7f 90       	pop	r7
    2400:	6f 90       	pop	r6
    2402:	5f 90       	pop	r5
    2404:	4f 90       	pop	r4
    2406:	08 95       	ret

00002408 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2408:	cf 92       	push	r12
    240a:	df 92       	push	r13
    240c:	ef 92       	push	r14
    240e:	ff 92       	push	r15
    2410:	0f 93       	push	r16
    2412:	1f 93       	push	r17
    2414:	cf 93       	push	r28
    2416:	df 93       	push	r29
    2418:	ec 01       	movw	r28, r24
    241a:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    241c:	8a 81       	ldd	r24, Y+2	; 0x02
    241e:	9b 81       	ldd	r25, Y+3	; 0x03
    2420:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <pcTaskGetTaskName>
    2424:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2426:	6a e0       	ldi	r22, 0x0A	; 10
    2428:	c7 01       	movw	r24, r14
    242a:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    242e:	8c 01       	movw	r16, r24
    2430:	60 ea       	ldi	r22, 0xA0	; 160
    2432:	74 e0       	ldi	r23, 0x04	; 4
    2434:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    2438:	6a e0       	ldi	r22, 0x0A	; 10
    243a:	c8 01       	movw	r24, r16
    243c:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2440:	8c 01       	movw	r16, r24
    2442:	69 e9       	ldi	r22, 0x99	; 153
    2444:	74 e0       	ldi	r23, 0x04	; 4
    2446:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    244a:	b6 01       	movw	r22, r12
    244c:	c8 01       	movw	r24, r16
    244e:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2452:	6a e0       	ldi	r22, 0x0A	; 10
    2454:	c8 01       	movw	r24, r16
    2456:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    245a:	8c 01       	movw	r16, r24
    245c:	63 e9       	ldi	r22, 0x93	; 147
    245e:	74 e0       	ldi	r23, 0x04	; 4
    2460:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    2464:	66 e0       	ldi	r22, 0x06	; 6
    2466:	c8 01       	movw	r24, r16
    2468:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    246c:	8a 85       	ldd	r24, Y+10	; 0x0a
    246e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2470:	e8 85       	ldd	r30, Y+8	; 0x08
    2472:	f9 85       	ldd	r31, Y+9	; 0x09
    2474:	01 e1       	ldi	r16, 0x11	; 17
    2476:	21 e0       	ldi	r18, 0x01	; 1
    2478:	a7 01       	movw	r20, r14
    247a:	bc 01       	movw	r22, r24
    247c:	8e 1b       	sub	r24, r30
    247e:	9f 0b       	sbc	r25, r31
    2480:	0e 94 06 15 	call	0x2a0c	; 0x2a0c <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2484:	8c 81       	ldd	r24, Y+4	; 0x04
    2486:	9d 81       	ldd	r25, Y+5	; 0x05
    2488:	00 97       	sbiw	r24, 0x00	; 0
    248a:	19 f0       	breq	.+6      	; 0x2492 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    248c:	b7 01       	movw	r22, r14
    248e:	0e 94 04 12 	call	0x2408	; 0x2408 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2492:	df 91       	pop	r29
    2494:	cf 91       	pop	r28
    2496:	1f 91       	pop	r17
    2498:	0f 91       	pop	r16
    249a:	ff 90       	pop	r15
    249c:	ef 90       	pop	r14
    249e:	df 90       	pop	r13
    24a0:	cf 90       	pop	r12
    24a2:	08 95       	ret

000024a4 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    24a4:	0f 93       	push	r16
    24a6:	1f 93       	push	r17
    24a8:	cf 93       	push	r28
    24aa:	df 93       	push	r29
    24ac:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    24ae:	80 91 fc 30 	lds	r24, 0x30FC	; 0x8030fc <last_created_task_pointer>
    24b2:	90 91 fd 30 	lds	r25, 0x30FD	; 0x8030fd <last_created_task_pointer+0x1>
    24b6:	00 97       	sbiw	r24, 0x00	; 0
    24b8:	19 f0       	breq	.+6      	; 0x24c0 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    24ba:	be 01       	movw	r22, r28
    24bc:	0e 94 04 12 	call	0x2408	; 0x2408 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    24c0:	6a e0       	ldi	r22, 0x0A	; 10
    24c2:	ce 01       	movw	r24, r28
    24c4:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    24c8:	8c 01       	movw	r16, r24
    24ca:	66 eb       	ldi	r22, 0xB6	; 182
    24cc:	74 e0       	ldi	r23, 0x04	; 4
    24ce:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    24d2:	6a e0       	ldi	r22, 0x0A	; 10
    24d4:	c8 01       	movw	r24, r16
    24d6:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    24da:	8c 01       	movw	r16, r24
    24dc:	6b ea       	ldi	r22, 0xAB	; 171
    24de:	74 e0       	ldi	r23, 0x04	; 4
    24e0:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    24e4:	6a e0       	ldi	r22, 0x0A	; 10
    24e6:	c8 01       	movw	r24, r16
    24e8:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    24ec:	8c 01       	movw	r16, r24
    24ee:	65 ea       	ldi	r22, 0xA5	; 165
    24f0:	74 e0       	ldi	r23, 0x04	; 4
    24f2:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    24f6:	66 e0       	ldi	r22, 0x06	; 6
    24f8:	c8 01       	movw	r24, r16
    24fa:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    24fe:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <portStackTopForTask>
    2502:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <portStackTopForTask+0x1>
    2506:	bc 01       	movw	r22, r24
    2508:	6f 5f       	subi	r22, 0xFF	; 255
    250a:	7f 4f       	sbci	r23, 0xFF	; 255
    250c:	01 e1       	ldi	r16, 0x11	; 17
    250e:	21 e0       	ldi	r18, 0x01	; 1
    2510:	ae 01       	movw	r20, r28
    2512:	83 56       	subi	r24, 0x63	; 99
    2514:	91 09       	sbc	r25, r1
    2516:	0e 94 06 15 	call	0x2a0c	; 0x2a0c <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    251a:	df 91       	pop	r29
    251c:	cf 91       	pop	r28
    251e:	1f 91       	pop	r17
    2520:	0f 91       	pop	r16
    2522:	08 95       	ret

00002524 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2524:	8f 92       	push	r8
    2526:	9f 92       	push	r9
    2528:	af 92       	push	r10
    252a:	bf 92       	push	r11
    252c:	cf 92       	push	r12
    252e:	df 92       	push	r13
    2530:	ef 92       	push	r14
    2532:	ff 92       	push	r15
    2534:	0f 93       	push	r16
    2536:	1f 93       	push	r17
    2538:	cf 93       	push	r28
    253a:	df 93       	push	r29
    253c:	ec 01       	movw	r28, r24
    253e:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2540:	8a 81       	ldd	r24, Y+2	; 0x02
    2542:	9b 81       	ldd	r25, Y+3	; 0x03
    2544:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <pcTaskGetTaskName>
    2548:	bc 01       	movw	r22, r24
    254a:	c8 01       	movw	r24, r16
    254c:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2550:	d8 01       	movw	r26, r16
    2552:	ed 91       	ld	r30, X+
    2554:	fc 91       	ld	r31, X
    2556:	02 80       	ldd	r0, Z+2	; 0x02
    2558:	f3 81       	ldd	r31, Z+3	; 0x03
    255a:	e0 2d       	mov	r30, r0
    255c:	69 e0       	ldi	r22, 0x09	; 9
    255e:	c8 01       	movw	r24, r16
    2560:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2562:	8a 81       	ldd	r24, Y+2	; 0x02
    2564:	9b 81       	ldd	r25, Y+3	; 0x03
    2566:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <pcTaskGetTaskName>
    256a:	fc 01       	movw	r30, r24
    256c:	01 90       	ld	r0, Z+
    256e:	00 20       	and	r0, r0
    2570:	e9 f7       	brne	.-6      	; 0x256c <_ZN8frt_task12print_statusER8emstream+0x48>
    2572:	31 97       	sbiw	r30, 0x01	; 1
    2574:	e8 1b       	sub	r30, r24
    2576:	f9 0b       	sbc	r31, r25
    2578:	38 97       	sbiw	r30, 0x08	; 8
    257a:	48 f4       	brcc	.+18     	; 0x258e <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    257c:	d8 01       	movw	r26, r16
    257e:	ed 91       	ld	r30, X+
    2580:	fc 91       	ld	r31, X
    2582:	02 80       	ldd	r0, Z+2	; 0x02
    2584:	f3 81       	ldd	r31, Z+3	; 0x03
    2586:	e0 2d       	mov	r30, r0
    2588:	69 e0       	ldi	r22, 0x09	; 9
    258a:	c8 01       	movw	r24, r16
    258c:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    258e:	ce 84       	ldd	r12, Y+14	; 0x0e
    2590:	df 84       	ldd	r13, Y+15	; 0x0f
    2592:	e8 88       	ldd	r14, Y+16	; 0x10
    2594:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2596:	a8 84       	ldd	r10, Y+8	; 0x08
    2598:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    259a:	8a 81       	ldd	r24, Y+2	; 0x02
    259c:	9b 81       	ldd	r25, Y+3	; 0x03
    259e:	0e 94 83 10 	call	0x2106	; 0x2106 <uxTaskGetStackHighWaterMark>
    25a2:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    25a4:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    25a6:	8a 81       	ldd	r24, Y+2	; 0x02
    25a8:	9b 81       	ldd	r25, Y+3	; 0x03
    25aa:	0e 94 bb 0c 	call	0x1976	; 0x1976 <uxTaskPriorityGet>
    25ae:	68 2f       	mov	r22, r24
    25b0:	c8 01       	movw	r24, r16
    25b2:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <_ZN8emstreamlsEh>
    25b6:	6a e0       	ldi	r22, 0x0A	; 10
    25b8:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    25bc:	ec 01       	movw	r28, r24
    25be:	6b e2       	ldi	r22, 0x2B	; 43
    25c0:	75 e0       	ldi	r23, 0x05	; 5
    25c2:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
			<< get_state ()
    25c6:	68 2d       	mov	r22, r8
    25c8:	ce 01       	movw	r24, r28
    25ca:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    25ce:	6a e0       	ldi	r22, 0x0A	; 10
    25d0:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    25d4:	ec 01       	movw	r28, r24
    25d6:	69 e2       	ldi	r22, 0x29	; 41
    25d8:	75 e0       	ldi	r23, 0x05	; 5
    25da:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    25de:	69 2d       	mov	r22, r9
    25e0:	ce 01       	movw	r24, r28
    25e2:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <_ZN8emstreamlsEh>
    25e6:	6a e0       	ldi	r22, 0x0A	; 10
    25e8:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    25ec:	ec 01       	movw	r28, r24
    25ee:	67 e2       	ldi	r22, 0x27	; 39
    25f0:	75 e0       	ldi	r23, 0x05	; 5
    25f2:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    25f6:	b5 01       	movw	r22, r10
    25f8:	ce 01       	movw	r24, r28
    25fa:	0e 94 03 17 	call	0x2e06	; 0x2e06 <_ZN8emstreamlsEj>
    25fe:	6a e0       	ldi	r22, 0x0A	; 10
    2600:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2604:	ec 01       	movw	r28, r24
    2606:	65 e2       	ldi	r22, 0x25	; 37
    2608:	75 e0       	ldi	r23, 0x05	; 5
    260a:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    260e:	6a e0       	ldi	r22, 0x0A	; 10
    2610:	ce 01       	movw	r24, r28
    2612:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2616:	ec 01       	movw	r28, r24
    2618:	63 e2       	ldi	r22, 0x23	; 35
    261a:	75 e0       	ldi	r23, 0x05	; 5
    261c:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    2620:	b7 01       	movw	r22, r14
    2622:	a6 01       	movw	r20, r12
    2624:	ce 01       	movw	r24, r28
    2626:	0e 94 37 17 	call	0x2e6e	; 0x2e6e <_ZN8emstreamlsEm>
}
    262a:	df 91       	pop	r29
    262c:	cf 91       	pop	r28
    262e:	1f 91       	pop	r17
    2630:	0f 91       	pop	r16
    2632:	ff 90       	pop	r15
    2634:	ef 90       	pop	r14
    2636:	df 90       	pop	r13
    2638:	cf 90       	pop	r12
    263a:	bf 90       	pop	r11
    263c:	af 90       	pop	r10
    263e:	9f 90       	pop	r9
    2640:	8f 90       	pop	r8
    2642:	08 95       	ret

00002644 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2644:	cf 93       	push	r28
    2646:	df 93       	push	r29
    2648:	ec 01       	movw	r28, r24
    264a:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    264c:	db 01       	movw	r26, r22
    264e:	ed 91       	ld	r30, X+
    2650:	fc 91       	ld	r31, X
    2652:	02 80       	ldd	r0, Z+2	; 0x02
    2654:	f3 81       	ldd	r31, Z+3	; 0x03
    2656:	e0 2d       	mov	r30, r0
    2658:	be 01       	movw	r22, r28
    265a:	19 95       	eicall
	return (ser_dev);
}
    265c:	ce 01       	movw	r24, r28
    265e:	df 91       	pop	r29
    2660:	cf 91       	pop	r28
    2662:	08 95       	ret

00002664 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2664:	0f 93       	push	r16
    2666:	1f 93       	push	r17
    2668:	cf 93       	push	r28
    266a:	df 93       	push	r29
    266c:	ec 01       	movw	r28, r24
    266e:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2670:	bc 01       	movw	r22, r24
    2672:	c8 01       	movw	r24, r16
    2674:	0e 94 22 13 	call	0x2644	; 0x2644 <_ZlsR8emstreamR8frt_task>
    2678:	66 e0       	ldi	r22, 0x06	; 6
    267a:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    267e:	8c 81       	ldd	r24, Y+4	; 0x04
    2680:	9d 81       	ldd	r25, Y+5	; 0x05
    2682:	00 97       	sbiw	r24, 0x00	; 0
    2684:	19 f0       	breq	.+6      	; 0x268c <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2686:	b8 01       	movw	r22, r16
    2688:	0e 94 32 13 	call	0x2664	; 0x2664 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    268c:	df 91       	pop	r29
    268e:	cf 91       	pop	r28
    2690:	1f 91       	pop	r17
    2692:	0f 91       	pop	r16
    2694:	08 95       	ret

00002696 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2696:	0f 93       	push	r16
    2698:	1f 93       	push	r17
    269a:	cf 93       	push	r28
    269c:	df 93       	push	r29
    269e:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    26a0:	6a e0       	ldi	r22, 0x0A	; 10
    26a2:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    26a6:	8c 01       	movw	r16, r24
    26a8:	68 e1       	ldi	r22, 0x18	; 24
    26aa:	75 e0       	ldi	r23, 0x05	; 5
    26ac:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    26b0:	6a e0       	ldi	r22, 0x0A	; 10
    26b2:	c8 01       	movw	r24, r16
    26b4:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    26b8:	8c 01       	movw	r16, r24
    26ba:	61 e1       	ldi	r22, 0x11	; 17
    26bc:	75 e0       	ldi	r23, 0x05	; 5
    26be:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    26c2:	66 e0       	ldi	r22, 0x06	; 6
    26c4:	c8 01       	movw	r24, r16
    26c6:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    26ca:	6a e0       	ldi	r22, 0x0A	; 10
    26cc:	ce 01       	movw	r24, r28
    26ce:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    26d2:	8c 01       	movw	r16, r24
    26d4:	60 e0       	ldi	r22, 0x00	; 0
    26d6:	75 e0       	ldi	r23, 0x05	; 5
    26d8:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    26dc:	6a e0       	ldi	r22, 0x0A	; 10
    26de:	c8 01       	movw	r24, r16
    26e0:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    26e4:	8c 01       	movw	r16, r24
    26e6:	64 ef       	ldi	r22, 0xF4	; 244
    26e8:	74 e0       	ldi	r23, 0x04	; 4
    26ea:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    26ee:	6a e0       	ldi	r22, 0x0A	; 10
    26f0:	c8 01       	movw	r24, r16
    26f2:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    26f6:	8c 01       	movw	r16, r24
    26f8:	6e ee       	ldi	r22, 0xEE	; 238
    26fa:	74 e0       	ldi	r23, 0x04	; 4
    26fc:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    2700:	66 e0       	ldi	r22, 0x06	; 6
    2702:	c8 01       	movw	r24, r16
    2704:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2708:	6a e0       	ldi	r22, 0x0A	; 10
    270a:	ce 01       	movw	r24, r28
    270c:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2710:	8c 01       	movw	r16, r24
    2712:	6d ed       	ldi	r22, 0xDD	; 221
    2714:	74 e0       	ldi	r23, 0x04	; 4
    2716:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    271a:	6a e0       	ldi	r22, 0x0A	; 10
    271c:	c8 01       	movw	r24, r16
    271e:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2722:	8c 01       	movw	r16, r24
    2724:	61 ed       	ldi	r22, 0xD1	; 209
    2726:	74 e0       	ldi	r23, 0x04	; 4
    2728:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    272c:	6a e0       	ldi	r22, 0x0A	; 10
    272e:	c8 01       	movw	r24, r16
    2730:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2734:	8c 01       	movw	r16, r24
    2736:	6b ec       	ldi	r22, 0xCB	; 203
    2738:	74 e0       	ldi	r23, 0x04	; 4
    273a:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    273e:	66 e0       	ldi	r22, 0x06	; 6
    2740:	c8 01       	movw	r24, r16
    2742:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2746:	80 91 fc 30 	lds	r24, 0x30FC	; 0x8030fc <last_created_task_pointer>
    274a:	90 91 fd 30 	lds	r25, 0x30FD	; 0x8030fd <last_created_task_pointer+0x1>
    274e:	00 97       	sbiw	r24, 0x00	; 0
    2750:	19 f0       	breq	.+6      	; 0x2758 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2752:	be 01       	movw	r22, r28
    2754:	0e 94 32 13 	call	0x2664	; 0x2664 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2758:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <xTaskGetIdleTaskHandle>
    275c:	0e 94 83 10 	call	0x2106	; 0x2106 <uxTaskGetStackHighWaterMark>
    2760:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2762:	6a e0       	ldi	r22, 0x0A	; 10
    2764:	ce 01       	movw	r24, r28
    2766:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    276a:	ec 01       	movw	r28, r24
    276c:	60 ec       	ldi	r22, 0xC0	; 192
    276e:	74 e0       	ldi	r23, 0x04	; 4
    2770:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2774:	61 2f       	mov	r22, r17
    2776:	ce 01       	movw	r24, r28
    2778:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    277c:	6a e0       	ldi	r22, 0x0A	; 10
    277e:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2782:	ec 01       	movw	r28, r24
    2784:	6e eb       	ldi	r22, 0xBE	; 190
    2786:	74 e0       	ldi	r23, 0x04	; 4
    2788:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    278c:	64 e6       	ldi	r22, 0x64	; 100
    278e:	70 e0       	ldi	r23, 0x00	; 0
    2790:	ce 01       	movw	r24, r28
    2792:	0e 94 03 17 	call	0x2e06	; 0x2e06 <_ZN8emstreamlsEj>
    2796:	6a e0       	ldi	r22, 0x0A	; 10
    2798:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    279c:	ec 01       	movw	r28, r24
    279e:	6b eb       	ldi	r22, 0xBB	; 187
    27a0:	74 e0       	ldi	r23, 0x04	; 4
    27a2:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    27a6:	66 e0       	ldi	r22, 0x06	; 6
    27a8:	ce 01       	movw	r24, r28
    27aa:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
}
    27ae:	df 91       	pop	r29
    27b0:	cf 91       	pop	r28
    27b2:	1f 91       	pop	r17
    27b4:	0f 91       	pop	r16
    27b6:	08 95       	ret

000027b8 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    27b8:	0f 93       	push	r16
    27ba:	cf 93       	push	r28
    27bc:	df 93       	push	r29
    27be:	1f 92       	push	r1
    27c0:	cd b7       	in	r28, 0x3d	; 61
    27c2:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    27c4:	00 e0       	ldi	r16, 0x00	; 0
    27c6:	2f ef       	ldi	r18, 0xFF	; 255
    27c8:	3f ef       	ldi	r19, 0xFF	; 255
    27ca:	a9 01       	movw	r20, r18
    27cc:	be 01       	movw	r22, r28
    27ce:	6f 5f       	subi	r22, 0xFF	; 255
    27d0:	7f 4f       	sbci	r23, 0xFF	; 255
    27d2:	fc 01       	movw	r30, r24
    27d4:	80 85       	ldd	r24, Z+8	; 0x08
    27d6:	91 85       	ldd	r25, Z+9	; 0x09
    27d8:	0e 94 97 0a 	call	0x152e	; 0x152e <xQueueGenericReceive>
    27dc:	81 30       	cpi	r24, 0x01	; 1
    27de:	19 f4       	brne	.+6      	; 0x27e6 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    27e0:	89 81       	ldd	r24, Y+1	; 0x01
    27e2:	90 e0       	ldi	r25, 0x00	; 0
    27e4:	02 c0       	rjmp	.+4      	; 0x27ea <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    27e6:	8f ef       	ldi	r24, 0xFF	; 255
    27e8:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    27ea:	0f 90       	pop	r0
    27ec:	df 91       	pop	r29
    27ee:	cf 91       	pop	r28
    27f0:	0f 91       	pop	r16
    27f2:	08 95       	ret

000027f4 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    27f4:	fc 01       	movw	r30, r24
    27f6:	80 85       	ldd	r24, Z+8	; 0x08
    27f8:	91 85       	ldd	r25, Z+9	; 0x09
    27fa:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <uxQueueMessagesWaiting>
    27fe:	91 e0       	ldi	r25, 0x01	; 1
    2800:	81 11       	cpse	r24, r1
    2802:	01 c0       	rjmp	.+2      	; 0x2806 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2804:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2806:	89 2f       	mov	r24, r25
    2808:	08 95       	ret

0000280a <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    280a:	0f 93       	push	r16
    280c:	cf 93       	push	r28
    280e:	df 93       	push	r29
    2810:	1f 92       	push	r1
    2812:	cd b7       	in	r28, 0x3d	; 61
    2814:	de b7       	in	r29, 0x3e	; 62
    2816:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2818:	fc 01       	movw	r30, r24
    281a:	22 85       	ldd	r18, Z+10	; 0x0a
    281c:	33 85       	ldd	r19, Z+11	; 0x0b
    281e:	44 85       	ldd	r20, Z+12	; 0x0c
    2820:	55 85       	ldd	r21, Z+13	; 0x0d
    2822:	00 e0       	ldi	r16, 0x00	; 0
    2824:	be 01       	movw	r22, r28
    2826:	6f 5f       	subi	r22, 0xFF	; 255
    2828:	7f 4f       	sbci	r23, 0xFF	; 255
    282a:	80 85       	ldd	r24, Z+8	; 0x08
    282c:	91 85       	ldd	r25, Z+9	; 0x09
    282e:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <xQueueGenericSend>
    2832:	91 e0       	ldi	r25, 0x01	; 1
    2834:	81 11       	cpse	r24, r1
    2836:	01 c0       	rjmp	.+2      	; 0x283a <_ZN14frt_text_queue7putcharEc+0x30>
    2838:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    283a:	89 2f       	mov	r24, r25
    283c:	0f 90       	pop	r0
    283e:	df 91       	pop	r29
    2840:	cf 91       	pop	r28
    2842:	0f 91       	pop	r16
    2844:	08 95       	ret

00002846 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2846:	8f 92       	push	r8
    2848:	9f 92       	push	r9
    284a:	bf 92       	push	r11
    284c:	cf 92       	push	r12
    284e:	df 92       	push	r13
    2850:	ef 92       	push	r14
    2852:	ff 92       	push	r15
    2854:	0f 93       	push	r16
    2856:	1f 93       	push	r17
    2858:	cf 93       	push	r28
    285a:	df 93       	push	r29
    285c:	ec 01       	movw	r28, r24
    285e:	b6 2e       	mov	r11, r22
    2860:	4a 01       	movw	r8, r20
    2862:	68 01       	movw	r12, r16
    2864:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2866:	0e 94 77 16 	call	0x2cee	; 0x2cee <_ZN8emstreamC1Ev>
    286a:	8f e2       	ldi	r24, 0x2F	; 47
    286c:	90 e2       	ldi	r25, 0x20	; 32
    286e:	88 83       	st	Y, r24
    2870:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2872:	8e 86       	std	Y+14, r8	; 0x0e
    2874:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2876:	40 e0       	ldi	r20, 0x00	; 0
    2878:	61 e0       	ldi	r22, 0x01	; 1
    287a:	8b 2d       	mov	r24, r11
    287c:	0e 94 ce 09 	call	0x139c	; 0x139c <xQueueGenericCreate>
    2880:	88 87       	std	Y+8, r24	; 0x08
    2882:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2884:	ca 86       	std	Y+10, r12	; 0x0a
    2886:	db 86       	std	Y+11, r13	; 0x0b
    2888:	ec 86       	std	Y+12, r14	; 0x0c
    288a:	fd 86       	std	Y+13, r15	; 0x0d
}
    288c:	df 91       	pop	r29
    288e:	cf 91       	pop	r28
    2890:	1f 91       	pop	r17
    2892:	0f 91       	pop	r16
    2894:	ff 90       	pop	r15
    2896:	ef 90       	pop	r14
    2898:	df 90       	pop	r13
    289a:	cf 90       	pop	r12
    289c:	bf 90       	pop	r11
    289e:	9f 90       	pop	r9
    28a0:	8f 90       	pop	r8
    28a2:	08 95       	ret

000028a4 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    28a4:	cf 92       	push	r12
    28a6:	df 92       	push	r13
    28a8:	ef 92       	push	r14
    28aa:	ff 92       	push	r15
    28ac:	cf 93       	push	r28
    28ae:	df 93       	push	r29
    28b0:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    28b2:	68 81       	ld	r22, Y
    28b4:	79 81       	ldd	r23, Y+1	; 0x01
    28b6:	8a 81       	ldd	r24, Y+2	; 0x02
    28b8:	9b 81       	ldd	r25, Y+3	; 0x03
    28ba:	0f 2e       	mov	r0, r31
    28bc:	f8 ee       	ldi	r31, 0xE8	; 232
    28be:	cf 2e       	mov	r12, r31
    28c0:	f3 e0       	ldi	r31, 0x03	; 3
    28c2:	df 2e       	mov	r13, r31
    28c4:	e1 2c       	mov	r14, r1
    28c6:	f1 2c       	mov	r15, r1
    28c8:	f0 2d       	mov	r31, r0
    28ca:	a7 01       	movw	r20, r14
    28cc:	96 01       	movw	r18, r12
    28ce:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <__udivmodsi4>
    28d2:	9b 01       	movw	r18, r22
    28d4:	ac 01       	movw	r20, r24
    28d6:	60 e4       	ldi	r22, 0x40	; 64
    28d8:	72 e4       	ldi	r23, 0x42	; 66
    28da:	8f e0       	ldi	r24, 0x0F	; 15
    28dc:	90 e0       	ldi	r25, 0x00	; 0
    28de:	0e 94 2d 1c 	call	0x385a	; 0x385a <__mulsi3>
    28e2:	a7 01       	movw	r20, r14
    28e4:	96 01       	movw	r18, r12
    28e6:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <__udivmodsi4>
    28ea:	69 01       	movw	r12, r18
    28ec:	7a 01       	movw	r14, r20
    28ee:	ac 81       	ldd	r26, Y+4	; 0x04
    28f0:	bd 81       	ldd	r27, Y+5	; 0x05
    28f2:	20 e4       	ldi	r18, 0x40	; 64
    28f4:	32 e4       	ldi	r19, 0x42	; 66
    28f6:	4f e0       	ldi	r20, 0x0F	; 15
    28f8:	50 e0       	ldi	r21, 0x00	; 0
    28fa:	0e 94 9b 1c 	call	0x3936	; 0x3936 <__muluhisi3>
    28fe:	20 e0       	ldi	r18, 0x00	; 0
    2900:	38 e4       	ldi	r19, 0x48	; 72
    2902:	48 ee       	ldi	r20, 0xE8	; 232
    2904:	51 e0       	ldi	r21, 0x01	; 1
    2906:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <__udivmodsi4>
    290a:	c7 01       	movw	r24, r14
    290c:	b6 01       	movw	r22, r12
    290e:	62 0f       	add	r22, r18
    2910:	73 1f       	adc	r23, r19
    2912:	84 1f       	adc	r24, r20
    2914:	95 1f       	adc	r25, r21
}
    2916:	df 91       	pop	r29
    2918:	cf 91       	pop	r28
    291a:	ff 90       	pop	r15
    291c:	ef 90       	pop	r14
    291e:	df 90       	pop	r13
    2920:	cf 90       	pop	r12
    2922:	08 95       	ret

00002924 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2924:	cf 92       	push	r12
    2926:	df 92       	push	r13
    2928:	ef 92       	push	r14
    292a:	ff 92       	push	r15
    292c:	0f 93       	push	r16
    292e:	1f 93       	push	r17
    2930:	cf 93       	push	r28
    2932:	df 93       	push	r29
    2934:	cd b7       	in	r28, 0x3d	; 61
    2936:	de b7       	in	r29, 0x3e	; 62
    2938:	2f 97       	sbiw	r28, 0x0f	; 15
    293a:	cd bf       	out	0x3d, r28	; 61
    293c:	de bf       	out	0x3e, r29	; 62
    293e:	6c 01       	movw	r12, r24
    2940:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2942:	db 01       	movw	r26, r22
    2944:	6d 91       	ld	r22, X+
    2946:	7d 91       	ld	r23, X+
    2948:	8d 91       	ld	r24, X+
    294a:	9c 91       	ld	r25, X
    294c:	28 ee       	ldi	r18, 0xE8	; 232
    294e:	33 e0       	ldi	r19, 0x03	; 3
    2950:	40 e0       	ldi	r20, 0x00	; 0
    2952:	50 e0       	ldi	r21, 0x00	; 0
    2954:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <__udivmodsi4>
    2958:	ba 01       	movw	r22, r20
    295a:	a9 01       	movw	r20, r18
    295c:	c6 01       	movw	r24, r12
    295e:	0e 94 37 17 	call	0x2e6e	; 0x2e6e <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2962:	d6 01       	movw	r26, r12
    2964:	ed 91       	ld	r30, X+
    2966:	fc 91       	ld	r31, X
    2968:	02 80       	ldd	r0, Z+2	; 0x02
    296a:	f3 81       	ldd	r31, Z+3	; 0x03
    296c:	e0 2d       	mov	r30, r0
    296e:	6e e2       	ldi	r22, 0x2E	; 46
    2970:	c6 01       	movw	r24, r12
    2972:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2974:	c8 01       	movw	r24, r16
    2976:	0e 94 52 14 	call	0x28a4	; 0x28a4 <_ZN10time_stamp12get_microsecEv>
    297a:	8e 01       	movw	r16, r28
    297c:	09 5f       	subi	r16, 0xF9	; 249
    297e:	1f 4f       	sbci	r17, 0xFF	; 255
    2980:	fe 01       	movw	r30, r28
    2982:	31 96       	adiw	r30, 0x01	; 1
    2984:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2986:	2a e0       	ldi	r18, 0x0A	; 10
    2988:	30 e0       	ldi	r19, 0x00	; 0
    298a:	40 e0       	ldi	r20, 0x00	; 0
    298c:	50 e0       	ldi	r21, 0x00	; 0
    298e:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <__divmodsi4>
    2992:	e6 2f       	mov	r30, r22
    2994:	28 87       	std	Y+8, r18	; 0x08
    2996:	39 87       	std	Y+9, r19	; 0x09
    2998:	4a 87       	std	Y+10, r20	; 0x0a
    299a:	5b 87       	std	Y+11, r21	; 0x0b
    299c:	68 85       	ldd	r22, Y+8	; 0x08
    299e:	79 85       	ldd	r23, Y+9	; 0x09
    29a0:	8a 85       	ldd	r24, Y+10	; 0x0a
    29a2:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    29a4:	20 e3       	ldi	r18, 0x30	; 48
    29a6:	2e 0f       	add	r18, r30
    29a8:	d8 01       	movw	r26, r16
    29aa:	2e 93       	st	-X, r18
    29ac:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    29ae:	ae 15       	cp	r26, r14
    29b0:	bf 05       	cpc	r27, r15
    29b2:	49 f7       	brne	.-46     	; 0x2986 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    29b4:	1f 82       	std	Y+7, r1	; 0x07
    29b6:	be 01       	movw	r22, r28
    29b8:	6f 5f       	subi	r22, 0xFF	; 255
    29ba:	7f 4f       	sbci	r23, 0xFF	; 255
    29bc:	c6 01       	movw	r24, r12
    29be:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    29c2:	c6 01       	movw	r24, r12
    29c4:	2f 96       	adiw	r28, 0x0f	; 15
    29c6:	cd bf       	out	0x3d, r28	; 61
    29c8:	de bf       	out	0x3e, r29	; 62
    29ca:	df 91       	pop	r29
    29cc:	cf 91       	pop	r28
    29ce:	1f 91       	pop	r17
    29d0:	0f 91       	pop	r16
    29d2:	ff 90       	pop	r15
    29d4:	ef 90       	pop	r14
    29d6:	df 90       	pop	r13
    29d8:	cf 90       	pop	r12
    29da:	08 95       	ret

000029dc <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    29dc:	cf 93       	push	r28
    29de:	df 93       	push	r29
    29e0:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    29e2:	0f b6       	in	r0, 0x3f	; 63
    29e4:	f8 94       	cli
    29e6:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    29e8:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    29ec:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    29f0:	8c 83       	std	Y+4, r24	; 0x04
    29f2:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    29f4:	0e 94 02 0d 	call	0x1a04	; 0x1a04 <xTaskGetTickCount>
    29f8:	68 83       	st	Y, r22
    29fa:	79 83       	std	Y+1, r23	; 0x01
    29fc:	8a 83       	std	Y+2, r24	; 0x02
    29fe:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2a00:	0f 90       	pop	r0
    2a02:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2a04:	ce 01       	movw	r24, r28
    2a06:	df 91       	pop	r29
    2a08:	cf 91       	pop	r28
    2a0a:	08 95       	ret

00002a0c <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2a0c:	5f 92       	push	r5
    2a0e:	6f 92       	push	r6
    2a10:	7f 92       	push	r7
    2a12:	8f 92       	push	r8
    2a14:	9f 92       	push	r9
    2a16:	af 92       	push	r10
    2a18:	bf 92       	push	r11
    2a1a:	cf 92       	push	r12
    2a1c:	df 92       	push	r13
    2a1e:	ef 92       	push	r14
    2a20:	ff 92       	push	r15
    2a22:	0f 93       	push	r16
    2a24:	1f 93       	push	r17
    2a26:	cf 93       	push	r28
    2a28:	df 93       	push	r29
    2a2a:	5c 01       	movw	r10, r24
    2a2c:	4b 01       	movw	r8, r22
    2a2e:	7a 01       	movw	r14, r20
    2a30:	12 2f       	mov	r17, r18
    2a32:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2a34:	63 e0       	ldi	r22, 0x03	; 3
    2a36:	ca 01       	movw	r24, r20
    2a38:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2a3c:	a8 14       	cp	r10, r8
    2a3e:	b9 04       	cpc	r11, r9
    2a40:	08 f0       	brcs	.+2      	; 0x2a44 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2a42:	7d c0       	rjmp	.+250    	; 0x2b3e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2a44:	65 01       	movw	r12, r10
    2a46:	84 e1       	ldi	r24, 0x14	; 20
    2a48:	c8 0e       	add	r12, r24
    2a4a:	d1 1c       	adc	r13, r1
    2a4c:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2a4e:	6a 2c       	mov	r6, r10
    2a50:	5b 2c       	mov	r5, r11
    2a52:	b5 01       	movw	r22, r10
    2a54:	c7 01       	movw	r24, r14
    2a56:	0e 94 03 17 	call	0x2e06	; 0x2e06 <_ZN8emstreamlsEj>
    2a5a:	6a e0       	ldi	r22, 0x0A	; 10
    2a5c:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2a60:	6d e3       	ldi	r22, 0x3D	; 61
    2a62:	75 e0       	ldi	r23, 0x05	; 5
    2a64:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2a68:	11 23       	and	r17, r17
    2a6a:	09 f4       	brne	.+2      	; 0x2a6e <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2a6c:	6d c0       	rjmp	.+218    	; 0x2b48 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2a6e:	00 23       	and	r16, r16
    2a70:	09 f4       	brne	.+2      	; 0x2a74 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2a72:	6a c0       	rjmp	.+212    	; 0x2b48 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2a74:	6a e0       	ldi	r22, 0x0A	; 10
    2a76:	c7 01       	movw	r24, r14
    2a78:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2a7c:	68 e3       	ldi	r22, 0x38	; 56
    2a7e:	75 e0       	ldi	r23, 0x05	; 5
    2a80:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    2a84:	61 c0       	rjmp	.+194    	; 0x2b48 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2a86:	11 23       	and	r17, r17
    2a88:	71 f0       	breq	.+28     	; 0x2aa6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2a8a:	01 11       	cpse	r16, r1
    2a8c:	0c c0       	rjmp	.+24     	; 0x2aa6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2a8e:	88 81       	ld	r24, Y
    2a90:	87 15       	cp	r24, r7
    2a92:	49 f0       	breq	.+18     	; 0x2aa6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2a94:	6a e0       	ldi	r22, 0x0A	; 10
    2a96:	c7 01       	movw	r24, r14
    2a98:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2a9c:	63 e3       	ldi	r22, 0x33	; 51
    2a9e:	75 e0       	ldi	r23, 0x05	; 5
    2aa0:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2aa4:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2aa6:	69 91       	ld	r22, Y+
    2aa8:	c7 01       	movw	r24, r14
    2aaa:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2aae:	dc 01       	movw	r26, r24
    2ab0:	ed 91       	ld	r30, X+
    2ab2:	fc 91       	ld	r31, X
    2ab4:	02 80       	ldd	r0, Z+2	; 0x02
    2ab6:	f3 81       	ldd	r31, Z+3	; 0x03
    2ab8:	e0 2d       	mov	r30, r0
    2aba:	60 e2       	ldi	r22, 0x20	; 32
    2abc:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2abe:	cc 16       	cp	r12, r28
    2ac0:	dd 06       	cpc	r13, r29
    2ac2:	09 f7       	brne	.-62     	; 0x2a86 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2ac4:	11 23       	and	r17, r17
    2ac6:	89 f0       	breq	.+34     	; 0x2aea <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2ac8:	6a e0       	ldi	r22, 0x0A	; 10
    2aca:	c7 01       	movw	r24, r14
    2acc:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2ad0:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2ad2:	6d e2       	ldi	r22, 0x2D	; 45
    2ad4:	75 e0       	ldi	r23, 0x05	; 5
    2ad6:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2ada:	e8 81       	ld	r30, Y
    2adc:	f9 81       	ldd	r31, Y+1	; 0x01
    2ade:	02 80       	ldd	r0, Z+2	; 0x02
    2ae0:	f3 81       	ldd	r31, Z+3	; 0x03
    2ae2:	e0 2d       	mov	r30, r0
    2ae4:	60 e2       	ldi	r22, 0x20	; 32
    2ae6:	ce 01       	movw	r24, r28
    2ae8:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2aea:	c6 2d       	mov	r28, r6
    2aec:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2aee:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2af0:	80 ee       	ldi	r24, 0xE0	; 224
    2af2:	86 0f       	add	r24, r22
    2af4:	8f 35       	cpi	r24, 0x5F	; 95
    2af6:	48 f4       	brcc	.+18     	; 0x2b0a <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2af8:	d7 01       	movw	r26, r14
    2afa:	ed 91       	ld	r30, X+
    2afc:	fc 91       	ld	r31, X
    2afe:	02 80       	ldd	r0, Z+2	; 0x02
    2b00:	f3 81       	ldd	r31, Z+3	; 0x03
    2b02:	e0 2d       	mov	r30, r0
    2b04:	c7 01       	movw	r24, r14
    2b06:	19 95       	eicall
    2b08:	09 c0       	rjmp	.+18     	; 0x2b1c <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2b0a:	d7 01       	movw	r26, r14
    2b0c:	ed 91       	ld	r30, X+
    2b0e:	fc 91       	ld	r31, X
    2b10:	02 80       	ldd	r0, Z+2	; 0x02
    2b12:	f3 81       	ldd	r31, Z+3	; 0x03
    2b14:	e0 2d       	mov	r30, r0
    2b16:	6e e2       	ldi	r22, 0x2E	; 46
    2b18:	c7 01       	movw	r24, r14
    2b1a:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2b1c:	cc 16       	cp	r12, r28
    2b1e:	dd 06       	cpc	r13, r29
    2b20:	31 f7       	brne	.-52     	; 0x2aee <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2b22:	b4 e1       	ldi	r27, 0x14	; 20
    2b24:	ab 0e       	add	r10, r27
    2b26:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2b28:	66 e0       	ldi	r22, 0x06	; 6
    2b2a:	c7 01       	movw	r24, r14
    2b2c:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    2b30:	84 e1       	ldi	r24, 0x14	; 20
    2b32:	c8 0e       	add	r12, r24
    2b34:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2b36:	a8 14       	cp	r10, r8
    2b38:	b9 04       	cpc	r11, r9
    2b3a:	08 f4       	brcc	.+2      	; 0x2b3e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2b3c:	88 cf       	rjmp	.-240    	; 0x2a4e <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2b3e:	62 e0       	ldi	r22, 0x02	; 2
    2b40:	c7 01       	movw	r24, r14
    2b42:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
}
    2b46:	03 c0       	rjmp	.+6      	; 0x2b4e <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2b48:	c6 2d       	mov	r28, r6
    2b4a:	d5 2d       	mov	r29, r5
    2b4c:	9c cf       	rjmp	.-200    	; 0x2a86 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2b4e:	df 91       	pop	r29
    2b50:	cf 91       	pop	r28
    2b52:	1f 91       	pop	r17
    2b54:	0f 91       	pop	r16
    2b56:	ff 90       	pop	r15
    2b58:	ef 90       	pop	r14
    2b5a:	df 90       	pop	r13
    2b5c:	cf 90       	pop	r12
    2b5e:	bf 90       	pop	r11
    2b60:	af 90       	pop	r10
    2b62:	9f 90       	pop	r9
    2b64:	8f 90       	pop	r8
    2b66:	7f 90       	pop	r7
    2b68:	6f 90       	pop	r6
    2b6a:	5f 90       	pop	r5
    2b6c:	08 95       	ret

00002b6e <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2b6e:	0e 94 e6 05 	call	0xbcc	; 0xbcc <pvPortMalloc>
    2b72:	08 95       	ret

00002b74 <_Znaj>:
    2b74:	0e 94 e6 05 	call	0xbcc	; 0xbcc <pvPortMalloc>
    2b78:	08 95       	ret

00002b7a <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2b7a:	08 95       	ret

00002b7c <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2b7c:	cf 93       	push	r28
    2b7e:	df 93       	push	r29
    2b80:	fc 01       	movw	r30, r24
    2b82:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2b84:	40 3a       	cpi	r20, 0xA0	; 160
    2b86:	68 e0       	ldi	r22, 0x08	; 8
    2b88:	56 07       	cpc	r21, r22
    2b8a:	49 f4       	brne	.+18     	; 0x2b9e <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2b8c:	80 e4       	ldi	r24, 0x40	; 64
    2b8e:	96 e0       	ldi	r25, 0x06	; 6
    2b90:	82 83       	std	Z+2, r24	; 0x02
    2b92:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2b94:	82 e0       	ldi	r24, 0x02	; 2
    2b96:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2b98:	83 e0       	ldi	r24, 0x03	; 3
    2b9a:	85 83       	std	Z+5, r24	; 0x05
    2b9c:	4c c0       	rjmp	.+152    	; 0x2c36 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2b9e:	40 3b       	cpi	r20, 0xB0	; 176
    2ba0:	78 e0       	ldi	r23, 0x08	; 8
    2ba2:	57 07       	cpc	r21, r23
    2ba4:	49 f4       	brne	.+18     	; 0x2bb8 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2ba6:	80 e4       	ldi	r24, 0x40	; 64
    2ba8:	96 e0       	ldi	r25, 0x06	; 6
    2baa:	82 83       	std	Z+2, r24	; 0x02
    2bac:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2bae:	86 e0       	ldi	r24, 0x06	; 6
    2bb0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2bb2:	87 e0       	ldi	r24, 0x07	; 7
    2bb4:	85 83       	std	Z+5, r24	; 0x05
    2bb6:	3f c0       	rjmp	.+126    	; 0x2c36 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    2bb8:	40 3a       	cpi	r20, 0xA0	; 160
    2bba:	89 e0       	ldi	r24, 0x09	; 9
    2bbc:	58 07       	cpc	r21, r24
    2bbe:	49 f4       	brne	.+18     	; 0x2bd2 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    2bc0:	80 e6       	ldi	r24, 0x60	; 96
    2bc2:	96 e0       	ldi	r25, 0x06	; 6
    2bc4:	82 83       	std	Z+2, r24	; 0x02
    2bc6:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2bc8:	82 e0       	ldi	r24, 0x02	; 2
    2bca:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2bcc:	83 e0       	ldi	r24, 0x03	; 3
    2bce:	85 83       	std	Z+5, r24	; 0x05
    2bd0:	32 c0       	rjmp	.+100    	; 0x2c36 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    2bd2:	40 3b       	cpi	r20, 0xB0	; 176
    2bd4:	69 e0       	ldi	r22, 0x09	; 9
    2bd6:	56 07       	cpc	r21, r22
    2bd8:	49 f4       	brne	.+18     	; 0x2bec <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    2bda:	80 e6       	ldi	r24, 0x60	; 96
    2bdc:	96 e0       	ldi	r25, 0x06	; 6
    2bde:	82 83       	std	Z+2, r24	; 0x02
    2be0:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2be2:	86 e0       	ldi	r24, 0x06	; 6
    2be4:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2be6:	87 e0       	ldi	r24, 0x07	; 7
    2be8:	85 83       	std	Z+5, r24	; 0x05
    2bea:	25 c0       	rjmp	.+74     	; 0x2c36 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    2bec:	40 3a       	cpi	r20, 0xA0	; 160
    2bee:	7a e0       	ldi	r23, 0x0A	; 10
    2bf0:	57 07       	cpc	r21, r23
    2bf2:	49 f4       	brne	.+18     	; 0x2c06 <_ZN7base232C1EjP12USART_struct+0x8a>
	{
		p_port = &PORTE;
    2bf4:	80 e8       	ldi	r24, 0x80	; 128
    2bf6:	96 e0       	ldi	r25, 0x06	; 6
    2bf8:	82 83       	std	Z+2, r24	; 0x02
    2bfa:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2bfc:	82 e0       	ldi	r24, 0x02	; 2
    2bfe:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2c00:	83 e0       	ldi	r24, 0x03	; 3
    2c02:	85 83       	std	Z+5, r24	; 0x05
    2c04:	18 c0       	rjmp	.+48     	; 0x2c36 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE1 
	else if(p_usart == &USARTE1)
    2c06:	40 3b       	cpi	r20, 0xB0	; 176
    2c08:	8a e0       	ldi	r24, 0x0A	; 10
    2c0a:	58 07       	cpc	r21, r24
    2c0c:	49 f4       	brne	.+18     	; 0x2c20 <_ZN7base232C1EjP12USART_struct+0xa4>
	{
		p_port = &PORTE;
    2c0e:	80 e8       	ldi	r24, 0x80	; 128
    2c10:	96 e0       	ldi	r25, 0x06	; 6
    2c12:	82 83       	std	Z+2, r24	; 0x02
    2c14:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2c16:	86 e0       	ldi	r24, 0x06	; 6
    2c18:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2c1a:	87 e0       	ldi	r24, 0x07	; 7
    2c1c:	85 83       	std	Z+5, r24	; 0x05
    2c1e:	0b c0       	rjmp	.+22     	; 0x2c36 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTF0 
	else if(p_usart == &USARTF0)
    2c20:	40 3a       	cpi	r20, 0xA0	; 160
    2c22:	5b 40       	sbci	r21, 0x0B	; 11
    2c24:	41 f4       	brne	.+16     	; 0x2c36 <_ZN7base232C1EjP12USART_struct+0xba>
	{
		p_port = &PORTF;
    2c26:	80 ea       	ldi	r24, 0xA0	; 160
    2c28:	96 e0       	ldi	r25, 0x06	; 6
    2c2a:	82 83       	std	Z+2, r24	; 0x02
    2c2c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2c2e:	82 e0       	ldi	r24, 0x02	; 2
    2c30:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2c32:	83 e0       	ldi	r24, 0x03	; 3
    2c34:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    2c36:	a6 83       	std	Z+6, r26	; 0x06
    2c38:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    2c3a:	cd 01       	movw	r24, r26
    2c3c:	01 96       	adiw	r24, 0x01	; 1
    2c3e:	80 87       	std	Z+8, r24	; 0x08
    2c40:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    2c42:	03 96       	adiw	r24, 0x03	; 3
    2c44:	82 87       	std	Z+10, r24	; 0x0a
    2c46:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    2c48:	25 81       	ldd	r18, Z+5	; 0x05
    2c4a:	c2 81       	ldd	r28, Z+2	; 0x02
    2c4c:	d3 81       	ldd	r29, Z+3	; 0x03
    2c4e:	4c 81       	ldd	r20, Y+4	; 0x04
    2c50:	81 e0       	ldi	r24, 0x01	; 1
    2c52:	90 e0       	ldi	r25, 0x00	; 0
    2c54:	bc 01       	movw	r22, r24
    2c56:	02 c0       	rjmp	.+4      	; 0x2c5c <_ZN7base232C1EjP12USART_struct+0xe0>
    2c58:	66 0f       	add	r22, r22
    2c5a:	77 1f       	adc	r23, r23
    2c5c:	2a 95       	dec	r18
    2c5e:	e2 f7       	brpl	.-8      	; 0x2c58 <_ZN7base232C1EjP12USART_struct+0xdc>
    2c60:	9b 01       	movw	r18, r22
    2c62:	24 2b       	or	r18, r20
    2c64:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    2c66:	25 81       	ldd	r18, Z+5	; 0x05
    2c68:	c2 81       	ldd	r28, Z+2	; 0x02
    2c6a:	d3 81       	ldd	r29, Z+3	; 0x03
    2c6c:	48 81       	ld	r20, Y
    2c6e:	bc 01       	movw	r22, r24
    2c70:	02 c0       	rjmp	.+4      	; 0x2c76 <_ZN7base232C1EjP12USART_struct+0xfa>
    2c72:	66 0f       	add	r22, r22
    2c74:	77 1f       	adc	r23, r23
    2c76:	2a 95       	dec	r18
    2c78:	e2 f7       	brpl	.-8      	; 0x2c72 <_ZN7base232C1EjP12USART_struct+0xf6>
    2c7a:	9b 01       	movw	r18, r22
    2c7c:	24 2b       	or	r18, r20
    2c7e:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    2c80:	34 81       	ldd	r19, Z+4	; 0x04
    2c82:	c2 81       	ldd	r28, Z+2	; 0x02
    2c84:	d3 81       	ldd	r29, Z+3	; 0x03
    2c86:	28 81       	ld	r18, Y
    2c88:	02 c0       	rjmp	.+4      	; 0x2c8e <_ZN7base232C1EjP12USART_struct+0x112>
    2c8a:	88 0f       	add	r24, r24
    2c8c:	99 1f       	adc	r25, r25
    2c8e:	3a 95       	dec	r19
    2c90:	e2 f7       	brpl	.-8      	; 0x2c8a <_ZN7base232C1EjP12USART_struct+0x10e>
    2c92:	80 95       	com	r24
    2c94:	90 95       	com	r25
    2c96:	82 23       	and	r24, r18
    2c98:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    2c9a:	80 e1       	ldi	r24, 0x10	; 16
    2c9c:	13 96       	adiw	r26, 0x03	; 3
    2c9e:	8c 93       	st	X, r24
    2ca0:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    2ca2:	83 e0       	ldi	r24, 0x03	; 3
    2ca4:	15 96       	adiw	r26, 0x05	; 5
    2ca6:	8c 93       	st	X, r24
    2ca8:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    2caa:	80 ef       	ldi	r24, 0xF0	; 240
    2cac:	17 96       	adiw	r26, 0x07	; 7
    2cae:	8c 93       	st	X, r24
    2cb0:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    2cb2:	81 e2       	ldi	r24, 0x21	; 33
    2cb4:	16 96       	adiw	r26, 0x06	; 6
    2cb6:	8c 93       	st	X, r24
    2cb8:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    2cba:	88 e1       	ldi	r24, 0x18	; 24
    2cbc:	14 96       	adiw	r26, 0x04	; 4
    2cbe:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    2cc0:	80 e8       	ldi	r24, 0x80	; 128
    2cc2:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    2cc4:	80 e4       	ldi	r24, 0x40	; 64
    2cc6:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    2cc8:	80 e2       	ldi	r24, 0x20	; 32
    2cca:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    2ccc:	06 80       	ldd	r0, Z+6	; 0x06
    2cce:	f7 81       	ldd	r31, Z+7	; 0x07
    2cd0:	e0 2d       	mov	r30, r0
    2cd2:	80 81       	ld	r24, Z
    2cd4:	80 81       	ld	r24, Z
}
    2cd6:	df 91       	pop	r29
    2cd8:	cf 91       	pop	r28
    2cda:	08 95       	ret

00002cdc <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    2cdc:	81 e0       	ldi	r24, 0x01	; 1
    2cde:	08 95       	ret

00002ce0 <_ZN8emstream7getcharEv>:
    2ce0:	80 e0       	ldi	r24, 0x00	; 0
    2ce2:	90 e0       	ldi	r25, 0x00	; 0
    2ce4:	08 95       	ret

00002ce6 <_ZN8emstream14check_for_charEv>:
    2ce6:	80 e0       	ldi	r24, 0x00	; 0
    2ce8:	08 95       	ret

00002cea <_ZN8emstream12transmit_nowEv>:
    2cea:	08 95       	ret

00002cec <_ZN8emstream12clear_screenEv>:
    2cec:	08 95       	ret

00002cee <_ZN8emstreamC1Ev>:
    2cee:	fc 01       	movw	r30, r24
    2cf0:	8f e3       	ldi	r24, 0x3F	; 63
    2cf2:	90 e2       	ldi	r25, 0x20	; 32
    2cf4:	80 83       	st	Z, r24
    2cf6:	91 83       	std	Z+1, r25	; 0x01
    2cf8:	8a e0       	ldi	r24, 0x0A	; 10
    2cfa:	82 83       	std	Z+2, r24	; 0x02
    2cfc:	13 82       	std	Z+3, r1	; 0x03
    2cfe:	83 e0       	ldi	r24, 0x03	; 3
    2d00:	85 83       	std	Z+5, r24	; 0x05
    2d02:	14 82       	std	Z+4, r1	; 0x04
    2d04:	16 82       	std	Z+6, r1	; 0x06
    2d06:	17 82       	std	Z+7, r1	; 0x07
    2d08:	08 95       	ret

00002d0a <_ZN8emstream4putsEPKc>:
    2d0a:	0f 93       	push	r16
    2d0c:	1f 93       	push	r17
    2d0e:	cf 93       	push	r28
    2d10:	df 93       	push	r29
    2d12:	8c 01       	movw	r16, r24
    2d14:	fb 01       	movw	r30, r22
    2d16:	dc 01       	movw	r26, r24
    2d18:	14 96       	adiw	r26, 0x04	; 4
    2d1a:	8c 91       	ld	r24, X
    2d1c:	81 11       	cpse	r24, r1
    2d1e:	04 c0       	rjmp	.+8      	; 0x2d28 <_ZN8emstream4putsEPKc+0x1e>
    2d20:	60 81       	ld	r22, Z
    2d22:	61 11       	cpse	r22, r1
    2d24:	17 c0       	rjmp	.+46     	; 0x2d54 <_ZN8emstream4putsEPKc+0x4a>
    2d26:	23 c0       	rjmp	.+70     	; 0x2d6e <_ZN8emstream4putsEPKc+0x64>
    2d28:	d8 01       	movw	r26, r16
    2d2a:	14 96       	adiw	r26, 0x04	; 4
    2d2c:	1c 92       	st	X, r1
    2d2e:	eb 01       	movw	r28, r22
    2d30:	21 96       	adiw	r28, 0x01	; 1
    2d32:	64 91       	lpm	r22, Z
    2d34:	66 23       	and	r22, r22
    2d36:	d9 f0       	breq	.+54     	; 0x2d6e <_ZN8emstream4putsEPKc+0x64>
    2d38:	d8 01       	movw	r26, r16
    2d3a:	ed 91       	ld	r30, X+
    2d3c:	fc 91       	ld	r31, X
    2d3e:	02 80       	ldd	r0, Z+2	; 0x02
    2d40:	f3 81       	ldd	r31, Z+3	; 0x03
    2d42:	e0 2d       	mov	r30, r0
    2d44:	c8 01       	movw	r24, r16
    2d46:	19 95       	eicall
    2d48:	fe 01       	movw	r30, r28
    2d4a:	64 91       	lpm	r22, Z
    2d4c:	21 96       	adiw	r28, 0x01	; 1
    2d4e:	61 11       	cpse	r22, r1
    2d50:	f3 cf       	rjmp	.-26     	; 0x2d38 <_ZN8emstream4putsEPKc+0x2e>
    2d52:	0d c0       	rjmp	.+26     	; 0x2d6e <_ZN8emstream4putsEPKc+0x64>
    2d54:	ef 01       	movw	r28, r30
    2d56:	21 96       	adiw	r28, 0x01	; 1
    2d58:	d8 01       	movw	r26, r16
    2d5a:	ed 91       	ld	r30, X+
    2d5c:	fc 91       	ld	r31, X
    2d5e:	02 80       	ldd	r0, Z+2	; 0x02
    2d60:	f3 81       	ldd	r31, Z+3	; 0x03
    2d62:	e0 2d       	mov	r30, r0
    2d64:	c8 01       	movw	r24, r16
    2d66:	19 95       	eicall
    2d68:	69 91       	ld	r22, Y+
    2d6a:	61 11       	cpse	r22, r1
    2d6c:	f5 cf       	rjmp	.-22     	; 0x2d58 <_ZN8emstream4putsEPKc+0x4e>
    2d6e:	df 91       	pop	r29
    2d70:	cf 91       	pop	r28
    2d72:	1f 91       	pop	r17
    2d74:	0f 91       	pop	r16
    2d76:	08 95       	ret

00002d78 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    2d78:	cf 93       	push	r28
    2d7a:	df 93       	push	r29
    2d7c:	ec 01       	movw	r28, r24
	switch (new_manip)
    2d7e:	86 2f       	mov	r24, r22
    2d80:	90 e0       	ldi	r25, 0x00	; 0
    2d82:	8b 30       	cpi	r24, 0x0B	; 11
    2d84:	91 05       	cpc	r25, r1
    2d86:	d8 f5       	brcc	.+118    	; 0x2dfe <_ZN8emstreamlsE15ser_manipulator+0x86>
    2d88:	fc 01       	movw	r30, r24
    2d8a:	88 27       	eor	r24, r24
    2d8c:	e2 50       	subi	r30, 0x02	; 2
    2d8e:	ff 4f       	sbci	r31, 0xFF	; 255
    2d90:	8f 4f       	sbci	r24, 0xFF	; 255
    2d92:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    2d96:	82 e0       	ldi	r24, 0x02	; 2
    2d98:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2d9a:	31 c0       	rjmp	.+98     	; 0x2dfe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    2d9c:	88 e0       	ldi	r24, 0x08	; 8
    2d9e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2da0:	2e c0       	rjmp	.+92     	; 0x2dfe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    2da2:	8a e0       	ldi	r24, 0x0A	; 10
    2da4:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2da6:	2b c0       	rjmp	.+86     	; 0x2dfe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    2da8:	80 e1       	ldi	r24, 0x10	; 16
    2daa:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2dac:	28 c0       	rjmp	.+80     	; 0x2dfe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    2dae:	81 e0       	ldi	r24, 0x01	; 1
    2db0:	8b 83       	std	Y+3, r24	; 0x03
			break;
    2db2:	25 c0       	rjmp	.+74     	; 0x2dfe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    2db4:	1b 82       	std	Y+3, r1	; 0x03
			break;
    2db6:	23 c0       	rjmp	.+70     	; 0x2dfe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    2db8:	e8 81       	ld	r30, Y
    2dba:	f9 81       	ldd	r31, Y+1	; 0x01
    2dbc:	02 80       	ldd	r0, Z+2	; 0x02
    2dbe:	f3 81       	ldd	r31, Z+3	; 0x03
    2dc0:	e0 2d       	mov	r30, r0
    2dc2:	6d e0       	ldi	r22, 0x0D	; 13
    2dc4:	ce 01       	movw	r24, r28
    2dc6:	19 95       	eicall
    2dc8:	e8 81       	ld	r30, Y
    2dca:	f9 81       	ldd	r31, Y+1	; 0x01
    2dcc:	02 80       	ldd	r0, Z+2	; 0x02
    2dce:	f3 81       	ldd	r31, Z+3	; 0x03
    2dd0:	e0 2d       	mov	r30, r0
    2dd2:	6a e0       	ldi	r22, 0x0A	; 10
    2dd4:	ce 01       	movw	r24, r28
    2dd6:	19 95       	eicall
			break;
    2dd8:	12 c0       	rjmp	.+36     	; 0x2dfe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    2dda:	e8 81       	ld	r30, Y
    2ddc:	f9 81       	ldd	r31, Y+1	; 0x01
    2dde:	02 84       	ldd	r0, Z+10	; 0x0a
    2de0:	f3 85       	ldd	r31, Z+11	; 0x0b
    2de2:	e0 2d       	mov	r30, r0
    2de4:	ce 01       	movw	r24, r28
    2de6:	19 95       	eicall
			break;
    2de8:	0a c0       	rjmp	.+20     	; 0x2dfe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    2dea:	e8 81       	ld	r30, Y
    2dec:	f9 81       	ldd	r31, Y+1	; 0x01
    2dee:	00 84       	ldd	r0, Z+8	; 0x08
    2df0:	f1 85       	ldd	r31, Z+9	; 0x09
    2df2:	e0 2d       	mov	r30, r0
    2df4:	ce 01       	movw	r24, r28
    2df6:	19 95       	eicall
			break;
    2df8:	02 c0       	rjmp	.+4      	; 0x2dfe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    2dfa:	81 e0       	ldi	r24, 0x01	; 1
    2dfc:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    2dfe:	ce 01       	movw	r24, r28
    2e00:	df 91       	pop	r29
    2e02:	cf 91       	pop	r28
    2e04:	08 95       	ret

00002e06 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    2e06:	ff 92       	push	r15
    2e08:	0f 93       	push	r16
    2e0a:	1f 93       	push	r17
    2e0c:	cf 93       	push	r28
    2e0e:	df 93       	push	r29
    2e10:	cd b7       	in	r28, 0x3d	; 61
    2e12:	de b7       	in	r29, 0x3e	; 62
    2e14:	61 97       	sbiw	r28, 0x11	; 17
    2e16:	cd bf       	out	0x3d, r28	; 61
    2e18:	de bf       	out	0x3e, r29	; 62
    2e1a:	8c 01       	movw	r16, r24
    2e1c:	f6 2e       	mov	r15, r22
    2e1e:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    2e20:	f8 01       	movw	r30, r16
    2e22:	42 81       	ldd	r20, Z+2	; 0x02
    2e24:	40 31       	cpi	r20, 0x10	; 16
    2e26:	21 f0       	breq	.+8      	; 0x2e30 <_ZN8emstreamlsEj+0x2a>
    2e28:	48 30       	cpi	r20, 0x08	; 8
    2e2a:	11 f0       	breq	.+4      	; 0x2e30 <_ZN8emstreamlsEj+0x2a>
    2e2c:	42 30       	cpi	r20, 0x02	; 2
    2e2e:	41 f4       	brne	.+16     	; 0x2e40 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    2e30:	69 2f       	mov	r22, r25
    2e32:	c8 01       	movw	r24, r16
    2e34:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <_ZN8emstreamlsEh>
    2e38:	6f 2d       	mov	r22, r15
    2e3a:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <_ZN8emstreamlsEh>
    2e3e:	0d c0       	rjmp	.+26     	; 0x2e5a <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    2e40:	50 e0       	ldi	r21, 0x00	; 0
    2e42:	be 01       	movw	r22, r28
    2e44:	6f 5f       	subi	r22, 0xFF	; 255
    2e46:	7f 4f       	sbci	r23, 0xFF	; 255
    2e48:	8f 2d       	mov	r24, r15
    2e4a:	0e 94 15 1d 	call	0x3a2a	; 0x3a2a <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    2e4e:	be 01       	movw	r22, r28
    2e50:	6f 5f       	subi	r22, 0xFF	; 255
    2e52:	7f 4f       	sbci	r23, 0xFF	; 255
    2e54:	c8 01       	movw	r24, r16
    2e56:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    2e5a:	c8 01       	movw	r24, r16
    2e5c:	61 96       	adiw	r28, 0x11	; 17
    2e5e:	cd bf       	out	0x3d, r28	; 61
    2e60:	de bf       	out	0x3e, r29	; 62
    2e62:	df 91       	pop	r29
    2e64:	cf 91       	pop	r28
    2e66:	1f 91       	pop	r17
    2e68:	0f 91       	pop	r16
    2e6a:	ff 90       	pop	r15
    2e6c:	08 95       	ret

00002e6e <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    2e6e:	df 92       	push	r13
    2e70:	ef 92       	push	r14
    2e72:	ff 92       	push	r15
    2e74:	0f 93       	push	r16
    2e76:	1f 93       	push	r17
    2e78:	cf 93       	push	r28
    2e7a:	df 93       	push	r29
    2e7c:	cd b7       	in	r28, 0x3d	; 61
    2e7e:	de b7       	in	r29, 0x3e	; 62
    2e80:	a1 97       	sbiw	r28, 0x21	; 33
    2e82:	cd bf       	out	0x3d, r28	; 61
    2e84:	de bf       	out	0x3e, r29	; 62
    2e86:	8c 01       	movw	r16, r24
    2e88:	d4 2e       	mov	r13, r20
    2e8a:	e5 2e       	mov	r14, r21
    2e8c:	f6 2e       	mov	r15, r22
    2e8e:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    2e90:	f8 01       	movw	r30, r16
    2e92:	22 81       	ldd	r18, Z+2	; 0x02
    2e94:	20 31       	cpi	r18, 0x10	; 16
    2e96:	21 f0       	breq	.+8      	; 0x2ea0 <_ZN8emstreamlsEm+0x32>
    2e98:	28 30       	cpi	r18, 0x08	; 8
    2e9a:	11 f0       	breq	.+4      	; 0x2ea0 <_ZN8emstreamlsEm+0x32>
    2e9c:	22 30       	cpi	r18, 0x02	; 2
    2e9e:	71 f4       	brne	.+28     	; 0x2ebc <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    2ea0:	69 2f       	mov	r22, r25
    2ea2:	c8 01       	movw	r24, r16
    2ea4:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <_ZN8emstreamlsEh>
    2ea8:	6f 2d       	mov	r22, r15
    2eaa:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <_ZN8emstreamlsEh>
    2eae:	6e 2d       	mov	r22, r14
    2eb0:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <_ZN8emstreamlsEh>
    2eb4:	6d 2d       	mov	r22, r13
    2eb6:	0e 94 79 17 	call	0x2ef2	; 0x2ef2 <_ZN8emstreamlsEh>
    2eba:	0f c0       	rjmp	.+30     	; 0x2eda <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    2ebc:	30 e0       	ldi	r19, 0x00	; 0
    2ebe:	ae 01       	movw	r20, r28
    2ec0:	4f 5f       	subi	r20, 0xFF	; 255
    2ec2:	5f 4f       	sbci	r21, 0xFF	; 255
    2ec4:	6d 2d       	mov	r22, r13
    2ec6:	7e 2d       	mov	r23, r14
    2ec8:	8f 2d       	mov	r24, r15
    2eca:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    2ece:	be 01       	movw	r22, r28
    2ed0:	6f 5f       	subi	r22, 0xFF	; 255
    2ed2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ed4:	c8 01       	movw	r24, r16
    2ed6:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    2eda:	c8 01       	movw	r24, r16
    2edc:	a1 96       	adiw	r28, 0x21	; 33
    2ede:	cd bf       	out	0x3d, r28	; 61
    2ee0:	de bf       	out	0x3e, r29	; 62
    2ee2:	df 91       	pop	r29
    2ee4:	cf 91       	pop	r28
    2ee6:	1f 91       	pop	r17
    2ee8:	0f 91       	pop	r16
    2eea:	ff 90       	pop	r15
    2eec:	ef 90       	pop	r14
    2eee:	df 90       	pop	r13
    2ef0:	08 95       	ret

00002ef2 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    2ef2:	cf 92       	push	r12
    2ef4:	df 92       	push	r13
    2ef6:	ef 92       	push	r14
    2ef8:	ff 92       	push	r15
    2efa:	0f 93       	push	r16
    2efc:	1f 93       	push	r17
    2efe:	cf 93       	push	r28
    2f00:	df 93       	push	r29
    2f02:	cd b7       	in	r28, 0x3d	; 61
    2f04:	de b7       	in	r29, 0x3e	; 62
    2f06:	29 97       	sbiw	r28, 0x09	; 9
    2f08:	cd bf       	out	0x3d, r28	; 61
    2f0a:	de bf       	out	0x3e, r29	; 62
    2f0c:	8c 01       	movw	r16, r24
    2f0e:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    2f10:	dc 01       	movw	r26, r24
    2f12:	13 96       	adiw	r26, 0x03	; 3
    2f14:	8c 91       	ld	r24, X
    2f16:	13 97       	sbiw	r26, 0x03	; 3
    2f18:	88 23       	and	r24, r24
    2f1a:	41 f0       	breq	.+16     	; 0x2f2c <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    2f1c:	ed 91       	ld	r30, X+
    2f1e:	fc 91       	ld	r31, X
    2f20:	02 80       	ldd	r0, Z+2	; 0x02
    2f22:	f3 81       	ldd	r31, Z+3	; 0x03
    2f24:	e0 2d       	mov	r30, r0
    2f26:	c8 01       	movw	r24, r16
    2f28:	19 95       	eicall
    2f2a:	56 c0       	rjmp	.+172    	; 0x2fd8 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    2f2c:	f8 01       	movw	r30, r16
    2f2e:	42 81       	ldd	r20, Z+2	; 0x02
    2f30:	42 30       	cpi	r20, 0x02	; 2
    2f32:	19 f5       	brne	.+70     	; 0x2f7a <_ZN8emstreamlsEh+0x88>
    2f34:	68 94       	set
    2f36:	cc 24       	eor	r12, r12
    2f38:	c3 f8       	bld	r12, 3
    2f3a:	d1 2c       	mov	r13, r1
    2f3c:	68 94       	set
    2f3e:	ff 24       	eor	r15, r15
    2f40:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    2f42:	8e 2d       	mov	r24, r14
    2f44:	8f 21       	and	r24, r15
    2f46:	51 f0       	breq	.+20     	; 0x2f5c <_ZN8emstreamlsEh+0x6a>
    2f48:	d8 01       	movw	r26, r16
    2f4a:	ed 91       	ld	r30, X+
    2f4c:	fc 91       	ld	r31, X
    2f4e:	02 80       	ldd	r0, Z+2	; 0x02
    2f50:	f3 81       	ldd	r31, Z+3	; 0x03
    2f52:	e0 2d       	mov	r30, r0
    2f54:	61 e3       	ldi	r22, 0x31	; 49
    2f56:	c8 01       	movw	r24, r16
    2f58:	19 95       	eicall
    2f5a:	09 c0       	rjmp	.+18     	; 0x2f6e <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    2f5c:	d8 01       	movw	r26, r16
    2f5e:	ed 91       	ld	r30, X+
    2f60:	fc 91       	ld	r31, X
    2f62:	02 80       	ldd	r0, Z+2	; 0x02
    2f64:	f3 81       	ldd	r31, Z+3	; 0x03
    2f66:	e0 2d       	mov	r30, r0
    2f68:	60 e3       	ldi	r22, 0x30	; 48
    2f6a:	c8 01       	movw	r24, r16
    2f6c:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    2f6e:	f6 94       	lsr	r15
    2f70:	b1 e0       	ldi	r27, 0x01	; 1
    2f72:	cb 1a       	sub	r12, r27
    2f74:	d1 08       	sbc	r13, r1
    2f76:	29 f7       	brne	.-54     	; 0x2f42 <_ZN8emstreamlsEh+0x50>
    2f78:	2f c0       	rjmp	.+94     	; 0x2fd8 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    2f7a:	40 31       	cpi	r20, 0x10	; 16
    2f7c:	f9 f4       	brne	.+62     	; 0x2fbc <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    2f7e:	62 95       	swap	r22
    2f80:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    2f82:	01 90       	ld	r0, Z+
    2f84:	f0 81       	ld	r31, Z
    2f86:	e0 2d       	mov	r30, r0
    2f88:	02 80       	ldd	r0, Z+2	; 0x02
    2f8a:	f3 81       	ldd	r31, Z+3	; 0x03
    2f8c:	e0 2d       	mov	r30, r0
    2f8e:	6a 30       	cpi	r22, 0x0A	; 10
    2f90:	10 f0       	brcs	.+4      	; 0x2f96 <_ZN8emstreamlsEh+0xa4>
    2f92:	69 5c       	subi	r22, 0xC9	; 201
    2f94:	01 c0       	rjmp	.+2      	; 0x2f98 <_ZN8emstreamlsEh+0xa6>
    2f96:	60 5d       	subi	r22, 0xD0	; 208
    2f98:	c8 01       	movw	r24, r16
    2f9a:	19 95       	eicall
		temp_char = num & 0x0F;
    2f9c:	6e 2d       	mov	r22, r14
    2f9e:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    2fa0:	d8 01       	movw	r26, r16
    2fa2:	ed 91       	ld	r30, X+
    2fa4:	fc 91       	ld	r31, X
    2fa6:	02 80       	ldd	r0, Z+2	; 0x02
    2fa8:	f3 81       	ldd	r31, Z+3	; 0x03
    2faa:	e0 2d       	mov	r30, r0
    2fac:	6a 30       	cpi	r22, 0x0A	; 10
    2fae:	10 f0       	brcs	.+4      	; 0x2fb4 <_ZN8emstreamlsEh+0xc2>
    2fb0:	69 5c       	subi	r22, 0xC9	; 201
    2fb2:	01 c0       	rjmp	.+2      	; 0x2fb6 <_ZN8emstreamlsEh+0xc4>
    2fb4:	60 5d       	subi	r22, 0xD0	; 208
    2fb6:	c8 01       	movw	r24, r16
    2fb8:	19 95       	eicall
    2fba:	0e c0       	rjmp	.+28     	; 0x2fd8 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    2fbc:	50 e0       	ldi	r21, 0x00	; 0
    2fbe:	be 01       	movw	r22, r28
    2fc0:	6f 5f       	subi	r22, 0xFF	; 255
    2fc2:	7f 4f       	sbci	r23, 0xFF	; 255
    2fc4:	8e 2d       	mov	r24, r14
    2fc6:	90 e0       	ldi	r25, 0x00	; 0
    2fc8:	0e 94 15 1d 	call	0x3a2a	; 0x3a2a <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    2fcc:	be 01       	movw	r22, r28
    2fce:	6f 5f       	subi	r22, 0xFF	; 255
    2fd0:	7f 4f       	sbci	r23, 0xFF	; 255
    2fd2:	c8 01       	movw	r24, r16
    2fd4:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    2fd8:	c8 01       	movw	r24, r16
    2fda:	29 96       	adiw	r28, 0x09	; 9
    2fdc:	cd bf       	out	0x3d, r28	; 61
    2fde:	de bf       	out	0x3e, r29	; 62
    2fe0:	df 91       	pop	r29
    2fe2:	cf 91       	pop	r28
    2fe4:	1f 91       	pop	r17
    2fe6:	0f 91       	pop	r16
    2fe8:	ff 90       	pop	r15
    2fea:	ef 90       	pop	r14
    2fec:	df 90       	pop	r13
    2fee:	cf 90       	pop	r12
    2ff0:	08 95       	ret

00002ff2 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    2ff2:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    2ff4:	50 96       	adiw	r26, 0x10	; 16
    2ff6:	ed 91       	ld	r30, X+
    2ff8:	fc 91       	ld	r31, X
    2ffa:	51 97       	sbiw	r26, 0x11	; 17
    2ffc:	80 81       	ld	r24, Z
    2ffe:	54 96       	adiw	r26, 0x14	; 20
    3000:	4c 91       	ld	r20, X
    3002:	54 97       	sbiw	r26, 0x14	; 20
    3004:	84 23       	and	r24, r20
    3006:	29 f0       	breq	.+10     	; 0x3012 <_ZN5rs2327putcharEc+0x20>
    3008:	09 c0       	rjmp	.+18     	; 0x301c <_ZN5rs2327putcharEc+0x2a>
    300a:	21 50       	subi	r18, 0x01	; 1
    300c:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    300e:	19 f4       	brne	.+6      	; 0x3016 <_ZN5rs2327putcharEc+0x24>
    3010:	12 c0       	rjmp	.+36     	; 0x3036 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3012:	21 e2       	ldi	r18, 0x21	; 33
    3014:	3e e4       	ldi	r19, 0x4E	; 78
    3016:	90 81       	ld	r25, Z
    3018:	94 23       	and	r25, r20
    301a:	b9 f3       	breq	.-18     	; 0x300a <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    301c:	90 81       	ld	r25, Z
    301e:	56 96       	adiw	r26, 0x16	; 22
    3020:	8c 91       	ld	r24, X
    3022:	56 97       	sbiw	r26, 0x16	; 22
    3024:	89 2b       	or	r24, r25
    3026:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3028:	1e 96       	adiw	r26, 0x0e	; 14
    302a:	ed 91       	ld	r30, X+
    302c:	fc 91       	ld	r31, X
    302e:	1f 97       	sbiw	r26, 0x0f	; 15
    3030:	60 83       	st	Z, r22
	return (true);
    3032:	81 e0       	ldi	r24, 0x01	; 1
    3034:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3036:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3038:	08 95       	ret

0000303a <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    303a:	cf 93       	push	r28
    303c:	df 93       	push	r29
    303e:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3040:	c1 8d       	ldd	r28, Z+25	; 0x19
    3042:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3044:	28 81       	ld	r18, Y
    3046:	39 81       	ldd	r19, Y+1	; 0x01
    3048:	a3 8d       	ldd	r26, Z+27	; 0x1b
    304a:	b4 8d       	ldd	r27, Z+28	; 0x1c
    304c:	4d 91       	ld	r20, X+
    304e:	5c 91       	ld	r21, X
    3050:	24 17       	cp	r18, r20
    3052:	35 07       	cpc	r19, r21
    3054:	e9 f3       	breq	.-6      	; 0x3050 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3056:	a7 89       	ldd	r26, Z+23	; 0x17
    3058:	b0 8d       	ldd	r27, Z+24	; 0x18
    305a:	0d 90       	ld	r0, X+
    305c:	bc 91       	ld	r27, X
    305e:	a0 2d       	mov	r26, r0
    3060:	a2 0f       	add	r26, r18
    3062:	b3 1f       	adc	r27, r19
    3064:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3066:	2f 5f       	subi	r18, 0xFF	; 255
    3068:	3f 4f       	sbci	r19, 0xFF	; 255
    306a:	28 83       	st	Y, r18
    306c:	39 83       	std	Y+1, r19	; 0x01
    306e:	24 36       	cpi	r18, 0x64	; 100
    3070:	31 05       	cpc	r19, r1
    3072:	28 f0       	brcs	.+10     	; 0x307e <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3074:	01 8c       	ldd	r0, Z+25	; 0x19
    3076:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3078:	e0 2d       	mov	r30, r0
    307a:	10 82       	st	Z, r1
    307c:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    307e:	90 e0       	ldi	r25, 0x00	; 0
    3080:	df 91       	pop	r29
    3082:	cf 91       	pop	r28
    3084:	08 95       	ret

00003086 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3086:	cf 93       	push	r28
    3088:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    308a:	ec 01       	movw	r28, r24
    308c:	a9 8d       	ldd	r26, Y+25	; 0x19
    308e:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3090:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3092:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3094:	81 e0       	ldi	r24, 0x01	; 1
    3096:	4d 91       	ld	r20, X+
    3098:	5c 91       	ld	r21, X
    309a:	20 81       	ld	r18, Z
    309c:	31 81       	ldd	r19, Z+1	; 0x01
    309e:	42 17       	cp	r20, r18
    30a0:	53 07       	cpc	r21, r19
    30a2:	09 f4       	brne	.+2      	; 0x30a6 <_ZN5rs23214check_for_charEv+0x20>
    30a4:	80 e0       	ldi	r24, 0x00	; 0
}
    30a6:	df 91       	pop	r29
    30a8:	cf 91       	pop	r28
    30aa:	08 95       	ret

000030ac <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    30ac:	dc 01       	movw	r26, r24
    30ae:	ed 91       	ld	r30, X+
    30b0:	fc 91       	ld	r31, X
    30b2:	02 80       	ldd	r0, Z+2	; 0x02
    30b4:	f3 81       	ldd	r31, Z+3	; 0x03
    30b6:	e0 2d       	mov	r30, r0
    30b8:	6c e0       	ldi	r22, 0x0C	; 12
    30ba:	19 95       	eicall
    30bc:	08 95       	ret

000030be <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    30be:	ef 92       	push	r14
    30c0:	ff 92       	push	r15
    30c2:	0f 93       	push	r16
    30c4:	1f 93       	push	r17
    30c6:	cf 93       	push	r28
    30c8:	df 93       	push	r29
    30ca:	ec 01       	movw	r28, r24
    30cc:	7b 01       	movw	r14, r22
    30ce:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    30d0:	0e 94 77 16 	call	0x2cee	; 0x2cee <_ZN8emstreamC1Ev>
    30d4:	a8 01       	movw	r20, r16
    30d6:	b7 01       	movw	r22, r14
    30d8:	ce 01       	movw	r24, r28
    30da:	08 96       	adiw	r24, 0x08	; 8
    30dc:	0e 94 be 15 	call	0x2b7c	; 0x2b7c <_ZN7base232C1EjP12USART_struct>
    30e0:	8f e4       	ldi	r24, 0x4F	; 79
    30e2:	90 e2       	ldi	r25, 0x20	; 32
    30e4:	88 83       	st	Y, r24
    30e6:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    30e8:	00 3a       	cpi	r16, 0xA0	; 160
    30ea:	88 e0       	ldi	r24, 0x08	; 8
    30ec:	18 07       	cpc	r17, r24
    30ee:	69 f4       	brne	.+26     	; 0x310a <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    30f0:	86 e2       	ldi	r24, 0x26	; 38
    30f2:	91 e3       	ldi	r25, 0x31	; 49
    30f4:	8f 8b       	std	Y+23, r24	; 0x17
    30f6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    30f8:	88 e1       	ldi	r24, 0x18	; 24
    30fa:	91 e3       	ldi	r25, 0x31	; 49
    30fc:	89 8f       	std	Y+25, r24	; 0x19
    30fe:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3100:	8a e0       	ldi	r24, 0x0A	; 10
    3102:	91 e3       	ldi	r25, 0x31	; 49
    3104:	8b 8f       	std	Y+27, r24	; 0x1b
    3106:	9c 8f       	std	Y+28, r25	; 0x1c
    3108:	64 c0       	rjmp	.+200    	; 0x31d2 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    310a:	00 3b       	cpi	r16, 0xB0	; 176
    310c:	e8 e0       	ldi	r30, 0x08	; 8
    310e:	1e 07       	cpc	r17, r30
    3110:	69 f4       	brne	.+26     	; 0x312c <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3112:	84 e2       	ldi	r24, 0x24	; 36
    3114:	91 e3       	ldi	r25, 0x31	; 49
    3116:	8f 8b       	std	Y+23, r24	; 0x17
    3118:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    311a:	86 e1       	ldi	r24, 0x16	; 22
    311c:	91 e3       	ldi	r25, 0x31	; 49
    311e:	89 8f       	std	Y+25, r24	; 0x19
    3120:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3122:	88 e0       	ldi	r24, 0x08	; 8
    3124:	91 e3       	ldi	r25, 0x31	; 49
    3126:	8b 8f       	std	Y+27, r24	; 0x1b
    3128:	9c 8f       	std	Y+28, r25	; 0x1c
    312a:	53 c0       	rjmp	.+166    	; 0x31d2 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    312c:	00 3a       	cpi	r16, 0xA0	; 160
    312e:	f9 e0       	ldi	r31, 0x09	; 9
    3130:	1f 07       	cpc	r17, r31
    3132:	69 f4       	brne	.+26     	; 0x314e <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3134:	82 e2       	ldi	r24, 0x22	; 34
    3136:	91 e3       	ldi	r25, 0x31	; 49
    3138:	8f 8b       	std	Y+23, r24	; 0x17
    313a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    313c:	84 e1       	ldi	r24, 0x14	; 20
    313e:	91 e3       	ldi	r25, 0x31	; 49
    3140:	89 8f       	std	Y+25, r24	; 0x19
    3142:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3144:	86 e0       	ldi	r24, 0x06	; 6
    3146:	91 e3       	ldi	r25, 0x31	; 49
    3148:	8b 8f       	std	Y+27, r24	; 0x1b
    314a:	9c 8f       	std	Y+28, r25	; 0x1c
    314c:	42 c0       	rjmp	.+132    	; 0x31d2 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    314e:	00 3b       	cpi	r16, 0xB0	; 176
    3150:	89 e0       	ldi	r24, 0x09	; 9
    3152:	18 07       	cpc	r17, r24
    3154:	69 f4       	brne	.+26     	; 0x3170 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3156:	80 e2       	ldi	r24, 0x20	; 32
    3158:	91 e3       	ldi	r25, 0x31	; 49
    315a:	8f 8b       	std	Y+23, r24	; 0x17
    315c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    315e:	82 e1       	ldi	r24, 0x12	; 18
    3160:	91 e3       	ldi	r25, 0x31	; 49
    3162:	89 8f       	std	Y+25, r24	; 0x19
    3164:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3166:	84 e0       	ldi	r24, 0x04	; 4
    3168:	91 e3       	ldi	r25, 0x31	; 49
    316a:	8b 8f       	std	Y+27, r24	; 0x1b
    316c:	9c 8f       	std	Y+28, r25	; 0x1c
    316e:	31 c0       	rjmp	.+98     	; 0x31d2 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3170:	00 3a       	cpi	r16, 0xA0	; 160
    3172:	ea e0       	ldi	r30, 0x0A	; 10
    3174:	1e 07       	cpc	r17, r30
    3176:	69 f4       	brne	.+26     	; 0x3192 <_ZN5rs232C1EjP12USART_struct+0xd4>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3178:	8e e1       	ldi	r24, 0x1E	; 30
    317a:	91 e3       	ldi	r25, 0x31	; 49
    317c:	8f 8b       	std	Y+23, r24	; 0x17
    317e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3180:	80 e1       	ldi	r24, 0x10	; 16
    3182:	91 e3       	ldi	r25, 0x31	; 49
    3184:	89 8f       	std	Y+25, r24	; 0x19
    3186:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3188:	82 e0       	ldi	r24, 0x02	; 2
    318a:	91 e3       	ldi	r25, 0x31	; 49
    318c:	8b 8f       	std	Y+27, r24	; 0x1b
    318e:	9c 8f       	std	Y+28, r25	; 0x1c
    3190:	20 c0       	rjmp	.+64     	; 0x31d2 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE1
	else if(p_usart == &USARTE1)
    3192:	00 3b       	cpi	r16, 0xB0	; 176
    3194:	fa e0       	ldi	r31, 0x0A	; 10
    3196:	1f 07       	cpc	r17, r31
    3198:	69 f4       	brne	.+26     	; 0x31b4 <_ZN5rs232C1EjP12USART_struct+0xf6>
	{
		p_rcv_buffer		= &rcvE1_buffer;
    319a:	8c e1       	ldi	r24, 0x1C	; 28
    319c:	91 e3       	ldi	r25, 0x31	; 49
    319e:	8f 8b       	std	Y+23, r24	; 0x17
    31a0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE1_read_index;
    31a2:	8e e0       	ldi	r24, 0x0E	; 14
    31a4:	91 e3       	ldi	r25, 0x31	; 49
    31a6:	89 8f       	std	Y+25, r24	; 0x19
    31a8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE1_write_index;
    31aa:	80 e0       	ldi	r24, 0x00	; 0
    31ac:	91 e3       	ldi	r25, 0x31	; 49
    31ae:	8b 8f       	std	Y+27, r24	; 0x1b
    31b0:	9c 8f       	std	Y+28, r25	; 0x1c
    31b2:	0f c0       	rjmp	.+30     	; 0x31d2 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTF0
	else if(p_usart == &USARTF0)
    31b4:	00 3a       	cpi	r16, 0xA0	; 160
    31b6:	1b 40       	sbci	r17, 0x0B	; 11
    31b8:	61 f4       	brne	.+24     	; 0x31d2 <_ZN5rs232C1EjP12USART_struct+0x114>
	{
		p_rcv_buffer		= &rcvF0_buffer;
    31ba:	8a e1       	ldi	r24, 0x1A	; 26
    31bc:	91 e3       	ldi	r25, 0x31	; 49
    31be:	8f 8b       	std	Y+23, r24	; 0x17
    31c0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvF0_read_index;
    31c2:	8c e0       	ldi	r24, 0x0C	; 12
    31c4:	91 e3       	ldi	r25, 0x31	; 49
    31c6:	89 8f       	std	Y+25, r24	; 0x19
    31c8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvF0_write_index;
    31ca:	8e ef       	ldi	r24, 0xFE	; 254
    31cc:	90 e3       	ldi	r25, 0x30	; 48
    31ce:	8b 8f       	std	Y+27, r24	; 0x1b
    31d0:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    31d2:	0f 89       	ldd	r16, Y+23	; 0x17
    31d4:	18 8d       	ldd	r17, Y+24	; 0x18
    31d6:	84 e6       	ldi	r24, 0x64	; 100
    31d8:	90 e0       	ldi	r25, 0x00	; 0
    31da:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <_Znaj>
    31de:	f8 01       	movw	r30, r16
    31e0:	80 83       	st	Z, r24
    31e2:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    31e4:	e9 8d       	ldd	r30, Y+25	; 0x19
    31e6:	fa 8d       	ldd	r31, Y+26	; 0x1a
    31e8:	10 82       	st	Z, r1
    31ea:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    31ec:	eb 8d       	ldd	r30, Y+27	; 0x1b
    31ee:	fc 8d       	ldd	r31, Y+28	; 0x1c
    31f0:	10 82       	st	Z, r1
    31f2:	11 82       	std	Z+1, r1	; 0x01
}
    31f4:	df 91       	pop	r29
    31f6:	cf 91       	pop	r28
    31f8:	1f 91       	pop	r17
    31fa:	0f 91       	pop	r16
    31fc:	ff 90       	pop	r15
    31fe:	ef 90       	pop	r14
    3200:	08 95       	ret

00003202 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3202:	1f 92       	push	r1
    3204:	0f 92       	push	r0
    3206:	0f b6       	in	r0, 0x3f	; 63
    3208:	0f 92       	push	r0
    320a:	11 24       	eor	r1, r1
    320c:	08 b6       	in	r0, 0x38	; 56
    320e:	0f 92       	push	r0
    3210:	18 be       	out	0x38, r1	; 56
    3212:	0b b6       	in	r0, 0x3b	; 59
    3214:	0f 92       	push	r0
    3216:	1b be       	out	0x3b, r1	; 59
    3218:	2f 93       	push	r18
    321a:	3f 93       	push	r19
    321c:	8f 93       	push	r24
    321e:	9f 93       	push	r25
    3220:	ef 93       	push	r30
    3222:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3224:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3228:	e0 91 26 31 	lds	r30, 0x3126	; 0x803126 <rcvC0_buffer>
    322c:	f0 91 27 31 	lds	r31, 0x3127	; 0x803127 <rcvC0_buffer+0x1>
    3230:	80 91 0a 31 	lds	r24, 0x310A	; 0x80310a <rcvC0_write_index>
    3234:	90 91 0b 31 	lds	r25, 0x310B	; 0x80310b <rcvC0_write_index+0x1>
    3238:	e8 0f       	add	r30, r24
    323a:	f9 1f       	adc	r31, r25
    323c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    323e:	80 91 0a 31 	lds	r24, 0x310A	; 0x80310a <rcvC0_write_index>
    3242:	90 91 0b 31 	lds	r25, 0x310B	; 0x80310b <rcvC0_write_index+0x1>
    3246:	01 96       	adiw	r24, 0x01	; 1
    3248:	84 36       	cpi	r24, 0x64	; 100
    324a:	91 05       	cpc	r25, r1
    324c:	60 f4       	brcc	.+24     	; 0x3266 <__vector_25+0x64>
    324e:	80 93 0a 31 	sts	0x310A, r24	; 0x80310a <rcvC0_write_index>
    3252:	90 93 0b 31 	sts	0x310B, r25	; 0x80310b <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3256:	20 91 18 31 	lds	r18, 0x3118	; 0x803118 <rcvC0_read_index>
    325a:	30 91 19 31 	lds	r19, 0x3119	; 0x803119 <rcvC0_read_index+0x1>
    325e:	82 17       	cp	r24, r18
    3260:	93 07       	cpc	r25, r19
    3262:	f1 f4       	brne	.+60     	; 0x32a0 <__vector_25+0x9e>
    3264:	0c c0       	rjmp	.+24     	; 0x327e <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3266:	10 92 0a 31 	sts	0x310A, r1	; 0x80310a <rcvC0_write_index>
    326a:	10 92 0b 31 	sts	0x310B, r1	; 0x80310b <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    326e:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <rcvC0_read_index>
    3272:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <rcvC0_read_index+0x1>
    3276:	18 16       	cp	r1, r24
    3278:	19 06       	cpc	r1, r25
    327a:	91 f4       	brne	.+36     	; 0x32a0 <__vector_25+0x9e>
    327c:	0e c0       	rjmp	.+28     	; 0x329a <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    327e:	01 96       	adiw	r24, 0x01	; 1
    3280:	84 36       	cpi	r24, 0x64	; 100
    3282:	91 05       	cpc	r25, r1
    3284:	28 f4       	brcc	.+10     	; 0x3290 <__vector_25+0x8e>
    3286:	80 93 18 31 	sts	0x3118, r24	; 0x803118 <rcvC0_read_index>
    328a:	90 93 19 31 	sts	0x3119, r25	; 0x803119 <rcvC0_read_index+0x1>
    328e:	08 c0       	rjmp	.+16     	; 0x32a0 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3290:	10 92 18 31 	sts	0x3118, r1	; 0x803118 <rcvC0_read_index>
    3294:	10 92 19 31 	sts	0x3119, r1	; 0x803119 <rcvC0_read_index+0x1>
}
    3298:	03 c0       	rjmp	.+6      	; 0x32a0 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    329a:	81 e0       	ldi	r24, 0x01	; 1
    329c:	90 e0       	ldi	r25, 0x00	; 0
    329e:	f3 cf       	rjmp	.-26     	; 0x3286 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    32a0:	ff 91       	pop	r31
    32a2:	ef 91       	pop	r30
    32a4:	9f 91       	pop	r25
    32a6:	8f 91       	pop	r24
    32a8:	3f 91       	pop	r19
    32aa:	2f 91       	pop	r18
    32ac:	0f 90       	pop	r0
    32ae:	0b be       	out	0x3b, r0	; 59
    32b0:	0f 90       	pop	r0
    32b2:	08 be       	out	0x38, r0	; 56
    32b4:	0f 90       	pop	r0
    32b6:	0f be       	out	0x3f, r0	; 63
    32b8:	0f 90       	pop	r0
    32ba:	1f 90       	pop	r1
    32bc:	18 95       	reti

000032be <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    32be:	1f 92       	push	r1
    32c0:	0f 92       	push	r0
    32c2:	0f b6       	in	r0, 0x3f	; 63
    32c4:	0f 92       	push	r0
    32c6:	11 24       	eor	r1, r1
    32c8:	08 b6       	in	r0, 0x38	; 56
    32ca:	0f 92       	push	r0
    32cc:	18 be       	out	0x38, r1	; 56
    32ce:	0b b6       	in	r0, 0x3b	; 59
    32d0:	0f 92       	push	r0
    32d2:	1b be       	out	0x3b, r1	; 59
    32d4:	2f 93       	push	r18
    32d6:	3f 93       	push	r19
    32d8:	8f 93       	push	r24
    32da:	9f 93       	push	r25
    32dc:	ef 93       	push	r30
    32de:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    32e0:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    32e4:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <rcvC1_buffer>
    32e8:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <rcvC1_buffer+0x1>
    32ec:	80 91 08 31 	lds	r24, 0x3108	; 0x803108 <rcvC1_write_index>
    32f0:	90 91 09 31 	lds	r25, 0x3109	; 0x803109 <rcvC1_write_index+0x1>
    32f4:	e8 0f       	add	r30, r24
    32f6:	f9 1f       	adc	r31, r25
    32f8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    32fa:	80 91 08 31 	lds	r24, 0x3108	; 0x803108 <rcvC1_write_index>
    32fe:	90 91 09 31 	lds	r25, 0x3109	; 0x803109 <rcvC1_write_index+0x1>
    3302:	01 96       	adiw	r24, 0x01	; 1
    3304:	84 36       	cpi	r24, 0x64	; 100
    3306:	91 05       	cpc	r25, r1
    3308:	60 f4       	brcc	.+24     	; 0x3322 <__vector_28+0x64>
    330a:	80 93 08 31 	sts	0x3108, r24	; 0x803108 <rcvC1_write_index>
    330e:	90 93 09 31 	sts	0x3109, r25	; 0x803109 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3312:	20 91 16 31 	lds	r18, 0x3116	; 0x803116 <rcvC1_read_index>
    3316:	30 91 17 31 	lds	r19, 0x3117	; 0x803117 <rcvC1_read_index+0x1>
    331a:	82 17       	cp	r24, r18
    331c:	93 07       	cpc	r25, r19
    331e:	f1 f4       	brne	.+60     	; 0x335c <__vector_28+0x9e>
    3320:	0c c0       	rjmp	.+24     	; 0x333a <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3322:	10 92 08 31 	sts	0x3108, r1	; 0x803108 <rcvC1_write_index>
    3326:	10 92 09 31 	sts	0x3109, r1	; 0x803109 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    332a:	80 91 16 31 	lds	r24, 0x3116	; 0x803116 <rcvC1_read_index>
    332e:	90 91 17 31 	lds	r25, 0x3117	; 0x803117 <rcvC1_read_index+0x1>
    3332:	18 16       	cp	r1, r24
    3334:	19 06       	cpc	r1, r25
    3336:	91 f4       	brne	.+36     	; 0x335c <__vector_28+0x9e>
    3338:	0e c0       	rjmp	.+28     	; 0x3356 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    333a:	01 96       	adiw	r24, 0x01	; 1
    333c:	84 36       	cpi	r24, 0x64	; 100
    333e:	91 05       	cpc	r25, r1
    3340:	28 f4       	brcc	.+10     	; 0x334c <__vector_28+0x8e>
    3342:	80 93 16 31 	sts	0x3116, r24	; 0x803116 <rcvC1_read_index>
    3346:	90 93 17 31 	sts	0x3117, r25	; 0x803117 <rcvC1_read_index+0x1>
    334a:	08 c0       	rjmp	.+16     	; 0x335c <__vector_28+0x9e>
	rcvC1_read_index = 0;
    334c:	10 92 16 31 	sts	0x3116, r1	; 0x803116 <rcvC1_read_index>
    3350:	10 92 17 31 	sts	0x3117, r1	; 0x803117 <rcvC1_read_index+0x1>
}
    3354:	03 c0       	rjmp	.+6      	; 0x335c <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3356:	81 e0       	ldi	r24, 0x01	; 1
    3358:	90 e0       	ldi	r25, 0x00	; 0
    335a:	f3 cf       	rjmp	.-26     	; 0x3342 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    335c:	ff 91       	pop	r31
    335e:	ef 91       	pop	r30
    3360:	9f 91       	pop	r25
    3362:	8f 91       	pop	r24
    3364:	3f 91       	pop	r19
    3366:	2f 91       	pop	r18
    3368:	0f 90       	pop	r0
    336a:	0b be       	out	0x3b, r0	; 59
    336c:	0f 90       	pop	r0
    336e:	08 be       	out	0x38, r0	; 56
    3370:	0f 90       	pop	r0
    3372:	0f be       	out	0x3f, r0	; 63
    3374:	0f 90       	pop	r0
    3376:	1f 90       	pop	r1
    3378:	18 95       	reti

0000337a <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    337a:	1f 92       	push	r1
    337c:	0f 92       	push	r0
    337e:	0f b6       	in	r0, 0x3f	; 63
    3380:	0f 92       	push	r0
    3382:	11 24       	eor	r1, r1
    3384:	08 b6       	in	r0, 0x38	; 56
    3386:	0f 92       	push	r0
    3388:	18 be       	out	0x38, r1	; 56
    338a:	0b b6       	in	r0, 0x3b	; 59
    338c:	0f 92       	push	r0
    338e:	1b be       	out	0x3b, r1	; 59
    3390:	2f 93       	push	r18
    3392:	3f 93       	push	r19
    3394:	8f 93       	push	r24
    3396:	9f 93       	push	r25
    3398:	ef 93       	push	r30
    339a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    339c:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    33a0:	e0 91 22 31 	lds	r30, 0x3122	; 0x803122 <rcvD0_buffer>
    33a4:	f0 91 23 31 	lds	r31, 0x3123	; 0x803123 <rcvD0_buffer+0x1>
    33a8:	80 91 0a 31 	lds	r24, 0x310A	; 0x80310a <rcvC0_write_index>
    33ac:	90 91 0b 31 	lds	r25, 0x310B	; 0x80310b <rcvC0_write_index+0x1>
    33b0:	e8 0f       	add	r30, r24
    33b2:	f9 1f       	adc	r31, r25
    33b4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    33b6:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <rcvD0_write_index>
    33ba:	90 91 07 31 	lds	r25, 0x3107	; 0x803107 <rcvD0_write_index+0x1>
    33be:	01 96       	adiw	r24, 0x01	; 1
    33c0:	84 36       	cpi	r24, 0x64	; 100
    33c2:	91 05       	cpc	r25, r1
    33c4:	60 f4       	brcc	.+24     	; 0x33de <__vector_88+0x64>
    33c6:	80 93 06 31 	sts	0x3106, r24	; 0x803106 <rcvD0_write_index>
    33ca:	90 93 07 31 	sts	0x3107, r25	; 0x803107 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    33ce:	20 91 14 31 	lds	r18, 0x3114	; 0x803114 <rcvD0_read_index>
    33d2:	30 91 15 31 	lds	r19, 0x3115	; 0x803115 <rcvD0_read_index+0x1>
    33d6:	82 17       	cp	r24, r18
    33d8:	93 07       	cpc	r25, r19
    33da:	f1 f4       	brne	.+60     	; 0x3418 <__vector_88+0x9e>
    33dc:	0c c0       	rjmp	.+24     	; 0x33f6 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    33de:	10 92 06 31 	sts	0x3106, r1	; 0x803106 <rcvD0_write_index>
    33e2:	10 92 07 31 	sts	0x3107, r1	; 0x803107 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    33e6:	80 91 14 31 	lds	r24, 0x3114	; 0x803114 <rcvD0_read_index>
    33ea:	90 91 15 31 	lds	r25, 0x3115	; 0x803115 <rcvD0_read_index+0x1>
    33ee:	18 16       	cp	r1, r24
    33f0:	19 06       	cpc	r1, r25
    33f2:	91 f4       	brne	.+36     	; 0x3418 <__vector_88+0x9e>
    33f4:	0e c0       	rjmp	.+28     	; 0x3412 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    33f6:	01 96       	adiw	r24, 0x01	; 1
    33f8:	84 36       	cpi	r24, 0x64	; 100
    33fa:	91 05       	cpc	r25, r1
    33fc:	28 f4       	brcc	.+10     	; 0x3408 <__vector_88+0x8e>
    33fe:	80 93 14 31 	sts	0x3114, r24	; 0x803114 <rcvD0_read_index>
    3402:	90 93 15 31 	sts	0x3115, r25	; 0x803115 <rcvD0_read_index+0x1>
    3406:	08 c0       	rjmp	.+16     	; 0x3418 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3408:	10 92 14 31 	sts	0x3114, r1	; 0x803114 <rcvD0_read_index>
    340c:	10 92 15 31 	sts	0x3115, r1	; 0x803115 <rcvD0_read_index+0x1>
}
    3410:	03 c0       	rjmp	.+6      	; 0x3418 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3412:	81 e0       	ldi	r24, 0x01	; 1
    3414:	90 e0       	ldi	r25, 0x00	; 0
    3416:	f3 cf       	rjmp	.-26     	; 0x33fe <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3418:	ff 91       	pop	r31
    341a:	ef 91       	pop	r30
    341c:	9f 91       	pop	r25
    341e:	8f 91       	pop	r24
    3420:	3f 91       	pop	r19
    3422:	2f 91       	pop	r18
    3424:	0f 90       	pop	r0
    3426:	0b be       	out	0x3b, r0	; 59
    3428:	0f 90       	pop	r0
    342a:	08 be       	out	0x38, r0	; 56
    342c:	0f 90       	pop	r0
    342e:	0f be       	out	0x3f, r0	; 63
    3430:	0f 90       	pop	r0
    3432:	1f 90       	pop	r1
    3434:	18 95       	reti

00003436 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3436:	1f 92       	push	r1
    3438:	0f 92       	push	r0
    343a:	0f b6       	in	r0, 0x3f	; 63
    343c:	0f 92       	push	r0
    343e:	11 24       	eor	r1, r1
    3440:	08 b6       	in	r0, 0x38	; 56
    3442:	0f 92       	push	r0
    3444:	18 be       	out	0x38, r1	; 56
    3446:	0b b6       	in	r0, 0x3b	; 59
    3448:	0f 92       	push	r0
    344a:	1b be       	out	0x3b, r1	; 59
    344c:	2f 93       	push	r18
    344e:	3f 93       	push	r19
    3450:	8f 93       	push	r24
    3452:	9f 93       	push	r25
    3454:	ef 93       	push	r30
    3456:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3458:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    345c:	e0 91 20 31 	lds	r30, 0x3120	; 0x803120 <rcvD1_buffer>
    3460:	f0 91 21 31 	lds	r31, 0x3121	; 0x803121 <rcvD1_buffer+0x1>
    3464:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <rcvD1_write_index>
    3468:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <rcvD1_write_index+0x1>
    346c:	e8 0f       	add	r30, r24
    346e:	f9 1f       	adc	r31, r25
    3470:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3472:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <rcvD1_write_index>
    3476:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <rcvD1_write_index+0x1>
    347a:	01 96       	adiw	r24, 0x01	; 1
    347c:	84 36       	cpi	r24, 0x64	; 100
    347e:	91 05       	cpc	r25, r1
    3480:	60 f4       	brcc	.+24     	; 0x349a <__vector_91+0x64>
    3482:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <rcvD1_write_index>
    3486:	90 93 05 31 	sts	0x3105, r25	; 0x803105 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    348a:	20 91 12 31 	lds	r18, 0x3112	; 0x803112 <rcvD1_read_index>
    348e:	30 91 13 31 	lds	r19, 0x3113	; 0x803113 <rcvD1_read_index+0x1>
    3492:	82 17       	cp	r24, r18
    3494:	93 07       	cpc	r25, r19
    3496:	f1 f4       	brne	.+60     	; 0x34d4 <__vector_91+0x9e>
    3498:	0c c0       	rjmp	.+24     	; 0x34b2 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    349a:	10 92 04 31 	sts	0x3104, r1	; 0x803104 <rcvD1_write_index>
    349e:	10 92 05 31 	sts	0x3105, r1	; 0x803105 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    34a2:	80 91 12 31 	lds	r24, 0x3112	; 0x803112 <rcvD1_read_index>
    34a6:	90 91 13 31 	lds	r25, 0x3113	; 0x803113 <rcvD1_read_index+0x1>
    34aa:	18 16       	cp	r1, r24
    34ac:	19 06       	cpc	r1, r25
    34ae:	91 f4       	brne	.+36     	; 0x34d4 <__vector_91+0x9e>
    34b0:	0e c0       	rjmp	.+28     	; 0x34ce <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    34b2:	01 96       	adiw	r24, 0x01	; 1
    34b4:	84 36       	cpi	r24, 0x64	; 100
    34b6:	91 05       	cpc	r25, r1
    34b8:	28 f4       	brcc	.+10     	; 0x34c4 <__vector_91+0x8e>
    34ba:	80 93 12 31 	sts	0x3112, r24	; 0x803112 <rcvD1_read_index>
    34be:	90 93 13 31 	sts	0x3113, r25	; 0x803113 <rcvD1_read_index+0x1>
    34c2:	08 c0       	rjmp	.+16     	; 0x34d4 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    34c4:	10 92 12 31 	sts	0x3112, r1	; 0x803112 <rcvD1_read_index>
    34c8:	10 92 13 31 	sts	0x3113, r1	; 0x803113 <rcvD1_read_index+0x1>
}
    34cc:	03 c0       	rjmp	.+6      	; 0x34d4 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    34ce:	81 e0       	ldi	r24, 0x01	; 1
    34d0:	90 e0       	ldi	r25, 0x00	; 0
    34d2:	f3 cf       	rjmp	.-26     	; 0x34ba <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    34d4:	ff 91       	pop	r31
    34d6:	ef 91       	pop	r30
    34d8:	9f 91       	pop	r25
    34da:	8f 91       	pop	r24
    34dc:	3f 91       	pop	r19
    34de:	2f 91       	pop	r18
    34e0:	0f 90       	pop	r0
    34e2:	0b be       	out	0x3b, r0	; 59
    34e4:	0f 90       	pop	r0
    34e6:	08 be       	out	0x38, r0	; 56
    34e8:	0f 90       	pop	r0
    34ea:	0f be       	out	0x3f, r0	; 63
    34ec:	0f 90       	pop	r0
    34ee:	1f 90       	pop	r1
    34f0:	18 95       	reti

000034f2 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    34f2:	1f 92       	push	r1
    34f4:	0f 92       	push	r0
    34f6:	0f b6       	in	r0, 0x3f	; 63
    34f8:	0f 92       	push	r0
    34fa:	11 24       	eor	r1, r1
    34fc:	08 b6       	in	r0, 0x38	; 56
    34fe:	0f 92       	push	r0
    3500:	18 be       	out	0x38, r1	; 56
    3502:	0b b6       	in	r0, 0x3b	; 59
    3504:	0f 92       	push	r0
    3506:	1b be       	out	0x3b, r1	; 59
    3508:	2f 93       	push	r18
    350a:	3f 93       	push	r19
    350c:	8f 93       	push	r24
    350e:	9f 93       	push	r25
    3510:	ef 93       	push	r30
    3512:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3514:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3518:	e0 91 1e 31 	lds	r30, 0x311E	; 0x80311e <rcvE0_buffer>
    351c:	f0 91 1f 31 	lds	r31, 0x311F	; 0x80311f <rcvE0_buffer+0x1>
    3520:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <rcvE0_write_index>
    3524:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <rcvE0_write_index+0x1>
    3528:	e8 0f       	add	r30, r24
    352a:	f9 1f       	adc	r31, r25
    352c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    352e:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <rcvE0_write_index>
    3532:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <rcvE0_write_index+0x1>
    3536:	01 96       	adiw	r24, 0x01	; 1
    3538:	84 36       	cpi	r24, 0x64	; 100
    353a:	91 05       	cpc	r25, r1
    353c:	60 f4       	brcc	.+24     	; 0x3556 <__vector_58+0x64>
    353e:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <rcvE0_write_index>
    3542:	90 93 03 31 	sts	0x3103, r25	; 0x803103 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3546:	20 91 10 31 	lds	r18, 0x3110	; 0x803110 <rcvE0_read_index>
    354a:	30 91 11 31 	lds	r19, 0x3111	; 0x803111 <rcvE0_read_index+0x1>
    354e:	82 17       	cp	r24, r18
    3550:	93 07       	cpc	r25, r19
    3552:	f1 f4       	brne	.+60     	; 0x3590 <__vector_58+0x9e>
    3554:	0c c0       	rjmp	.+24     	; 0x356e <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3556:	10 92 02 31 	sts	0x3102, r1	; 0x803102 <rcvE0_write_index>
    355a:	10 92 03 31 	sts	0x3103, r1	; 0x803103 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    355e:	80 91 10 31 	lds	r24, 0x3110	; 0x803110 <rcvE0_read_index>
    3562:	90 91 11 31 	lds	r25, 0x3111	; 0x803111 <rcvE0_read_index+0x1>
    3566:	18 16       	cp	r1, r24
    3568:	19 06       	cpc	r1, r25
    356a:	91 f4       	brne	.+36     	; 0x3590 <__vector_58+0x9e>
    356c:	0e c0       	rjmp	.+28     	; 0x358a <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    356e:	01 96       	adiw	r24, 0x01	; 1
    3570:	84 36       	cpi	r24, 0x64	; 100
    3572:	91 05       	cpc	r25, r1
    3574:	28 f4       	brcc	.+10     	; 0x3580 <__vector_58+0x8e>
    3576:	80 93 10 31 	sts	0x3110, r24	; 0x803110 <rcvE0_read_index>
    357a:	90 93 11 31 	sts	0x3111, r25	; 0x803111 <rcvE0_read_index+0x1>
    357e:	08 c0       	rjmp	.+16     	; 0x3590 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3580:	10 92 10 31 	sts	0x3110, r1	; 0x803110 <rcvE0_read_index>
    3584:	10 92 11 31 	sts	0x3111, r1	; 0x803111 <rcvE0_read_index+0x1>
}
    3588:	03 c0       	rjmp	.+6      	; 0x3590 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    358a:	81 e0       	ldi	r24, 0x01	; 1
    358c:	90 e0       	ldi	r25, 0x00	; 0
    358e:	f3 cf       	rjmp	.-26     	; 0x3576 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3590:	ff 91       	pop	r31
    3592:	ef 91       	pop	r30
    3594:	9f 91       	pop	r25
    3596:	8f 91       	pop	r24
    3598:	3f 91       	pop	r19
    359a:	2f 91       	pop	r18
    359c:	0f 90       	pop	r0
    359e:	0b be       	out	0x3b, r0	; 59
    35a0:	0f 90       	pop	r0
    35a2:	08 be       	out	0x38, r0	; 56
    35a4:	0f 90       	pop	r0
    35a6:	0f be       	out	0x3f, r0	; 63
    35a8:	0f 90       	pop	r0
    35aa:	1f 90       	pop	r1
    35ac:	18 95       	reti

000035ae <__vector_61>:
#endif

#ifdef USARTE1_RXC_vect
ISR (USARTE1_RXC_vect)
{
    35ae:	1f 92       	push	r1
    35b0:	0f 92       	push	r0
    35b2:	0f b6       	in	r0, 0x3f	; 63
    35b4:	0f 92       	push	r0
    35b6:	11 24       	eor	r1, r1
    35b8:	08 b6       	in	r0, 0x38	; 56
    35ba:	0f 92       	push	r0
    35bc:	18 be       	out	0x38, r1	; 56
    35be:	0b b6       	in	r0, 0x3b	; 59
    35c0:	0f 92       	push	r0
    35c2:	1b be       	out	0x3b, r1	; 59
    35c4:	2f 93       	push	r18
    35c6:	3f 93       	push	r19
    35c8:	8f 93       	push	r24
    35ca:	9f 93       	push	r25
    35cc:	ef 93       	push	r30
    35ce:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;
    35d0:	20 91 b0 0a 	lds	r18, 0x0AB0	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x700ab0>
    35d4:	e0 91 1c 31 	lds	r30, 0x311C	; 0x80311c <rcvE1_buffer>
    35d8:	f0 91 1d 31 	lds	r31, 0x311D	; 0x80311d <rcvE1_buffer+0x1>
    35dc:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <rcvE1_write_index>
    35e0:	90 91 01 31 	lds	r25, 0x3101	; 0x803101 <rcvE1_write_index+0x1>
    35e4:	e8 0f       	add	r30, r24
    35e6:	f9 1f       	adc	r31, r25
    35e8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
    35ea:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <rcvE1_write_index>
    35ee:	90 91 01 31 	lds	r25, 0x3101	; 0x803101 <rcvE1_write_index+0x1>
    35f2:	01 96       	adiw	r24, 0x01	; 1
    35f4:	84 36       	cpi	r24, 0x64	; 100
    35f6:	91 05       	cpc	r25, r1
    35f8:	60 f4       	brcc	.+24     	; 0x3612 <__vector_61+0x64>
    35fa:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <rcvE1_write_index>
    35fe:	90 93 01 31 	sts	0x3101, r25	; 0x803101 <rcvE1_write_index+0x1>
	rcvE1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    3602:	20 91 0e 31 	lds	r18, 0x310E	; 0x80310e <rcvE1_read_index>
    3606:	30 91 0f 31 	lds	r19, 0x310F	; 0x80310f <rcvE1_read_index+0x1>
    360a:	82 17       	cp	r24, r18
    360c:	93 07       	cpc	r25, r19
    360e:	f1 f4       	brne	.+60     	; 0x364c <__vector_61+0x9e>
    3610:	0c c0       	rjmp	.+24     	; 0x362a <__vector_61+0x7c>

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
	rcvE1_write_index = 0;
    3612:	10 92 00 31 	sts	0x3100, r1	; 0x803100 <rcvE1_write_index>
    3616:	10 92 01 31 	sts	0x3101, r1	; 0x803101 <rcvE1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    361a:	80 91 0e 31 	lds	r24, 0x310E	; 0x80310e <rcvE1_read_index>
    361e:	90 91 0f 31 	lds	r25, 0x310F	; 0x80310f <rcvE1_read_index+0x1>
    3622:	18 16       	cp	r1, r24
    3624:	19 06       	cpc	r1, r25
    3626:	91 f4       	brne	.+36     	; 0x364c <__vector_61+0x9e>
    3628:	0e c0       	rjmp	.+28     	; 0x3646 <__vector_61+0x98>
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    362a:	01 96       	adiw	r24, 0x01	; 1
    362c:	84 36       	cpi	r24, 0x64	; 100
    362e:	91 05       	cpc	r25, r1
    3630:	28 f4       	brcc	.+10     	; 0x363c <__vector_61+0x8e>
    3632:	80 93 0e 31 	sts	0x310E, r24	; 0x80310e <rcvE1_read_index>
    3636:	90 93 0f 31 	sts	0x310F, r25	; 0x80310f <rcvE1_read_index+0x1>
    363a:	08 c0       	rjmp	.+16     	; 0x364c <__vector_61+0x9e>
	rcvE1_read_index = 0;
    363c:	10 92 0e 31 	sts	0x310E, r1	; 0x80310e <rcvE1_read_index>
    3640:	10 92 0f 31 	sts	0x310F, r1	; 0x80310f <rcvE1_read_index+0x1>
}
    3644:	03 c0       	rjmp	.+6      	; 0x364c <__vector_61+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3646:	81 e0       	ldi	r24, 0x01	; 1
    3648:	90 e0       	ldi	r25, 0x00	; 0
    364a:	f3 cf       	rjmp	.-26     	; 0x3632 <__vector_61+0x84>
	rcvE1_read_index = 0;
}
    364c:	ff 91       	pop	r31
    364e:	ef 91       	pop	r30
    3650:	9f 91       	pop	r25
    3652:	8f 91       	pop	r24
    3654:	3f 91       	pop	r19
    3656:	2f 91       	pop	r18
    3658:	0f 90       	pop	r0
    365a:	0b be       	out	0x3b, r0	; 59
    365c:	0f 90       	pop	r0
    365e:	08 be       	out	0x38, r0	; 56
    3660:	0f 90       	pop	r0
    3662:	0f be       	out	0x3f, r0	; 63
    3664:	0f 90       	pop	r0
    3666:	1f 90       	pop	r1
    3668:	18 95       	reti

0000366a <__vector_119>:
#endif

#ifdef USARTF0_RXC_vect
ISR (USARTF0_RXC_vect)
{
    366a:	1f 92       	push	r1
    366c:	0f 92       	push	r0
    366e:	0f b6       	in	r0, 0x3f	; 63
    3670:	0f 92       	push	r0
    3672:	11 24       	eor	r1, r1
    3674:	08 b6       	in	r0, 0x38	; 56
    3676:	0f 92       	push	r0
    3678:	18 be       	out	0x38, r1	; 56
    367a:	0b b6       	in	r0, 0x3b	; 59
    367c:	0f 92       	push	r0
    367e:	1b be       	out	0x3b, r1	; 59
    3680:	2f 93       	push	r18
    3682:	3f 93       	push	r19
    3684:	8f 93       	push	r24
    3686:	9f 93       	push	r25
    3688:	ef 93       	push	r30
    368a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;
    368c:	20 91 a0 0b 	lds	r18, 0x0BA0	; 0x800ba0 <__TEXT_REGION_LENGTH__+0x700ba0>
    3690:	e0 91 1a 31 	lds	r30, 0x311A	; 0x80311a <rcvF0_buffer>
    3694:	f0 91 1b 31 	lds	r31, 0x311B	; 0x80311b <rcvF0_buffer+0x1>
    3698:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <rcvF0_write_index>
    369c:	90 91 ff 30 	lds	r25, 0x30FF	; 0x8030ff <rcvF0_write_index+0x1>
    36a0:	e8 0f       	add	r30, r24
    36a2:	f9 1f       	adc	r31, r25
    36a4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
    36a6:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <rcvF0_write_index>
    36aa:	90 91 ff 30 	lds	r25, 0x30FF	; 0x8030ff <rcvF0_write_index+0x1>
    36ae:	01 96       	adiw	r24, 0x01	; 1
    36b0:	84 36       	cpi	r24, 0x64	; 100
    36b2:	91 05       	cpc	r25, r1
    36b4:	60 f4       	brcc	.+24     	; 0x36ce <__vector_119+0x64>
    36b6:	80 93 fe 30 	sts	0x30FE, r24	; 0x8030fe <rcvF0_write_index>
    36ba:	90 93 ff 30 	sts	0x30FF, r25	; 0x8030ff <rcvF0_write_index+0x1>
	rcvF0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    36be:	20 91 0c 31 	lds	r18, 0x310C	; 0x80310c <rcvF0_read_index>
    36c2:	30 91 0d 31 	lds	r19, 0x310D	; 0x80310d <rcvF0_read_index+0x1>
    36c6:	82 17       	cp	r24, r18
    36c8:	93 07       	cpc	r25, r19
    36ca:	f1 f4       	brne	.+60     	; 0x3708 <__vector_119+0x9e>
    36cc:	0c c0       	rjmp	.+24     	; 0x36e6 <__vector_119+0x7c>

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
	rcvF0_write_index = 0;
    36ce:	10 92 fe 30 	sts	0x30FE, r1	; 0x8030fe <rcvF0_write_index>
    36d2:	10 92 ff 30 	sts	0x30FF, r1	; 0x8030ff <rcvF0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    36d6:	80 91 0c 31 	lds	r24, 0x310C	; 0x80310c <rcvF0_read_index>
    36da:	90 91 0d 31 	lds	r25, 0x310D	; 0x80310d <rcvF0_read_index+0x1>
    36de:	18 16       	cp	r1, r24
    36e0:	19 06       	cpc	r1, r25
    36e2:	91 f4       	brne	.+36     	; 0x3708 <__vector_119+0x9e>
    36e4:	0e c0       	rjmp	.+28     	; 0x3702 <__vector_119+0x98>
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    36e6:	01 96       	adiw	r24, 0x01	; 1
    36e8:	84 36       	cpi	r24, 0x64	; 100
    36ea:	91 05       	cpc	r25, r1
    36ec:	28 f4       	brcc	.+10     	; 0x36f8 <__vector_119+0x8e>
    36ee:	80 93 0c 31 	sts	0x310C, r24	; 0x80310c <rcvF0_read_index>
    36f2:	90 93 0d 31 	sts	0x310D, r25	; 0x80310d <rcvF0_read_index+0x1>
    36f6:	08 c0       	rjmp	.+16     	; 0x3708 <__vector_119+0x9e>
	rcvF0_read_index = 0;
    36f8:	10 92 0c 31 	sts	0x310C, r1	; 0x80310c <rcvF0_read_index>
    36fc:	10 92 0d 31 	sts	0x310D, r1	; 0x80310d <rcvF0_read_index+0x1>
}
    3700:	03 c0       	rjmp	.+6      	; 0x3708 <__vector_119+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3702:	81 e0       	ldi	r24, 0x01	; 1
    3704:	90 e0       	ldi	r25, 0x00	; 0
    3706:	f3 cf       	rjmp	.-26     	; 0x36ee <__vector_119+0x84>
	rcvF0_read_index = 0;
}
    3708:	ff 91       	pop	r31
    370a:	ef 91       	pop	r30
    370c:	9f 91       	pop	r25
    370e:	8f 91       	pop	r24
    3710:	3f 91       	pop	r19
    3712:	2f 91       	pop	r18
    3714:	0f 90       	pop	r0
    3716:	0b be       	out	0x3b, r0	; 59
    3718:	0f 90       	pop	r0
    371a:	08 be       	out	0x38, r0	; 56
    371c:	0f 90       	pop	r0
    371e:	0f be       	out	0x3f, r0	; 63
    3720:	0f 90       	pop	r0
    3722:	1f 90       	pop	r1
    3724:	18 95       	reti

00003726 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3726:	0f 93       	push	r16
    3728:	cf 93       	push	r28
    372a:	df 93       	push	r29
    372c:	1f 92       	push	r1
    372e:	cd b7       	in	r28, 0x3d	; 61
    3730:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3732:	2f b7       	in	r18, 0x3f	; 63
    3734:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3736:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3738:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    373a:	fc 01       	movw	r30, r24
    373c:	08 ed       	ldi	r16, 0xD8	; 216
    373e:	04 bf       	out	0x34, r16	; 52
    3740:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3742:	89 81       	ldd	r24, Y+1	; 0x01
    3744:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3746:	0f 90       	pop	r0
    3748:	df 91       	pop	r29
    374a:	cf 91       	pop	r28
    374c:	0f 91       	pop	r16
    374e:	08 95       	ret

00003750 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3750:	0f 93       	push	r16
    3752:	1f 93       	push	r17
    3754:	cf 93       	push	r28
    3756:	df 93       	push	r29
    3758:	cd b7       	in	r28, 0x3d	; 61
    375a:	de b7       	in	r29, 0x3e	; 62
    375c:	6d 97       	sbiw	r28, 0x1d	; 29
    375e:	cd bf       	out	0x3d, r28	; 61
    3760:	de bf       	out	0x3e, r29	; 62
	//Clear any interrupts
	cli();
    3762:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator  <-----------------------MAY NEED TO CHANGE FOR 16MHz 
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3764:	e0 e5       	ldi	r30, 0x50	; 80
    3766:	f0 e0       	ldi	r31, 0x00	; 0
    3768:	80 81       	ld	r24, Z
    376a:	82 60       	ori	r24, 0x02	; 2
    376c:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    376e:	81 81       	ldd	r24, Z+1	; 0x01
    3770:	81 ff       	sbrs	r24, 1
    3772:	fd cf       	rjmp	.-6      	; 0x376e <main+0x1e>

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3774:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3778:	68 7f       	andi	r22, 0xF8	; 248
    377a:	61 60       	ori	r22, 0x01	; 1
    377c:	80 e4       	ldi	r24, 0x40	; 64
    377e:	90 e0       	ldi	r25, 0x00	; 0
    3780:	0e 94 93 1b 	call	0x3726	; 0x3726 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3784:	e0 e5       	ldi	r30, 0x50	; 80
    3786:	f0 e0       	ldi	r31, 0x00	; 0
    3788:	80 81       	ld	r24, Z
    378a:	8e 7f       	andi	r24, 0xFE	; 254
    378c:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    378e:	9d ef       	ldi	r25, 0xFD	; 253
    3790:	88 ed       	ldi	r24, 0xD8	; 216
    3792:	08 b6       	in	r0, 0x38	; 56
    3794:	18 be       	out	0x38, r1	; 56
    3796:	84 bf       	out	0x34, r24	; 52
    3798:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    379c:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC0); // Create a serial device on USART E0 with always baud = 115200
    379e:	40 ea       	ldi	r20, 0xA0	; 160
    37a0:	58 e0       	ldi	r21, 0x08	; 8
    37a2:	60 e0       	ldi	r22, 0x00	; 0
    37a4:	70 e0       	ldi	r23, 0x00	; 0
    37a6:	ce 01       	movw	r24, r28
    37a8:	01 96       	adiw	r24, 0x01	; 1
    37aa:	0e 94 5f 18 	call	0x30be	; 0x30be <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    37ae:	67 e0       	ldi	r22, 0x07	; 7
    37b0:	ce 01       	movw	r24, r28
    37b2:	01 96       	adiw	r24, 0x01	; 1
    37b4:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    37b8:	8c 01       	movw	r16, r24
    37ba:	6b e5       	ldi	r22, 0x5B	; 91
    37bc:	70 e2       	ldi	r23, 0x20	; 32
    37be:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8emstream4putsEPKc>
    37c2:	66 e0       	ldi	r22, 0x06	; 6
    37c4:	c8 01       	movw	r24, r16
    37c6:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
    37ca:	66 e0       	ldi	r22, 0x06	; 6
    37cc:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    37d0:	82 e1       	ldi	r24, 0x12	; 18
    37d2:	90 e0       	ldi	r25, 0x00	; 0
    37d4:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <_Znwj>
    37d8:	8e 01       	movw	r16, r28
    37da:	0f 5f       	subi	r16, 0xFF	; 255
    37dc:	1f 4f       	sbci	r17, 0xFF	; 255
    37de:	24 e0       	ldi	r18, 0x04	; 4
    37e0:	31 e0       	ldi	r19, 0x01	; 1
    37e2:	40 e0       	ldi	r20, 0x00	; 0
    37e4:	6a e7       	ldi	r22, 0x7A	; 122
    37e6:	70 e2       	ldi	r23, 0x20	; 32
    37e8:	0e 94 76 03 	call	0x6ec	; 0x6ec <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(1), 260, &ser_dev);
    37ec:	82 e1       	ldi	r24, 0x12	; 18
    37ee:	90 e0       	ldi	r25, 0x00	; 0
    37f0:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <_Znwj>
    37f4:	24 e0       	ldi	r18, 0x04	; 4
    37f6:	31 e0       	ldi	r19, 0x01	; 1
    37f8:	41 e0       	ldi	r20, 0x01	; 1
    37fa:	62 e8       	ldi	r22, 0x82	; 130
    37fc:	70 e2       	ldi	r23, 0x20	; 32
    37fe:	0e 94 34 03 	call	0x668	; 0x668 <_ZN12EncoderMotorC1EPKchjP8emstream>
	
	// The LimitSwitches Task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(2), 260, &ser_dev);
    3802:	82 e1       	ldi	r24, 0x12	; 18
    3804:	90 e0       	ldi	r25, 0x00	; 0
    3806:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <_Znwj>
    380a:	24 e0       	ldi	r18, 0x04	; 4
    380c:	31 e0       	ldi	r19, 0x01	; 1
    380e:	42 e0       	ldi	r20, 0x02	; 2
    3810:	69 e8       	ldi	r22, 0x89	; 137
    3812:	70 e2       	ldi	r23, 0x20	; 32
    3814:	0e 94 66 03 	call	0x6cc	; 0x6cc <_ZN13LimitSwitchesC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3818:	87 e0       	ldi	r24, 0x07	; 7
    381a:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    381e:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3820:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vTaskStartScheduler>
	
	return 0;
    3824:	80 e0       	ldi	r24, 0x00	; 0
    3826:	90 e0       	ldi	r25, 0x00	; 0
    3828:	6d 96       	adiw	r28, 0x1d	; 29
    382a:	cd bf       	out	0x3d, r28	; 61
    382c:	de bf       	out	0x3e, r29	; 62
    382e:	df 91       	pop	r29
    3830:	cf 91       	pop	r28
    3832:	1f 91       	pop	r17
    3834:	0f 91       	pop	r16
    3836:	08 95       	ret

00003838 <_GLOBAL__sub_I_counter>:
    3838:	0f 93       	push	r16
    383a:	1f 93       	push	r17
#include "EncoderMotor.h"					// Header for Encoder of Motor
#include "LimitSwitches.h"					// Header for Limit Switches
//#include "util/delay.h"					// Header for delay

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    383c:	0a e0       	ldi	r16, 0x0A	; 10
    383e:	10 e0       	ldi	r17, 0x00	; 0
    3840:	20 e0       	ldi	r18, 0x00	; 0
    3842:	30 e0       	ldi	r19, 0x00	; 0
    3844:	40 e0       	ldi	r20, 0x00	; 0
    3846:	50 e0       	ldi	r21, 0x00	; 0
    3848:	60 e2       	ldi	r22, 0x20	; 32
    384a:	70 e0       	ldi	r23, 0x00	; 0
    384c:	8a e2       	ldi	r24, 0x2A	; 42
    384e:	91 e3       	ldi	r25, 0x31	; 49
    3850:	0e 94 23 14 	call	0x2846	; 0x2846 <_ZN14frt_text_queueC1EjP8emstreamm>
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	return 0;
    3854:	1f 91       	pop	r17
    3856:	0f 91       	pop	r16
    3858:	08 95       	ret

0000385a <__mulsi3>:
    385a:	db 01       	movw	r26, r22
    385c:	8f 93       	push	r24
    385e:	9f 93       	push	r25
    3860:	0e 94 9b 1c 	call	0x3936	; 0x3936 <__muluhisi3>
    3864:	bf 91       	pop	r27
    3866:	af 91       	pop	r26
    3868:	a2 9f       	mul	r26, r18
    386a:	80 0d       	add	r24, r0
    386c:	91 1d       	adc	r25, r1
    386e:	a3 9f       	mul	r26, r19
    3870:	90 0d       	add	r25, r0
    3872:	b2 9f       	mul	r27, r18
    3874:	90 0d       	add	r25, r0
    3876:	11 24       	eor	r1, r1
    3878:	08 95       	ret

0000387a <__divmodhi4>:
    387a:	97 fb       	bst	r25, 7
    387c:	07 2e       	mov	r0, r23
    387e:	16 f4       	brtc	.+4      	; 0x3884 <__divmodhi4+0xa>
    3880:	00 94       	com	r0
    3882:	07 d0       	rcall	.+14     	; 0x3892 <__divmodhi4_neg1>
    3884:	77 fd       	sbrc	r23, 7
    3886:	09 d0       	rcall	.+18     	; 0x389a <__divmodhi4_neg2>
    3888:	0e 94 a6 1c 	call	0x394c	; 0x394c <__udivmodhi4>
    388c:	07 fc       	sbrc	r0, 7
    388e:	05 d0       	rcall	.+10     	; 0x389a <__divmodhi4_neg2>
    3890:	3e f4       	brtc	.+14     	; 0x38a0 <__divmodhi4_exit>

00003892 <__divmodhi4_neg1>:
    3892:	90 95       	com	r25
    3894:	81 95       	neg	r24
    3896:	9f 4f       	sbci	r25, 0xFF	; 255
    3898:	08 95       	ret

0000389a <__divmodhi4_neg2>:
    389a:	70 95       	com	r23
    389c:	61 95       	neg	r22
    389e:	7f 4f       	sbci	r23, 0xFF	; 255

000038a0 <__divmodhi4_exit>:
    38a0:	08 95       	ret

000038a2 <__udivmodsi4>:
    38a2:	a1 e2       	ldi	r26, 0x21	; 33
    38a4:	1a 2e       	mov	r1, r26
    38a6:	aa 1b       	sub	r26, r26
    38a8:	bb 1b       	sub	r27, r27
    38aa:	fd 01       	movw	r30, r26
    38ac:	0d c0       	rjmp	.+26     	; 0x38c8 <__udivmodsi4_ep>

000038ae <__udivmodsi4_loop>:
    38ae:	aa 1f       	adc	r26, r26
    38b0:	bb 1f       	adc	r27, r27
    38b2:	ee 1f       	adc	r30, r30
    38b4:	ff 1f       	adc	r31, r31
    38b6:	a2 17       	cp	r26, r18
    38b8:	b3 07       	cpc	r27, r19
    38ba:	e4 07       	cpc	r30, r20
    38bc:	f5 07       	cpc	r31, r21
    38be:	20 f0       	brcs	.+8      	; 0x38c8 <__udivmodsi4_ep>
    38c0:	a2 1b       	sub	r26, r18
    38c2:	b3 0b       	sbc	r27, r19
    38c4:	e4 0b       	sbc	r30, r20
    38c6:	f5 0b       	sbc	r31, r21

000038c8 <__udivmodsi4_ep>:
    38c8:	66 1f       	adc	r22, r22
    38ca:	77 1f       	adc	r23, r23
    38cc:	88 1f       	adc	r24, r24
    38ce:	99 1f       	adc	r25, r25
    38d0:	1a 94       	dec	r1
    38d2:	69 f7       	brne	.-38     	; 0x38ae <__udivmodsi4_loop>
    38d4:	60 95       	com	r22
    38d6:	70 95       	com	r23
    38d8:	80 95       	com	r24
    38da:	90 95       	com	r25
    38dc:	9b 01       	movw	r18, r22
    38de:	ac 01       	movw	r20, r24
    38e0:	bd 01       	movw	r22, r26
    38e2:	cf 01       	movw	r24, r30
    38e4:	08 95       	ret

000038e6 <__divmodsi4>:
    38e6:	05 2e       	mov	r0, r21
    38e8:	97 fb       	bst	r25, 7
    38ea:	1e f4       	brtc	.+6      	; 0x38f2 <__divmodsi4+0xc>
    38ec:	00 94       	com	r0
    38ee:	0e 94 8a 1c 	call	0x3914	; 0x3914 <__negsi2>
    38f2:	57 fd       	sbrc	r21, 7
    38f4:	07 d0       	rcall	.+14     	; 0x3904 <__divmodsi4_neg2>
    38f6:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <__udivmodsi4>
    38fa:	07 fc       	sbrc	r0, 7
    38fc:	03 d0       	rcall	.+6      	; 0x3904 <__divmodsi4_neg2>
    38fe:	4e f4       	brtc	.+18     	; 0x3912 <__divmodsi4_exit>
    3900:	0c 94 8a 1c 	jmp	0x3914	; 0x3914 <__negsi2>

00003904 <__divmodsi4_neg2>:
    3904:	50 95       	com	r21
    3906:	40 95       	com	r20
    3908:	30 95       	com	r19
    390a:	21 95       	neg	r18
    390c:	3f 4f       	sbci	r19, 0xFF	; 255
    390e:	4f 4f       	sbci	r20, 0xFF	; 255
    3910:	5f 4f       	sbci	r21, 0xFF	; 255

00003912 <__divmodsi4_exit>:
    3912:	08 95       	ret

00003914 <__negsi2>:
    3914:	90 95       	com	r25
    3916:	80 95       	com	r24
    3918:	70 95       	com	r23
    391a:	61 95       	neg	r22
    391c:	7f 4f       	sbci	r23, 0xFF	; 255
    391e:	8f 4f       	sbci	r24, 0xFF	; 255
    3920:	9f 4f       	sbci	r25, 0xFF	; 255
    3922:	08 95       	ret

00003924 <__tablejump2__>:
    3924:	ee 0f       	add	r30, r30
    3926:	ff 1f       	adc	r31, r31
    3928:	88 1f       	adc	r24, r24
    392a:	8b bf       	out	0x3b, r24	; 59
    392c:	07 90       	elpm	r0, Z+
    392e:	f6 91       	elpm	r31, Z
    3930:	e0 2d       	mov	r30, r0
    3932:	1b be       	out	0x3b, r1	; 59
    3934:	19 94       	eijmp

00003936 <__muluhisi3>:
    3936:	0e 94 ba 1c 	call	0x3974	; 0x3974 <__umulhisi3>
    393a:	a5 9f       	mul	r26, r21
    393c:	90 0d       	add	r25, r0
    393e:	b4 9f       	mul	r27, r20
    3940:	90 0d       	add	r25, r0
    3942:	a4 9f       	mul	r26, r20
    3944:	80 0d       	add	r24, r0
    3946:	91 1d       	adc	r25, r1
    3948:	11 24       	eor	r1, r1
    394a:	08 95       	ret

0000394c <__udivmodhi4>:
    394c:	aa 1b       	sub	r26, r26
    394e:	bb 1b       	sub	r27, r27
    3950:	51 e1       	ldi	r21, 0x11	; 17
    3952:	07 c0       	rjmp	.+14     	; 0x3962 <__udivmodhi4_ep>

00003954 <__udivmodhi4_loop>:
    3954:	aa 1f       	adc	r26, r26
    3956:	bb 1f       	adc	r27, r27
    3958:	a6 17       	cp	r26, r22
    395a:	b7 07       	cpc	r27, r23
    395c:	10 f0       	brcs	.+4      	; 0x3962 <__udivmodhi4_ep>
    395e:	a6 1b       	sub	r26, r22
    3960:	b7 0b       	sbc	r27, r23

00003962 <__udivmodhi4_ep>:
    3962:	88 1f       	adc	r24, r24
    3964:	99 1f       	adc	r25, r25
    3966:	5a 95       	dec	r21
    3968:	a9 f7       	brne	.-22     	; 0x3954 <__udivmodhi4_loop>
    396a:	80 95       	com	r24
    396c:	90 95       	com	r25
    396e:	bc 01       	movw	r22, r24
    3970:	cd 01       	movw	r24, r26
    3972:	08 95       	ret

00003974 <__umulhisi3>:
    3974:	a2 9f       	mul	r26, r18
    3976:	b0 01       	movw	r22, r0
    3978:	b3 9f       	mul	r27, r19
    397a:	c0 01       	movw	r24, r0
    397c:	a3 9f       	mul	r26, r19
    397e:	70 0d       	add	r23, r0
    3980:	81 1d       	adc	r24, r1
    3982:	11 24       	eor	r1, r1
    3984:	91 1d       	adc	r25, r1
    3986:	b2 9f       	mul	r27, r18
    3988:	70 0d       	add	r23, r0
    398a:	81 1d       	adc	r24, r1
    398c:	11 24       	eor	r1, r1
    398e:	91 1d       	adc	r25, r1
    3990:	08 95       	ret

00003992 <memcpy>:
    3992:	fb 01       	movw	r30, r22
    3994:	dc 01       	movw	r26, r24
    3996:	02 c0       	rjmp	.+4      	; 0x399c <memcpy+0xa>
    3998:	01 90       	ld	r0, Z+
    399a:	0d 92       	st	X+, r0
    399c:	41 50       	subi	r20, 0x01	; 1
    399e:	50 40       	sbci	r21, 0x00	; 0
    39a0:	d8 f7       	brcc	.-10     	; 0x3998 <memcpy+0x6>
    39a2:	08 95       	ret

000039a4 <memset>:
    39a4:	dc 01       	movw	r26, r24
    39a6:	01 c0       	rjmp	.+2      	; 0x39aa <memset+0x6>
    39a8:	6d 93       	st	X+, r22
    39aa:	41 50       	subi	r20, 0x01	; 1
    39ac:	50 40       	sbci	r21, 0x00	; 0
    39ae:	e0 f7       	brcc	.-8      	; 0x39a8 <memset+0x4>
    39b0:	08 95       	ret

000039b2 <strncpy>:
    39b2:	fb 01       	movw	r30, r22
    39b4:	dc 01       	movw	r26, r24
    39b6:	41 50       	subi	r20, 0x01	; 1
    39b8:	50 40       	sbci	r21, 0x00	; 0
    39ba:	48 f0       	brcs	.+18     	; 0x39ce <strncpy+0x1c>
    39bc:	01 90       	ld	r0, Z+
    39be:	0d 92       	st	X+, r0
    39c0:	00 20       	and	r0, r0
    39c2:	c9 f7       	brne	.-14     	; 0x39b6 <strncpy+0x4>
    39c4:	01 c0       	rjmp	.+2      	; 0x39c8 <strncpy+0x16>
    39c6:	1d 92       	st	X+, r1
    39c8:	41 50       	subi	r20, 0x01	; 1
    39ca:	50 40       	sbci	r21, 0x00	; 0
    39cc:	e0 f7       	brcc	.-8      	; 0x39c6 <strncpy+0x14>
    39ce:	08 95       	ret

000039d0 <ultoa>:
    39d0:	25 32       	cpi	r18, 0x25	; 37
    39d2:	31 05       	cpc	r19, r1
    39d4:	20 f4       	brcc	.+8      	; 0x39de <ultoa+0xe>
    39d6:	22 30       	cpi	r18, 0x02	; 2
    39d8:	10 f0       	brcs	.+4      	; 0x39de <ultoa+0xe>
    39da:	0c 94 f3 1c 	jmp	0x39e6	; 0x39e6 <__ultoa_ncheck>
    39de:	fa 01       	movw	r30, r20
    39e0:	10 82       	st	Z, r1
    39e2:	ca 01       	movw	r24, r20
    39e4:	08 95       	ret

000039e6 <__ultoa_ncheck>:
    39e6:	bb 27       	eor	r27, r27

000039e8 <__ultoa_common>:
    39e8:	fa 01       	movw	r30, r20
    39ea:	a6 2f       	mov	r26, r22
    39ec:	62 17       	cp	r22, r18
    39ee:	71 05       	cpc	r23, r1
    39f0:	81 05       	cpc	r24, r1
    39f2:	91 05       	cpc	r25, r1
    39f4:	33 0b       	sbc	r19, r19
    39f6:	30 fb       	bst	r19, 0
    39f8:	66 f0       	brts	.+24     	; 0x3a12 <__ultoa_common+0x2a>
    39fa:	aa 27       	eor	r26, r26
    39fc:	66 0f       	add	r22, r22
    39fe:	77 1f       	adc	r23, r23
    3a00:	88 1f       	adc	r24, r24
    3a02:	99 1f       	adc	r25, r25
    3a04:	aa 1f       	adc	r26, r26
    3a06:	a2 17       	cp	r26, r18
    3a08:	10 f0       	brcs	.+4      	; 0x3a0e <__ultoa_common+0x26>
    3a0a:	a2 1b       	sub	r26, r18
    3a0c:	63 95       	inc	r22
    3a0e:	38 50       	subi	r19, 0x08	; 8
    3a10:	a9 f7       	brne	.-22     	; 0x39fc <__ultoa_common+0x14>
    3a12:	a0 5d       	subi	r26, 0xD0	; 208
    3a14:	aa 33       	cpi	r26, 0x3A	; 58
    3a16:	08 f0       	brcs	.+2      	; 0x3a1a <__ultoa_common+0x32>
    3a18:	a9 5d       	subi	r26, 0xD9	; 217
    3a1a:	a1 93       	st	Z+, r26
    3a1c:	36 f7       	brtc	.-52     	; 0x39ea <__ultoa_common+0x2>
    3a1e:	b1 11       	cpse	r27, r1
    3a20:	b1 93       	st	Z+, r27
    3a22:	10 82       	st	Z, r1
    3a24:	ca 01       	movw	r24, r20
    3a26:	0c 94 3a 1d 	jmp	0x3a74	; 0x3a74 <strrev>

00003a2a <utoa>:
    3a2a:	45 32       	cpi	r20, 0x25	; 37
    3a2c:	51 05       	cpc	r21, r1
    3a2e:	20 f4       	brcc	.+8      	; 0x3a38 <utoa+0xe>
    3a30:	42 30       	cpi	r20, 0x02	; 2
    3a32:	10 f0       	brcs	.+4      	; 0x3a38 <utoa+0xe>
    3a34:	0c 94 20 1d 	jmp	0x3a40	; 0x3a40 <__utoa_ncheck>
    3a38:	fb 01       	movw	r30, r22
    3a3a:	10 82       	st	Z, r1
    3a3c:	cb 01       	movw	r24, r22
    3a3e:	08 95       	ret

00003a40 <__utoa_ncheck>:
    3a40:	bb 27       	eor	r27, r27

00003a42 <__utoa_common>:
    3a42:	fb 01       	movw	r30, r22
    3a44:	55 27       	eor	r21, r21
    3a46:	aa 27       	eor	r26, r26
    3a48:	88 0f       	add	r24, r24
    3a4a:	99 1f       	adc	r25, r25
    3a4c:	aa 1f       	adc	r26, r26
    3a4e:	a4 17       	cp	r26, r20
    3a50:	10 f0       	brcs	.+4      	; 0x3a56 <__utoa_common+0x14>
    3a52:	a4 1b       	sub	r26, r20
    3a54:	83 95       	inc	r24
    3a56:	50 51       	subi	r21, 0x10	; 16
    3a58:	b9 f7       	brne	.-18     	; 0x3a48 <__utoa_common+0x6>
    3a5a:	a0 5d       	subi	r26, 0xD0	; 208
    3a5c:	aa 33       	cpi	r26, 0x3A	; 58
    3a5e:	08 f0       	brcs	.+2      	; 0x3a62 <__utoa_common+0x20>
    3a60:	a9 5d       	subi	r26, 0xD9	; 217
    3a62:	a1 93       	st	Z+, r26
    3a64:	00 97       	sbiw	r24, 0x00	; 0
    3a66:	79 f7       	brne	.-34     	; 0x3a46 <__utoa_common+0x4>
    3a68:	b1 11       	cpse	r27, r1
    3a6a:	b1 93       	st	Z+, r27
    3a6c:	11 92       	st	Z+, r1
    3a6e:	cb 01       	movw	r24, r22
    3a70:	0c 94 3a 1d 	jmp	0x3a74	; 0x3a74 <strrev>

00003a74 <strrev>:
    3a74:	dc 01       	movw	r26, r24
    3a76:	fc 01       	movw	r30, r24
    3a78:	67 2f       	mov	r22, r23
    3a7a:	71 91       	ld	r23, Z+
    3a7c:	77 23       	and	r23, r23
    3a7e:	e1 f7       	brne	.-8      	; 0x3a78 <strrev+0x4>
    3a80:	32 97       	sbiw	r30, 0x02	; 2
    3a82:	04 c0       	rjmp	.+8      	; 0x3a8c <strrev+0x18>
    3a84:	7c 91       	ld	r23, X
    3a86:	6d 93       	st	X+, r22
    3a88:	70 83       	st	Z, r23
    3a8a:	62 91       	ld	r22, -Z
    3a8c:	ae 17       	cp	r26, r30
    3a8e:	bf 07       	cpc	r27, r31
    3a90:	c8 f3       	brcs	.-14     	; 0x3a84 <strrev+0x10>
    3a92:	08 95       	ret

00003a94 <_exit>:
    3a94:	f8 94       	cli

00003a96 <__stop_program>:
    3a96:	ff cf       	rjmp	.-2      	; 0x3a96 <__stop_program>
