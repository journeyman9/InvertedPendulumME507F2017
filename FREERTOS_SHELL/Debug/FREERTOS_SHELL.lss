
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000476a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000bc  00802000  0000476a  000047fe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010aa  008020bc  008020bc  000048ba  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000048ba  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000048ec  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006c0  00000000  00000000  0000492c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012a2b  00000000  00000000  00004fec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000064d0  00000000  00000000  00017a17  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005676  00000000  00000000  0001dee7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001284  00000000  00000000  00023560  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000630d  00000000  00000000  000247e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006126  00000000  00000000  0002aaf1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000578  00000000  00000000  00030c17  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 95 03 	jmp	0x72a	; 0x72a <__ctors_end>
       4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      10:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      14:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      18:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      1c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      20:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      24:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      28:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      2c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      30:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      34:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      38:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      3c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      40:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      44:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      48:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      4c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      50:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      54:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      58:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      5c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      60:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      64:	0c 94 7e 1f 	jmp	0x3efc	; 0x3efc <__vector_25>
      68:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      6c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      70:	0c 94 dc 1f 	jmp	0x3fb8	; 0x3fb8 <__vector_28>
      74:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      78:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      7c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      80:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      84:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      88:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      8c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      90:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      94:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      98:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      9c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c4:	0c 94 6f 0f 	jmp	0x1ede	; 0x1ede <__vector_49>
      c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e8:	0c 94 f6 20 	jmp	0x41ec	; 0x41ec <__vector_58>
      ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      fc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     100:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     104:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     108:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     10c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     110:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     114:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     118:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     11c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     120:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     124:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     128:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     12c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     130:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     134:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     138:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     13c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     140:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     144:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     148:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     14c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     150:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     154:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     158:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     15c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     160:	0c 94 3a 20 	jmp	0x4074	; 0x4074 <__vector_88>
     164:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     168:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     16c:	0c 94 98 20 	jmp	0x4130	; 0x4130 <__vector_91>
     170:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     174:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     178:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     17c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     180:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     184:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     188:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     18c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     190:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     194:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     198:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     19c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1fc:	b6 0b       	sbc	r27, r22
     1fe:	2e 0c       	add	r2, r14
     200:	2e 0c       	add	r2, r14
     202:	2e 0c       	add	r2, r14
     204:	2e 0c       	add	r2, r14
     206:	2e 0c       	add	r2, r14
     208:	2e 0c       	add	r2, r14
     20a:	2e 0c       	add	r2, r14
     20c:	2e 0c       	add	r2, r14
     20e:	2e 0c       	add	r2, r14
     210:	2e 0c       	add	r2, r14
     212:	2e 0c       	add	r2, r14
     214:	2e 0c       	add	r2, r14
     216:	2e 0c       	add	r2, r14
     218:	2e 0c       	add	r2, r14
     21a:	2e 0c       	add	r2, r14
     21c:	2e 0c       	add	r2, r14
     21e:	2e 0c       	add	r2, r14
     220:	2e 0c       	add	r2, r14
     222:	2e 0c       	add	r2, r14
     224:	2e 0c       	add	r2, r14
     226:	2e 0c       	add	r2, r14
     228:	2e 0c       	add	r2, r14
     22a:	2e 0c       	add	r2, r14
     22c:	2e 0c       	add	r2, r14
     22e:	2e 0c       	add	r2, r14
     230:	2e 0c       	add	r2, r14
     232:	2e 0c       	add	r2, r14
     234:	2e 0c       	add	r2, r14
     236:	2e 0c       	add	r2, r14
     238:	2e 0c       	add	r2, r14
     23a:	2e 0c       	add	r2, r14
     23c:	2e 0c       	add	r2, r14
     23e:	2e 0c       	add	r2, r14
     240:	2e 0c       	add	r2, r14
     242:	2e 0c       	add	r2, r14
     244:	2e 0c       	add	r2, r14
     246:	2e 0c       	add	r2, r14
     248:	2e 0c       	add	r2, r14
     24a:	2e 0c       	add	r2, r14
     24c:	2e 0c       	add	r2, r14
     24e:	2e 0c       	add	r2, r14
     250:	2e 0c       	add	r2, r14
     252:	2e 0c       	add	r2, r14
     254:	2e 0c       	add	r2, r14
     256:	2e 0c       	add	r2, r14
     258:	2e 0c       	add	r2, r14
     25a:	2e 0c       	add	r2, r14
     25c:	2e 0c       	add	r2, r14
     25e:	2e 0c       	add	r2, r14
     260:	2e 0c       	add	r2, r14
     262:	2e 0c       	add	r2, r14
     264:	2e 0c       	add	r2, r14
     266:	2e 0c       	add	r2, r14
     268:	2e 0c       	add	r2, r14
     26a:	2e 0c       	add	r2, r14
     26c:	2e 0c       	add	r2, r14
     26e:	2e 0c       	add	r2, r14
     270:	2e 0c       	add	r2, r14
     272:	2e 0c       	add	r2, r14
     274:	2e 0c       	add	r2, r14
     276:	2e 0c       	add	r2, r14
     278:	2e 0c       	add	r2, r14
     27a:	2e 0c       	add	r2, r14
     27c:	2e 0c       	add	r2, r14
     27e:	2e 0c       	add	r2, r14
     280:	2e 0c       	add	r2, r14
     282:	2e 0c       	add	r2, r14
     284:	2e 0c       	add	r2, r14
     286:	2e 0c       	add	r2, r14
     288:	2e 0c       	add	r2, r14
     28a:	ca 0b       	sbc	r28, r26
     28c:	2e 0c       	add	r2, r14
     28e:	fc 0b       	sbc	r31, r28
     290:	b6 0b       	sbc	r27, r22
     292:	2e 0c       	add	r2, r14
     294:	e4 0b       	sbc	r30, r20
     296:	b2 0b       	sbc	r27, r18
     298:	2e 0c       	add	r2, r14
     29a:	2e 0c       	add	r2, r14
     29c:	2e 0c       	add	r2, r14
     29e:	2e 0c       	add	r2, r14
     2a0:	2e 0c       	add	r2, r14
     2a2:	98 0b       	sbc	r25, r24
     2a4:	2e 0c       	add	r2, r14
     2a6:	2e 0c       	add	r2, r14
     2a8:	2e 0c       	add	r2, r14
     2aa:	16 0c       	add	r1, r6
     2ac:	aa 0b       	sbc	r26, r26
     2ae:	2e 0c       	add	r2, r14
     2b0:	2e 0c       	add	r2, r14
     2b2:	a6 0b       	sbc	r26, r22
     2b4:	41 1d       	adc	r20, r1
     2b6:	44 1d       	adc	r20, r4
     2b8:	47 1d       	adc	r20, r7
     2ba:	4a 1d       	adc	r20, r10
     2bc:	4d 1d       	adc	r20, r13
     2be:	50 1d       	adc	r21, r0
     2c0:	52 1d       	adc	r21, r2
     2c2:	63 1d       	adc	r22, r3
     2c4:	6b 1d       	adc	r22, r11
     2c6:	75 1d       	adc	r23, r5
     2c8:	73 1d       	adc	r23, r3

000002ca <__trampolines_start>:
     2ca:	0c 94 e9 1c 	jmp	0x39d2	; 0x39d2 <_ZN8emstream14check_for_charEv>
     2ce:	0c 94 52 1d 	jmp	0x3aa4	; 0x3aa4 <_ZN8emstreamlsE15ser_manipulator+0x40>
     2d2:	0c 94 aa 0b 	jmp	0x1754	; 0x1754 <_ZN9task_user3runEv+0x170>
     2d6:	0c 94 b2 0b 	jmp	0x1764	; 0x1764 <_ZN9task_user3runEv+0x180>
     2da:	0c 94 e6 1c 	jmp	0x39cc	; 0x39cc <_ZN8emstream7getcharEv>
     2de:	0c 94 4d 1c 	jmp	0x389a	; 0x389a <__cxa_pure_virtual>
     2e2:	0c 94 2e 0c 	jmp	0x185c	; 0x185c <_ZN9task_user3runEv+0x278>
     2e6:	0c 94 b6 0b 	jmp	0x176c	; 0x176c <_ZN9task_user3runEv+0x188>
     2ea:	0c 94 6b 1d 	jmp	0x3ad6	; 0x3ad6 <_ZN8emstreamlsE15ser_manipulator+0x72>
     2ee:	0c 94 f8 21 	jmp	0x43f0	; 0x43f0 <_GLOBAL__sub_I_counter>
     2f2:	0c 94 41 1d 	jmp	0x3a82	; 0x3a82 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2f6:	0c 94 50 1d 	jmp	0x3aa0	; 0x3aa0 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2fa:	0c 94 b4 04 	jmp	0x968	; 0x968 <_ZN13LimitSwitches3runEv>
     2fe:	0c 94 f3 11 	jmp	0x23e6	; 0x23e6 <prvIdleTask>
     302:	0c 94 47 1d 	jmp	0x3a8e	; 0x3a8e <_ZN8emstreamlsE15ser_manipulator+0x2a>
     306:	0c 94 8a 1a 	jmp	0x3514	; 0x3514 <_ZN14frt_text_queue14check_for_charEv>
     30a:	0c 94 22 19 	jmp	0x3244	; 0x3244 <_ZN8frt_task12print_statusER8emstream>
     30e:	0c 94 16 0c 	jmp	0x182c	; 0x182c <_ZN9task_user3runEv+0x248>
     312:	0c 94 95 1a 	jmp	0x352a	; 0x352a <_ZN14frt_text_queue7putcharEc>
     316:	0c 94 98 1e 	jmp	0x3d30	; 0x3d30 <_ZN5rs2327putcharEc>
     31a:	0c 94 5b 04 	jmp	0x8b6	; 0x8b6 <_ZN15EncoderPendulum3runEv>
     31e:	0c 94 98 0b 	jmp	0x1730	; 0x1730 <_ZN9task_user3runEv+0x14c>
     322:	0c 94 73 1d 	jmp	0x3ae6	; 0x3ae6 <_ZN8emstreamlsE15ser_manipulator+0x82>
     326:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <_ZN9task_user3runEv+0x168>
     32a:	0c 94 e2 1e 	jmp	0x3dc4	; 0x3dc4 <_ZN5rs23214check_for_charEv>
     32e:	0c 94 44 1d 	jmp	0x3a88	; 0x3a88 <_ZN8emstreamlsE15ser_manipulator+0x24>
     332:	0c 94 f5 1e 	jmp	0x3dea	; 0x3dea <_ZN5rs23212clear_screenEv>
     336:	0c 94 ec 1c 	jmp	0x39d8	; 0x39d8 <_ZN8emstream12clear_screenEv>
     33a:	0c 94 ca 0b 	jmp	0x1794	; 0x1794 <_ZN9task_user3runEv+0x1b0>
     33e:	0c 94 f2 0a 	jmp	0x15e4	; 0x15e4 <_ZN9task_user3runEv>
     342:	0c 94 e4 0b 	jmp	0x17c8	; 0x17c8 <_ZN9task_user3runEv+0x1e4>
     346:	0c 94 6c 1a 	jmp	0x34d8	; 0x34d8 <_ZN14frt_text_queue7getcharEv>
     34a:	0c 94 75 1d 	jmp	0x3aea	; 0x3aea <_ZN8emstreamlsE15ser_manipulator+0x86>
     34e:	0c 94 cd 03 	jmp	0x79a	; 0x79a <_ZN12EncoderMotor3runEv>
     352:	0c 94 bc 1e 	jmp	0x3d78	; 0x3d78 <_ZN5rs2327getcharEv>
     356:	0c 94 4d 1d 	jmp	0x3a9a	; 0x3a9a <_ZN8emstreamlsE15ser_manipulator+0x36>
     35a:	0c 94 4a 1d 	jmp	0x3a94	; 0x3a94 <_ZN8emstreamlsE15ser_manipulator+0x30>
     35e:	0c 94 63 1d 	jmp	0x3ac6	; 0x3ac6 <_ZN8emstreamlsE15ser_manipulator+0x62>
     362:	0c 94 e4 1c 	jmp	0x39c8	; 0x39c8 <_ZN8emstream13ready_to_sendEv>
     366:	0c 94 19 05 	jmp	0xa32	; 0xa32 <_ZN5Motor3runEv>
     36a:	0c 94 fc 0b 	jmp	0x17f8	; 0x17f8 <_ZN9task_user3runEv+0x214>
     36e:	0c 94 eb 1c 	jmp	0x39d6	; 0x39d6 <_ZN8emstream12transmit_nowEv>
     372:	0c 94 92 03 	jmp	0x724	; 0x724 <_call_static_run_method>

00000376 <__trampolines_end>:
     376:	2c 20       	and	r2, r12
     378:	54 43       	sbci	r21, 0x34	; 52
     37a:	43 30       	cpi	r20, 0x03	; 3
     37c:	43 43       	sbci	r20, 0x33	; 51
     37e:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000381 <_ZZN9task_user11show_statusEvE3__c_3>:
     381:	2f 00                                               /.

00000383 <_ZZN9task_user11show_statusEvE3__c_2>:
     383:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

00000391 <_ZZN9task_user11show_statusEvE3__c_1>:
     391:	54 69 6d 65 3a 20 00                                Time: .

00000398 <_ZZN9task_user11show_statusEvE3__c_0>:
     398:	44 65 63 20 20 37 20 32 30 31 37 00                 Dec  7 2017.

000003a4 <_ZZN9task_user11show_statusEvE3__c>:
     3a4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3b4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003c3 <_ZZN9task_user18print_help_messageEvE3__c_14>:
     3c3:	20 20 20 20 72 3a 20 20 20 52 65 73 65 74 20 74         r:   Reset t
     3d3:	6f 20 49 64 6c 65 00                                o Idle.

000003da <_ZZN9task_user18print_help_messageEvE3__c_13>:
     3da:	20 20 20 20 64 3a 20 20 20 45 6d 65 72 67 65 6e         d:   Emergen
     3ea:	63 79 20 53 74 6f 70 00                             cy Stop.

000003f2 <_ZZN9task_user18print_help_messageEvE3__c_12>:
     3f2:	20 20 20 20 67 3a 20 20 20 53 77 69 6e 67 20 50         g:   Swing P
     402:	65 6e 64 75 6c 75 6d 20 55 70 72 69 67 68 74 2c     endulum Upright,
     412:	20 74 68 65 6e 20 47 6f 2e 00                        then Go..

0000041c <_ZZN9task_user18print_help_messageEvE3__c_11>:
     41c:	20 20 20 20 62 3a 20 20 20 42 65 67 69 6e 20 43         b:   Begin C
     42c:	61 6c 69 62 72 61 74 69 6f 6e 20 6f 66 20 49 6e     alibration of In
     43c:	76 65 72 74 65 64 20 50 65 6e 64 75 6c 75 6d 3f     verted Pendulum?
	...

0000044d <_ZZN9task_user18print_help_messageEvE3__c_10>:
     44d:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000045c <_ZZN9task_user18print_help_messageEvE3__c_9>:
     45c:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     46c:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000477 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     477:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     487:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000495 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     495:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     4a5:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     4b5:	6d 61 74 69 6f 6e 00                                mation.

000004bc <_ZZN9task_user18print_help_messageEvE3__c_6>:
     4bc:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     4cc:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000004dd <_ZZN9task_user18print_help_messageEvE3__c_5>:
     4dd:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4ed:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004f5 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4f5:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     505:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000511 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     511:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     521:	68 65 20 41 56 52 00                                he AVR.

00000528 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     528:	20 68 65 6c 70 00                                    help.

0000052e <_ZZN9task_user18print_help_messageEvE3__c_1>:
     52e:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     53e:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000054d <_ZZN9task_user18print_help_messageEvE3__c_0>:
     54d:	1b 5b 33 30 6d 00                                   .[30m.

00000553 <_ZZN9task_user18print_help_messageEvE3__c>:
     553:	1b 5b 34 36 6d 00                                   .[46m.

00000559 <_ZZN9task_user3runEvE3__c_7>:
     559:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     569:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000576 <_ZZN9task_user3runEvE3__c_6>:
     576:	3a 57 54 46 3f 00                                   :WTF?.

0000057c <_ZZN9task_user3runEvE3__c_5>:
     57c:	52 65 73 65 74 2c 20 74 72 79 20 48 6f 6d 69 6e     Reset, try Homin
     58c:	67 20 61 67 61 69 6e 20 62 79 20 70 72 65 73 73     g again by press
     59c:	69 6e 67 20 27 62 27 00                             ing 'b'.

000005a4 <_ZZN9task_user3runEvE3__c_4>:
     5a4:	45 4d 45 52 47 45 4e 43 59 20 53 54 4f 50 00        EMERGENCY STOP.

000005b3 <_ZZN9task_user3runEvE3__c_3>:
     5b3:	43 6f 6d 6d 65 6e 63 65 20 42 61 6c 61 6e 63 65     Commence Balance
	...

000005c4 <_ZZN9task_user3runEvE3__c_2>:
     5c4:	42 65 67 69 6e 20 48 6f 6d 69 6e 67 00              Begin Homing.

000005d1 <_ZZN9task_user3runEvE3__c_1>:
     5d1:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     5e1:	65 00                                               e.

000005e3 <_ZZN9task_user3runEvE3__c_0>:
     5e3:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000005f1 <_ZZN9task_user3runEvE3__c>:
     5f1:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 74 6f 20     Press Ctrl-A to 
     601:	67 65 74 20 74 6f 20 63 6f 6d 6d 61 6e 64 20 6d     get to command m
     611:	6f 64 65 20 66 6f 72 20 49 6e 76 65 72 74 65 64     ode for Inverted
     621:	20 50 65 6e 64 75 6c 75 6d 00                        Pendulum.

0000062b <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     62b:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000635 <_ZZN8frt_task15emergency_resetEvE3__c>:
     635:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000644 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     644:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     654:	61 73 6b 20 00                                      ask .

00000659 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     659:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000667 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     667:	20 63 72 65 61 74 65 64 00                           created.

00000670 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     670:	54 61 73 6b 20 00                                   Task .

00000676 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     676:	1b 5b 32 32 6d 00                                   .[22m.

0000067c <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     67c:	54 61 73 6b 3a 20 00                                Task: .

00000683 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     683:	1b 5b 31 6d 00                                      .[1m.

00000688 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     688:	1b 5b 32 32 6d 00                                   .[22m.

0000068e <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     68e:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

00000699 <_ZZ17print_task_stacksP8emstreamE3__c>:
     699:	1b 5b 31 6d 00                                      .[1m.

0000069e <_ZZ15print_task_listP8emstreamE3__c_9>:
     69e:	09 09 00                                            ...

000006a1 <_ZZ15print_task_listP8emstreamE3__c_8>:
     6a1:	2f 00                                               /.

000006a3 <_ZZ15print_task_listP8emstreamE3__c_7>:
     6a3:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000006ae <_ZZ15print_task_listP8emstreamE3__c_6>:
     6ae:	09 2d 2d 2d 2d 00                                   .----.

000006b4 <_ZZ15print_task_listP8emstreamE3__c_5>:
     6b4:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000006c0 <_ZZ15print_task_listP8emstreamE3__c_4>:
     6c0:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000006d1 <_ZZ15print_task_listP8emstreamE3__c_3>:
     6d1:	09 52 75 6e 73 00                                   .Runs.

000006d7 <_ZZ15print_task_listP8emstreamE3__c_2>:
     6d7:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000006e3 <_ZZ15print_task_listP8emstreamE3__c_1>:
     6e3:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000006f4 <_ZZ15print_task_listP8emstreamE3__c_0>:
     6f4:	09 53 74 61 63 6b 00                                .Stack.

000006fb <_ZZ15print_task_listP8emstreamE3__c>:
     6fb:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000706 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     706:	09 00                                               ..

00000708 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     708:	09 00                                               ..

0000070a <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     70a:	2f 00                                               /.

0000070c <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     70c:	09 00                                               ..

0000070e <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     70e:	09 00                                               ..

00000710 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     710:	1b 5b 32 32 6d 00                                   .[22m.

00000716 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     716:	1b 5b 31 6d 00                                      .[1m.

0000071b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     71b:	1b 5b 31 6d 00                                      .[1m.

00000720 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     720:	20 20 00 00                                           ..

00000724 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     724:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <_ZN8frt_task22_call_users_run_methodEPS_>

00000728 <__ctors_start>:
     728:	f8 21       	and	r31, r8

0000072a <__ctors_end>:
     72a:	11 24       	eor	r1, r1
     72c:	1f be       	out	0x3f, r1	; 63
     72e:	cf ef       	ldi	r28, 0xFF	; 255
     730:	cd bf       	out	0x3d, r28	; 61
     732:	df e3       	ldi	r29, 0x3F	; 63
     734:	de bf       	out	0x3e, r29	; 62
     736:	00 e0       	ldi	r16, 0x00	; 0
     738:	0c bf       	out	0x3c, r16	; 60
     73a:	18 be       	out	0x38, r1	; 56
     73c:	19 be       	out	0x39, r1	; 57
     73e:	1a be       	out	0x3a, r1	; 58
     740:	1b be       	out	0x3b, r1	; 59

00000742 <__do_copy_data>:
     742:	10 e2       	ldi	r17, 0x20	; 32
     744:	a0 e0       	ldi	r26, 0x00	; 0
     746:	b0 e2       	ldi	r27, 0x20	; 32
     748:	ea e6       	ldi	r30, 0x6A	; 106
     74a:	f7 e4       	ldi	r31, 0x47	; 71
     74c:	00 e0       	ldi	r16, 0x00	; 0
     74e:	0b bf       	out	0x3b, r16	; 59
     750:	02 c0       	rjmp	.+4      	; 0x756 <__do_copy_data+0x14>
     752:	07 90       	elpm	r0, Z+
     754:	0d 92       	st	X+, r0
     756:	ac 3b       	cpi	r26, 0xBC	; 188
     758:	b1 07       	cpc	r27, r17
     75a:	d9 f7       	brne	.-10     	; 0x752 <__do_copy_data+0x10>
     75c:	1b be       	out	0x3b, r1	; 59

0000075e <__do_clear_bss>:
     75e:	21 e3       	ldi	r18, 0x31	; 49
     760:	ac eb       	ldi	r26, 0xBC	; 188
     762:	b0 e2       	ldi	r27, 0x20	; 32
     764:	01 c0       	rjmp	.+2      	; 0x768 <.do_clear_bss_start>

00000766 <.do_clear_bss_loop>:
     766:	1d 92       	st	X+, r1

00000768 <.do_clear_bss_start>:
     768:	a6 36       	cpi	r26, 0x66	; 102
     76a:	b2 07       	cpc	r27, r18
     76c:	e1 f7       	brne	.-8      	; 0x766 <.do_clear_bss_loop>

0000076e <__do_global_ctors>:
     76e:	13 e0       	ldi	r17, 0x03	; 3
     770:	c5 e9       	ldi	r28, 0x95	; 149
     772:	d3 e0       	ldi	r29, 0x03	; 3
     774:	00 e0       	ldi	r16, 0x00	; 0
     776:	06 c0       	rjmp	.+12     	; 0x784 <__do_global_ctors+0x16>
     778:	21 97       	sbiw	r28, 0x01	; 1
     77a:	01 09       	sbc	r16, r1
     77c:	80 2f       	mov	r24, r16
     77e:	fe 01       	movw	r30, r28
     780:	0e 94 d9 22 	call	0x45b2	; 0x45b2 <__tablejump2__>
     784:	c4 39       	cpi	r28, 0x94	; 148
     786:	d1 07       	cpc	r29, r17
     788:	80 e0       	ldi	r24, 0x00	; 0
     78a:	08 07       	cpc	r16, r24
     78c:	a9 f7       	brne	.-22     	; 0x778 <__do_global_ctors+0xa>
     78e:	0e 94 69 21 	call	0x42d2	; 0x42d2 <main>
     792:	0c 94 b3 23 	jmp	0x4766	; 0x4766 <_exit>

00000796 <__bad_interrupt>:
     796:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000079a <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     79a:	cf 93       	push	r28
     79c:	df 93       	push	r29
     79e:	00 d0       	rcall	.+0      	; 0x7a0 <_ZN12EncoderMotor3runEv+0x6>
     7a0:	1f 92       	push	r1
     7a2:	cd b7       	in	r28, 0x3d	; 61
     7a4:	de b7       	in	r29, 0x3e	; 62
     7a6:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7a8:	0e 94 92 13 	call	0x2724	; 0x2724 <xTaskGetTickCount>
     7ac:	69 83       	std	Y+1, r22	; 0x01
     7ae:	7a 83       	std	Y+2, r23	; 0x02
     7b0:	8b 83       	std	Y+3, r24	; 0x03
     7b2:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     7b4:	e0 e8       	ldi	r30, 0x80	; 128
     7b6:	f6 e0       	ldi	r31, 0x06	; 6
     7b8:	8c e0       	ldi	r24, 0x0C	; 12
     7ba:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     7bc:	82 89       	ldd	r24, Z+18	; 0x12
     7be:	83 60       	ori	r24, 0x03	; 3
     7c0:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     7c2:	83 89       	ldd	r24, Z+19	; 0x13
     7c4:	83 60       	ori	r24, 0x03	; 3
     7c6:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     7c8:	e0 e8       	ldi	r30, 0x80	; 128
     7ca:	f1 e0       	ldi	r31, 0x01	; 1
     7cc:	82 e7       	ldi	r24, 0x72	; 114
     7ce:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     7d0:	89 e0       	ldi	r24, 0x09	; 9
     7d2:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     7d4:	e0 e0       	ldi	r30, 0x00	; 0
     7d6:	f9 e0       	ldi	r31, 0x09	; 9
     7d8:	88 e6       	ldi	r24, 0x68	; 104
     7da:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     7dc:	8f ef       	ldi	r24, 0xFF	; 255
     7de:	9f ef       	ldi	r25, 0xFF	; 255
     7e0:	86 a3       	std	Z+38, r24	; 0x26
     7e2:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     7e8:	0f 2e       	mov	r0, r31
     7ea:	a1 2c       	mov	r10, r1
     7ec:	f9 e0       	ldi	r31, 0x09	; 9
     7ee:	bf 2e       	mov	r11, r31
     7f0:	f0 2d       	mov	r31, r0
     7f2:	f5 01       	movw	r30, r10
     7f4:	00 a1       	ldd	r16, Z+32	; 0x20
     7f6:	11 a1       	ldd	r17, Z+33	; 0x21
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     7f8:	0f b6       	in	r0, 0x3f	; 63
     7fa:	f8 94       	cli
     7fc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     802:	0f b6       	in	r0, 0x3f	; 63
     804:	f8 94       	cli
     806:	0f 92       	push	r0
			the_data = new_data;
     808:	c8 01       	movw	r24, r16
     80a:	01 2e       	mov	r0, r17
     80c:	00 0c       	add	r0, r0
     80e:	aa 0b       	sbc	r26, r26
     810:	bb 0b       	sbc	r27, r27
     812:	ac 01       	movw	r20, r24
     814:	bd 01       	movw	r22, r26
     816:	44 0f       	add	r20, r20
     818:	55 1f       	adc	r21, r21
     81a:	66 1f       	adc	r22, r22
     81c:	77 1f       	adc	r23, r23
     81e:	3a 01       	movw	r6, r20
     820:	4b 01       	movw	r8, r22
     822:	68 0e       	add	r6, r24
     824:	79 1e       	adc	r7, r25
     826:	8a 1e       	adc	r8, r26
     828:	9b 1e       	adc	r9, r27
     82a:	c4 01       	movw	r24, r8
     82c:	b3 01       	movw	r22, r6
     82e:	24 e6       	ldi	r18, 0x64	; 100
     830:	30 e0       	ldi	r19, 0x00	; 0
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	50 e0       	ldi	r21, 0x00	; 0
     836:	0e 94 ba 22 	call	0x4574	; 0x4574 <__divmodsi4>
     83a:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <linear_offset>
     83e:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <linear_offset+0x1>
     842:	28 1b       	sub	r18, r24
     844:	39 0b       	sbc	r19, r25
     846:	20 93 52 31 	sts	0x3152, r18	; 0x803152 <linear_position>
     84a:	30 93 53 31 	sts	0x3153, r19	; 0x803153 <linear_position+0x1>
			portEXIT_CRITICAL ();
     84e:	0f 90       	pop	r0
     850:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	0f 92       	push	r0
			the_data = new_data;
     858:	c8 01       	movw	r24, r16
     85a:	8c 19       	sub	r24, r12
     85c:	9d 09       	sbc	r25, r13
     85e:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <thdMotor>
     862:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     866:	0f 90       	pop	r0
     868:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     86a:	f7 01       	movw	r30, r14
     86c:	86 85       	ldd	r24, Z+14	; 0x0e
     86e:	97 85       	ldd	r25, Z+15	; 0x0f
     870:	a0 89       	ldd	r26, Z+16	; 0x10
     872:	b1 89       	ldd	r27, Z+17	; 0x11
     874:	01 96       	adiw	r24, 0x01	; 1
     876:	a1 1d       	adc	r26, r1
     878:	b1 1d       	adc	r27, r1
     87a:	86 87       	std	Z+14, r24	; 0x0e
     87c:	97 87       	std	Z+15, r25	; 0x0f
     87e:	a0 8b       	std	Z+16, r26	; 0x10
     880:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     882:	41 e0       	ldi	r20, 0x01	; 1
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	ce 01       	movw	r24, r28
     88c:	01 96       	adiw	r24, 0x01	; 1
     88e:	0e 94 30 15 	call	0x2a60	; 0x2a60 <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     892:	68 01       	movw	r12, r16
     894:	ae cf       	rjmp	.-164    	; 0x7f2 <_ZN12EncoderMotor3runEv+0x58>

00000896 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     896:	0f 93       	push	r16
     898:	1f 93       	push	r17
     89a:	cf 93       	push	r28
     89c:	df 93       	push	r29
     89e:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8a0:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <_ZN8frt_taskC1EPKchjP8emstream>
     8a4:	8a e0       	ldi	r24, 0x0A	; 10
     8a6:	90 e2       	ldi	r25, 0x20	; 32
     8a8:	88 83       	st	Y, r24
     8aa:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	08 95       	ret

000008b6 <_ZN15EncoderPendulum3runEv>:
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void)
{
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	00 d0       	rcall	.+0      	; 0x8bc <_ZN15EncoderPendulum3runEv+0x6>
     8bc:	1f 92       	push	r1
     8be:	cd b7       	in	r28, 0x3d	; 61
     8c0:	de b7       	in	r29, 0x3e	; 62
     8c2:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8c4:	0e 94 92 13 	call	0x2724	; 0x2724 <xTaskGetTickCount>
     8c8:	69 83       	std	Y+1, r22	; 0x01
     8ca:	7a 83       	std	Y+2, r23	; 0x02
     8cc:	8b 83       	std	Y+3, r24	; 0x03
     8ce:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     8d0:	e0 e8       	ldi	r30, 0x80	; 128
     8d2:	f6 e0       	ldi	r31, 0x06	; 6
     8d4:	83 e0       	ldi	r24, 0x03	; 3
     8d6:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     8d8:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     8da:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     8dc:	e0 e8       	ldi	r30, 0x80	; 128
     8de:	f1 e0       	ldi	r31, 0x01	; 1
     8e0:	80 e7       	ldi	r24, 0x70	; 112
     8e2:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     8e4:	89 e0       	ldi	r24, 0x09	; 9
     8e6:	82 87       	std	Z+10, r24	; 0x0a
	
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     8e8:	e0 e4       	ldi	r30, 0x40	; 64
     8ea:	f8 e0       	ldi	r31, 0x08	; 8
     8ec:	8a e6       	ldi	r24, 0x6A	; 106
     8ee:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     8f0:	80 ea       	ldi	r24, 0xA0	; 160
     8f2:	95 e0       	ldi	r25, 0x05	; 5
     8f4:	86 a3       	std	Z+38, r24	; 0x26
     8f6:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     8f8:	81 e0       	ldi	r24, 0x01	; 1
     8fa:	80 83       	st	Z, r24
	
	int16_t count; // contains the current encoder value
	
	while(1)
	{
		count = TCC1.CNT; // read value from hardware counter
     8fc:	68 94       	set
     8fe:	ee 24       	eor	r14, r14
     900:	e6 f8       	bld	r14, 6
     902:	ff 24       	eor	r15, r15
     904:	f3 f8       	bld	r15, 3
     906:	f7 01       	movw	r30, r14
     908:	80 a1       	ldd	r24, Z+32	; 0x20
     90a:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	0f 92       	push	r0
			the_data = new_data;
     912:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <thPendulum>
     916:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <thPendulum+0x1>
			portEXIT_CRITICAL ();
     91a:	0f 90       	pop	r0
     91c:	0f be       	out	0x3f, r0	; 63
		//theta_pendulum = ( (int32_t) count*100/4);			// count/(4*360)*360 degrees * 100
		
		thPendulum.put(count); // push angular position [ticks] to pendulum controller task
		
		// Increment counter for debugging
		runs++;
     91e:	f8 01       	movw	r30, r16
     920:	86 85       	ldd	r24, Z+14	; 0x0e
     922:	97 85       	ldd	r25, Z+15	; 0x0f
     924:	a0 89       	ldd	r26, Z+16	; 0x10
     926:	b1 89       	ldd	r27, Z+17	; 0x11
     928:	01 96       	adiw	r24, 0x01	; 1
     92a:	a1 1d       	adc	r26, r1
     92c:	b1 1d       	adc	r27, r1
     92e:	86 87       	std	Z+14, r24	; 0x0e
     930:	97 87       	std	Z+15, r25	; 0x0f
     932:	a0 8b       	std	Z+16, r26	; 0x10
     934:	b1 8b       	std	Z+17, r27	; 0x11
     936:	41 e0       	ldi	r20, 0x01	; 1
     938:	50 e0       	ldi	r21, 0x00	; 0
     93a:	60 e0       	ldi	r22, 0x00	; 0
     93c:	70 e0       	ldi	r23, 0x00	; 0
     93e:	ce 01       	movw	r24, r28
     940:	01 96       	adiw	r24, 0x01	; 1
     942:	0e 94 30 15 	call	0x2a60	; 0x2a60 <vTaskDelayUntil>
     946:	df cf       	rjmp	.-66     	; 0x906 <_ZN15EncoderPendulum3runEv+0x50>

00000948 <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     948:	0f 93       	push	r16
     94a:	1f 93       	push	r17
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     952:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <_ZN8frt_taskC1EPKchjP8emstream>
     956:	82 e1       	ldi	r24, 0x12	; 18
     958:	90 e2       	ldi	r25, 0x20	; 32
     95a:	88 83       	st	Y, r24
     95c:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	1f 91       	pop	r17
     964:	0f 91       	pop	r16
     966:	08 95       	ret

00000968 <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	00 d0       	rcall	.+0      	; 0x96e <_ZN13LimitSwitches3runEv+0x6>
     96e:	1f 92       	push	r1
     970:	cd b7       	in	r28, 0x3d	; 61
     972:	de b7       	in	r29, 0x3e	; 62
     974:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     976:	0e 94 92 13 	call	0x2724	; 0x2724 <xTaskGetTickCount>
     97a:	69 83       	std	Y+1, r22	; 0x01
     97c:	7a 83       	std	Y+2, r23	; 0x02
     97e:	8b 83       	std	Y+3, r24	; 0x03
     980:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     982:	e0 e6       	ldi	r30, 0x60	; 96
     984:	f6 e0       	ldi	r31, 0x06	; 6
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     98a:	84 e0       	ldi	r24, 0x04	; 4
     98c:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     98e:	88 e1       	ldi	r24, 0x18	; 24
     990:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     992:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     994:	08 e6       	ldi	r16, 0x68	; 104
     996:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     998:	dd 24       	eor	r13, r13
     99a:	d3 94       	inc	r13
     99c:	f8 01       	movw	r30, r16
     99e:	80 81       	ld	r24, Z
     9a0:	80 fd       	sbrc	r24, 0
     9a2:	08 c0       	rjmp	.+16     	; 0x9b4 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9a4:	0f b6       	in	r0, 0x3f	; 63
     9a6:	f8 94       	cli
     9a8:	0f 92       	push	r0
			the_data = new_data;
     9aa:	d0 92 4d 31 	sts	0x314D, r13	; 0x80314d <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9ae:	0f 90       	pop	r0
     9b0:	0f be       	out	0x3f, r0	; 63
     9b2:	07 c0       	rjmp	.+14     	; 0x9c2 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9b4:	0f b6       	in	r0, 0x3f	; 63
     9b6:	f8 94       	cli
     9b8:	0f 92       	push	r0
			the_data = new_data;
     9ba:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9be:	0f 90       	pop	r0
     9c0:	0f be       	out	0x3f, r0	; 63
			leftLimitSwitch.put(leftLimit);

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     9c2:	f8 01       	movw	r30, r16
     9c4:	80 81       	ld	r24, Z
     9c6:	82 fd       	sbrc	r24, 2
     9c8:	08 c0       	rjmp	.+16     	; 0x9da <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9ca:	0f b6       	in	r0, 0x3f	; 63
     9cc:	f8 94       	cli
     9ce:	0f 92       	push	r0
			the_data = new_data;
     9d0:	d0 92 4c 31 	sts	0x314C, r13	; 0x80314c <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9d4:	0f 90       	pop	r0
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	07 c0       	rjmp	.+14     	; 0x9e8 <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9da:	0f b6       	in	r0, 0x3f	; 63
     9dc:	f8 94       	cli
     9de:	0f 92       	push	r0
			the_data = new_data;
     9e0:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9e4:	0f 90       	pop	r0
     9e6:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     9e8:	f7 01       	movw	r30, r14
     9ea:	86 85       	ldd	r24, Z+14	; 0x0e
     9ec:	97 85       	ldd	r25, Z+15	; 0x0f
     9ee:	a0 89       	ldd	r26, Z+16	; 0x10
     9f0:	b1 89       	ldd	r27, Z+17	; 0x11
     9f2:	01 96       	adiw	r24, 0x01	; 1
     9f4:	a1 1d       	adc	r26, r1
     9f6:	b1 1d       	adc	r27, r1
     9f8:	86 87       	std	Z+14, r24	; 0x0e
     9fa:	97 87       	std	Z+15, r25	; 0x0f
     9fc:	a0 8b       	std	Z+16, r26	; 0x10
     9fe:	b1 8b       	std	Z+17, r27	; 0x11
     a00:	41 e0       	ldi	r20, 0x01	; 1
     a02:	50 e0       	ldi	r21, 0x00	; 0
     a04:	60 e0       	ldi	r22, 0x00	; 0
     a06:	70 e0       	ldi	r23, 0x00	; 0
     a08:	ce 01       	movw	r24, r28
     a0a:	01 96       	adiw	r24, 0x01	; 1
     a0c:	0e 94 30 15 	call	0x2a60	; 0x2a60 <vTaskDelayUntil>
     a10:	c5 cf       	rjmp	.-118    	; 0x99c <_ZN13LimitSwitches3runEv+0x34>

00000a12 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     a12:	0f 93       	push	r16
     a14:	1f 93       	push	r17
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     a1c:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <_ZN8frt_taskC1EPKchjP8emstream>
     a20:	8a e1       	ldi	r24, 0x1A	; 26
     a22:	90 e2       	ldi	r25, 0x20	; 32
     a24:	88 83       	st	Y, r24
     a26:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     a28:	df 91       	pop	r29
     a2a:	cf 91       	pop	r28
     a2c:	1f 91       	pop	r17
     a2e:	0f 91       	pop	r16
     a30:	08 95       	ret

00000a32 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	cd b7       	in	r28, 0x3d	; 61
     a38:	de b7       	in	r29, 0x3e	; 62
     a3a:	6a 97       	sbiw	r28, 0x1a	; 26
     a3c:	cd bf       	out	0x3d, r28	; 61
     a3e:	de bf       	out	0x3e, r29	; 62
     a40:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     a42:	0e 94 92 13 	call	0x2724	; 0x2724 <xTaskGetTickCount>
     a46:	69 83       	std	Y+1, r22	; 0x01
     a48:	7a 83       	std	Y+2, r23	; 0x02
     a4a:	8b 83       	std	Y+3, r24	; 0x03
     a4c:	9c 83       	std	Y+4, r25	; 0x04

	dt = 1; // [ms]
     a4e:	f8 01       	movw	r30, r16
     a50:	fe 96       	adiw	r30, 0x3e	; 62
     a52:	81 e0       	ldi	r24, 0x01	; 1
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	a0 e0       	ldi	r26, 0x00	; 0
     a58:	b0 e0       	ldi	r27, 0x00	; 0
     a5a:	80 83       	st	Z, r24
     a5c:	91 83       	std	Z+1, r25	; 0x01
     a5e:	a2 83       	std	Z+2, r26	; 0x02
     a60:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     a62:	d8 01       	movw	r26, r16
     a64:	dc 96       	adiw	r26, 0x3c	; 60
     a66:	8d 93       	st	X+, r24
     a68:	9c 93       	st	X, r25
     a6a:	dd 97       	sbiw	r26, 0x3d	; 61
	
	// Initialize PWM 
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     a6c:	a0 e4       	ldi	r26, 0x40	; 64
     a6e:	b6 e0       	ldi	r27, 0x06	; 6
     a70:	87 e0       	ldi	r24, 0x07	; 7
     a72:	11 96       	adiw	r26, 0x01	; 1
     a74:	8c 93       	st	X, r24
     a76:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     a78:	84 e0       	ldi	r24, 0x04	; 4
     a7a:	15 96       	adiw	r26, 0x05	; 5
     a7c:	8c 93       	st	X, r24
     a7e:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     a80:	e0 e0       	ldi	r30, 0x00	; 0
     a82:	f8 e0       	ldi	r31, 0x08	; 8
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     a88:	83 e0       	ldi	r24, 0x03	; 3
     a8a:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     a8c:	a6 a3       	std	Z+38, r26	; 0x26
     a8e:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     a90:	10 a6       	std	Z+40, r1	; 0x28
     a92:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     a94:	12 a6       	std	Z+42, r1	; 0x2a
     a96:	13 a6       	std	Z+43, r1	; 0x2b
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     a98:	81 81       	ldd	r24, Z+1	; 0x01
     a9a:	80 63       	ori	r24, 0x30	; 48
     a9c:	81 83       	std	Z+1, r24	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     a9e:	0f b6       	in	r0, 0x3f	; 63
     aa0:	f8 94       	cli
     aa2:	0f 92       	push	r0
			the_data = new_data;
     aa4:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <linear_offset>
     aa8:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     aac:	0f 90       	pop	r0
     aae:	0f be       	out	0x3f, r0	; 63
	linear_offset.put(0);								// Initialize motor offset	
	int16_t left_home;									// Initialize left distance to calculate center
	int16_t position_set;								// Setpoint of cart's position
	int16_t KP_pos = 0.5*256;							// P gain for cart position				
	int16_t position_error = 0;							// positional error	
	int16_t position_midpoint = 0;						// midpoint calculated from homing sequence
     ab0:	1d 8a       	std	Y+21, r1	; 0x15
     ab2:	1e 8a       	std	Y+22, r1	; 0x16
				break;
			
			// Delay loop 
			case (2) :
				delay_ms(500);
				_integral = 0;
     ab4:	58 01       	movw	r10, r16
     ab6:	b0 e5       	ldi	r27, 0x50	; 80
     ab8:	ab 0e       	add	r10, r27
     aba:	b1 1c       	adc	r11, r1
			case(4) :
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				
				// Derivative term
				angle_derivative = (angle_error-_pre_angle_error) / dt;
     abc:	f8 01       	movw	r30, r16
     abe:	fe 96       	adiw	r30, 0x3e	; 62
     ac0:	ed 83       	std	Y+5, r30	; 0x05
     ac2:	fe 83       	std	Y+6, r31	; 0x06
				_pre_angle_error = angle_error;
				angle_Dout = (_Kd_angle * angle_derivative)/256;

				output_correct = output;
     ac4:	68 01       	movw	r12, r16
     ac6:	fe e5       	ldi	r31, 0x5E	; 94
     ac8:	cf 0e       	add	r12, r31
     aca:	d1 1c       	adc	r13, r1
     acc:	98 01       	movw	r18, r16
     ace:	20 5a       	subi	r18, 0xA0	; 160
     ad0:	3f 4f       	sbci	r19, 0xFF	; 255
     ad2:	2f 87       	std	Y+15, r18	; 0x0f
     ad4:	38 8b       	std	Y+16, r19	; 0x10
				linear_offset.put(0);										// re initialize
				if (begin.get())											// If user begins Calibration Sequence
				{
					reset.put(0);											// turn off flag
					stop.put(0);
					omegam_set = 10;	// [ticks/ms]
     ad6:	0f 2e       	mov	r0, r31
     ad8:	fa e0       	ldi	r31, 0x0A	; 10
     ada:	2f 2e       	mov	r2, r31
     adc:	31 2c       	mov	r3, r1
     ade:	f0 2d       	mov	r31, r0
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     ae0:	c8 01       	movw	r24, r16
     ae2:	88 5b       	subi	r24, 0xB8	; 184
     ae4:	9f 4f       	sbci	r25, 0xFF	; 255
     ae6:	89 8b       	std	Y+17, r24	; 0x11
     ae8:	9a 8b       	std	Y+18, r25	; 0x12
		_Ki = .7*256;
     aea:	d8 01       	movw	r26, r16
     aec:	a4 5b       	subi	r26, 0xB4	; 180
     aee:	bf 4f       	sbci	r27, 0xFF	; 255
     af0:	af 83       	std	Y+7, r26	; 0x07
     af2:	b8 87       	std	Y+8, r27	; 0x08
		_Kd = 0;
     af4:	f8 01       	movw	r30, r16
     af6:	e6 5b       	subi	r30, 0xB6	; 182
     af8:	ff 4f       	sbci	r31, 0xFF	; 255
     afa:	eb 8b       	std	Y+19, r30	; 0x13
     afc:	fc 8b       	std	Y+20, r31	; 0x14
		antiwind_gain = .75*256;
     afe:	2c 5f       	subi	r18, 0xFC	; 252
     b00:	3f 4f       	sbci	r19, 0xFF	; 255
     b02:	29 87       	std	Y+9, r18	; 0x09
     b04:	3a 87       	std	Y+10, r19	; 0x0a
		
		_max = 1600;
     b06:	04 97       	sbiw	r24, 0x04	; 4
     b08:	8b 87       	std	Y+11, r24	; 0x0b
     b0a:	9c 87       	std	Y+12, r25	; 0x0c
		_min = -1600;
     b0c:	16 97       	sbiw	r26, 0x06	; 6
     b0e:	ad 87       	std	Y+13, r26	; 0x0d
     b10:	be 87       	std	Y+14, r27	; 0x0e
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
     b12:	48 01       	movw	r8, r16
     b14:	b6 e6       	ldi	r27, 0x66	; 102
     b16:	8b 0e       	add	r8, r27
     b18:	91 1c       	adc	r9, r1
	int16_t omegam_saturation_point;
	int16_t K_position_antiwind = 0*256;				// position anti windup gain
	
	while(1){
		// Increment counter for debugging
		runs++;
     b1a:	f8 01       	movw	r30, r16
     b1c:	46 85       	ldd	r20, Z+14	; 0x0e
     b1e:	57 85       	ldd	r21, Z+15	; 0x0f
     b20:	60 89       	ldd	r22, Z+16	; 0x10
     b22:	71 89       	ldd	r23, Z+17	; 0x11
     b24:	4f 5f       	subi	r20, 0xFF	; 255
     b26:	5f 4f       	sbci	r21, 0xFF	; 255
     b28:	6f 4f       	sbci	r22, 0xFF	; 255
     b2a:	7f 4f       	sbci	r23, 0xFF	; 255
     b2c:	46 87       	std	Z+14, r20	; 0x0e
     b2e:	57 87       	std	Z+15, r21	; 0x0f
     b30:	60 8b       	std	Z+16, r22	; 0x10
     b32:	71 8b       	std	Z+17, r23	; 0x11
		
		switch (state)
     b34:	84 85       	ldd	r24, Z+12	; 0x0c
     b36:	82 30       	cpi	r24, 0x02	; 2
     b38:	09 f4       	brne	.+2      	; 0xb3c <_ZN5Motor3runEv+0x10a>
     b3a:	99 c0       	rjmp	.+306    	; 0xc6e <_ZN5Motor3runEv+0x23c>
     b3c:	30 f4       	brcc	.+12     	; 0xb4a <_ZN5Motor3runEv+0x118>
     b3e:	88 23       	and	r24, r24
     b40:	69 f0       	breq	.+26     	; 0xb5c <_ZN5Motor3runEv+0x12a>
     b42:	81 30       	cpi	r24, 0x01	; 1
     b44:	09 f4       	brne	.+2      	; 0xb48 <_ZN5Motor3runEv+0x116>
     b46:	58 c0       	rjmp	.+176    	; 0xbf8 <_ZN5Motor3runEv+0x1c6>
     b48:	cb c1       	rjmp	.+918    	; 0xee0 <_ZN5Motor3runEv+0x4ae>
     b4a:	84 30       	cpi	r24, 0x04	; 4
     b4c:	09 f4       	brne	.+2      	; 0xb50 <_ZN5Motor3runEv+0x11e>
     b4e:	07 c1       	rjmp	.+526    	; 0xd5e <_ZN5Motor3runEv+0x32c>
     b50:	08 f4       	brcc	.+2      	; 0xb54 <_ZN5Motor3runEv+0x122>
     b52:	a1 c0       	rjmp	.+322    	; 0xc96 <_ZN5Motor3runEv+0x264>
     b54:	84 36       	cpi	r24, 0x64	; 100
     b56:	09 f4       	brne	.+2      	; 0xb5a <_ZN5Motor3runEv+0x128>
     b58:	8f c1       	rjmp	.+798    	; 0xe78 <_ZN5Motor3runEv+0x446>
     b5a:	c2 c1       	rjmp	.+900    	; 0xee0 <_ZN5Motor3runEv+0x4ae>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b5c:	0f b6       	in	r0, 0x3f	; 63
     b5e:	f8 94       	cli
     b60:	0f 92       	push	r0
			the_data = new_data;
     b62:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <linear_offset>
     b66:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     b6a:	0f 90       	pop	r0
     b6c:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b6e:	0f b6       	in	r0, 0x3f	; 63
     b70:	f8 94       	cli
     b72:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b74:	0f 90       	pop	r0
     b76:	0f be       	out	0x3f, r0	; 63
		{
			// Home right
			case(0) :
				linear_offset.put(0);										// re initialize
				if (begin.get())											// If user begins Calibration Sequence
     b78:	80 91 49 31 	lds	r24, 0x3149	; 0x803149 <begin>
     b7c:	88 23       	and	r24, r24
     b7e:	09 f4       	brne	.+2      	; 0xb82 <_ZN5Motor3runEv+0x150>
     b80:	af c1       	rjmp	.+862    	; 0xee0 <_ZN5Motor3runEv+0x4ae>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b82:	0f b6       	in	r0, 0x3f	; 63
     b84:	f8 94       	cli
     b86:	0f 92       	push	r0
			the_data = new_data;
     b88:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <reset>
			portEXIT_CRITICAL ();
     b8c:	0f 90       	pop	r0
     b8e:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b90:	0f b6       	in	r0, 0x3f	; 63
     b92:	f8 94       	cli
     b94:	0f 92       	push	r0
			the_data = new_data;
     b96:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <stop>
			portEXIT_CRITICAL ();
     b9a:	0f 90       	pop	r0
     b9c:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);											// turn off flag
					stop.put(0);
					omegam_set = 10;	// [ticks/ms]
     b9e:	f8 01       	movw	r30, r16
     ba0:	22 8e       	std	Z+26, r2	; 0x1a
     ba2:	33 8e       	std	Z+27, r3	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ba4:	0f b6       	in	r0, 0x3f	; 63
     ba6:	f8 94       	cli
     ba8:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     baa:	0f 90       	pop	r0
     bac:	0f be       	out	0x3f, r0	; 63

					if (rightLimitSwitch.get())
     bae:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rightLimitSwitch>
     bb2:	88 23       	and	r24, r24
     bb4:	09 f4       	brne	.+2      	; 0xbb8 <_ZN5Motor3runEv+0x186>
     bb6:	94 c1       	rjmp	.+808    	; 0xee0 <_ZN5Motor3runEv+0x4ae>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     bb8:	0f b6       	in	r0, 0x3f	; 63
     bba:	f8 94       	cli
     bbc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     bbe:	0f 90       	pop	r0
     bc0:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     bc2:	0f b6       	in	r0, 0x3f	; 63
     bc4:	f8 94       	cli
     bc6:	0f 92       	push	r0
			the_data = new_data;
     bc8:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <linear_position>
     bcc:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <linear_position+0x1>
     bd0:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <linear_offset>
     bd4:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <linear_offset+0x1>
			portEXIT_CRITICAL ();
     bd8:	0f 90       	pop	r0
     bda:	0f be       	out	0x3f, r0	; 63
					{
						linear_offset.put(linear_position.get());			// set the offset
						_integral = 0;
     bdc:	d5 01       	movw	r26, r10
     bde:	1d 92       	st	X+, r1
     be0:	1d 92       	st	X+, r1
     be2:	1d 92       	st	X+, r1
     be4:	1c 92       	st	X, r1
     be6:	13 97       	sbiw	r26, 0x03	; 3
						output_correct = 0;
     be8:	f6 01       	movw	r30, r12
     bea:	10 82       	st	Z, r1
     bec:	11 82       	std	Z+1, r1	; 0x01
						transition_to(1);									// if right Limit Switch is triggered 
     bee:	61 e0       	ldi	r22, 0x01	; 1
     bf0:	c8 01       	movw	r24, r16
     bf2:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <_ZN8frt_task13transition_toEh>
     bf6:	74 c1       	rjmp	.+744    	; 0xee0 <_ZN5Motor3runEv+0x4ae>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     bf8:	0f b6       	in	r0, 0x3f	; 63
     bfa:	f8 94       	cli
     bfc:	0f 92       	push	r0
			the_data = new_data;
     bfe:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <begin>
			portEXIT_CRITICAL ();
     c02:	0f 90       	pop	r0
     c04:	0f be       	out	0x3f, r0	; 63
				break;
				
			// Home left
			case(1) :
				begin.put(0);		// turn off flag
				omegam_set = -10;	// [ticks/ms]
     c06:	86 ef       	ldi	r24, 0xF6	; 246
     c08:	9f ef       	ldi	r25, 0xFF	; 255
     c0a:	82 8f       	std	Z+26, r24	; 0x1a
     c0c:	93 8f       	std	Z+27, r25	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c0e:	0f b6       	in	r0, 0x3f	; 63
     c10:	f8 94       	cli
     c12:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c14:	0f 90       	pop	r0
     c16:	0f be       	out	0x3f, r0	; 63
				
				if (leftLimitSwitch.get())
     c18:	80 91 4d 31 	lds	r24, 0x314D	; 0x80314d <leftLimitSwitch>
     c1c:	88 23       	and	r24, r24
     c1e:	c1 f0       	breq	.+48     	; 0xc50 <_ZN5Motor3runEv+0x21e>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c20:	0f b6       	in	r0, 0x3f	; 63
     c22:	f8 94       	cli
     c24:	0f 92       	push	r0
			temporary_copy = the_data;
     c26:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <linear_position>
     c2a:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <linear_position+0x1>
     c2e:	ef 8b       	std	Y+23, r30	; 0x17
     c30:	f8 8f       	std	Y+24, r31	; 0x18
			portEXIT_CRITICAL ();
     c32:	0f 90       	pop	r0
     c34:	0f be       	out	0x3f, r0	; 63
				{
					left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     c36:	d5 01       	movw	r26, r10
     c38:	1d 92       	st	X+, r1
     c3a:	1d 92       	st	X+, r1
     c3c:	1d 92       	st	X+, r1
     c3e:	1c 92       	st	X, r1
     c40:	13 97       	sbiw	r26, 0x03	; 3
					output_correct = 0;
     c42:	f6 01       	movw	r30, r12
     c44:	10 82       	st	Z, r1
     c46:	11 82       	std	Z+1, r1	; 0x01
					transition_to(2);									// if left limit switch is triggered
     c48:	62 e0       	ldi	r22, 0x02	; 2
     c4a:	c8 01       	movw	r24, r16
     c4c:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c50:	0f b6       	in	r0, 0x3f	; 63
     c52:	f8 94       	cli
     c54:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c56:	0f 90       	pop	r0
     c58:	0f be       	out	0x3f, r0	; 63
				}
						
				if (reset.get() == 1)
     c5a:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     c5e:	88 23       	and	r24, r24
     c60:	09 f4       	brne	.+2      	; 0xc64 <_ZN5Motor3runEv+0x232>
     c62:	3e c1       	rjmp	.+636    	; 0xee0 <_ZN5Motor3runEv+0x4ae>
				{
					transition_to(0);
     c64:	60 e0       	ldi	r22, 0x00	; 0
     c66:	c8 01       	movw	r24, r16
     c68:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <_ZN8frt_task13transition_toEh>
     c6c:	39 c1       	rjmp	.+626    	; 0xee0 <_ZN5Motor3runEv+0x4ae>
		 *  @param milliseconds The number of milliseconds to delay
		 */
		void delay_ms (portTickType milliseconds)
		{
			portTickType duration = configMS_TO_TICKS (milliseconds);
			vTaskDelay (duration);
     c6e:	64 ef       	ldi	r22, 0xF4	; 244
     c70:	71 e0       	ldi	r23, 0x01	; 1
     c72:	80 e0       	ldi	r24, 0x00	; 0
     c74:	90 e0       	ldi	r25, 0x00	; 0
     c76:	0e 94 9d 15 	call	0x2b3a	; 0x2b3a <vTaskDelay>
				break;
			
			// Delay loop 
			case (2) :
				delay_ms(500);
				_integral = 0;
     c7a:	d5 01       	movw	r26, r10
     c7c:	1d 92       	st	X+, r1
     c7e:	1d 92       	st	X+, r1
     c80:	1d 92       	st	X+, r1
     c82:	1c 92       	st	X, r1
     c84:	13 97       	sbiw	r26, 0x03	; 3
				omegam_set = 0;
     c86:	f8 01       	movw	r30, r16
     c88:	12 8e       	std	Z+26, r1	; 0x1a
     c8a:	13 8e       	std	Z+27, r1	; 0x1b
				transition_to(3);
     c8c:	63 e0       	ldi	r22, 0x03	; 3
     c8e:	c8 01       	movw	r24, r16
     c90:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <_ZN8frt_task13transition_toEh>
				break;
     c94:	25 c1       	rjmp	.+586    	; 0xee0 <_ZN5Motor3runEv+0x4ae>
				
			
			// Center Cart - Position Loop included
			case(3) :
				position_midpoint = left_home/2;
     c96:	8f 89       	ldd	r24, Y+23	; 0x17
     c98:	98 8d       	ldd	r25, Y+24	; 0x18
     c9a:	99 23       	and	r25, r25
     c9c:	0c f4       	brge	.+2      	; 0xca0 <_ZN5Motor3runEv+0x26e>
     c9e:	01 96       	adiw	r24, 0x01	; 1
     ca0:	9c 01       	movw	r18, r24
     ca2:	35 95       	asr	r19
     ca4:	27 95       	ror	r18
     ca6:	2d 8b       	std	Y+21, r18	; 0x15
     ca8:	3e 8b       	std	Y+22, r19	; 0x16
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     caa:	0f b6       	in	r0, 0x3f	; 63
     cac:	f8 94       	cli
     cae:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cb0:	0f 90       	pop	r0
     cb2:	0f be       	out	0x3f, r0	; 63
				
				position_error_windup = position_error - antiwind_pos_correct;			// Subtracts omegam_set windup
				position_windup_integral = (_Ki_position * position_error_windup);	// Integral gain on omegam_set windup difference
				//position_windup_Ki = (_Ki_position * position_error);
				omegam_set_Ki += (position_windup_integral * dt)/256;						// Integrates omegam_set windup difference with gain
				omegam_set_windup = ssadd(omegam_set_Kp, omegam_set_Ki);					// Add proportionality and integral gain
     cb4:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <linear_position>
     cb8:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <linear_position+0x1>
     cbc:	28 1b       	sub	r18, r24
     cbe:	39 0b       	sbc	r19, r25
     cc0:	c9 01       	movw	r24, r18
     cc2:	36 95       	lsr	r19
     cc4:	32 2f       	mov	r19, r18
     cc6:	22 27       	eor	r18, r18
     cc8:	37 95       	ror	r19
     cca:	27 95       	ror	r18
     ccc:	90 ff       	sbrs	r25, 0
     cce:	02 c0       	rjmp	.+4      	; 0xcd4 <_ZN5Motor3runEv+0x2a2>
     cd0:	21 50       	subi	r18, 0x01	; 1
     cd2:	3f 4f       	sbci	r19, 0xFF	; 255
     cd4:	60 e0       	ldi	r22, 0x00	; 0
     cd6:	70 e0       	ldi	r23, 0x00	; 0
     cd8:	83 2f       	mov	r24, r19
     cda:	93 2f       	mov	r25, r19
     cdc:	99 0f       	add	r25, r25
     cde:	99 0b       	sbc	r25, r25
     ce0:	0e 94 49 09 	call	0x1292	; 0x1292 <_ZN7satmath20signed_saturated_addEii>
				omegam_set = omegam_set_windup;												// Set desired to requested
				
				omegam_saturation_point = 40;
				if( omegam_set > omegam_saturation_point )														// Saturate requested omegam_set
     ce4:	89 32       	cpi	r24, 0x29	; 41
     ce6:	91 05       	cpc	r25, r1
     ce8:	44 f0       	brlt	.+16     	; 0xcfa <_ZN5Motor3runEv+0x2c8>
				{
					omegam_set = omegam_saturation_point;
     cea:	88 e2       	ldi	r24, 0x28	; 40
     cec:	90 e0       	ldi	r25, 0x00	; 0
     cee:	d8 01       	movw	r26, r16
     cf0:	5a 96       	adiw	r26, 0x1a	; 26
     cf2:	8d 93       	st	X+, r24
     cf4:	9c 93       	st	X, r25
     cf6:	5b 97       	sbiw	r26, 0x1b	; 27
     cf8:	0f c0       	rjmp	.+30     	; 0xd18 <_ZN5Motor3runEv+0x2e6>
				}
				else if( omegam_set < -omegam_saturation_point )
     cfa:	88 3d       	cpi	r24, 0xD8	; 216
     cfc:	bf ef       	ldi	r27, 0xFF	; 255
     cfe:	9b 07       	cpc	r25, r27
     d00:	24 f0       	brlt	.+8      	; 0xd0a <_ZN5Motor3runEv+0x2d8>
				position_error_windup = position_error - antiwind_pos_correct;			// Subtracts omegam_set windup
				position_windup_integral = (_Ki_position * position_error_windup);	// Integral gain on omegam_set windup difference
				//position_windup_Ki = (_Ki_position * position_error);
				omegam_set_Ki += (position_windup_integral * dt)/256;						// Integrates omegam_set windup difference with gain
				omegam_set_windup = ssadd(omegam_set_Kp, omegam_set_Ki);					// Add proportionality and integral gain
				omegam_set = omegam_set_windup;												// Set desired to requested
     d02:	f8 01       	movw	r30, r16
     d04:	82 8f       	std	Z+26, r24	; 0x1a
     d06:	93 8f       	std	Z+27, r25	; 0x1b
     d08:	07 c0       	rjmp	.+14     	; 0xd18 <_ZN5Motor3runEv+0x2e6>
				{
					omegam_set = omegam_saturation_point;
				}
				else if( omegam_set < -omegam_saturation_point )
				{
					omegam_set = -omegam_saturation_point;
     d0a:	88 ed       	ldi	r24, 0xD8	; 216
     d0c:	9f ef       	ldi	r25, 0xFF	; 255
     d0e:	d8 01       	movw	r26, r16
     d10:	5a 96       	adiw	r26, 0x1a	; 26
     d12:	8d 93       	st	X+, r24
     d14:	9c 93       	st	X, r25
     d16:	5b 97       	sbiw	r26, 0x1b	; 27
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d18:	0f b6       	in	r0, 0x3f	; 63
     d1a:	f8 94       	cli
     d1c:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d1e:	0f 90       	pop	r0
     d20:	0f be       	out	0x3f, r0	; 63
				}
				
				antiwind_position = omegam_set_windup - omegam_set;					// Calculate windup error between desired and requested
				antiwind_pos_correct = (antiwind_error*K_position_antiwind)/256;
				
				if (reset.get() == 1)			// if user hits reset
     d22:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     d26:	88 23       	and	r24, r24
     d28:	59 f0       	breq	.+22     	; 0xd40 <_ZN5Motor3runEv+0x30e>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     d2a:	0f b6       	in	r0, 0x3f	; 63
     d2c:	f8 94       	cli
     d2e:	0f 92       	push	r0
			the_data = new_data;
     d30:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <reset>
			portEXIT_CRITICAL ();
     d34:	0f 90       	pop	r0
     d36:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);				// turn off flag
					transition_to(0);
     d38:	60 e0       	ldi	r22, 0x00	; 0
     d3a:	c8 01       	movw	r24, r16
     d3c:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d40:	0f b6       	in	r0, 0x3f	; 63
     d42:	f8 94       	cli
     d44:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d46:	0f 90       	pop	r0
     d48:	0f be       	out	0x3f, r0	; 63
					
				}
				
				if(go.get() == 1)				// If user says pendulum is upright or angle = 720;
     d4a:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <go>
     d4e:	88 23       	and	r24, r24
     d50:	09 f4       	brne	.+2      	; 0xd54 <_ZN5Motor3runEv+0x322>
     d52:	c6 c0       	rjmp	.+396    	; 0xee0 <_ZN5Motor3runEv+0x4ae>
				{
					transition_to(4);
     d54:	64 e0       	ldi	r22, 0x04	; 4
     d56:	c8 01       	movw	r24, r16
     d58:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <_ZN8frt_task13transition_toEh>
     d5c:	c1 c0       	rjmp	.+386    	; 0xee0 <_ZN5Motor3runEv+0x4ae>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     d5e:	0f b6       	in	r0, 0x3f	; 63
     d60:	f8 94       	cli
     d62:	0f 92       	push	r0
			the_data = new_data;
     d64:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <go>
			portEXIT_CRITICAL ();
     d68:	0f 90       	pop	r0
     d6a:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d6c:	0f b6       	in	r0, 0x3f	; 63
     d6e:	f8 94       	cli
     d70:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d72:	0f 90       	pop	r0
     d74:	0f be       	out	0x3f, r0	; 63
			break;
			
			// Pendulum Balance if user sets pendulum "Inverted" and presses go
			case(4) :
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
     d76:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <thPendulum>
     d7a:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <thPendulum+0x1>
     d7e:	20 ed       	ldi	r18, 0xD0	; 208
     d80:	32 e0       	ldi	r19, 0x02	; 2
     d82:	79 01       	movw	r14, r18
     d84:	e8 1a       	sub	r14, r24
     d86:	f9 0a       	sbc	r15, r25
				
				// Derivative term
				angle_derivative = (angle_error-_pre_angle_error) / dt;
				_pre_angle_error = angle_error;
				angle_Dout = (_Kd_angle * angle_derivative)/256;
     d88:	b7 01       	movw	r22, r14
     d8a:	e9 8d       	ldd	r30, Y+25	; 0x19
     d8c:	fa 8d       	ldd	r31, Y+26	; 0x1a
     d8e:	6e 1b       	sub	r22, r30
     d90:	7f 0b       	sbc	r23, r31
     d92:	07 2e       	mov	r0, r23
     d94:	00 0c       	add	r0, r0
     d96:	88 0b       	sbc	r24, r24
     d98:	99 0b       	sbc	r25, r25
     d9a:	ad 81       	ldd	r26, Y+5	; 0x05
     d9c:	be 81       	ldd	r27, Y+6	; 0x06
     d9e:	2d 91       	ld	r18, X+
     da0:	3d 91       	ld	r19, X+
     da2:	4d 91       	ld	r20, X+
     da4:	5c 91       	ld	r21, X
     da6:	0e 94 ba 22 	call	0x4574	; 0x4574 <__divmodsi4>
     daa:	67 ee       	ldi	r22, 0xE7	; 231
     dac:	62 03       	mulsu	r22, r18
     dae:	c0 01       	movw	r24, r0
     db0:	63 9f       	mul	r22, r19
     db2:	90 0d       	add	r25, r0
     db4:	11 24       	eor	r1, r1
     db6:	99 23       	and	r25, r25
     db8:	14 f4       	brge	.+4      	; 0xdbe <_ZN5Motor3runEv+0x38c>
     dba:	81 50       	subi	r24, 0x01	; 1
     dbc:	9f 4f       	sbci	r25, 0xFF	; 255
     dbe:	79 2f       	mov	r23, r25
     dc0:	77 0f       	add	r23, r23
     dc2:	77 0b       	sbc	r23, r23
     dc4:	69 2f       	mov	r22, r25

				output_correct = output;
     dc6:	ef 85       	ldd	r30, Y+15	; 0x0f
     dc8:	f8 89       	ldd	r31, Y+16	; 0x10
     dca:	80 81       	ld	r24, Z
     dcc:	91 81       	ldd	r25, Z+1	; 0x01
     dce:	d6 01       	movw	r26, r12
     dd0:	8d 93       	st	X+, r24
     dd2:	9c 93       	st	X, r25
				Pang_out = position_midpoint + (angle_error*KP_angle)/256;
				
				// Calculate total output
				position_set = ssadd(Pang_out, angle_Dout);
     dd4:	2a e1       	ldi	r18, 0x1A	; 26
     dd6:	3c ef       	ldi	r19, 0xFC	; 252
     dd8:	e2 9e       	mul	r14, r18
     dda:	c0 01       	movw	r24, r0
     ddc:	e3 9e       	mul	r14, r19
     dde:	90 0d       	add	r25, r0
     de0:	f2 9e       	mul	r15, r18
     de2:	90 0d       	add	r25, r0
     de4:	11 24       	eor	r1, r1
     de6:	99 23       	and	r25, r25
     de8:	14 f4       	brge	.+4      	; 0xdee <_ZN5Motor3runEv+0x3bc>
     dea:	81 50       	subi	r24, 0x01	; 1
     dec:	9f 4f       	sbci	r25, 0xFF	; 255
     dee:	89 2f       	mov	r24, r25
     df0:	99 0f       	add	r25, r25
     df2:	99 0b       	sbc	r25, r25
     df4:	ed 89       	ldd	r30, Y+21	; 0x15
     df6:	fe 89       	ldd	r31, Y+22	; 0x16
     df8:	8e 0f       	add	r24, r30
     dfa:	9f 1f       	adc	r25, r31
     dfc:	0e 94 49 09 	call	0x1292	; 0x1292 <_ZN7satmath20signed_saturated_addEii>
				
				// Saturation for limits of tracks
				
				if (position_set >= -150) //20
     e00:	8a 36       	cpi	r24, 0x6A	; 106
     e02:	ff ef       	ldi	r31, 0xFF	; 255
     e04:	9f 07       	cpc	r25, r31
     e06:	3c f4       	brge	.+14     	; 0xe16 <_ZN5Motor3runEv+0x3e4>
				{
					position_set = -150;
					omegam_set = 0;
				}
				else if (position_set <= -250) //325
     e08:	87 30       	cpi	r24, 0x07	; 7
     e0a:	2f ef       	ldi	r18, 0xFF	; 255
     e0c:	92 07       	cpc	r25, r18
     e0e:	2c f4       	brge	.+10     	; 0xe1a <_ZN5Motor3runEv+0x3e8>
				{
					position_set = -250; //352
     e10:	86 e0       	ldi	r24, 0x06	; 6
     e12:	9f ef       	ldi	r25, 0xFF	; 255
     e14:	02 c0       	rjmp	.+4      	; 0xe1a <_ZN5Motor3runEv+0x3e8>
				
				// Saturation for limits of tracks
				
				if (position_set >= -150) //20
				{
					position_set = -150;
     e16:	8a e6       	ldi	r24, 0x6A	; 106
     e18:	9f ef       	ldi	r25, 0xFF	; 255
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e1a:	0f b6       	in	r0, 0x3f	; 63
     e1c:	f8 94       	cli
     e1e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     e20:	0f 90       	pop	r0
     e22:	0f be       	out	0x3f, r0	; 63
					position_set = position_set;
				}
				
				position_error = position_set - linear_position.get();  // 
				omegam_set_windup = position_error*KP_pos/256;
				omegam_set = omegam_set_windup;
     e24:	20 91 52 31 	lds	r18, 0x3152	; 0x803152 <linear_position>
     e28:	30 91 53 31 	lds	r19, 0x3153	; 0x803153 <linear_position+0x1>
     e2c:	82 1b       	sub	r24, r18
     e2e:	93 0b       	sbc	r25, r19
     e30:	9c 01       	movw	r18, r24
     e32:	36 95       	lsr	r19
     e34:	32 2f       	mov	r19, r18
     e36:	22 27       	eor	r18, r18
     e38:	37 95       	ror	r19
     e3a:	27 95       	ror	r18
     e3c:	90 ff       	sbrs	r25, 0
     e3e:	02 c0       	rjmp	.+4      	; 0xe44 <_ZN5Motor3runEv+0x412>
     e40:	21 50       	subi	r18, 0x01	; 1
     e42:	3f 4f       	sbci	r19, 0xFF	; 255
     e44:	83 2f       	mov	r24, r19
     e46:	88 0f       	add	r24, r24
     e48:	88 0b       	sbc	r24, r24
     e4a:	d8 01       	movw	r26, r16
     e4c:	5a 96       	adiw	r26, 0x1a	; 26
     e4e:	3c 93       	st	X, r19
     e50:	5a 97       	sbiw	r26, 0x1a	; 26
     e52:	5b 96       	adiw	r26, 0x1b	; 27
     e54:	8c 93       	st	X, r24
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     e56:	0f b6       	in	r0, 0x3f	; 63
     e58:	f8 94       	cli
     e5a:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     e5c:	0f 90       	pop	r0
     e5e:	0f be       	out	0x3f, r0	; 63
				
				if (reset.get())
     e60:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     e64:	88 23       	and	r24, r24
     e66:	09 f4       	brne	.+2      	; 0xe6a <_ZN5Motor3runEv+0x438>
     e68:	39 c0       	rjmp	.+114    	; 0xedc <_ZN5Motor3runEv+0x4aa>
				{
					transition_to(0);
     e6a:	60 e0       	ldi	r22, 0x00	; 0
     e6c:	c8 01       	movw	r24, r16
     e6e:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <_ZN8frt_task13transition_toEh>
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				
				// Derivative term
				angle_derivative = (angle_error-_pre_angle_error) / dt;
				_pre_angle_error = angle_error;
     e72:	e9 8e       	std	Y+25, r14	; 0x19
     e74:	fa 8e       	std	Y+26, r15	; 0x1a
     e76:	34 c0       	rjmp	.+104    	; 0xee0 <_ZN5Motor3runEv+0x4ae>
				}
					
			break;
			
			case(100) :
			omegam_set = 0;
     e78:	f8 01       	movw	r30, r16
     e7a:	12 8e       	std	Z+26, r1	; 0x1a
     e7c:	13 8e       	std	Z+27, r1	; 0x1b
			
			if (runs%300 == 0)
     e7e:	cb 01       	movw	r24, r22
     e80:	ba 01       	movw	r22, r20
     e82:	2c e2       	ldi	r18, 0x2C	; 44
     e84:	31 e0       	ldi	r19, 0x01	; 1
     e86:	40 e0       	ldi	r20, 0x00	; 0
     e88:	50 e0       	ldi	r21, 0x00	; 0
     e8a:	0e 94 98 22 	call	0x4530	; 0x4530 <__udivmodsi4>
     e8e:	67 2b       	or	r22, r23
     e90:	68 2b       	or	r22, r24
     e92:	69 2b       	or	r22, r25
     e94:	71 f4       	brne	.+28     	; 0xeb2 <_ZN5Motor3runEv+0x480>
			{
				*p_serial << "Error State" << endl;
     e96:	d8 01       	movw	r26, r16
     e98:	16 96       	adiw	r26, 0x06	; 6
     e9a:	ed 90       	ld	r14, X+
     e9c:	fc 90       	ld	r15, X
     e9e:	17 97       	sbiw	r26, 0x07	; 7
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     ea0:	6e e1       	ldi	r22, 0x1E	; 30
     ea2:	70 e2       	ldi	r23, 0x20	; 32
     ea4:	c7 01       	movw	r24, r14
     ea6:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
     eaa:	66 e0       	ldi	r22, 0x06	; 6
     eac:	c7 01       	movw	r24, r14
     eae:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     eb2:	0f b6       	in	r0, 0x3f	; 63
     eb4:	f8 94       	cli
     eb6:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     eb8:	0f 90       	pop	r0
     eba:	0f be       	out	0x3f, r0	; 63
			}
			
				if (reset.get())										// if user hits reset
     ebc:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <reset>
     ec0:	88 23       	and	r24, r24
     ec2:	71 f0       	breq	.+28     	; 0xee0 <_ZN5Motor3runEv+0x4ae>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     ec4:	0f b6       	in	r0, 0x3f	; 63
     ec6:	f8 94       	cli
     ec8:	0f 92       	push	r0
			the_data = new_data;
     eca:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <reset>
			portEXIT_CRITICAL ();
     ece:	0f 90       	pop	r0
     ed0:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);
					transition_to(0);
     ed2:	60 e0       	ldi	r22, 0x00	; 0
     ed4:	c8 01       	movw	r24, r16
     ed6:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <_ZN8frt_task13transition_toEh>
     eda:	02 c0       	rjmp	.+4      	; 0xee0 <_ZN5Motor3runEv+0x4ae>
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				
				// Derivative term
				angle_derivative = (angle_error-_pre_angle_error) / dt;
				_pre_angle_error = angle_error;
     edc:	e9 8e       	std	Y+25, r14	; 0x19
     ede:	fa 8e       	std	Y+26, r15	; 0x1a
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ee0:	0f b6       	in	r0, 0x3f	; 63
     ee2:	f8 94       	cli
     ee4:	0f 92       	push	r0
			temporary_copy = the_data;
     ee6:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <thdMotor>
     eea:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     eee:	0f 90       	pop	r0
     ef0:	0f be       	out	0x3f, r0	; 63
		
		};

		
		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     ef2:	f8 01       	movw	r30, r16
     ef4:	86 8f       	std	Z+30, r24	; 0x1e
     ef6:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     ef8:	a9 89       	ldd	r26, Y+17	; 0x11
     efa:	ba 89       	ldd	r27, Y+18	; 0x12
     efc:	2d 92       	st	X+, r2
     efe:	3c 92       	st	X, r3
		_Ki = .7*256;
     f00:	23 eb       	ldi	r18, 0xB3	; 179
     f02:	30 e0       	ldi	r19, 0x00	; 0
     f04:	ef 81       	ldd	r30, Y+7	; 0x07
     f06:	f8 85       	ldd	r31, Y+8	; 0x08
     f08:	20 83       	st	Z, r18
     f0a:	31 83       	std	Z+1, r19	; 0x01
		_Kd = 0;
     f0c:	ab 89       	ldd	r26, Y+19	; 0x13
     f0e:	bc 89       	ldd	r27, Y+20	; 0x14
     f10:	1d 92       	st	X+, r1
     f12:	1c 92       	st	X, r1
		antiwind_gain = .75*256;
     f14:	20 ec       	ldi	r18, 0xC0	; 192
     f16:	30 e0       	ldi	r19, 0x00	; 0
     f18:	e9 85       	ldd	r30, Y+9	; 0x09
     f1a:	fa 85       	ldd	r31, Y+10	; 0x0a
     f1c:	20 83       	st	Z, r18
     f1e:	31 83       	std	Z+1, r19	; 0x01
		
		_max = 1600;
     f20:	20 e4       	ldi	r18, 0x40	; 64
     f22:	36 e0       	ldi	r19, 0x06	; 6
     f24:	ab 85       	ldd	r26, Y+11	; 0x0b
     f26:	bc 85       	ldd	r27, Y+12	; 0x0c
     f28:	2d 93       	st	X+, r18
     f2a:	3c 93       	st	X, r19
		_min = -1600;
     f2c:	20 ec       	ldi	r18, 0xC0	; 192
     f2e:	39 ef       	ldi	r19, 0xF9	; 249
     f30:	ed 85       	ldd	r30, Y+13	; 0x0d
     f32:	fe 85       	ldd	r31, Y+14	; 0x0e
     f34:	20 83       	st	Z, r18
     f36:	31 83       	std	Z+1, r19	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     f38:	d8 01       	movw	r26, r16
     f3a:	5a 96       	adiw	r26, 0x1a	; 26
     f3c:	ed 90       	ld	r14, X+
     f3e:	fc 90       	ld	r15, X
     f40:	5b 97       	sbiw	r26, 0x1b	; 27
     f42:	e8 1a       	sub	r14, r24
     f44:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     f46:	b7 01       	movw	r22, r14
     f48:	c1 01       	movw	r24, r2
     f4a:	0e 94 65 09 	call	0x12ca	; 0x12ca <_ZN7satmath20signed_saturated_mulEii>
     f4e:	2b 01       	movw	r4, r22
     f50:	3c 01       	movw	r6, r24
     f52:	f8 01       	movw	r30, r16
     f54:	e4 5a       	subi	r30, 0xA4	; 164
     f56:	ff 4f       	sbci	r31, 0xFF	; 255
     f58:	60 83       	st	Z, r22
     f5a:	71 83       	std	Z+1, r23	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     f5c:	f4 01       	movw	r30, r8
     f5e:	80 81       	ld	r24, Z
     f60:	91 81       	ldd	r25, Z+1	; 0x01
     f62:	97 01       	movw	r18, r14
     f64:	28 1b       	sub	r18, r24
     f66:	39 0b       	sbc	r19, r25
     f68:	c9 01       	movw	r24, r18
     f6a:	f8 01       	movw	r30, r16
     f6c:	e8 59       	subi	r30, 0x98	; 152
     f6e:	ff 4f       	sbci	r31, 0xFF	; 255
     f70:	20 83       	st	Z, r18
     f72:	31 83       	std	Z+1, r19	; 0x01
		error_int_gain = (_Ki * error_int);
     f74:	af 81       	ldd	r26, Y+7	; 0x07
     f76:	b8 85       	ldd	r27, Y+8	; 0x08
     f78:	2d 91       	ld	r18, X+
     f7a:	3c 91       	ld	r19, X
     f7c:	82 9f       	mul	r24, r18
     f7e:	d0 01       	movw	r26, r0
     f80:	83 9f       	mul	r24, r19
     f82:	b0 0d       	add	r27, r0
     f84:	92 9f       	mul	r25, r18
     f86:	b0 0d       	add	r27, r0
     f88:	11 24       	eor	r1, r1
     f8a:	32 96       	adiw	r30, 0x02	; 2
     f8c:	a0 83       	st	Z, r26
     f8e:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     f90:	ed 81       	ldd	r30, Y+5	; 0x05
     f92:	fe 81       	ldd	r31, Y+6	; 0x06
     f94:	20 81       	ld	r18, Z
     f96:	31 81       	ldd	r19, Z+1	; 0x01
     f98:	42 81       	ldd	r20, Z+2	; 0x02
     f9a:	53 81       	ldd	r21, Z+3	; 0x03
     f9c:	0e 94 0b 23 	call	0x4616	; 0x4616 <__mulshisi3>
     fa0:	9b 01       	movw	r18, r22
     fa2:	ac 01       	movw	r20, r24
     fa4:	99 23       	and	r25, r25
     fa6:	24 f4       	brge	.+8      	; 0xfb0 <_ZN5Motor3runEv+0x57e>
     fa8:	21 50       	subi	r18, 0x01	; 1
     faa:	3f 4f       	sbci	r19, 0xFF	; 255
     fac:	4f 4f       	sbci	r20, 0xFF	; 255
     fae:	5f 4f       	sbci	r21, 0xFF	; 255
     fb0:	bb 27       	eor	r27, r27
     fb2:	57 fd       	sbrc	r21, 7
     fb4:	ba 95       	dec	r27
     fb6:	a5 2f       	mov	r26, r21
     fb8:	94 2f       	mov	r25, r20
     fba:	83 2f       	mov	r24, r19
     fbc:	f5 01       	movw	r30, r10
     fbe:	40 81       	ld	r20, Z
     fc0:	51 81       	ldd	r21, Z+1	; 0x01
     fc2:	62 81       	ldd	r22, Z+2	; 0x02
     fc4:	73 81       	ldd	r23, Z+3	; 0x03
     fc6:	84 0f       	add	r24, r20
     fc8:	95 1f       	adc	r25, r21
     fca:	a6 1f       	adc	r26, r22
     fcc:	b7 1f       	adc	r27, r23
		if(_integral > 1000000000)
     fce:	81 30       	cpi	r24, 0x01	; 1
     fd0:	fa ec       	ldi	r31, 0xCA	; 202
     fd2:	9f 07       	cpc	r25, r31
     fd4:	fa e9       	ldi	r31, 0x9A	; 154
     fd6:	af 07       	cpc	r26, r31
     fd8:	fb e3       	ldi	r31, 0x3B	; 59
     fda:	bf 07       	cpc	r27, r31
     fdc:	54 f0       	brlt	.+20     	; 0xff2 <_ZN5Motor3runEv+0x5c0>
		{
			_integral = 1000000000;
     fde:	80 e0       	ldi	r24, 0x00	; 0
     fe0:	9a ec       	ldi	r25, 0xCA	; 202
     fe2:	aa e9       	ldi	r26, 0x9A	; 154
     fe4:	bb e3       	ldi	r27, 0x3B	; 59
     fe6:	f5 01       	movw	r30, r10
     fe8:	80 83       	st	Z, r24
     fea:	91 83       	std	Z+1, r25	; 0x01
     fec:	a2 83       	std	Z+2, r26	; 0x02
     fee:	b3 83       	std	Z+3, r27	; 0x03
     ff0:	17 c0       	rjmp	.+46     	; 0x1020 <_ZN5Motor3runEv+0x5ee>
		}
		else if(_integral < -1000000000)
     ff2:	81 15       	cp	r24, r1
     ff4:	f6 e3       	ldi	r31, 0x36	; 54
     ff6:	9f 07       	cpc	r25, r31
     ff8:	f5 e6       	ldi	r31, 0x65	; 101
     ffa:	af 07       	cpc	r26, r31
     ffc:	f4 ec       	ldi	r31, 0xC4	; 196
     ffe:	bf 07       	cpc	r27, r31
    1000:	34 f0       	brlt	.+12     	; 0x100e <_ZN5Motor3runEv+0x5dc>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
    1002:	f5 01       	movw	r30, r10
    1004:	80 83       	st	Z, r24
    1006:	91 83       	std	Z+1, r25	; 0x01
    1008:	a2 83       	std	Z+2, r26	; 0x02
    100a:	b3 83       	std	Z+3, r27	; 0x03
    100c:	09 c0       	rjmp	.+18     	; 0x1020 <_ZN5Motor3runEv+0x5ee>
		{
			_integral = 1000000000;
		}
		else if(_integral < -1000000000)
		{
			_integral = -1000000000;
    100e:	80 e0       	ldi	r24, 0x00	; 0
    1010:	96 e3       	ldi	r25, 0x36	; 54
    1012:	a5 e6       	ldi	r26, 0x65	; 101
    1014:	b4 ec       	ldi	r27, 0xC4	; 196
    1016:	f5 01       	movw	r30, r10
    1018:	80 83       	st	Z, r24
    101a:	91 83       	std	Z+1, r25	; 0x01
    101c:	a2 83       	std	Z+2, r26	; 0x02
    101e:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
    1020:	d5 01       	movw	r26, r10
    1022:	6d 91       	ld	r22, X+
    1024:	7c 91       	ld	r23, X
    1026:	c2 01       	movw	r24, r4
    1028:	0e 94 49 09 	call	0x1292	; 0x1292 <_ZN7satmath20signed_saturated_addEii>
    102c:	ef 85       	ldd	r30, Y+15	; 0x0f
    102e:	f8 89       	ldd	r31, Y+16	; 0x10
    1030:	80 83       	st	Z, r24
    1032:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
    1034:	d6 01       	movw	r26, r12
    1036:	8d 93       	st	X+, r24
    1038:	9c 93       	st	X, r25
    103a:	11 97       	sbiw	r26, 0x01	; 1
		
		// Restrict to max/min
		if( output_correct > _max )
    103c:	eb 85       	ldd	r30, Y+11	; 0x0b
    103e:	fc 85       	ldd	r31, Y+12	; 0x0c
    1040:	20 81       	ld	r18, Z
    1042:	31 81       	ldd	r19, Z+1	; 0x01
    1044:	28 17       	cp	r18, r24
    1046:	39 07       	cpc	r19, r25
    1048:	1c f4       	brge	.+6      	; 0x1050 <_ZN5Motor3runEv+0x61e>
		{
		output_correct = _max;
    104a:	2d 93       	st	X+, r18
    104c:	3c 93       	st	X, r19
    104e:	0a c0       	rjmp	.+20     	; 0x1064 <_ZN5Motor3runEv+0x632>
		}
		else if( output_correct < _min )
    1050:	ad 85       	ldd	r26, Y+13	; 0x0d
    1052:	be 85       	ldd	r27, Y+14	; 0x0e
    1054:	2d 91       	ld	r18, X+
    1056:	3c 91       	ld	r19, X
    1058:	82 17       	cp	r24, r18
    105a:	93 07       	cpc	r25, r19
    105c:	1c f4       	brge	.+6      	; 0x1064 <_ZN5Motor3runEv+0x632>
		{
		output_correct = _min;
    105e:	f6 01       	movw	r30, r12
    1060:	20 83       	st	Z, r18
    1062:	31 83       	std	Z+1, r19	; 0x01
		}

		// Save error to previous error
		_pre_error = error;
    1064:	f8 01       	movw	r30, r16
    1066:	e2 5b       	subi	r30, 0xB2	; 178
    1068:	ff 4f       	sbci	r31, 0xFF	; 255
    106a:	e0 82       	st	Z, r14
    106c:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
    106e:	d6 01       	movw	r26, r12
    1070:	2d 91       	ld	r18, X+
    1072:	3c 91       	ld	r19, X
    1074:	82 1b       	sub	r24, r18
    1076:	93 0b       	sbc	r25, r19
    1078:	74 96       	adiw	r30, 0x14	; 20
    107a:	80 83       	st	Z, r24
    107c:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
    107e:	e9 85       	ldd	r30, Y+9	; 0x09
    1080:	fa 85       	ldd	r31, Y+10	; 0x0a
    1082:	40 81       	ld	r20, Z
    1084:	51 81       	ldd	r21, Z+1	; 0x01
    1086:	84 9f       	mul	r24, r20
    1088:	90 01       	movw	r18, r0
    108a:	85 9f       	mul	r24, r21
    108c:	30 0d       	add	r19, r0
    108e:	94 9f       	mul	r25, r20
    1090:	30 0d       	add	r19, r0
    1092:	11 24       	eor	r1, r1
    1094:	33 23       	and	r19, r19
    1096:	14 f4       	brge	.+4      	; 0x109c <_ZN5Motor3runEv+0x66a>
    1098:	21 50       	subi	r18, 0x01	; 1
    109a:	3f 4f       	sbci	r19, 0xFF	; 255
    109c:	83 2f       	mov	r24, r19
    109e:	88 0f       	add	r24, r24
    10a0:	88 0b       	sbc	r24, r24
    10a2:	d4 01       	movw	r26, r8
    10a4:	3c 93       	st	X, r19
    10a6:	11 96       	adiw	r26, 0x01	; 1
    10a8:	8c 93       	st	X, r24
		
		
			if(runs%150 == 0){
    10aa:	f8 01       	movw	r30, r16
    10ac:	66 85       	ldd	r22, Z+14	; 0x0e
    10ae:	77 85       	ldd	r23, Z+15	; 0x0f
    10b0:	80 89       	ldd	r24, Z+16	; 0x10
    10b2:	91 89       	ldd	r25, Z+17	; 0x11
    10b4:	26 e9       	ldi	r18, 0x96	; 150
    10b6:	30 e0       	ldi	r19, 0x00	; 0
    10b8:	40 e0       	ldi	r20, 0x00	; 0
    10ba:	50 e0       	ldi	r21, 0x00	; 0
    10bc:	0e 94 98 22 	call	0x4530	; 0x4530 <__udivmodsi4>
    10c0:	67 2b       	or	r22, r23
    10c2:	68 2b       	or	r22, r24
    10c4:	69 2b       	or	r22, r25
    10c6:	61 f4       	brne	.+24     	; 0x10e0 <_ZN5Motor3runEv+0x6ae>
				//*p_serial << "angle error: " << angle_error << endl;
				//*p_serial << "begin flag" << begin.get() << endl;
				//*p_serial << "go flag " << go.get() << endl;
				//*p_serial << "stop flag" << stop.get() << endl;
				//*p_serial << "reset flag " << reset.get() << endl;
				*p_serial << position_midpoint << endl;
    10c8:	6d 89       	ldd	r22, Y+21	; 0x15
    10ca:	7e 89       	ldd	r23, Y+22	; 0x16
    10cc:	d8 01       	movw	r26, r16
    10ce:	16 96       	adiw	r26, 0x06	; 6
    10d0:	8d 91       	ld	r24, X+
    10d2:	9c 91       	ld	r25, X
    10d4:	17 97       	sbiw	r26, 0x07	; 7
    10d6:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <_ZN8emstreamlsEi>
    10da:	66 e0       	ldi	r22, 0x06	; 6
    10dc:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    10e0:	0f b6       	in	r0, 0x3f	; 63
    10e2:	f8 94       	cli
    10e4:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    10e6:	0f 90       	pop	r0
    10e8:	0f be       	out	0x3f, r0	; 63
			}
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get() || stop.get())		// If limit switch or If emergency stop button was hit
    10ea:	80 91 4d 31 	lds	r24, 0x314D	; 0x80314d <leftLimitSwitch>
    10ee:	81 11       	cpse	r24, r1
    10f0:	12 c0       	rjmp	.+36     	; 0x1116 <_ZN5Motor3runEv+0x6e4>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    10f2:	0f b6       	in	r0, 0x3f	; 63
    10f4:	f8 94       	cli
    10f6:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    10f8:	0f 90       	pop	r0
    10fa:	0f be       	out	0x3f, r0	; 63
    10fc:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rightLimitSwitch>
    1100:	81 11       	cpse	r24, r1
    1102:	09 c0       	rjmp	.+18     	; 0x1116 <_ZN5Motor3runEv+0x6e4>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
    1104:	0f b6       	in	r0, 0x3f	; 63
    1106:	f8 94       	cli
    1108:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
    110a:	0f 90       	pop	r0
    110c:	0f be       	out	0x3f, r0	; 63
    110e:	80 91 47 31 	lds	r24, 0x3147	; 0x803147 <stop>
    1112:	88 23       	and	r24, r24
    1114:	89 f0       	breq	.+34     	; 0x1138 <_ZN5Motor3runEv+0x706>
		{
			//omegam_set = 0; // [ticks/ms]
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
    1116:	f5 01       	movw	r30, r10
    1118:	10 82       	st	Z, r1
    111a:	11 82       	std	Z+1, r1	; 0x01
    111c:	12 82       	std	Z+2, r1	; 0x02
    111e:	13 82       	std	Z+3, r1	; 0x03
			output_correct = 0;
    1120:	d6 01       	movw	r26, r12
    1122:	1d 92       	st	X+, r1
    1124:	1c 92       	st	X, r1
			
			if (state == 4 || state == 3)
    1126:	f8 01       	movw	r30, r16
    1128:	84 85       	ldd	r24, Z+12	; 0x0c
    112a:	83 50       	subi	r24, 0x03	; 3
    112c:	82 30       	cpi	r24, 0x02	; 2
    112e:	20 f4       	brcc	.+8      	; 0x1138 <_ZN5Motor3runEv+0x706>
			{
				transition_to(100);
    1130:	64 e6       	ldi	r22, 0x64	; 100
    1132:	c8 01       	movw	r24, r16
    1134:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <_ZN8frt_task13transition_toEh>
		
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
    1138:	d8 01       	movw	r26, r16
    113a:	98 96       	adiw	r26, 0x28	; 40
    113c:	1d 92       	st	X+, r1
    113e:	1c 92       	st	X, r1
    1140:	99 97       	sbiw	r26, 0x29	; 41
		Im_set = Tset/K_T;
    1142:	92 96       	adiw	r26, 0x22	; 34
    1144:	8d 91       	ld	r24, X+
    1146:	9c 91       	ld	r25, X
    1148:	93 97       	sbiw	r26, 0x23	; 35
    114a:	60 e0       	ldi	r22, 0x00	; 0
    114c:	70 e0       	ldi	r23, 0x00	; 0
    114e:	0e 94 84 22 	call	0x4508	; 0x4508 <__divmodhi4>
    1152:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
    1154:	07 2e       	mov	r0, r23
    1156:	00 0c       	add	r0, r0
    1158:	88 0b       	sbc	r24, r24
    115a:	99 0b       	sbc	r25, r25
    115c:	0e 94 10 22 	call	0x4420	; 0x4420 <__floatsisf>
    1160:	2b 01       	movw	r4, r22
    1162:	3c 01       	movw	r6, r24
    1164:	23 e3       	ldi	r18, 0x33	; 51
    1166:	33 e3       	ldi	r19, 0x33	; 51
    1168:	4b e8       	ldi	r20, 0x8B	; 139
    116a:	51 e4       	ldi	r21, 0x41	; 65
    116c:	0e 94 6f 22 	call	0x44de	; 0x44de <__gesf2>
    1170:	18 16       	cp	r1, r24
    1172:	34 f4       	brge	.+12     	; 0x1180 <_ZN5Motor3runEv+0x74e>
			Im_set = 17.4;
    1174:	81 e1       	ldi	r24, 0x11	; 17
    1176:	90 e0       	ldi	r25, 0x00	; 0
    1178:	f8 01       	movw	r30, r16
    117a:	84 a3       	std	Z+36, r24	; 0x24
    117c:	95 a3       	std	Z+37, r25	; 0x25
    117e:	15 c0       	rjmp	.+42     	; 0x11aa <_ZN5Motor3runEv+0x778>
		} else if(Im_set < -17.4) {
    1180:	23 e3       	ldi	r18, 0x33	; 51
    1182:	33 e3       	ldi	r19, 0x33	; 51
    1184:	4b e8       	ldi	r20, 0x8B	; 139
    1186:	51 ec       	ldi	r21, 0xC1	; 193
    1188:	c3 01       	movw	r24, r6
    118a:	b2 01       	movw	r22, r4
    118c:	0e 94 09 22 	call	0x4412	; 0x4412 <__cmpsf2>
    1190:	88 23       	and	r24, r24
    1192:	34 f0       	brlt	.+12     	; 0x11a0 <_ZN5Motor3runEv+0x76e>
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
    1194:	d8 01       	movw	r26, r16
    1196:	94 96       	adiw	r26, 0x24	; 36
    1198:	ed 92       	st	X+, r14
    119a:	fc 92       	st	X, r15
    119c:	95 97       	sbiw	r26, 0x25	; 37
    119e:	05 c0       	rjmp	.+10     	; 0x11aa <_ZN5Motor3runEv+0x778>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
    11a0:	8f ee       	ldi	r24, 0xEF	; 239
    11a2:	9f ef       	ldi	r25, 0xFF	; 255
    11a4:	f8 01       	movw	r30, r16
    11a6:	84 a3       	std	Z+36, r24	; 0x24
    11a8:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
    11aa:	d8 01       	movw	r26, r16
    11ac:	d6 96       	adiw	r26, 0x36	; 54
    11ae:	1d 92       	st	X+, r1
    11b0:	1c 92       	st	X, r1
    11b2:	d7 97       	sbiw	r26, 0x37	; 55
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
    11b4:	d2 96       	adiw	r26, 0x32	; 50
    11b6:	1d 92       	st	X+, r1
    11b8:	1c 92       	st	X, r1
    11ba:	d3 97       	sbiw	r26, 0x33	; 51
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
    11bc:	d4 96       	adiw	r26, 0x34	; 52
    11be:	1d 92       	st	X+, r1
    11c0:	1c 92       	st	X, r1
    11c2:	d5 97       	sbiw	r26, 0x35	; 53

		V_m = V_R + V_E;
    11c4:	d0 96       	adiw	r26, 0x30	; 48
    11c6:	8d 91       	ld	r24, X+
    11c8:	9c 91       	ld	r25, X
    11ca:	d1 97       	sbiw	r26, 0x31	; 49

		// Saturater for voltage
		if (V_m > 24) {
    11cc:	89 31       	cpi	r24, 0x19	; 25
    11ce:	91 05       	cpc	r25, r1
    11d0:	3c f0       	brlt	.+14     	; 0x11e0 <_ZN5Motor3runEv+0x7ae>
			V_m = 24;
    11d2:	88 e1       	ldi	r24, 0x18	; 24
    11d4:	90 e0       	ldi	r25, 0x00	; 0
    11d6:	d8 96       	adiw	r26, 0x38	; 56
    11d8:	8d 93       	st	X+, r24
    11da:	9c 93       	st	X, r25
    11dc:	d9 97       	sbiw	r26, 0x39	; 57
    11de:	0f c0       	rjmp	.+30     	; 0x11fe <_ZN5Motor3runEv+0x7cc>
		} else if(V_m < -24) {
    11e0:	88 3e       	cpi	r24, 0xE8	; 232
    11e2:	bf ef       	ldi	r27, 0xFF	; 255
    11e4:	9b 07       	cpc	r25, r27
    11e6:	24 f0       	brlt	.+8      	; 0x11f0 <_ZN5Motor3runEv+0x7be>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
    11e8:	f8 01       	movw	r30, r16
    11ea:	80 af       	std	Z+56, r24	; 0x38
    11ec:	91 af       	std	Z+57, r25	; 0x39
    11ee:	07 c0       	rjmp	.+14     	; 0x11fe <_ZN5Motor3runEv+0x7cc>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
    11f0:	88 ee       	ldi	r24, 0xE8	; 232
    11f2:	9f ef       	ldi	r25, 0xFF	; 255
    11f4:	d8 01       	movw	r26, r16
    11f6:	d8 96       	adiw	r26, 0x38	; 56
    11f8:	8d 93       	st	X+, r24
    11fa:	9c 93       	st	X, r25
    11fc:	d9 97       	sbiw	r26, 0x39	; 57
		}

		
		// PWM function to command motor
		if (output_correct >= 0)
    11fe:	f6 01       	movw	r30, r12
    1200:	80 81       	ld	r24, Z
    1202:	91 81       	ldd	r25, Z+1	; 0x01
    1204:	99 23       	and	r25, r25
    1206:	3c f0       	brlt	.+14     	; 0x1216 <_ZN5Motor3runEv+0x7e4>
		{
			TCC0.CCA = output_correct;
    1208:	e0 e0       	ldi	r30, 0x00	; 0
    120a:	f8 e0       	ldi	r31, 0x08	; 8
    120c:	80 a7       	std	Z+40, r24	; 0x28
    120e:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
    1210:	12 a6       	std	Z+42, r1	; 0x2a
    1212:	13 a6       	std	Z+43, r1	; 0x2b
    1214:	0c c0       	rjmp	.+24     	; 0x122e <_ZN5Motor3runEv+0x7fc>
		}
		else if (output_correct < 0)
		{
			TCC0.CCA = 0;
    1216:	e0 e0       	ldi	r30, 0x00	; 0
    1218:	f8 e0       	ldi	r31, 0x08	; 8
    121a:	10 a6       	std	Z+40, r1	; 0x28
    121c:	11 a6       	std	Z+41, r1	; 0x29
			TCC0.CCB = -output_correct;
    121e:	d6 01       	movw	r26, r12
    1220:	8d 91       	ld	r24, X+
    1222:	9c 91       	ld	r25, X
    1224:	91 95       	neg	r25
    1226:	81 95       	neg	r24
    1228:	91 09       	sbc	r25, r1
    122a:	82 a7       	std	Z+42, r24	; 0x2a
    122c:	93 a7       	std	Z+43, r25	; 0x2b

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
    122e:	ed 81       	ldd	r30, Y+5	; 0x05
    1230:	fe 81       	ldd	r31, Y+6	; 0x06
    1232:	20 81       	ld	r18, Z
    1234:	31 81       	ldd	r19, Z+1	; 0x01
    1236:	42 81       	ldd	r20, Z+2	; 0x02
    1238:	53 81       	ldd	r21, Z+3	; 0x03
    123a:	a8 ee       	ldi	r26, 0xE8	; 232
    123c:	b3 e0       	ldi	r27, 0x03	; 3
    123e:	0e 94 00 23 	call	0x4600	; 0x4600 <__muluhisi3>
    1242:	68 3e       	cpi	r22, 0xE8	; 232
    1244:	f3 e0       	ldi	r31, 0x03	; 3
    1246:	7f 07       	cpc	r23, r31
    1248:	81 05       	cpc	r24, r1
    124a:	91 05       	cpc	r25, r1
    124c:	48 f0       	brcs	.+18     	; 0x1260 <_ZN5Motor3runEv+0x82e>
    124e:	28 ee       	ldi	r18, 0xE8	; 232
    1250:	33 e0       	ldi	r19, 0x03	; 3
    1252:	40 e0       	ldi	r20, 0x00	; 0
    1254:	50 e0       	ldi	r21, 0x00	; 0
    1256:	0e 94 98 22 	call	0x4530	; 0x4530 <__udivmodsi4>
    125a:	ba 01       	movw	r22, r20
    125c:	a9 01       	movw	r20, r18
    125e:	04 c0       	rjmp	.+8      	; 0x1268 <_ZN5Motor3runEv+0x836>
    1260:	41 e0       	ldi	r20, 0x01	; 1
    1262:	50 e0       	ldi	r21, 0x00	; 0
    1264:	60 e0       	ldi	r22, 0x00	; 0
    1266:	70 e0       	ldi	r23, 0x00	; 0
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
    1268:	ce 01       	movw	r24, r28
    126a:	01 96       	adiw	r24, 0x01	; 1
    126c:	0e 94 30 15 	call	0x2a60	; 0x2a60 <vTaskDelayUntil>
    1270:	54 cc       	rjmp	.-1880   	; 0xb1a <_ZN5Motor3runEv+0xe8>

00001272 <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
    1272:	0f 93       	push	r16
    1274:	1f 93       	push	r17
    1276:	cf 93       	push	r28
    1278:	df 93       	push	r29
    127a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    127c:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <_ZN8frt_taskC1EPKchjP8emstream>
    1280:	8e e2       	ldi	r24, 0x2E	; 46
    1282:	90 e2       	ldi	r25, 0x20	; 32
    1284:	88 83       	st	Y, r24
    1286:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
    1288:	df 91       	pop	r29
    128a:	cf 91       	pop	r28
    128c:	1f 91       	pop	r17
    128e:	0f 91       	pop	r16
    1290:	08 95       	ret

00001292 <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
    1292:	9c 01       	movw	r18, r24
    1294:	93 2f       	mov	r25, r19
    1296:	99 1f       	adc	r25, r25
    1298:	99 27       	eor	r25, r25
    129a:	99 1f       	adc	r25, r25
    129c:	89 2f       	mov	r24, r25
    129e:	90 e0       	ldi	r25, 0x00	; 0
    12a0:	81 50       	subi	r24, 0x01	; 1
    12a2:	90 48       	sbci	r25, 0x80	; 128
    12a4:	43 2f       	mov	r20, r19
    12a6:	40 95       	com	r20
    12a8:	44 1f       	adc	r20, r20
    12aa:	44 27       	eor	r20, r20
    12ac:	44 1f       	adc	r20, r20
    12ae:	fc 01       	movw	r30, r24
    12b0:	e2 1b       	sub	r30, r18
    12b2:	f3 0b       	sbc	r31, r19
    12b4:	51 e0       	ldi	r21, 0x01	; 1
    12b6:	e6 17       	cp	r30, r22
    12b8:	f7 07       	cpc	r31, r23
    12ba:	0c f0       	brlt	.+2      	; 0x12be <_ZN7satmath20signed_saturated_addEii+0x2c>
    12bc:	50 e0       	ldi	r21, 0x00	; 0
    12be:	45 17       	cp	r20, r21
    12c0:	19 f0       	breq	.+6      	; 0x12c8 <_ZN7satmath20signed_saturated_addEii+0x36>
    12c2:	c9 01       	movw	r24, r18
    12c4:	86 0f       	add	r24, r22
    12c6:	97 1f       	adc	r25, r23
    12c8:	08 95       	ret

000012ca <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    12ca:	81 15       	cp	r24, r1
    12cc:	20 e8       	ldi	r18, 0x80	; 128
    12ce:	92 07       	cpc	r25, r18
    12d0:	21 f4       	brne	.+8      	; 0x12da <_ZN7satmath20signed_saturated_mulEii+0x10>
    12d2:	61 15       	cp	r22, r1
    12d4:	20 e8       	ldi	r18, 0x80	; 128
    12d6:	72 07       	cpc	r23, r18
    12d8:	29 f0       	breq	.+10     	; 0x12e4 <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
    12da:	9c 01       	movw	r18, r24
    12dc:	db 01       	movw	r26, r22
    12de:	0e 94 e2 22 	call	0x45c4	; 0x45c4 <__mulhisi3>
    12e2:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    12e4:	6f ef       	ldi	r22, 0xFF	; 255
    12e6:	7f ef       	ldi	r23, 0xFF	; 255
    12e8:	8f ef       	ldi	r24, 0xFF	; 255
    12ea:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
    12ec:	08 95       	ret

000012ee <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    12ee:	0f 93       	push	r16
    12f0:	1f 93       	push	r17
    12f2:	cf 93       	push	r28
    12f4:	df 93       	push	r29
    12f6:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    12f8:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <_ZN8frt_taskC1EPKchjP8emstream>
    12fc:	86 e3       	ldi	r24, 0x36	; 54
    12fe:	90 e2       	ldi	r25, 0x20	; 32
    1300:	88 83       	st	Y, r24
    1302:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    1304:	df 91       	pop	r29
    1306:	cf 91       	pop	r28
    1308:	1f 91       	pop	r17
    130a:	0f 91       	pop	r16
    130c:	08 95       	ret

0000130e <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    130e:	0f 93       	push	r16
    1310:	1f 93       	push	r17
    1312:	cf 93       	push	r28
    1314:	df 93       	push	r29
    1316:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    1318:	6a e0       	ldi	r22, 0x0A	; 10
    131a:	8e 81       	ldd	r24, Y+6	; 0x06
    131c:	9f 81       	ldd	r25, Y+7	; 0x07
    131e:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1322:	8c 01       	movw	r16, r24
    1324:	63 e5       	ldi	r22, 0x53	; 83
    1326:	75 e0       	ldi	r23, 0x05	; 5
    1328:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    132c:	6a e0       	ldi	r22, 0x0A	; 10
    132e:	c8 01       	movw	r24, r16
    1330:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1334:	8c 01       	movw	r16, r24
    1336:	6d e4       	ldi	r22, 0x4D	; 77
    1338:	75 e0       	ldi	r23, 0x05	; 5
    133a:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    133e:	67 e0       	ldi	r22, 0x07	; 7
    1340:	c8 01       	movw	r24, r16
    1342:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    1346:	6a e0       	ldi	r22, 0x0A	; 10
    1348:	8e 81       	ldd	r24, Y+6	; 0x06
    134a:	9f 81       	ldd	r25, Y+7	; 0x07
    134c:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1350:	8c 01       	movw	r16, r24
    1352:	6e e2       	ldi	r22, 0x2E	; 46
    1354:	75 e0       	ldi	r23, 0x05	; 5
    1356:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    135a:	6a e0       	ldi	r22, 0x0A	; 10
    135c:	c8 01       	movw	r24, r16
    135e:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1362:	8c 01       	movw	r16, r24
    1364:	68 e2       	ldi	r22, 0x28	; 40
    1366:	75 e0       	ldi	r23, 0x05	; 5
    1368:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    136c:	66 e0       	ldi	r22, 0x06	; 6
    136e:	c8 01       	movw	r24, r16
    1370:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    1374:	6a e0       	ldi	r22, 0x0A	; 10
    1376:	8e 81       	ldd	r24, Y+6	; 0x06
    1378:	9f 81       	ldd	r25, Y+7	; 0x07
    137a:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    137e:	8c 01       	movw	r16, r24
    1380:	61 e1       	ldi	r22, 0x11	; 17
    1382:	75 e0       	ldi	r23, 0x05	; 5
    1384:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    1388:	66 e0       	ldi	r22, 0x06	; 6
    138a:	c8 01       	movw	r24, r16
    138c:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    1390:	6a e0       	ldi	r22, 0x0A	; 10
    1392:	8e 81       	ldd	r24, Y+6	; 0x06
    1394:	9f 81       	ldd	r25, Y+7	; 0x07
    1396:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    139a:	8c 01       	movw	r16, r24
    139c:	65 ef       	ldi	r22, 0xF5	; 245
    139e:	74 e0       	ldi	r23, 0x04	; 4
    13a0:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    13a4:	66 e0       	ldi	r22, 0x06	; 6
    13a6:	c8 01       	movw	r24, r16
    13a8:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    13ac:	6a e0       	ldi	r22, 0x0A	; 10
    13ae:	8e 81       	ldd	r24, Y+6	; 0x06
    13b0:	9f 81       	ldd	r25, Y+7	; 0x07
    13b2:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    13b6:	8c 01       	movw	r16, r24
    13b8:	6d ed       	ldi	r22, 0xDD	; 221
    13ba:	74 e0       	ldi	r23, 0x04	; 4
    13bc:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    13c0:	66 e0       	ldi	r22, 0x06	; 6
    13c2:	c8 01       	movw	r24, r16
    13c4:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    13c8:	6a e0       	ldi	r22, 0x0A	; 10
    13ca:	8e 81       	ldd	r24, Y+6	; 0x06
    13cc:	9f 81       	ldd	r25, Y+7	; 0x07
    13ce:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    13d2:	8c 01       	movw	r16, r24
    13d4:	6c eb       	ldi	r22, 0xBC	; 188
    13d6:	74 e0       	ldi	r23, 0x04	; 4
    13d8:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    13dc:	66 e0       	ldi	r22, 0x06	; 6
    13de:	c8 01       	movw	r24, r16
    13e0:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    13e4:	6a e0       	ldi	r22, 0x0A	; 10
    13e6:	8e 81       	ldd	r24, Y+6	; 0x06
    13e8:	9f 81       	ldd	r25, Y+7	; 0x07
    13ea:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    13ee:	8c 01       	movw	r16, r24
    13f0:	65 e9       	ldi	r22, 0x95	; 149
    13f2:	74 e0       	ldi	r23, 0x04	; 4
    13f4:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    13f8:	66 e0       	ldi	r22, 0x06	; 6
    13fa:	c8 01       	movw	r24, r16
    13fc:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    1400:	6a e0       	ldi	r22, 0x0A	; 10
    1402:	8e 81       	ldd	r24, Y+6	; 0x06
    1404:	9f 81       	ldd	r25, Y+7	; 0x07
    1406:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    140a:	8c 01       	movw	r16, r24
    140c:	67 e7       	ldi	r22, 0x77	; 119
    140e:	74 e0       	ldi	r23, 0x04	; 4
    1410:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    1414:	66 e0       	ldi	r22, 0x06	; 6
    1416:	c8 01       	movw	r24, r16
    1418:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    141c:	6a e0       	ldi	r22, 0x0A	; 10
    141e:	8e 81       	ldd	r24, Y+6	; 0x06
    1420:	9f 81       	ldd	r25, Y+7	; 0x07
    1422:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1426:	8c 01       	movw	r16, r24
    1428:	6c e5       	ldi	r22, 0x5C	; 92
    142a:	74 e0       	ldi	r23, 0x04	; 4
    142c:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    1430:	66 e0       	ldi	r22, 0x06	; 6
    1432:	c8 01       	movw	r24, r16
    1434:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    1438:	6a e0       	ldi	r22, 0x0A	; 10
    143a:	8e 81       	ldd	r24, Y+6	; 0x06
    143c:	9f 81       	ldd	r25, Y+7	; 0x07
    143e:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1442:	8c 01       	movw	r16, r24
    1444:	6d e4       	ldi	r22, 0x4D	; 77
    1446:	74 e0       	ldi	r23, 0x04	; 4
    1448:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    144c:	66 e0       	ldi	r22, 0x06	; 6
    144e:	c8 01       	movw	r24, r16
    1450:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    b:   Begin Calibration of Inverted Pendulum?") << endl;
    1454:	6a e0       	ldi	r22, 0x0A	; 10
    1456:	8e 81       	ldd	r24, Y+6	; 0x06
    1458:	9f 81       	ldd	r25, Y+7	; 0x07
    145a:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    145e:	8c 01       	movw	r16, r24
    1460:	6c e1       	ldi	r22, 0x1C	; 28
    1462:	74 e0       	ldi	r23, 0x04	; 4
    1464:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    1468:	66 e0       	ldi	r22, 0x06	; 6
    146a:	c8 01       	movw	r24, r16
    146c:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    g:   Swing Pendulum Upright, then Go.") << endl;
    1470:	6a e0       	ldi	r22, 0x0A	; 10
    1472:	8e 81       	ldd	r24, Y+6	; 0x06
    1474:	9f 81       	ldd	r25, Y+7	; 0x07
    1476:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    147a:	8c 01       	movw	r16, r24
    147c:	62 ef       	ldi	r22, 0xF2	; 242
    147e:	73 e0       	ldi	r23, 0x03	; 3
    1480:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    1484:	66 e0       	ldi	r22, 0x06	; 6
    1486:	c8 01       	movw	r24, r16
    1488:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    d:   Emergency Stop") << endl;
    148c:	6a e0       	ldi	r22, 0x0A	; 10
    148e:	8e 81       	ldd	r24, Y+6	; 0x06
    1490:	9f 81       	ldd	r25, Y+7	; 0x07
    1492:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1496:	8c 01       	movw	r16, r24
    1498:	6a ed       	ldi	r22, 0xDA	; 218
    149a:	73 e0       	ldi	r23, 0x03	; 3
    149c:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    14a0:	66 e0       	ldi	r22, 0x06	; 6
    14a2:	c8 01       	movw	r24, r16
    14a4:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    r:   Reset to Idle") << endl;
    14a8:	6a e0       	ldi	r22, 0x0A	; 10
    14aa:	8e 81       	ldd	r24, Y+6	; 0x06
    14ac:	9f 81       	ldd	r25, Y+7	; 0x07
    14ae:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    14b2:	ec 01       	movw	r28, r24
    14b4:	63 ec       	ldi	r22, 0xC3	; 195
    14b6:	73 e0       	ldi	r23, 0x03	; 3
    14b8:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    14bc:	66 e0       	ldi	r22, 0x06	; 6
    14be:	ce 01       	movw	r24, r28
    14c0:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
}
    14c4:	df 91       	pop	r29
    14c6:	cf 91       	pop	r28
    14c8:	1f 91       	pop	r17
    14ca:	0f 91       	pop	r16
    14cc:	08 95       	ret

000014ce <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    14ce:	af 92       	push	r10
    14d0:	bf 92       	push	r11
    14d2:	cf 92       	push	r12
    14d4:	df 92       	push	r13
    14d6:	ef 92       	push	r14
    14d8:	ff 92       	push	r15
    14da:	0f 93       	push	r16
    14dc:	1f 93       	push	r17
    14de:	cf 93       	push	r28
    14e0:	df 93       	push	r29
    14e2:	00 d0       	rcall	.+0      	; 0x14e4 <_ZN9task_user11show_statusEv+0x16>
    14e4:	00 d0       	rcall	.+0      	; 0x14e6 <_ZN9task_user11show_statusEv+0x18>
    14e6:	cd b7       	in	r28, 0x3d	; 61
    14e8:	de b7       	in	r29, 0x3e	; 62
    14ea:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    14ec:	19 82       	std	Y+1, r1	; 0x01
    14ee:	1a 82       	std	Y+2, r1	; 0x02
    14f0:	1b 82       	std	Y+3, r1	; 0x03
    14f2:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    14f4:	1d 82       	std	Y+5, r1	; 0x05
    14f6:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    14f8:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <xPortGetFreeHeapSize>
    14fc:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    14fe:	ce 01       	movw	r24, r28
    1500:	01 96       	adiw	r24, 0x01	; 1
    1502:	0e 94 7e 1b 	call	0x36fc	; 0x36fc <_ZN10time_stamp10set_to_nowEv>
    1506:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1508:	66 e0       	ldi	r22, 0x06	; 6
    150a:	f8 01       	movw	r30, r16
    150c:	86 81       	ldd	r24, Z+6	; 0x06
    150e:	97 81       	ldd	r25, Z+7	; 0x07
    1510:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1514:	6a e0       	ldi	r22, 0x0A	; 10
    1516:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    151a:	7c 01       	movw	r14, r24
    151c:	64 ea       	ldi	r22, 0xA4	; 164
    151e:	73 e0       	ldi	r23, 0x03	; 3
    1520:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    1524:	6a e0       	ldi	r22, 0x0A	; 10
    1526:	c7 01       	movw	r24, r14
    1528:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    152c:	7c 01       	movw	r14, r24
    152e:	68 e9       	ldi	r22, 0x98	; 152
    1530:	73 e0       	ldi	r23, 0x03	; 3
    1532:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    1536:	66 e0       	ldi	r22, 0x06	; 6
    1538:	c7 01       	movw	r24, r14
    153a:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    153e:	6a e0       	ldi	r22, 0x0A	; 10
    1540:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1544:	7c 01       	movw	r14, r24
    1546:	61 e9       	ldi	r22, 0x91	; 145
    1548:	73 e0       	ldi	r23, 0x03	; 3
    154a:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    154e:	b5 01       	movw	r22, r10
    1550:	c7 01       	movw	r24, r14
    1552:	0e 94 22 1b 	call	0x3644	; 0x3644 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1556:	6a e0       	ldi	r22, 0x0A	; 10
    1558:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    155c:	7c 01       	movw	r14, r24
    155e:	63 e8       	ldi	r22, 0x83	; 131
    1560:	73 e0       	ldi	r23, 0x03	; 3
    1562:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    1566:	b6 01       	movw	r22, r12
    1568:	c7 01       	movw	r24, r14
    156a:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <_ZN8emstreamlsEj>
    156e:	6a e0       	ldi	r22, 0x0A	; 10
    1570:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1574:	7c 01       	movw	r14, r24
    1576:	61 e8       	ldi	r22, 0x81	; 129
    1578:	73 e0       	ldi	r23, 0x03	; 3
    157a:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    157e:	4f ef       	ldi	r20, 0xFF	; 255
    1580:	5f e0       	ldi	r21, 0x0F	; 15
    1582:	60 e0       	ldi	r22, 0x00	; 0
    1584:	70 e0       	ldi	r23, 0x00	; 0
    1586:	c7 01       	movw	r24, r14
    1588:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    158c:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1590:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1594:	6a e0       	ldi	r22, 0x0A	; 10
    1596:	f8 01       	movw	r30, r16
    1598:	86 81       	ldd	r24, Z+6	; 0x06
    159a:	97 81       	ldd	r25, Z+7	; 0x07
    159c:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    15a0:	7c 01       	movw	r14, r24
    15a2:	66 e7       	ldi	r22, 0x76	; 118
    15a4:	73 e0       	ldi	r23, 0x03	; 3
    15a6:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    15aa:	b6 01       	movw	r22, r12
    15ac:	c7 01       	movw	r24, r14
    15ae:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <_ZN8emstreamlsEj>
    15b2:	66 e0       	ldi	r22, 0x06	; 6
    15b4:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    15b8:	66 e0       	ldi	r22, 0x06	; 6
    15ba:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    15be:	f8 01       	movw	r30, r16
    15c0:	86 81       	ldd	r24, Z+6	; 0x06
    15c2:	97 81       	ldd	r25, Z+7	; 0x07
    15c4:	0e 94 db 19 	call	0x33b6	; 0x33b6 <_Z15print_task_listP8emstream>
}
    15c8:	26 96       	adiw	r28, 0x06	; 6
    15ca:	cd bf       	out	0x3d, r28	; 61
    15cc:	de bf       	out	0x3e, r29	; 62
    15ce:	df 91       	pop	r29
    15d0:	cf 91       	pop	r28
    15d2:	1f 91       	pop	r17
    15d4:	0f 91       	pop	r16
    15d6:	ff 90       	pop	r15
    15d8:	ef 90       	pop	r14
    15da:	df 90       	pop	r13
    15dc:	cf 90       	pop	r12
    15de:	bf 90       	pop	r11
    15e0:	af 90       	pop	r10
    15e2:	08 95       	ret

000015e4 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    15e4:	cf 93       	push	r28
    15e6:	df 93       	push	r29
    15e8:	00 d0       	rcall	.+0      	; 0x15ea <_ZN9task_user3runEv+0x6>
    15ea:	00 d0       	rcall	.+0      	; 0x15ec <_ZN9task_user3runEv+0x8>
    15ec:	cd b7       	in	r28, 0x3d	; 61
    15ee:	de b7       	in	r29, 0x3e	; 62
    15f0:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    15f2:	19 82       	std	Y+1, r1	; 0x01
    15f4:	1a 82       	std	Y+2, r1	; 0x02
    15f6:	1b 82       	std	Y+3, r1	; 0x03
    15f8:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    15fa:	1d 82       	std	Y+5, r1	; 0x05
    15fc:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;
    15fe:	6a e0       	ldi	r22, 0x0A	; 10
    1600:	dc 01       	movw	r26, r24
    1602:	16 96       	adiw	r26, 0x06	; 6
    1604:	8d 91       	ld	r24, X+
    1606:	9c 91       	ld	r25, X
    1608:	17 97       	sbiw	r26, 0x07	; 7
    160a:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    160e:	7c 01       	movw	r14, r24
    1610:	61 ef       	ldi	r22, 0xF1	; 241
    1612:	75 e0       	ldi	r23, 0x05	; 5
    1614:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    1618:	66 e0       	ldi	r22, 0x06	; 6
    161a:	c7 01       	movw	r24, r14
    161c:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1620:	f8 01       	movw	r30, r16
    1622:	84 85       	ldd	r24, Z+12	; 0x0c
    1624:	88 23       	and	r24, r24
    1626:	21 f0       	breq	.+8      	; 0x1630 <_ZN9task_user3runEv+0x4c>
    1628:	81 30       	cpi	r24, 0x01	; 1
    162a:	09 f4       	brne	.+2      	; 0x162e <_ZN9task_user3runEv+0x4a>
    162c:	5d c0       	rjmp	.+186    	; 0x16e8 <_ZN9task_user3runEv+0x104>
    162e:	32 c1       	rjmp	.+612    	; 0x1894 <_ZN9task_user3runEv+0x2b0>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1630:	86 81       	ldd	r24, Z+6	; 0x06
    1632:	97 81       	ldd	r25, Z+7	; 0x07
    1634:	dc 01       	movw	r26, r24
    1636:	ed 91       	ld	r30, X+
    1638:	fc 91       	ld	r31, X
    163a:	04 80       	ldd	r0, Z+4	; 0x04
    163c:	f5 81       	ldd	r31, Z+5	; 0x05
    163e:	e0 2d       	mov	r30, r0
    1640:	19 95       	eicall
    1642:	88 23       	and	r24, r24
    1644:	a9 f1       	breq	.+106    	; 0x16b0 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1646:	f8 01       	movw	r30, r16
    1648:	86 81       	ldd	r24, Z+6	; 0x06
    164a:	97 81       	ldd	r25, Z+7	; 0x07
    164c:	dc 01       	movw	r26, r24
    164e:	ed 91       	ld	r30, X+
    1650:	fc 91       	ld	r31, X
    1652:	06 80       	ldd	r0, Z+6	; 0x06
    1654:	f7 81       	ldd	r31, Z+7	; 0x07
    1656:	e0 2d       	mov	r30, r0
    1658:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    165a:	99 27       	eor	r25, r25
    165c:	81 30       	cpi	r24, 0x01	; 1
    165e:	91 05       	cpc	r25, r1
    1660:	f9 f0       	breq	.+62     	; 0x16a0 <_ZN9task_user3runEv+0xbc>
    1662:	03 97       	sbiw	r24, 0x03	; 3
    1664:	09 f0       	breq	.+2      	; 0x1668 <_ZN9task_user3runEv+0x84>
    1666:	31 c1       	rjmp	.+610    	; 0x18ca <_ZN9task_user3runEv+0x2e6>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1668:	6a e0       	ldi	r22, 0x0A	; 10
    166a:	f8 01       	movw	r30, r16
    166c:	86 81       	ldd	r24, Z+6	; 0x06
    166e:	97 81       	ldd	r25, Z+7	; 0x07
    1670:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1674:	8c 01       	movw	r16, r24
    1676:	63 ee       	ldi	r22, 0xE3	; 227
    1678:	75 e0       	ldi	r23, 0x05	; 5
    167a:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    167e:	66 e0       	ldi	r22, 0x06	; 6
    1680:	c8 01       	movw	r24, r16
    1682:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1686:	93 e0       	ldi	r25, 0x03	; 3
    1688:	88 ed       	ldi	r24, 0xD8	; 216
    168a:	08 b6       	in	r0, 0x38	; 56
    168c:	18 be       	out	0x38, r1	; 56
    168e:	84 bf       	out	0x34, r24	; 52
    1690:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1694:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1698:	81 fd       	sbrc	r24, 1
    169a:	fc cf       	rjmp	.-8      	; 0x1694 <_ZN9task_user3runEv+0xb0>
    169c:	08 be       	out	0x38, r0	; 56
    169e:	ff cf       	rjmp	.-2      	; 0x169e <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    16a0:	c8 01       	movw	r24, r16
    16a2:	0e 94 87 09 	call	0x130e	; 0x130e <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    16a6:	61 e0       	ldi	r22, 0x01	; 1
    16a8:	c8 01       	movw	r24, r16
    16aa:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <_ZN8frt_task13transition_toEh>
							break;
    16ae:	0d c1       	rjmp	.+538    	; 0x18ca <_ZN9task_user3runEv+0x2e6>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    16b0:	84 e5       	ldi	r24, 0x54	; 84
    16b2:	91 e3       	ldi	r25, 0x31	; 49
    16b4:	0e 94 8a 1a 	call	0x3514	; 0x3514 <_ZN14frt_text_queue14check_for_charEv>
    16b8:	88 23       	and	r24, r24
    16ba:	09 f4       	brne	.+2      	; 0x16be <_ZN9task_user3runEv+0xda>
    16bc:	06 c1       	rjmp	.+524    	; 0x18ca <_ZN9task_user3runEv+0x2e6>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    16be:	d8 01       	movw	r26, r16
    16c0:	16 96       	adiw	r26, 0x06	; 6
    16c2:	ed 91       	ld	r30, X+
    16c4:	fc 91       	ld	r31, X
    16c6:	17 97       	sbiw	r26, 0x07	; 7
    16c8:	01 90       	ld	r0, Z+
    16ca:	f0 81       	ld	r31, Z
    16cc:	e0 2d       	mov	r30, r0
    16ce:	e2 80       	ldd	r14, Z+2	; 0x02
    16d0:	f3 80       	ldd	r15, Z+3	; 0x03
    16d2:	84 e5       	ldi	r24, 0x54	; 84
    16d4:	91 e3       	ldi	r25, 0x31	; 49
    16d6:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <_ZN14frt_text_queue7getcharEv>
    16da:	68 2f       	mov	r22, r24
    16dc:	f8 01       	movw	r30, r16
    16de:	86 81       	ldd	r24, Z+6	; 0x06
    16e0:	97 81       	ldd	r25, Z+7	; 0x07
    16e2:	f7 01       	movw	r30, r14
    16e4:	19 95       	eicall
    16e6:	f1 c0       	rjmp	.+482    	; 0x18ca <_ZN9task_user3runEv+0x2e6>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    16e8:	86 81       	ldd	r24, Z+6	; 0x06
    16ea:	97 81       	ldd	r25, Z+7	; 0x07
    16ec:	dc 01       	movw	r26, r24
    16ee:	ed 91       	ld	r30, X+
    16f0:	fc 91       	ld	r31, X
    16f2:	04 80       	ldd	r0, Z+4	; 0x04
    16f4:	f5 81       	ldd	r31, Z+5	; 0x05
    16f6:	e0 2d       	mov	r30, r0
    16f8:	19 95       	eicall
    16fa:	88 23       	and	r24, r24
    16fc:	09 f4       	brne	.+2      	; 0x1700 <_ZN9task_user3runEv+0x11c>
    16fe:	e5 c0       	rjmp	.+458    	; 0x18ca <_ZN9task_user3runEv+0x2e6>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1700:	f8 01       	movw	r30, r16
    1702:	86 81       	ldd	r24, Z+6	; 0x06
    1704:	97 81       	ldd	r25, Z+7	; 0x07
    1706:	dc 01       	movw	r26, r24
    1708:	ed 91       	ld	r30, X+
    170a:	fc 91       	ld	r31, X
    170c:	06 80       	ldd	r0, Z+6	; 0x06
    170e:	f7 81       	ldd	r31, Z+7	; 0x07
    1710:	e0 2d       	mov	r30, r0
    1712:	19 95       	eicall
    1714:	bc 01       	movw	r22, r24

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1716:	fc 01       	movw	r30, r24
    1718:	ff 27       	eor	r31, r31
    171a:	7b 97       	sbiw	r30, 0x1b	; 27
    171c:	ec 35       	cpi	r30, 0x5C	; 92
    171e:	f1 05       	cpc	r31, r1
    1720:	08 f0       	brcs	.+2      	; 0x1724 <_ZN9task_user3runEv+0x140>
    1722:	9c c0       	rjmp	.+312    	; 0x185c <_ZN9task_user3runEv+0x278>
    1724:	88 27       	eor	r24, r24
    1726:	e2 50       	subi	r30, 0x02	; 2
    1728:	ff 4f       	sbci	r31, 0xFF	; 255
    172a:	8f 4f       	sbci	r24, 0xFF	; 255
    172c:	0c 94 d9 22 	jmp	0x45b2	; 0x45b2 <__tablejump2__>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1730:	ce 01       	movw	r24, r28
    1732:	01 96       	adiw	r24, 0x01	; 1
    1734:	0e 94 7e 1b 	call	0x36fc	; 0x36fc <_ZN10time_stamp10set_to_nowEv>
    1738:	bc 01       	movw	r22, r24
    173a:	f8 01       	movw	r30, r16
    173c:	86 81       	ldd	r24, Z+6	; 0x06
    173e:	97 81       	ldd	r25, Z+7	; 0x07
    1740:	0e 94 22 1b 	call	0x3644	; 0x3644 <_ZlsR8emstreamR10time_stamp>
    1744:	66 e0       	ldi	r22, 0x06	; 6
    1746:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
							break;
    174a:	bf c0       	rjmp	.+382    	; 0x18ca <_ZN9task_user3runEv+0x2e6>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    174c:	c8 01       	movw	r24, r16
    174e:	0e 94 67 0a 	call	0x14ce	; 0x14ce <_ZN9task_user11show_statusEv>
							break;
    1752:	bb c0       	rjmp	.+374    	; 0x18ca <_ZN9task_user3runEv+0x2e6>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1754:	d8 01       	movw	r26, r16
    1756:	16 96       	adiw	r26, 0x06	; 6
    1758:	8d 91       	ld	r24, X+
    175a:	9c 91       	ld	r25, X
    175c:	17 97       	sbiw	r26, 0x07	; 7
    175e:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <_Z17print_task_stacksP8emstream>
							break;
    1762:	b3 c0       	rjmp	.+358    	; 0x18ca <_ZN9task_user3runEv+0x2e6>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1764:	c8 01       	movw	r24, r16
    1766:	0e 94 87 09 	call	0x130e	; 0x130e <_ZN9task_user18print_help_messageEv>
							break;
    176a:	af c0       	rjmp	.+350    	; 0x18ca <_ZN9task_user3runEv+0x2e6>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    176c:	6a e0       	ldi	r22, 0x0A	; 10
    176e:	f8 01       	movw	r30, r16
    1770:	86 81       	ldd	r24, Z+6	; 0x06
    1772:	97 81       	ldd	r25, Z+7	; 0x07
    1774:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1778:	7c 01       	movw	r14, r24
    177a:	61 ed       	ldi	r22, 0xD1	; 209
    177c:	75 e0       	ldi	r23, 0x05	; 5
    177e:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    1782:	66 e0       	ldi	r22, 0x06	; 6
    1784:	c7 01       	movw	r24, r14
    1786:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0); 
    178a:	60 e0       	ldi	r22, 0x00	; 0
    178c:	c8 01       	movw	r24, r16
    178e:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <_ZN8frt_task13transition_toEh>
							break;
    1792:	9b c0       	rjmp	.+310    	; 0x18ca <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    1794:	0f b6       	in	r0, 0x3f	; 63
    1796:	f8 94       	cli
    1798:	0f 92       	push	r0
			the_data = new_data;
    179a:	81 e0       	ldi	r24, 0x01	; 1
    179c:	80 93 49 31 	sts	0x3149, r24	; 0x803149 <begin>
			portEXIT_CRITICAL ();
    17a0:	0f 90       	pop	r0
    17a2:	0f be       	out	0x3f, r0	; 63
							
						case ('b'):
							begin.put(true);
							*p_serial << PMS ("Begin Homing") << endl;
    17a4:	6a e0       	ldi	r22, 0x0A	; 10
    17a6:	d8 01       	movw	r26, r16
    17a8:	16 96       	adiw	r26, 0x06	; 6
    17aa:	8d 91       	ld	r24, X+
    17ac:	9c 91       	ld	r25, X
    17ae:	17 97       	sbiw	r26, 0x07	; 7
    17b0:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    17b4:	7c 01       	movw	r14, r24
    17b6:	64 ec       	ldi	r22, 0xC4	; 196
    17b8:	75 e0       	ldi	r23, 0x05	; 5
    17ba:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    17be:	66 e0       	ldi	r22, 0x06	; 6
    17c0:	c7 01       	movw	r24, r14
    17c2:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
							break;
    17c6:	81 c0       	rjmp	.+258    	; 0x18ca <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    17c8:	0f b6       	in	r0, 0x3f	; 63
    17ca:	f8 94       	cli
    17cc:	0f 92       	push	r0
			the_data = new_data;
    17ce:	81 e0       	ldi	r24, 0x01	; 1
    17d0:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <go>
			portEXIT_CRITICAL ();
    17d4:	0f 90       	pop	r0
    17d6:	0f be       	out	0x3f, r0	; 63
						
						case ('g'):
							go.put(true);
							*p_serial << PMS ("Commence Balance") << endl;
    17d8:	6a e0       	ldi	r22, 0x0A	; 10
    17da:	f8 01       	movw	r30, r16
    17dc:	86 81       	ldd	r24, Z+6	; 0x06
    17de:	97 81       	ldd	r25, Z+7	; 0x07
    17e0:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    17e4:	7c 01       	movw	r14, r24
    17e6:	63 eb       	ldi	r22, 0xB3	; 179
    17e8:	75 e0       	ldi	r23, 0x05	; 5
    17ea:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    17ee:	66 e0       	ldi	r22, 0x06	; 6
    17f0:	c7 01       	movw	r24, r14
    17f2:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
							break;
    17f6:	69 c0       	rjmp	.+210    	; 0x18ca <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    17f8:	0f b6       	in	r0, 0x3f	; 63
    17fa:	f8 94       	cli
    17fc:	0f 92       	push	r0
			the_data = new_data;
    17fe:	81 e0       	ldi	r24, 0x01	; 1
    1800:	80 93 47 31 	sts	0x3147, r24	; 0x803147 <stop>
			portEXIT_CRITICAL ();
    1804:	0f 90       	pop	r0
    1806:	0f be       	out	0x3f, r0	; 63
						
						case('d'):
							stop.put(true);
							*p_serial << PMS ("EMERGENCY STOP") << endl;
    1808:	6a e0       	ldi	r22, 0x0A	; 10
    180a:	d8 01       	movw	r26, r16
    180c:	16 96       	adiw	r26, 0x06	; 6
    180e:	8d 91       	ld	r24, X+
    1810:	9c 91       	ld	r25, X
    1812:	17 97       	sbiw	r26, 0x07	; 7
    1814:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1818:	7c 01       	movw	r14, r24
    181a:	64 ea       	ldi	r22, 0xA4	; 164
    181c:	75 e0       	ldi	r23, 0x05	; 5
    181e:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    1822:	66 e0       	ldi	r22, 0x06	; 6
    1824:	c7 01       	movw	r24, r14
    1826:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
							break;
    182a:	4f c0       	rjmp	.+158    	; 0x18ca <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    182c:	0f b6       	in	r0, 0x3f	; 63
    182e:	f8 94       	cli
    1830:	0f 92       	push	r0
			the_data = new_data;
    1832:	81 e0       	ldi	r24, 0x01	; 1
    1834:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <reset>
			portEXIT_CRITICAL ();
    1838:	0f 90       	pop	r0
    183a:	0f be       	out	0x3f, r0	; 63
						
						case('r'):
							reset.put(true);
							*p_serial << PMS ("Reset, try Homing again by pressing 'b'") << endl;
    183c:	6a e0       	ldi	r22, 0x0A	; 10
    183e:	f8 01       	movw	r30, r16
    1840:	86 81       	ldd	r24, Z+6	; 0x06
    1842:	97 81       	ldd	r25, Z+7	; 0x07
    1844:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1848:	7c 01       	movw	r14, r24
    184a:	6c e7       	ldi	r22, 0x7C	; 124
    184c:	75 e0       	ldi	r23, 0x05	; 5
    184e:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    1852:	66 e0       	ldi	r22, 0x06	; 6
    1854:	c7 01       	movw	r24, r14
    1856:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
							break;
    185a:	37 c0       	rjmp	.+110    	; 0x18ca <_ZN9task_user3runEv+0x2e6>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    185c:	d8 01       	movw	r26, r16
    185e:	16 96       	adiw	r26, 0x06	; 6
    1860:	8d 91       	ld	r24, X+
    1862:	9c 91       	ld	r25, X
    1864:	17 97       	sbiw	r26, 0x07	; 7
    1866:	dc 01       	movw	r26, r24
    1868:	ed 91       	ld	r30, X+
    186a:	fc 91       	ld	r31, X
    186c:	02 80       	ldd	r0, Z+2	; 0x02
    186e:	f3 81       	ldd	r31, Z+3	; 0x03
    1870:	e0 2d       	mov	r30, r0
    1872:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1874:	6a e0       	ldi	r22, 0x0A	; 10
    1876:	f8 01       	movw	r30, r16
    1878:	86 81       	ldd	r24, Z+6	; 0x06
    187a:	97 81       	ldd	r25, Z+7	; 0x07
    187c:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    1880:	7c 01       	movw	r14, r24
    1882:	66 e7       	ldi	r22, 0x76	; 118
    1884:	75 e0       	ldi	r23, 0x05	; 5
    1886:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    188a:	66 e0       	ldi	r22, 0x06	; 6
    188c:	c7 01       	movw	r24, r14
    188e:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1892:	1b c0       	rjmp	.+54     	; 0x18ca <_ZN9task_user3runEv+0x2e6>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1894:	6a e0       	ldi	r22, 0x0A	; 10
    1896:	86 81       	ldd	r24, Z+6	; 0x06
    1898:	97 81       	ldd	r25, Z+7	; 0x07
    189a:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    189e:	8c 01       	movw	r16, r24
    18a0:	69 e5       	ldi	r22, 0x59	; 89
    18a2:	75 e0       	ldi	r23, 0x05	; 5
    18a4:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    18a8:	66 e0       	ldi	r22, 0x06	; 6
    18aa:	c8 01       	movw	r24, r16
    18ac:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    18b0:	93 e0       	ldi	r25, 0x03	; 3
    18b2:	88 ed       	ldi	r24, 0xD8	; 216
    18b4:	08 b6       	in	r0, 0x38	; 56
    18b6:	18 be       	out	0x38, r1	; 56
    18b8:	84 bf       	out	0x34, r24	; 52
    18ba:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    18be:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    18c2:	81 fd       	sbrc	r24, 1
    18c4:	fc cf       	rjmp	.-8      	; 0x18be <_ZN9task_user3runEv+0x2da>
    18c6:	08 be       	out	0x38, r0	; 56
    18c8:	ff cf       	rjmp	.-2      	; 0x18c8 <_ZN9task_user3runEv+0x2e4>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    18ca:	f8 01       	movw	r30, r16
    18cc:	86 85       	ldd	r24, Z+14	; 0x0e
    18ce:	97 85       	ldd	r25, Z+15	; 0x0f
    18d0:	a0 89       	ldd	r26, Z+16	; 0x10
    18d2:	b1 89       	ldd	r27, Z+17	; 0x11
    18d4:	01 96       	adiw	r24, 0x01	; 1
    18d6:	a1 1d       	adc	r26, r1
    18d8:	b1 1d       	adc	r27, r1
    18da:	86 87       	std	Z+14, r24	; 0x0e
    18dc:	97 87       	std	Z+15, r25	; 0x0f
    18de:	a0 8b       	std	Z+16, r26	; 0x10
    18e0:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    18e2:	61 e0       	ldi	r22, 0x01	; 1
    18e4:	70 e0       	ldi	r23, 0x00	; 0
    18e6:	80 e0       	ldi	r24, 0x00	; 0
    18e8:	90 e0       	ldi	r25, 0x00	; 0
    18ea:	0e 94 9d 15 	call	0x2b3a	; 0x2b3a <vTaskDelay>
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;

	
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    18ee:	98 ce       	rjmp	.-720    	; 0x1620 <_ZN9task_user3runEv+0x3c>

000018f0 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    18f0:	0f 93       	push	r16
    18f2:	1f 93       	push	r17
    18f4:	cf 93       	push	r28
    18f6:	df 93       	push	r29
    18f8:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    18fa:	0e 94 8c 13 	call	0x2718	; 0x2718 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    18fe:	80 91 bc 20 	lds	r24, 0x20BC	; 0x8020bc <__data_end>
    1902:	81 11       	cpse	r24, r1
    1904:	1d c0       	rjmp	.+58     	; 0x1940 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1906:	a1 ec       	ldi	r26, 0xC1	; 193
    1908:	b0 e2       	ldi	r27, 0x20	; 32
    190a:	e5 ec       	ldi	r30, 0xC5	; 197
    190c:	f0 e2       	ldi	r31, 0x20	; 32
    190e:	ed 93       	st	X+, r30
    1910:	fc 93       	st	X, r31
    1912:	11 97       	sbiw	r26, 0x01	; 1
    1914:	12 96       	adiw	r26, 0x02	; 2
    1916:	1d 92       	st	X+, r1
    1918:	1c 92       	st	X, r1
    191a:	13 97       	sbiw	r26, 0x03	; 3
    191c:	ad eb       	ldi	r26, 0xBD	; 189
    191e:	b0 e2       	ldi	r27, 0x20	; 32
    1920:	8f ef       	ldi	r24, 0xFF	; 255
    1922:	9f e0       	ldi	r25, 0x0F	; 15
    1924:	12 96       	adiw	r26, 0x02	; 2
    1926:	8d 93       	st	X+, r24
    1928:	9c 93       	st	X, r25
    192a:	13 97       	sbiw	r26, 0x03	; 3
    192c:	1d 92       	st	X+, r1
    192e:	1c 92       	st	X, r1
    1930:	11 97       	sbiw	r26, 0x01	; 1
    1932:	82 83       	std	Z+2, r24	; 0x02
    1934:	93 83       	std	Z+3, r25	; 0x03
    1936:	a0 83       	st	Z, r26
    1938:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    193a:	81 e0       	ldi	r24, 0x01	; 1
    193c:	80 93 bc 20 	sts	0x20BC, r24	; 0x8020bc <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1940:	20 97       	sbiw	r28, 0x00	; 0
    1942:	09 f4       	brne	.+2      	; 0x1946 <pvPortMalloc+0x56>
    1944:	5f c0       	rjmp	.+190    	; 0x1a04 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1946:	9e 01       	movw	r18, r28
    1948:	2b 5f       	subi	r18, 0xFB	; 251
    194a:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    194c:	24 96       	adiw	r28, 0x04	; 4
    194e:	ce 3f       	cpi	r28, 0xFE	; 254
    1950:	df 40       	sbci	r29, 0x0F	; 15
    1952:	08 f0       	brcs	.+2      	; 0x1956 <pvPortMalloc+0x66>
    1954:	5a c0       	rjmp	.+180    	; 0x1a0a <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1956:	e0 91 c1 20 	lds	r30, 0x20C1	; 0x8020c1 <xStart>
    195a:	f0 91 c2 20 	lds	r31, 0x20C2	; 0x8020c2 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    195e:	a1 ec       	ldi	r26, 0xC1	; 193
    1960:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1962:	02 c0       	rjmp	.+4      	; 0x1968 <pvPortMalloc+0x78>
    1964:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1966:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1968:	82 81       	ldd	r24, Z+2	; 0x02
    196a:	93 81       	ldd	r25, Z+3	; 0x03
    196c:	82 17       	cp	r24, r18
    196e:	93 07       	cpc	r25, r19
    1970:	20 f4       	brcc	.+8      	; 0x197a <pvPortMalloc+0x8a>
    1972:	80 81       	ld	r24, Z
    1974:	91 81       	ldd	r25, Z+1	; 0x01
    1976:	00 97       	sbiw	r24, 0x00	; 0
    1978:	a9 f7       	brne	.-22     	; 0x1964 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    197a:	c0 e2       	ldi	r28, 0x20	; 32
    197c:	ed 3b       	cpi	r30, 0xBD	; 189
    197e:	fc 07       	cpc	r31, r28
    1980:	09 f4       	brne	.+2      	; 0x1984 <pvPortMalloc+0x94>
    1982:	46 c0       	rjmp	.+140    	; 0x1a10 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1984:	cd 91       	ld	r28, X+
    1986:	dc 91       	ld	r29, X
    1988:	11 97       	sbiw	r26, 0x01	; 1
    198a:	8e 01       	movw	r16, r28
    198c:	0b 5f       	subi	r16, 0xFB	; 251
    198e:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1990:	80 81       	ld	r24, Z
    1992:	91 81       	ldd	r25, Z+1	; 0x01
    1994:	8d 93       	st	X+, r24
    1996:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1998:	82 81       	ldd	r24, Z+2	; 0x02
    199a:	93 81       	ldd	r25, Z+3	; 0x03
    199c:	82 1b       	sub	r24, r18
    199e:	93 0b       	sbc	r25, r19
    19a0:	8b 30       	cpi	r24, 0x0B	; 11
    19a2:	91 05       	cpc	r25, r1
    19a4:	10 f1       	brcs	.+68     	; 0x19ea <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    19a6:	bf 01       	movw	r22, r30
    19a8:	62 0f       	add	r22, r18
    19aa:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    19ac:	db 01       	movw	r26, r22
    19ae:	12 96       	adiw	r26, 0x02	; 2
    19b0:	8d 93       	st	X+, r24
    19b2:	9c 93       	st	X, r25
    19b4:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    19b6:	22 83       	std	Z+2, r18	; 0x02
    19b8:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    19ba:	12 96       	adiw	r26, 0x02	; 2
    19bc:	4d 91       	ld	r20, X+
    19be:	5c 91       	ld	r21, X
    19c0:	13 97       	sbiw	r26, 0x03	; 3
    19c2:	81 ec       	ldi	r24, 0xC1	; 193
    19c4:	90 e2       	ldi	r25, 0x20	; 32
    19c6:	01 c0       	rjmp	.+2      	; 0x19ca <pvPortMalloc+0xda>
    19c8:	cd 01       	movw	r24, r26
    19ca:	ec 01       	movw	r28, r24
    19cc:	a8 81       	ld	r26, Y
    19ce:	b9 81       	ldd	r27, Y+1	; 0x01
    19d0:	12 96       	adiw	r26, 0x02	; 2
    19d2:	2d 91       	ld	r18, X+
    19d4:	3c 91       	ld	r19, X
    19d6:	13 97       	sbiw	r26, 0x03	; 3
    19d8:	24 17       	cp	r18, r20
    19da:	35 07       	cpc	r19, r21
    19dc:	a8 f3       	brcs	.-22     	; 0x19c8 <pvPortMalloc+0xd8>
    19de:	eb 01       	movw	r28, r22
    19e0:	a8 83       	st	Y, r26
    19e2:	b9 83       	std	Y+1, r27	; 0x01
    19e4:	dc 01       	movw	r26, r24
    19e6:	6d 93       	st	X+, r22
    19e8:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    19ea:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    19ee:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    19f2:	22 81       	ldd	r18, Z+2	; 0x02
    19f4:	33 81       	ldd	r19, Z+3	; 0x03
    19f6:	82 1b       	sub	r24, r18
    19f8:	93 0b       	sbc	r25, r19
    19fa:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    19fe:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1a02:	08 c0       	rjmp	.+16     	; 0x1a14 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1a04:	00 e0       	ldi	r16, 0x00	; 0
    1a06:	10 e0       	ldi	r17, 0x00	; 0
    1a08:	05 c0       	rjmp	.+10     	; 0x1a14 <pvPortMalloc+0x124>
    1a0a:	00 e0       	ldi	r16, 0x00	; 0
    1a0c:	10 e0       	ldi	r17, 0x00	; 0
    1a0e:	02 c0       	rjmp	.+4      	; 0x1a14 <pvPortMalloc+0x124>
    1a10:	00 e0       	ldi	r16, 0x00	; 0
    1a12:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1a14:	0e 94 ae 14 	call	0x295c	; 0x295c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1a18:	c8 01       	movw	r24, r16
    1a1a:	df 91       	pop	r29
    1a1c:	cf 91       	pop	r28
    1a1e:	1f 91       	pop	r17
    1a20:	0f 91       	pop	r16
    1a22:	08 95       	ret

00001a24 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1a24:	0f 93       	push	r16
    1a26:	1f 93       	push	r17
    1a28:	cf 93       	push	r28
    1a2a:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1a2c:	00 97       	sbiw	r24, 0x00	; 0
    1a2e:	41 f1       	breq	.+80     	; 0x1a80 <vPortFree+0x5c>
    1a30:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1a32:	8c 01       	movw	r16, r24
    1a34:	05 50       	subi	r16, 0x05	; 5
    1a36:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1a38:	0e 94 8c 13 	call	0x2718	; 0x2718 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1a3c:	f8 01       	movw	r30, r16
    1a3e:	42 81       	ldd	r20, Z+2	; 0x02
    1a40:	53 81       	ldd	r21, Z+3	; 0x03
    1a42:	a1 ec       	ldi	r26, 0xC1	; 193
    1a44:	b0 e2       	ldi	r27, 0x20	; 32
    1a46:	01 c0       	rjmp	.+2      	; 0x1a4a <vPortFree+0x26>
    1a48:	df 01       	movw	r26, r30
    1a4a:	ed 91       	ld	r30, X+
    1a4c:	fc 91       	ld	r31, X
    1a4e:	11 97       	sbiw	r26, 0x01	; 1
    1a50:	22 81       	ldd	r18, Z+2	; 0x02
    1a52:	33 81       	ldd	r19, Z+3	; 0x03
    1a54:	24 17       	cp	r18, r20
    1a56:	35 07       	cpc	r19, r21
    1a58:	b8 f3       	brcs	.-18     	; 0x1a48 <vPortFree+0x24>
    1a5a:	25 97       	sbiw	r28, 0x05	; 5
    1a5c:	e8 83       	st	Y, r30
    1a5e:	f9 83       	std	Y+1, r31	; 0x01
    1a60:	0d 93       	st	X+, r16
    1a62:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1a64:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1a68:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1a6c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a6e:	9b 81       	ldd	r25, Y+3	; 0x03
    1a70:	82 0f       	add	r24, r18
    1a72:	93 1f       	adc	r25, r19
    1a74:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1a78:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1a7c:	0e 94 ae 14 	call	0x295c	; 0x295c <xTaskResumeAll>
	}
}
    1a80:	df 91       	pop	r29
    1a82:	cf 91       	pop	r28
    1a84:	1f 91       	pop	r17
    1a86:	0f 91       	pop	r16
    1a88:	08 95       	ret

00001a8a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1a8a:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1a8e:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1a92:	08 95       	ret

00001a94 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1a94:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1a96:	03 96       	adiw	r24, 0x03	; 3
    1a98:	81 83       	std	Z+1, r24	; 0x01
    1a9a:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1a9c:	4f ef       	ldi	r20, 0xFF	; 255
    1a9e:	5f ef       	ldi	r21, 0xFF	; 255
    1aa0:	ba 01       	movw	r22, r20
    1aa2:	43 83       	std	Z+3, r20	; 0x03
    1aa4:	54 83       	std	Z+4, r21	; 0x04
    1aa6:	65 83       	std	Z+5, r22	; 0x05
    1aa8:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1aaa:	87 83       	std	Z+7, r24	; 0x07
    1aac:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1aae:	81 87       	std	Z+9, r24	; 0x09
    1ab0:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1ab2:	10 82       	st	Z, r1
    1ab4:	08 95       	ret

00001ab6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1ab6:	fc 01       	movw	r30, r24
    1ab8:	12 86       	std	Z+10, r1	; 0x0a
    1aba:	13 86       	std	Z+11, r1	; 0x0b
    1abc:	08 95       	ret

00001abe <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1abe:	cf 93       	push	r28
    1ac0:	df 93       	push	r29
    1ac2:	fc 01       	movw	r30, r24
    1ac4:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1ac6:	21 81       	ldd	r18, Z+1	; 0x01
    1ac8:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1aca:	e9 01       	movw	r28, r18
    1acc:	8c 81       	ldd	r24, Y+4	; 0x04
    1ace:	9d 81       	ldd	r25, Y+5	; 0x05
    1ad0:	14 96       	adiw	r26, 0x04	; 4
    1ad2:	8d 93       	st	X+, r24
    1ad4:	9c 93       	st	X, r25
    1ad6:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1ad8:	81 81       	ldd	r24, Z+1	; 0x01
    1ada:	92 81       	ldd	r25, Z+2	; 0x02
    1adc:	16 96       	adiw	r26, 0x06	; 6
    1ade:	8d 93       	st	X+, r24
    1ae0:	9c 93       	st	X, r25
    1ae2:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1ae4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ae6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ae8:	ec 01       	movw	r28, r24
    1aea:	6e 83       	std	Y+6, r22	; 0x06
    1aec:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1aee:	e9 01       	movw	r28, r18
    1af0:	6c 83       	std	Y+4, r22	; 0x04
    1af2:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1af4:	61 83       	std	Z+1, r22	; 0x01
    1af6:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1af8:	1a 96       	adiw	r26, 0x0a	; 10
    1afa:	ed 93       	st	X+, r30
    1afc:	fc 93       	st	X, r31
    1afe:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1b00:	80 81       	ld	r24, Z
    1b02:	8f 5f       	subi	r24, 0xFF	; 255
    1b04:	80 83       	st	Z, r24
}
    1b06:	df 91       	pop	r29
    1b08:	cf 91       	pop	r28
    1b0a:	08 95       	ret

00001b0c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1b0c:	0f 93       	push	r16
    1b0e:	1f 93       	push	r17
    1b10:	cf 93       	push	r28
    1b12:	df 93       	push	r29
    1b14:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1b16:	08 81       	ld	r16, Y
    1b18:	19 81       	ldd	r17, Y+1	; 0x01
    1b1a:	2a 81       	ldd	r18, Y+2	; 0x02
    1b1c:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1b1e:	0f 3f       	cpi	r16, 0xFF	; 255
    1b20:	4f ef       	ldi	r20, 0xFF	; 255
    1b22:	14 07       	cpc	r17, r20
    1b24:	24 07       	cpc	r18, r20
    1b26:	34 07       	cpc	r19, r20
    1b28:	31 f4       	brne	.+12     	; 0x1b36 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1b2a:	dc 01       	movw	r26, r24
    1b2c:	19 96       	adiw	r26, 0x09	; 9
    1b2e:	ed 91       	ld	r30, X+
    1b30:	fc 91       	ld	r31, X
    1b32:	1a 97       	sbiw	r26, 0x0a	; 10
    1b34:	1f c0       	rjmp	.+62     	; 0x1b74 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1b36:	fc 01       	movw	r30, r24
    1b38:	33 96       	adiw	r30, 0x03	; 3
    1b3a:	dc 01       	movw	r26, r24
    1b3c:	17 96       	adiw	r26, 0x07	; 7
    1b3e:	4d 91       	ld	r20, X+
    1b40:	5c 91       	ld	r21, X
    1b42:	18 97       	sbiw	r26, 0x08	; 8
    1b44:	da 01       	movw	r26, r20
    1b46:	4d 91       	ld	r20, X+
    1b48:	5d 91       	ld	r21, X+
    1b4a:	6d 91       	ld	r22, X+
    1b4c:	7c 91       	ld	r23, X
    1b4e:	04 17       	cp	r16, r20
    1b50:	15 07       	cpc	r17, r21
    1b52:	26 07       	cpc	r18, r22
    1b54:	37 07       	cpc	r19, r23
    1b56:	70 f0       	brcs	.+28     	; 0x1b74 <vListInsert+0x68>
    1b58:	04 80       	ldd	r0, Z+4	; 0x04
    1b5a:	f5 81       	ldd	r31, Z+5	; 0x05
    1b5c:	e0 2d       	mov	r30, r0
    1b5e:	a4 81       	ldd	r26, Z+4	; 0x04
    1b60:	b5 81       	ldd	r27, Z+5	; 0x05
    1b62:	4d 91       	ld	r20, X+
    1b64:	5d 91       	ld	r21, X+
    1b66:	6d 91       	ld	r22, X+
    1b68:	7c 91       	ld	r23, X
    1b6a:	04 17       	cp	r16, r20
    1b6c:	15 07       	cpc	r17, r21
    1b6e:	26 07       	cpc	r18, r22
    1b70:	37 07       	cpc	r19, r23
    1b72:	90 f7       	brcc	.-28     	; 0x1b58 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1b74:	a4 81       	ldd	r26, Z+4	; 0x04
    1b76:	b5 81       	ldd	r27, Z+5	; 0x05
    1b78:	ac 83       	std	Y+4, r26	; 0x04
    1b7a:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1b7c:	16 96       	adiw	r26, 0x06	; 6
    1b7e:	cd 93       	st	X+, r28
    1b80:	dc 93       	st	X, r29
    1b82:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1b84:	ee 83       	std	Y+6, r30	; 0x06
    1b86:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1b88:	c4 83       	std	Z+4, r28	; 0x04
    1b8a:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1b8c:	8a 87       	std	Y+10, r24	; 0x0a
    1b8e:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1b90:	fc 01       	movw	r30, r24
    1b92:	20 81       	ld	r18, Z
    1b94:	2f 5f       	subi	r18, 0xFF	; 255
    1b96:	20 83       	st	Z, r18
}
    1b98:	df 91       	pop	r29
    1b9a:	cf 91       	pop	r28
    1b9c:	1f 91       	pop	r17
    1b9e:	0f 91       	pop	r16
    1ba0:	08 95       	ret

00001ba2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1ba2:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1ba4:	a4 81       	ldd	r26, Z+4	; 0x04
    1ba6:	b5 81       	ldd	r27, Z+5	; 0x05
    1ba8:	86 81       	ldd	r24, Z+6	; 0x06
    1baa:	97 81       	ldd	r25, Z+7	; 0x07
    1bac:	16 96       	adiw	r26, 0x06	; 6
    1bae:	8d 93       	st	X+, r24
    1bb0:	9c 93       	st	X, r25
    1bb2:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1bb4:	a6 81       	ldd	r26, Z+6	; 0x06
    1bb6:	b7 81       	ldd	r27, Z+7	; 0x07
    1bb8:	84 81       	ldd	r24, Z+4	; 0x04
    1bba:	95 81       	ldd	r25, Z+5	; 0x05
    1bbc:	14 96       	adiw	r26, 0x04	; 4
    1bbe:	8d 93       	st	X+, r24
    1bc0:	9c 93       	st	X, r25
    1bc2:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1bc4:	a2 85       	ldd	r26, Z+10	; 0x0a
    1bc6:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1bc8:	11 96       	adiw	r26, 0x01	; 1
    1bca:	8d 91       	ld	r24, X+
    1bcc:	9c 91       	ld	r25, X
    1bce:	12 97       	sbiw	r26, 0x02	; 2
    1bd0:	e8 17       	cp	r30, r24
    1bd2:	f9 07       	cpc	r31, r25
    1bd4:	31 f4       	brne	.+12     	; 0x1be2 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1bd6:	86 81       	ldd	r24, Z+6	; 0x06
    1bd8:	97 81       	ldd	r25, Z+7	; 0x07
    1bda:	11 96       	adiw	r26, 0x01	; 1
    1bdc:	8d 93       	st	X+, r24
    1bde:	9c 93       	st	X, r25
    1be0:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1be2:	12 86       	std	Z+10, r1	; 0x0a
    1be4:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1be6:	8c 91       	ld	r24, X
    1be8:	81 50       	subi	r24, 0x01	; 1
    1bea:	8c 93       	st	X, r24
    1bec:	08 95       	ret

00001bee <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1bee:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <portStackTopForTask>
    1bf2:	90 93 65 31 	sts	0x3165, r25	; 0x803165 <portStackTopForTask+0x1>
    1bf6:	31 e1       	ldi	r19, 0x11	; 17
    1bf8:	fc 01       	movw	r30, r24
    1bfa:	30 83       	st	Z, r19
    1bfc:	31 97       	sbiw	r30, 0x01	; 1
    1bfe:	22 e2       	ldi	r18, 0x22	; 34
    1c00:	20 83       	st	Z, r18
    1c02:	31 97       	sbiw	r30, 0x01	; 1
    1c04:	a3 e3       	ldi	r26, 0x33	; 51
    1c06:	a0 83       	st	Z, r26
    1c08:	31 97       	sbiw	r30, 0x01	; 1
    1c0a:	60 83       	st	Z, r22
    1c0c:	31 97       	sbiw	r30, 0x01	; 1
    1c0e:	70 83       	st	Z, r23
    1c10:	31 97       	sbiw	r30, 0x01	; 1
    1c12:	10 82       	st	Z, r1
    1c14:	31 97       	sbiw	r30, 0x01	; 1
    1c16:	10 82       	st	Z, r1
    1c18:	31 97       	sbiw	r30, 0x01	; 1
    1c1a:	60 e8       	ldi	r22, 0x80	; 128
    1c1c:	60 83       	st	Z, r22
    1c1e:	31 97       	sbiw	r30, 0x01	; 1
    1c20:	10 82       	st	Z, r1
    1c22:	31 97       	sbiw	r30, 0x01	; 1
    1c24:	10 82       	st	Z, r1
    1c26:	31 97       	sbiw	r30, 0x01	; 1
    1c28:	10 82       	st	Z, r1
    1c2a:	31 97       	sbiw	r30, 0x01	; 1
    1c2c:	62 e0       	ldi	r22, 0x02	; 2
    1c2e:	60 83       	st	Z, r22
    1c30:	31 97       	sbiw	r30, 0x01	; 1
    1c32:	63 e0       	ldi	r22, 0x03	; 3
    1c34:	60 83       	st	Z, r22
    1c36:	31 97       	sbiw	r30, 0x01	; 1
    1c38:	64 e0       	ldi	r22, 0x04	; 4
    1c3a:	60 83       	st	Z, r22
    1c3c:	31 97       	sbiw	r30, 0x01	; 1
    1c3e:	65 e0       	ldi	r22, 0x05	; 5
    1c40:	60 83       	st	Z, r22
    1c42:	31 97       	sbiw	r30, 0x01	; 1
    1c44:	66 e0       	ldi	r22, 0x06	; 6
    1c46:	60 83       	st	Z, r22
    1c48:	31 97       	sbiw	r30, 0x01	; 1
    1c4a:	67 e0       	ldi	r22, 0x07	; 7
    1c4c:	60 83       	st	Z, r22
    1c4e:	31 97       	sbiw	r30, 0x01	; 1
    1c50:	68 e0       	ldi	r22, 0x08	; 8
    1c52:	60 83       	st	Z, r22
    1c54:	31 97       	sbiw	r30, 0x01	; 1
    1c56:	69 e0       	ldi	r22, 0x09	; 9
    1c58:	60 83       	st	Z, r22
    1c5a:	31 97       	sbiw	r30, 0x01	; 1
    1c5c:	60 e1       	ldi	r22, 0x10	; 16
    1c5e:	60 83       	st	Z, r22
    1c60:	31 97       	sbiw	r30, 0x01	; 1
    1c62:	30 83       	st	Z, r19
    1c64:	31 97       	sbiw	r30, 0x01	; 1
    1c66:	32 e1       	ldi	r19, 0x12	; 18
    1c68:	30 83       	st	Z, r19
    1c6a:	31 97       	sbiw	r30, 0x01	; 1
    1c6c:	33 e1       	ldi	r19, 0x13	; 19
    1c6e:	30 83       	st	Z, r19
    1c70:	31 97       	sbiw	r30, 0x01	; 1
    1c72:	34 e1       	ldi	r19, 0x14	; 20
    1c74:	30 83       	st	Z, r19
    1c76:	31 97       	sbiw	r30, 0x01	; 1
    1c78:	35 e1       	ldi	r19, 0x15	; 21
    1c7a:	30 83       	st	Z, r19
    1c7c:	31 97       	sbiw	r30, 0x01	; 1
    1c7e:	36 e1       	ldi	r19, 0x16	; 22
    1c80:	30 83       	st	Z, r19
    1c82:	31 97       	sbiw	r30, 0x01	; 1
    1c84:	37 e1       	ldi	r19, 0x17	; 23
    1c86:	30 83       	st	Z, r19
    1c88:	31 97       	sbiw	r30, 0x01	; 1
    1c8a:	38 e1       	ldi	r19, 0x18	; 24
    1c8c:	30 83       	st	Z, r19
    1c8e:	31 97       	sbiw	r30, 0x01	; 1
    1c90:	39 e1       	ldi	r19, 0x19	; 25
    1c92:	30 83       	st	Z, r19
    1c94:	31 97       	sbiw	r30, 0x01	; 1
    1c96:	30 e2       	ldi	r19, 0x20	; 32
    1c98:	30 83       	st	Z, r19
    1c9a:	31 97       	sbiw	r30, 0x01	; 1
    1c9c:	31 e2       	ldi	r19, 0x21	; 33
    1c9e:	30 83       	st	Z, r19
    1ca0:	31 97       	sbiw	r30, 0x01	; 1
    1ca2:	20 83       	st	Z, r18
    1ca4:	31 97       	sbiw	r30, 0x01	; 1
    1ca6:	23 e2       	ldi	r18, 0x23	; 35
    1ca8:	20 83       	st	Z, r18
    1caa:	31 97       	sbiw	r30, 0x01	; 1
    1cac:	40 83       	st	Z, r20
    1cae:	31 97       	sbiw	r30, 0x01	; 1
    1cb0:	50 83       	st	Z, r21
    1cb2:	31 97       	sbiw	r30, 0x01	; 1
    1cb4:	26 e2       	ldi	r18, 0x26	; 38
    1cb6:	20 83       	st	Z, r18
    1cb8:	31 97       	sbiw	r30, 0x01	; 1
    1cba:	27 e2       	ldi	r18, 0x27	; 39
    1cbc:	20 83       	st	Z, r18
    1cbe:	31 97       	sbiw	r30, 0x01	; 1
    1cc0:	28 e2       	ldi	r18, 0x28	; 40
    1cc2:	20 83       	st	Z, r18
    1cc4:	31 97       	sbiw	r30, 0x01	; 1
    1cc6:	29 e2       	ldi	r18, 0x29	; 41
    1cc8:	20 83       	st	Z, r18
    1cca:	31 97       	sbiw	r30, 0x01	; 1
    1ccc:	20 e3       	ldi	r18, 0x30	; 48
    1cce:	20 83       	st	Z, r18
    1cd0:	31 97       	sbiw	r30, 0x01	; 1
    1cd2:	21 e3       	ldi	r18, 0x31	; 49
    1cd4:	20 83       	st	Z, r18
    1cd6:	89 97       	sbiw	r24, 0x29	; 41
    1cd8:	08 95       	ret

00001cda <xPortStartScheduler>:
    1cda:	8c e7       	ldi	r24, 0x7C	; 124
    1cdc:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1ce0:	8f ef       	ldi	r24, 0xFF	; 255
    1ce2:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1ce6:	81 e0       	ldi	r24, 0x01	; 1
    1ce8:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    1cec:	91 e1       	ldi	r25, 0x11	; 17
    1cee:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    1cf2:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    1cf6:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1cfa:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1cfe:	cd 91       	ld	r28, X+
    1d00:	cd bf       	out	0x3d, r28	; 61
    1d02:	dd 91       	ld	r29, X+
    1d04:	de bf       	out	0x3e, r29	; 62
    1d06:	ff 91       	pop	r31
    1d08:	ef 91       	pop	r30
    1d0a:	df 91       	pop	r29
    1d0c:	cf 91       	pop	r28
    1d0e:	bf 91       	pop	r27
    1d10:	af 91       	pop	r26
    1d12:	9f 91       	pop	r25
    1d14:	8f 91       	pop	r24
    1d16:	7f 91       	pop	r23
    1d18:	6f 91       	pop	r22
    1d1a:	5f 91       	pop	r21
    1d1c:	4f 91       	pop	r20
    1d1e:	3f 91       	pop	r19
    1d20:	2f 91       	pop	r18
    1d22:	1f 91       	pop	r17
    1d24:	0f 91       	pop	r16
    1d26:	ff 90       	pop	r15
    1d28:	ef 90       	pop	r14
    1d2a:	df 90       	pop	r13
    1d2c:	cf 90       	pop	r12
    1d2e:	bf 90       	pop	r11
    1d30:	af 90       	pop	r10
    1d32:	9f 90       	pop	r9
    1d34:	8f 90       	pop	r8
    1d36:	7f 90       	pop	r7
    1d38:	6f 90       	pop	r6
    1d3a:	5f 90       	pop	r5
    1d3c:	4f 90       	pop	r4
    1d3e:	3f 90       	pop	r3
    1d40:	2f 90       	pop	r2
    1d42:	1f 90       	pop	r1
    1d44:	0f 90       	pop	r0
    1d46:	0c be       	out	0x3c, r0	; 60
    1d48:	0f 90       	pop	r0
    1d4a:	0b be       	out	0x3b, r0	; 59
    1d4c:	0f 90       	pop	r0
    1d4e:	0f be       	out	0x3f, r0	; 63
    1d50:	0f 90       	pop	r0
    1d52:	08 95       	ret
    1d54:	08 95       	ret

00001d56 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1d56:	0f 92       	push	r0
    1d58:	0f b6       	in	r0, 0x3f	; 63
    1d5a:	f8 94       	cli
    1d5c:	0f 92       	push	r0
    1d5e:	0b b6       	in	r0, 0x3b	; 59
    1d60:	0f 92       	push	r0
    1d62:	0c b6       	in	r0, 0x3c	; 60
    1d64:	0f 92       	push	r0
    1d66:	1f 92       	push	r1
    1d68:	11 24       	eor	r1, r1
    1d6a:	2f 92       	push	r2
    1d6c:	3f 92       	push	r3
    1d6e:	4f 92       	push	r4
    1d70:	5f 92       	push	r5
    1d72:	6f 92       	push	r6
    1d74:	7f 92       	push	r7
    1d76:	8f 92       	push	r8
    1d78:	9f 92       	push	r9
    1d7a:	af 92       	push	r10
    1d7c:	bf 92       	push	r11
    1d7e:	cf 92       	push	r12
    1d80:	df 92       	push	r13
    1d82:	ef 92       	push	r14
    1d84:	ff 92       	push	r15
    1d86:	0f 93       	push	r16
    1d88:	1f 93       	push	r17
    1d8a:	2f 93       	push	r18
    1d8c:	3f 93       	push	r19
    1d8e:	4f 93       	push	r20
    1d90:	5f 93       	push	r21
    1d92:	6f 93       	push	r22
    1d94:	7f 93       	push	r23
    1d96:	8f 93       	push	r24
    1d98:	9f 93       	push	r25
    1d9a:	af 93       	push	r26
    1d9c:	bf 93       	push	r27
    1d9e:	cf 93       	push	r28
    1da0:	df 93       	push	r29
    1da2:	ef 93       	push	r30
    1da4:	ff 93       	push	r31
    1da6:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1daa:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1dae:	0d b6       	in	r0, 0x3d	; 61
    1db0:	0d 92       	st	X+, r0
    1db2:	0e b6       	in	r0, 0x3e	; 62
    1db4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1db6:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1dba:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1dbe:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1dc2:	cd 91       	ld	r28, X+
    1dc4:	cd bf       	out	0x3d, r28	; 61
    1dc6:	dd 91       	ld	r29, X+
    1dc8:	de bf       	out	0x3e, r29	; 62
    1dca:	ff 91       	pop	r31
    1dcc:	ef 91       	pop	r30
    1dce:	df 91       	pop	r29
    1dd0:	cf 91       	pop	r28
    1dd2:	bf 91       	pop	r27
    1dd4:	af 91       	pop	r26
    1dd6:	9f 91       	pop	r25
    1dd8:	8f 91       	pop	r24
    1dda:	7f 91       	pop	r23
    1ddc:	6f 91       	pop	r22
    1dde:	5f 91       	pop	r21
    1de0:	4f 91       	pop	r20
    1de2:	3f 91       	pop	r19
    1de4:	2f 91       	pop	r18
    1de6:	1f 91       	pop	r17
    1de8:	0f 91       	pop	r16
    1dea:	ff 90       	pop	r15
    1dec:	ef 90       	pop	r14
    1dee:	df 90       	pop	r13
    1df0:	cf 90       	pop	r12
    1df2:	bf 90       	pop	r11
    1df4:	af 90       	pop	r10
    1df6:	9f 90       	pop	r9
    1df8:	8f 90       	pop	r8
    1dfa:	7f 90       	pop	r7
    1dfc:	6f 90       	pop	r6
    1dfe:	5f 90       	pop	r5
    1e00:	4f 90       	pop	r4
    1e02:	3f 90       	pop	r3
    1e04:	2f 90       	pop	r2
    1e06:	1f 90       	pop	r1
    1e08:	0f 90       	pop	r0
    1e0a:	0c be       	out	0x3c, r0	; 60
    1e0c:	0f 90       	pop	r0
    1e0e:	0b be       	out	0x3b, r0	; 59
    1e10:	0f 90       	pop	r0
    1e12:	0f be       	out	0x3f, r0	; 63
    1e14:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1e16:	08 95       	ret

00001e18 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1e18:	0f 92       	push	r0
    1e1a:	0f b6       	in	r0, 0x3f	; 63
    1e1c:	f8 94       	cli
    1e1e:	0f 92       	push	r0
    1e20:	0b b6       	in	r0, 0x3b	; 59
    1e22:	0f 92       	push	r0
    1e24:	0c b6       	in	r0, 0x3c	; 60
    1e26:	0f 92       	push	r0
    1e28:	1f 92       	push	r1
    1e2a:	11 24       	eor	r1, r1
    1e2c:	2f 92       	push	r2
    1e2e:	3f 92       	push	r3
    1e30:	4f 92       	push	r4
    1e32:	5f 92       	push	r5
    1e34:	6f 92       	push	r6
    1e36:	7f 92       	push	r7
    1e38:	8f 92       	push	r8
    1e3a:	9f 92       	push	r9
    1e3c:	af 92       	push	r10
    1e3e:	bf 92       	push	r11
    1e40:	cf 92       	push	r12
    1e42:	df 92       	push	r13
    1e44:	ef 92       	push	r14
    1e46:	ff 92       	push	r15
    1e48:	0f 93       	push	r16
    1e4a:	1f 93       	push	r17
    1e4c:	2f 93       	push	r18
    1e4e:	3f 93       	push	r19
    1e50:	4f 93       	push	r20
    1e52:	5f 93       	push	r21
    1e54:	6f 93       	push	r22
    1e56:	7f 93       	push	r23
    1e58:	8f 93       	push	r24
    1e5a:	9f 93       	push	r25
    1e5c:	af 93       	push	r26
    1e5e:	bf 93       	push	r27
    1e60:	cf 93       	push	r28
    1e62:	df 93       	push	r29
    1e64:	ef 93       	push	r30
    1e66:	ff 93       	push	r31
    1e68:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1e6c:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1e70:	0d b6       	in	r0, 0x3d	; 61
    1e72:	0d 92       	st	X+, r0
    1e74:	0e b6       	in	r0, 0x3e	; 62
    1e76:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1e78:	0e 94 ad 13 	call	0x275a	; 0x275a <vTaskIncrementTick>
	vTaskSwitchContext();
    1e7c:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1e80:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1e84:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1e88:	cd 91       	ld	r28, X+
    1e8a:	cd bf       	out	0x3d, r28	; 61
    1e8c:	dd 91       	ld	r29, X+
    1e8e:	de bf       	out	0x3e, r29	; 62
    1e90:	ff 91       	pop	r31
    1e92:	ef 91       	pop	r30
    1e94:	df 91       	pop	r29
    1e96:	cf 91       	pop	r28
    1e98:	bf 91       	pop	r27
    1e9a:	af 91       	pop	r26
    1e9c:	9f 91       	pop	r25
    1e9e:	8f 91       	pop	r24
    1ea0:	7f 91       	pop	r23
    1ea2:	6f 91       	pop	r22
    1ea4:	5f 91       	pop	r21
    1ea6:	4f 91       	pop	r20
    1ea8:	3f 91       	pop	r19
    1eaa:	2f 91       	pop	r18
    1eac:	1f 91       	pop	r17
    1eae:	0f 91       	pop	r16
    1eb0:	ff 90       	pop	r15
    1eb2:	ef 90       	pop	r14
    1eb4:	df 90       	pop	r13
    1eb6:	cf 90       	pop	r12
    1eb8:	bf 90       	pop	r11
    1eba:	af 90       	pop	r10
    1ebc:	9f 90       	pop	r9
    1ebe:	8f 90       	pop	r8
    1ec0:	7f 90       	pop	r7
    1ec2:	6f 90       	pop	r6
    1ec4:	5f 90       	pop	r5
    1ec6:	4f 90       	pop	r4
    1ec8:	3f 90       	pop	r3
    1eca:	2f 90       	pop	r2
    1ecc:	1f 90       	pop	r1
    1ece:	0f 90       	pop	r0
    1ed0:	0c be       	out	0x3c, r0	; 60
    1ed2:	0f 90       	pop	r0
    1ed4:	0b be       	out	0x3b, r0	; 59
    1ed6:	0f 90       	pop	r0
    1ed8:	0f be       	out	0x3f, r0	; 63
    1eda:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1edc:	08 95       	ret

00001ede <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1ede:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1ee2:	18 95       	reti

00001ee4 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1ee4:	cf 93       	push	r28
    1ee6:	df 93       	push	r29
    1ee8:	ec 01       	movw	r28, r24
    1eea:	88 a1       	ldd	r24, Y+32	; 0x20
    1eec:	81 11       	cpse	r24, r1
    1eee:	0b c0       	rjmp	.+22     	; 0x1f06 <prvCopyDataToQueue+0x22>
    1ef0:	88 81       	ld	r24, Y
    1ef2:	99 81       	ldd	r25, Y+1	; 0x01
    1ef4:	89 2b       	or	r24, r25
    1ef6:	e1 f5       	brne	.+120    	; 0x1f70 <prvCopyDataToQueue+0x8c>
    1ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    1efa:	9b 81       	ldd	r25, Y+3	; 0x03
    1efc:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <vTaskPriorityDisinherit>
    1f00:	1a 82       	std	Y+2, r1	; 0x02
    1f02:	1b 82       	std	Y+3, r1	; 0x03
    1f04:	35 c0       	rjmp	.+106    	; 0x1f70 <prvCopyDataToQueue+0x8c>
    1f06:	41 11       	cpse	r20, r1
    1f08:	17 c0       	rjmp	.+46     	; 0x1f38 <prvCopyDataToQueue+0x54>
    1f0a:	48 2f       	mov	r20, r24
    1f0c:	50 e0       	ldi	r21, 0x00	; 0
    1f0e:	8c 81       	ldd	r24, Y+4	; 0x04
    1f10:	9d 81       	ldd	r25, Y+5	; 0x05
    1f12:	0e 94 27 23 	call	0x464e	; 0x464e <memcpy>
    1f16:	28 a1       	ldd	r18, Y+32	; 0x20
    1f18:	8c 81       	ldd	r24, Y+4	; 0x04
    1f1a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f1c:	82 0f       	add	r24, r18
    1f1e:	91 1d       	adc	r25, r1
    1f20:	8c 83       	std	Y+4, r24	; 0x04
    1f22:	9d 83       	std	Y+5, r25	; 0x05
    1f24:	2a 81       	ldd	r18, Y+2	; 0x02
    1f26:	3b 81       	ldd	r19, Y+3	; 0x03
    1f28:	82 17       	cp	r24, r18
    1f2a:	93 07       	cpc	r25, r19
    1f2c:	08 f1       	brcs	.+66     	; 0x1f70 <prvCopyDataToQueue+0x8c>
    1f2e:	88 81       	ld	r24, Y
    1f30:	99 81       	ldd	r25, Y+1	; 0x01
    1f32:	8c 83       	std	Y+4, r24	; 0x04
    1f34:	9d 83       	std	Y+5, r25	; 0x05
    1f36:	1c c0       	rjmp	.+56     	; 0x1f70 <prvCopyDataToQueue+0x8c>
    1f38:	48 2f       	mov	r20, r24
    1f3a:	50 e0       	ldi	r21, 0x00	; 0
    1f3c:	8e 81       	ldd	r24, Y+6	; 0x06
    1f3e:	9f 81       	ldd	r25, Y+7	; 0x07
    1f40:	0e 94 27 23 	call	0x464e	; 0x464e <memcpy>
    1f44:	88 a1       	ldd	r24, Y+32	; 0x20
    1f46:	90 e0       	ldi	r25, 0x00	; 0
    1f48:	91 95       	neg	r25
    1f4a:	81 95       	neg	r24
    1f4c:	91 09       	sbc	r25, r1
    1f4e:	2e 81       	ldd	r18, Y+6	; 0x06
    1f50:	3f 81       	ldd	r19, Y+7	; 0x07
    1f52:	28 0f       	add	r18, r24
    1f54:	39 1f       	adc	r19, r25
    1f56:	2e 83       	std	Y+6, r18	; 0x06
    1f58:	3f 83       	std	Y+7, r19	; 0x07
    1f5a:	48 81       	ld	r20, Y
    1f5c:	59 81       	ldd	r21, Y+1	; 0x01
    1f5e:	24 17       	cp	r18, r20
    1f60:	35 07       	cpc	r19, r21
    1f62:	30 f4       	brcc	.+12     	; 0x1f70 <prvCopyDataToQueue+0x8c>
    1f64:	2a 81       	ldd	r18, Y+2	; 0x02
    1f66:	3b 81       	ldd	r19, Y+3	; 0x03
    1f68:	82 0f       	add	r24, r18
    1f6a:	93 1f       	adc	r25, r19
    1f6c:	8e 83       	std	Y+6, r24	; 0x06
    1f6e:	9f 83       	std	Y+7, r25	; 0x07
    1f70:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f72:	8f 5f       	subi	r24, 0xFF	; 255
    1f74:	8e 8f       	std	Y+30, r24	; 0x1e
    1f76:	df 91       	pop	r29
    1f78:	cf 91       	pop	r28
    1f7a:	08 95       	ret

00001f7c <prvCopyDataFromQueue>:
    1f7c:	fc 01       	movw	r30, r24
    1f7e:	80 81       	ld	r24, Z
    1f80:	91 81       	ldd	r25, Z+1	; 0x01
    1f82:	00 97       	sbiw	r24, 0x00	; 0
    1f84:	a1 f0       	breq	.+40     	; 0x1fae <prvCopyDataFromQueue+0x32>
    1f86:	40 a1       	ldd	r20, Z+32	; 0x20
    1f88:	50 e0       	ldi	r21, 0x00	; 0
    1f8a:	26 81       	ldd	r18, Z+6	; 0x06
    1f8c:	37 81       	ldd	r19, Z+7	; 0x07
    1f8e:	24 0f       	add	r18, r20
    1f90:	35 1f       	adc	r19, r21
    1f92:	26 83       	std	Z+6, r18	; 0x06
    1f94:	37 83       	std	Z+7, r19	; 0x07
    1f96:	a2 81       	ldd	r26, Z+2	; 0x02
    1f98:	b3 81       	ldd	r27, Z+3	; 0x03
    1f9a:	2a 17       	cp	r18, r26
    1f9c:	3b 07       	cpc	r19, r27
    1f9e:	10 f0       	brcs	.+4      	; 0x1fa4 <prvCopyDataFromQueue+0x28>
    1fa0:	86 83       	std	Z+6, r24	; 0x06
    1fa2:	97 83       	std	Z+7, r25	; 0x07
    1fa4:	cb 01       	movw	r24, r22
    1fa6:	66 81       	ldd	r22, Z+6	; 0x06
    1fa8:	77 81       	ldd	r23, Z+7	; 0x07
    1faa:	0e 94 27 23 	call	0x464e	; 0x464e <memcpy>
    1fae:	08 95       	ret

00001fb0 <prvUnlockQueue>:
    1fb0:	0f 93       	push	r16
    1fb2:	1f 93       	push	r17
    1fb4:	cf 93       	push	r28
    1fb6:	df 93       	push	r29
    1fb8:	ec 01       	movw	r28, r24
    1fba:	0f b6       	in	r0, 0x3f	; 63
    1fbc:	f8 94       	cli
    1fbe:	0f 92       	push	r0
    1fc0:	8a a1       	ldd	r24, Y+34	; 0x22
    1fc2:	18 16       	cp	r1, r24
    1fc4:	b4 f4       	brge	.+44     	; 0x1ff2 <prvUnlockQueue+0x42>
    1fc6:	8b 89       	ldd	r24, Y+19	; 0x13
    1fc8:	81 11       	cpse	r24, r1
    1fca:	05 c0       	rjmp	.+10     	; 0x1fd6 <prvUnlockQueue+0x26>
    1fcc:	12 c0       	rjmp	.+36     	; 0x1ff2 <prvUnlockQueue+0x42>
    1fce:	8b 89       	ldd	r24, Y+19	; 0x13
    1fd0:	81 11       	cpse	r24, r1
    1fd2:	04 c0       	rjmp	.+8      	; 0x1fdc <prvUnlockQueue+0x2c>
    1fd4:	0e c0       	rjmp	.+28     	; 0x1ff2 <prvUnlockQueue+0x42>
    1fd6:	8e 01       	movw	r16, r28
    1fd8:	0d 5e       	subi	r16, 0xED	; 237
    1fda:	1f 4f       	sbci	r17, 0xFF	; 255
    1fdc:	c8 01       	movw	r24, r16
    1fde:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <xTaskRemoveFromEventList>
    1fe2:	81 11       	cpse	r24, r1
    1fe4:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vTaskMissedYield>
    1fe8:	8a a1       	ldd	r24, Y+34	; 0x22
    1fea:	81 50       	subi	r24, 0x01	; 1
    1fec:	8a a3       	std	Y+34, r24	; 0x22
    1fee:	18 16       	cp	r1, r24
    1ff0:	74 f3       	brlt	.-36     	; 0x1fce <prvUnlockQueue+0x1e>
    1ff2:	8f ef       	ldi	r24, 0xFF	; 255
    1ff4:	8a a3       	std	Y+34, r24	; 0x22
    1ff6:	0f 90       	pop	r0
    1ff8:	0f be       	out	0x3f, r0	; 63
    1ffa:	0f b6       	in	r0, 0x3f	; 63
    1ffc:	f8 94       	cli
    1ffe:	0f 92       	push	r0
    2000:	89 a1       	ldd	r24, Y+33	; 0x21
    2002:	18 16       	cp	r1, r24
    2004:	b4 f4       	brge	.+44     	; 0x2032 <prvUnlockQueue+0x82>
    2006:	88 85       	ldd	r24, Y+8	; 0x08
    2008:	81 11       	cpse	r24, r1
    200a:	05 c0       	rjmp	.+10     	; 0x2016 <prvUnlockQueue+0x66>
    200c:	12 c0       	rjmp	.+36     	; 0x2032 <prvUnlockQueue+0x82>
    200e:	88 85       	ldd	r24, Y+8	; 0x08
    2010:	81 11       	cpse	r24, r1
    2012:	04 c0       	rjmp	.+8      	; 0x201c <prvUnlockQueue+0x6c>
    2014:	0e c0       	rjmp	.+28     	; 0x2032 <prvUnlockQueue+0x82>
    2016:	8e 01       	movw	r16, r28
    2018:	08 5f       	subi	r16, 0xF8	; 248
    201a:	1f 4f       	sbci	r17, 0xFF	; 255
    201c:	c8 01       	movw	r24, r16
    201e:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <xTaskRemoveFromEventList>
    2022:	81 11       	cpse	r24, r1
    2024:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <vTaskMissedYield>
    2028:	89 a1       	ldd	r24, Y+33	; 0x21
    202a:	81 50       	subi	r24, 0x01	; 1
    202c:	89 a3       	std	Y+33, r24	; 0x21
    202e:	18 16       	cp	r1, r24
    2030:	74 f3       	brlt	.-36     	; 0x200e <prvUnlockQueue+0x5e>
    2032:	8f ef       	ldi	r24, 0xFF	; 255
    2034:	89 a3       	std	Y+33, r24	; 0x21
    2036:	0f 90       	pop	r0
    2038:	0f be       	out	0x3f, r0	; 63
    203a:	df 91       	pop	r29
    203c:	cf 91       	pop	r28
    203e:	1f 91       	pop	r17
    2040:	0f 91       	pop	r16
    2042:	08 95       	ret

00002044 <xQueueGenericReset>:
    2044:	1f 93       	push	r17
    2046:	cf 93       	push	r28
    2048:	df 93       	push	r29
    204a:	61 30       	cpi	r22, 0x01	; 1
    204c:	59 f0       	breq	.+22     	; 0x2064 <xQueueGenericReset+0x20>
    204e:	fc 01       	movw	r30, r24
    2050:	23 89       	ldd	r18, Z+19	; 0x13
    2052:	30 85       	ldd	r19, Z+8	; 0x08
    2054:	31 11       	cpse	r19, r1
    2056:	2c c0       	rjmp	.+88     	; 0x20b0 <xQueueGenericReset+0x6c>
    2058:	11 e0       	ldi	r17, 0x01	; 1
    205a:	21 11       	cpse	r18, r1
    205c:	10 e0       	ldi	r17, 0x00	; 0
    205e:	21 11       	cpse	r18, r1
    2060:	28 c0       	rjmp	.+80     	; 0x20b2 <xQueueGenericReset+0x6e>
    2062:	01 c0       	rjmp	.+2      	; 0x2066 <xQueueGenericReset+0x22>
    2064:	11 e0       	ldi	r17, 0x01	; 1
    2066:	ec 01       	movw	r28, r24
    2068:	48 81       	ld	r20, Y
    206a:	59 81       	ldd	r21, Y+1	; 0x01
    206c:	28 a1       	ldd	r18, Y+32	; 0x20
    206e:	30 e0       	ldi	r19, 0x00	; 0
    2070:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2072:	62 9f       	mul	r22, r18
    2074:	c0 01       	movw	r24, r0
    2076:	63 9f       	mul	r22, r19
    2078:	90 0d       	add	r25, r0
    207a:	11 24       	eor	r1, r1
    207c:	ba 01       	movw	r22, r20
    207e:	68 0f       	add	r22, r24
    2080:	79 1f       	adc	r23, r25
    2082:	6a 83       	std	Y+2, r22	; 0x02
    2084:	7b 83       	std	Y+3, r23	; 0x03
    2086:	1e 8e       	std	Y+30, r1	; 0x1e
    2088:	4c 83       	std	Y+4, r20	; 0x04
    208a:	5d 83       	std	Y+5, r21	; 0x05
    208c:	82 1b       	sub	r24, r18
    208e:	93 0b       	sbc	r25, r19
    2090:	84 0f       	add	r24, r20
    2092:	95 1f       	adc	r25, r21
    2094:	8e 83       	std	Y+6, r24	; 0x06
    2096:	9f 83       	std	Y+7, r25	; 0x07
    2098:	8f ef       	ldi	r24, 0xFF	; 255
    209a:	89 a3       	std	Y+33, r24	; 0x21
    209c:	8a a3       	std	Y+34, r24	; 0x22
    209e:	ce 01       	movw	r24, r28
    20a0:	08 96       	adiw	r24, 0x08	; 8
    20a2:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInitialise>
    20a6:	ce 01       	movw	r24, r28
    20a8:	43 96       	adiw	r24, 0x13	; 19
    20aa:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInitialise>
    20ae:	01 c0       	rjmp	.+2      	; 0x20b2 <xQueueGenericReset+0x6e>
    20b0:	10 e0       	ldi	r17, 0x00	; 0
    20b2:	81 2f       	mov	r24, r17
    20b4:	df 91       	pop	r29
    20b6:	cf 91       	pop	r28
    20b8:	1f 91       	pop	r17
    20ba:	08 95       	ret

000020bc <xQueueGenericCreate>:
    20bc:	0f 93       	push	r16
    20be:	1f 93       	push	r17
    20c0:	cf 93       	push	r28
    20c2:	df 93       	push	r29
    20c4:	88 23       	and	r24, r24
    20c6:	01 f1       	breq	.+64     	; 0x2108 <xQueueGenericCreate+0x4c>
    20c8:	06 2f       	mov	r16, r22
    20ca:	18 2f       	mov	r17, r24
    20cc:	83 e2       	ldi	r24, 0x23	; 35
    20ce:	90 e0       	ldi	r25, 0x00	; 0
    20d0:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <pvPortMalloc>
    20d4:	ec 01       	movw	r28, r24
    20d6:	89 2b       	or	r24, r25
    20d8:	c9 f0       	breq	.+50     	; 0x210c <xQueueGenericCreate+0x50>
    20da:	10 9f       	mul	r17, r16
    20dc:	c0 01       	movw	r24, r0
    20de:	11 24       	eor	r1, r1
    20e0:	01 96       	adiw	r24, 0x01	; 1
    20e2:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <pvPortMalloc>
    20e6:	88 83       	st	Y, r24
    20e8:	99 83       	std	Y+1, r25	; 0x01
    20ea:	89 2b       	or	r24, r25
    20ec:	39 f0       	breq	.+14     	; 0x20fc <xQueueGenericCreate+0x40>
    20ee:	1f 8f       	std	Y+31, r17	; 0x1f
    20f0:	08 a3       	std	Y+32, r16	; 0x20
    20f2:	61 e0       	ldi	r22, 0x01	; 1
    20f4:	ce 01       	movw	r24, r28
    20f6:	0e 94 22 10 	call	0x2044	; 0x2044 <xQueueGenericReset>
    20fa:	08 c0       	rjmp	.+16     	; 0x210c <xQueueGenericCreate+0x50>
    20fc:	ce 01       	movw	r24, r28
    20fe:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <vPortFree>
    2102:	c0 e0       	ldi	r28, 0x00	; 0
    2104:	d0 e0       	ldi	r29, 0x00	; 0
    2106:	02 c0       	rjmp	.+4      	; 0x210c <xQueueGenericCreate+0x50>
    2108:	c0 e0       	ldi	r28, 0x00	; 0
    210a:	d0 e0       	ldi	r29, 0x00	; 0
    210c:	ce 01       	movw	r24, r28
    210e:	df 91       	pop	r29
    2110:	cf 91       	pop	r28
    2112:	1f 91       	pop	r17
    2114:	0f 91       	pop	r16
    2116:	08 95       	ret

00002118 <xQueueGenericSend>:
    2118:	af 92       	push	r10
    211a:	bf 92       	push	r11
    211c:	cf 92       	push	r12
    211e:	df 92       	push	r13
    2120:	ef 92       	push	r14
    2122:	ff 92       	push	r15
    2124:	0f 93       	push	r16
    2126:	1f 93       	push	r17
    2128:	cf 93       	push	r28
    212a:	df 93       	push	r29
    212c:	cd b7       	in	r28, 0x3d	; 61
    212e:	de b7       	in	r29, 0x3e	; 62
    2130:	29 97       	sbiw	r28, 0x09	; 9
    2132:	cd bf       	out	0x3d, r28	; 61
    2134:	de bf       	out	0x3e, r29	; 62
    2136:	7c 01       	movw	r14, r24
    2138:	5b 01       	movw	r10, r22
    213a:	2e 83       	std	Y+6, r18	; 0x06
    213c:	3f 83       	std	Y+7, r19	; 0x07
    213e:	48 87       	std	Y+8, r20	; 0x08
    2140:	59 87       	std	Y+9, r21	; 0x09
    2142:	10 e0       	ldi	r17, 0x00	; 0
    2144:	6c 01       	movw	r12, r24
    2146:	88 e0       	ldi	r24, 0x08	; 8
    2148:	c8 0e       	add	r12, r24
    214a:	d1 1c       	adc	r13, r1
    214c:	0f b6       	in	r0, 0x3f	; 63
    214e:	f8 94       	cli
    2150:	0f 92       	push	r0
    2152:	f7 01       	movw	r30, r14
    2154:	96 8d       	ldd	r25, Z+30	; 0x1e
    2156:	87 8d       	ldd	r24, Z+31	; 0x1f
    2158:	98 17       	cp	r25, r24
    215a:	a8 f4       	brcc	.+42     	; 0x2186 <xQueueGenericSend+0x6e>
    215c:	40 2f       	mov	r20, r16
    215e:	b5 01       	movw	r22, r10
    2160:	c7 01       	movw	r24, r14
    2162:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <prvCopyDataToQueue>
    2166:	f7 01       	movw	r30, r14
    2168:	83 89       	ldd	r24, Z+19	; 0x13
    216a:	88 23       	and	r24, r24
    216c:	41 f0       	breq	.+16     	; 0x217e <xQueueGenericSend+0x66>
    216e:	c7 01       	movw	r24, r14
    2170:	43 96       	adiw	r24, 0x13	; 19
    2172:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <xTaskRemoveFromEventList>
    2176:	81 30       	cpi	r24, 0x01	; 1
    2178:	11 f4       	brne	.+4      	; 0x217e <xQueueGenericSend+0x66>
    217a:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vPortYield>
    217e:	0f 90       	pop	r0
    2180:	0f be       	out	0x3f, r0	; 63
    2182:	81 e0       	ldi	r24, 0x01	; 1
    2184:	56 c0       	rjmp	.+172    	; 0x2232 <xQueueGenericSend+0x11a>
    2186:	8e 81       	ldd	r24, Y+6	; 0x06
    2188:	9f 81       	ldd	r25, Y+7	; 0x07
    218a:	a8 85       	ldd	r26, Y+8	; 0x08
    218c:	b9 85       	ldd	r27, Y+9	; 0x09
    218e:	89 2b       	or	r24, r25
    2190:	8a 2b       	or	r24, r26
    2192:	8b 2b       	or	r24, r27
    2194:	21 f4       	brne	.+8      	; 0x219e <xQueueGenericSend+0x86>
    2196:	0f 90       	pop	r0
    2198:	0f be       	out	0x3f, r0	; 63
    219a:	80 e0       	ldi	r24, 0x00	; 0
    219c:	4a c0       	rjmp	.+148    	; 0x2232 <xQueueGenericSend+0x11a>
    219e:	11 11       	cpse	r17, r1
    21a0:	05 c0       	rjmp	.+10     	; 0x21ac <xQueueGenericSend+0x94>
    21a2:	ce 01       	movw	r24, r28
    21a4:	01 96       	adiw	r24, 0x01	; 1
    21a6:	0e 94 91 16 	call	0x2d22	; 0x2d22 <vTaskSetTimeOutState>
    21aa:	11 e0       	ldi	r17, 0x01	; 1
    21ac:	0f 90       	pop	r0
    21ae:	0f be       	out	0x3f, r0	; 63
    21b0:	0e 94 8c 13 	call	0x2718	; 0x2718 <vTaskSuspendAll>
    21b4:	0f b6       	in	r0, 0x3f	; 63
    21b6:	f8 94       	cli
    21b8:	0f 92       	push	r0
    21ba:	f7 01       	movw	r30, r14
    21bc:	81 a1       	ldd	r24, Z+33	; 0x21
    21be:	8f 3f       	cpi	r24, 0xFF	; 255
    21c0:	09 f4       	brne	.+2      	; 0x21c4 <xQueueGenericSend+0xac>
    21c2:	11 a2       	std	Z+33, r1	; 0x21
    21c4:	f7 01       	movw	r30, r14
    21c6:	82 a1       	ldd	r24, Z+34	; 0x22
    21c8:	8f 3f       	cpi	r24, 0xFF	; 255
    21ca:	09 f4       	brne	.+2      	; 0x21ce <xQueueGenericSend+0xb6>
    21cc:	12 a2       	std	Z+34, r1	; 0x22
    21ce:	0f 90       	pop	r0
    21d0:	0f be       	out	0x3f, r0	; 63
    21d2:	be 01       	movw	r22, r28
    21d4:	6a 5f       	subi	r22, 0xFA	; 250
    21d6:	7f 4f       	sbci	r23, 0xFF	; 255
    21d8:	ce 01       	movw	r24, r28
    21da:	01 96       	adiw	r24, 0x01	; 1
    21dc:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <xTaskCheckForTimeOut>
    21e0:	81 11       	cpse	r24, r1
    21e2:	21 c0       	rjmp	.+66     	; 0x2226 <xQueueGenericSend+0x10e>
    21e4:	0f b6       	in	r0, 0x3f	; 63
    21e6:	f8 94       	cli
    21e8:	0f 92       	push	r0
    21ea:	f7 01       	movw	r30, r14
    21ec:	96 8d       	ldd	r25, Z+30	; 0x1e
    21ee:	0f 90       	pop	r0
    21f0:	0f be       	out	0x3f, r0	; 63
    21f2:	87 8d       	ldd	r24, Z+31	; 0x1f
    21f4:	98 13       	cpse	r25, r24
    21f6:	11 c0       	rjmp	.+34     	; 0x221a <xQueueGenericSend+0x102>
    21f8:	4e 81       	ldd	r20, Y+6	; 0x06
    21fa:	5f 81       	ldd	r21, Y+7	; 0x07
    21fc:	68 85       	ldd	r22, Y+8	; 0x08
    21fe:	79 85       	ldd	r23, Y+9	; 0x09
    2200:	c6 01       	movw	r24, r12
    2202:	0e 94 28 16 	call	0x2c50	; 0x2c50 <vTaskPlaceOnEventList>
    2206:	c7 01       	movw	r24, r14
    2208:	0e 94 d8 0f 	call	0x1fb0	; 0x1fb0 <prvUnlockQueue>
    220c:	0e 94 ae 14 	call	0x295c	; 0x295c <xTaskResumeAll>
    2210:	81 11       	cpse	r24, r1
    2212:	9c cf       	rjmp	.-200    	; 0x214c <xQueueGenericSend+0x34>
    2214:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vPortYield>
    2218:	99 cf       	rjmp	.-206    	; 0x214c <xQueueGenericSend+0x34>
    221a:	c7 01       	movw	r24, r14
    221c:	0e 94 d8 0f 	call	0x1fb0	; 0x1fb0 <prvUnlockQueue>
    2220:	0e 94 ae 14 	call	0x295c	; 0x295c <xTaskResumeAll>
    2224:	93 cf       	rjmp	.-218    	; 0x214c <xQueueGenericSend+0x34>
    2226:	c7 01       	movw	r24, r14
    2228:	0e 94 d8 0f 	call	0x1fb0	; 0x1fb0 <prvUnlockQueue>
    222c:	0e 94 ae 14 	call	0x295c	; 0x295c <xTaskResumeAll>
    2230:	80 e0       	ldi	r24, 0x00	; 0
    2232:	29 96       	adiw	r28, 0x09	; 9
    2234:	cd bf       	out	0x3d, r28	; 61
    2236:	de bf       	out	0x3e, r29	; 62
    2238:	df 91       	pop	r29
    223a:	cf 91       	pop	r28
    223c:	1f 91       	pop	r17
    223e:	0f 91       	pop	r16
    2240:	ff 90       	pop	r15
    2242:	ef 90       	pop	r14
    2244:	df 90       	pop	r13
    2246:	cf 90       	pop	r12
    2248:	bf 90       	pop	r11
    224a:	af 90       	pop	r10
    224c:	08 95       	ret

0000224e <xQueueGenericReceive>:
    224e:	af 92       	push	r10
    2250:	bf 92       	push	r11
    2252:	cf 92       	push	r12
    2254:	df 92       	push	r13
    2256:	ef 92       	push	r14
    2258:	ff 92       	push	r15
    225a:	0f 93       	push	r16
    225c:	1f 93       	push	r17
    225e:	cf 93       	push	r28
    2260:	df 93       	push	r29
    2262:	cd b7       	in	r28, 0x3d	; 61
    2264:	de b7       	in	r29, 0x3e	; 62
    2266:	29 97       	sbiw	r28, 0x09	; 9
    2268:	cd bf       	out	0x3d, r28	; 61
    226a:	de bf       	out	0x3e, r29	; 62
    226c:	7c 01       	movw	r14, r24
    226e:	5b 01       	movw	r10, r22
    2270:	2e 83       	std	Y+6, r18	; 0x06
    2272:	3f 83       	std	Y+7, r19	; 0x07
    2274:	48 87       	std	Y+8, r20	; 0x08
    2276:	59 87       	std	Y+9, r21	; 0x09
    2278:	10 e0       	ldi	r17, 0x00	; 0
    227a:	6c 01       	movw	r12, r24
    227c:	83 e1       	ldi	r24, 0x13	; 19
    227e:	c8 0e       	add	r12, r24
    2280:	d1 1c       	adc	r13, r1
    2282:	0f b6       	in	r0, 0x3f	; 63
    2284:	f8 94       	cli
    2286:	0f 92       	push	r0
    2288:	f7 01       	movw	r30, r14
    228a:	86 8d       	ldd	r24, Z+30	; 0x1e
    228c:	88 23       	and	r24, r24
    228e:	99 f1       	breq	.+102    	; 0x22f6 <xQueueGenericReceive+0xa8>
    2290:	c6 80       	ldd	r12, Z+6	; 0x06
    2292:	d7 80       	ldd	r13, Z+7	; 0x07
    2294:	b5 01       	movw	r22, r10
    2296:	c7 01       	movw	r24, r14
    2298:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <prvCopyDataFromQueue>
    229c:	01 11       	cpse	r16, r1
    229e:	1a c0       	rjmp	.+52     	; 0x22d4 <xQueueGenericReceive+0x86>
    22a0:	f7 01       	movw	r30, r14
    22a2:	86 8d       	ldd	r24, Z+30	; 0x1e
    22a4:	81 50       	subi	r24, 0x01	; 1
    22a6:	86 8f       	std	Z+30, r24	; 0x1e
    22a8:	80 81       	ld	r24, Z
    22aa:	91 81       	ldd	r25, Z+1	; 0x01
    22ac:	89 2b       	or	r24, r25
    22ae:	29 f4       	brne	.+10     	; 0x22ba <xQueueGenericReceive+0x6c>
    22b0:	0e 94 2c 17 	call	0x2e58	; 0x2e58 <xTaskGetCurrentTaskHandle>
    22b4:	f7 01       	movw	r30, r14
    22b6:	82 83       	std	Z+2, r24	; 0x02
    22b8:	93 83       	std	Z+3, r25	; 0x03
    22ba:	f7 01       	movw	r30, r14
    22bc:	80 85       	ldd	r24, Z+8	; 0x08
    22be:	88 23       	and	r24, r24
    22c0:	b1 f0       	breq	.+44     	; 0x22ee <xQueueGenericReceive+0xa0>
    22c2:	c7 01       	movw	r24, r14
    22c4:	08 96       	adiw	r24, 0x08	; 8
    22c6:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <xTaskRemoveFromEventList>
    22ca:	81 30       	cpi	r24, 0x01	; 1
    22cc:	81 f4       	brne	.+32     	; 0x22ee <xQueueGenericReceive+0xa0>
    22ce:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vPortYield>
    22d2:	0d c0       	rjmp	.+26     	; 0x22ee <xQueueGenericReceive+0xa0>
    22d4:	f7 01       	movw	r30, r14
    22d6:	c6 82       	std	Z+6, r12	; 0x06
    22d8:	d7 82       	std	Z+7, r13	; 0x07
    22da:	83 89       	ldd	r24, Z+19	; 0x13
    22dc:	88 23       	and	r24, r24
    22de:	39 f0       	breq	.+14     	; 0x22ee <xQueueGenericReceive+0xa0>
    22e0:	c7 01       	movw	r24, r14
    22e2:	43 96       	adiw	r24, 0x13	; 19
    22e4:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <xTaskRemoveFromEventList>
    22e8:	81 11       	cpse	r24, r1
    22ea:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vPortYield>
    22ee:	0f 90       	pop	r0
    22f0:	0f be       	out	0x3f, r0	; 63
    22f2:	81 e0       	ldi	r24, 0x01	; 1
    22f4:	62 c0       	rjmp	.+196    	; 0x23ba <xQueueGenericReceive+0x16c>
    22f6:	8e 81       	ldd	r24, Y+6	; 0x06
    22f8:	9f 81       	ldd	r25, Y+7	; 0x07
    22fa:	a8 85       	ldd	r26, Y+8	; 0x08
    22fc:	b9 85       	ldd	r27, Y+9	; 0x09
    22fe:	89 2b       	or	r24, r25
    2300:	8a 2b       	or	r24, r26
    2302:	8b 2b       	or	r24, r27
    2304:	21 f4       	brne	.+8      	; 0x230e <xQueueGenericReceive+0xc0>
    2306:	0f 90       	pop	r0
    2308:	0f be       	out	0x3f, r0	; 63
    230a:	80 e0       	ldi	r24, 0x00	; 0
    230c:	56 c0       	rjmp	.+172    	; 0x23ba <xQueueGenericReceive+0x16c>
    230e:	11 11       	cpse	r17, r1
    2310:	05 c0       	rjmp	.+10     	; 0x231c <xQueueGenericReceive+0xce>
    2312:	ce 01       	movw	r24, r28
    2314:	01 96       	adiw	r24, 0x01	; 1
    2316:	0e 94 91 16 	call	0x2d22	; 0x2d22 <vTaskSetTimeOutState>
    231a:	11 e0       	ldi	r17, 0x01	; 1
    231c:	0f 90       	pop	r0
    231e:	0f be       	out	0x3f, r0	; 63
    2320:	0e 94 8c 13 	call	0x2718	; 0x2718 <vTaskSuspendAll>
    2324:	0f b6       	in	r0, 0x3f	; 63
    2326:	f8 94       	cli
    2328:	0f 92       	push	r0
    232a:	f7 01       	movw	r30, r14
    232c:	81 a1       	ldd	r24, Z+33	; 0x21
    232e:	8f 3f       	cpi	r24, 0xFF	; 255
    2330:	09 f4       	brne	.+2      	; 0x2334 <xQueueGenericReceive+0xe6>
    2332:	11 a2       	std	Z+33, r1	; 0x21
    2334:	f7 01       	movw	r30, r14
    2336:	82 a1       	ldd	r24, Z+34	; 0x22
    2338:	8f 3f       	cpi	r24, 0xFF	; 255
    233a:	09 f4       	brne	.+2      	; 0x233e <xQueueGenericReceive+0xf0>
    233c:	12 a2       	std	Z+34, r1	; 0x22
    233e:	0f 90       	pop	r0
    2340:	0f be       	out	0x3f, r0	; 63
    2342:	be 01       	movw	r22, r28
    2344:	6a 5f       	subi	r22, 0xFA	; 250
    2346:	7f 4f       	sbci	r23, 0xFF	; 255
    2348:	ce 01       	movw	r24, r28
    234a:	01 96       	adiw	r24, 0x01	; 1
    234c:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <xTaskCheckForTimeOut>
    2350:	81 11       	cpse	r24, r1
    2352:	2d c0       	rjmp	.+90     	; 0x23ae <xQueueGenericReceive+0x160>
    2354:	0f b6       	in	r0, 0x3f	; 63
    2356:	f8 94       	cli
    2358:	0f 92       	push	r0
    235a:	f7 01       	movw	r30, r14
    235c:	86 8d       	ldd	r24, Z+30	; 0x1e
    235e:	0f 90       	pop	r0
    2360:	0f be       	out	0x3f, r0	; 63
    2362:	81 11       	cpse	r24, r1
    2364:	1e c0       	rjmp	.+60     	; 0x23a2 <xQueueGenericReceive+0x154>
    2366:	80 81       	ld	r24, Z
    2368:	91 81       	ldd	r25, Z+1	; 0x01
    236a:	89 2b       	or	r24, r25
    236c:	49 f4       	brne	.+18     	; 0x2380 <xQueueGenericReceive+0x132>
    236e:	0f b6       	in	r0, 0x3f	; 63
    2370:	f8 94       	cli
    2372:	0f 92       	push	r0
    2374:	82 81       	ldd	r24, Z+2	; 0x02
    2376:	93 81       	ldd	r25, Z+3	; 0x03
    2378:	0e 94 31 17 	call	0x2e62	; 0x2e62 <vTaskPriorityInherit>
    237c:	0f 90       	pop	r0
    237e:	0f be       	out	0x3f, r0	; 63
    2380:	4e 81       	ldd	r20, Y+6	; 0x06
    2382:	5f 81       	ldd	r21, Y+7	; 0x07
    2384:	68 85       	ldd	r22, Y+8	; 0x08
    2386:	79 85       	ldd	r23, Y+9	; 0x09
    2388:	c6 01       	movw	r24, r12
    238a:	0e 94 28 16 	call	0x2c50	; 0x2c50 <vTaskPlaceOnEventList>
    238e:	c7 01       	movw	r24, r14
    2390:	0e 94 d8 0f 	call	0x1fb0	; 0x1fb0 <prvUnlockQueue>
    2394:	0e 94 ae 14 	call	0x295c	; 0x295c <xTaskResumeAll>
    2398:	81 11       	cpse	r24, r1
    239a:	73 cf       	rjmp	.-282    	; 0x2282 <xQueueGenericReceive+0x34>
    239c:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vPortYield>
    23a0:	70 cf       	rjmp	.-288    	; 0x2282 <xQueueGenericReceive+0x34>
    23a2:	c7 01       	movw	r24, r14
    23a4:	0e 94 d8 0f 	call	0x1fb0	; 0x1fb0 <prvUnlockQueue>
    23a8:	0e 94 ae 14 	call	0x295c	; 0x295c <xTaskResumeAll>
    23ac:	6a cf       	rjmp	.-300    	; 0x2282 <xQueueGenericReceive+0x34>
    23ae:	c7 01       	movw	r24, r14
    23b0:	0e 94 d8 0f 	call	0x1fb0	; 0x1fb0 <prvUnlockQueue>
    23b4:	0e 94 ae 14 	call	0x295c	; 0x295c <xTaskResumeAll>
    23b8:	80 e0       	ldi	r24, 0x00	; 0
    23ba:	29 96       	adiw	r28, 0x09	; 9
    23bc:	cd bf       	out	0x3d, r28	; 61
    23be:	de bf       	out	0x3e, r29	; 62
    23c0:	df 91       	pop	r29
    23c2:	cf 91       	pop	r28
    23c4:	1f 91       	pop	r17
    23c6:	0f 91       	pop	r16
    23c8:	ff 90       	pop	r15
    23ca:	ef 90       	pop	r14
    23cc:	df 90       	pop	r13
    23ce:	cf 90       	pop	r12
    23d0:	bf 90       	pop	r11
    23d2:	af 90       	pop	r10
    23d4:	08 95       	ret

000023d6 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    23d6:	0f b6       	in	r0, 0x3f	; 63
    23d8:	f8 94       	cli
    23da:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    23dc:	fc 01       	movw	r30, r24
    23de:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    23e0:	0f 90       	pop	r0
    23e2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    23e4:	08 95       	ret

000023e6 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    23e6:	c8 ef       	ldi	r28, 0xF8	; 248
    23e8:	d0 e3       	ldi	r29, 0x30	; 48
    23ea:	88 81       	ld	r24, Y
    23ec:	82 30       	cpi	r24, 0x02	; 2
    23ee:	e8 f3       	brcs	.-6      	; 0x23ea <prvIdleTask+0x4>
    23f0:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vPortYield>
    23f4:	fa cf       	rjmp	.-12     	; 0x23ea <prvIdleTask+0x4>

000023f6 <prvAddCurrentTaskToDelayedList>:
    23f6:	cf 92       	push	r12
    23f8:	df 92       	push	r13
    23fa:	ef 92       	push	r14
    23fc:	ff 92       	push	r15
    23fe:	6b 01       	movw	r12, r22
    2400:	7c 01       	movw	r14, r24
    2402:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2406:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    240a:	62 83       	std	Z+2, r22	; 0x02
    240c:	73 83       	std	Z+3, r23	; 0x03
    240e:	84 83       	std	Z+4, r24	; 0x04
    2410:	95 83       	std	Z+5, r25	; 0x05
    2412:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2416:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    241a:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    241e:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2422:	c8 16       	cp	r12, r24
    2424:	d9 06       	cpc	r13, r25
    2426:	ea 06       	cpc	r14, r26
    2428:	fb 06       	cpc	r15, r27
    242a:	68 f4       	brcc	.+26     	; 0x2446 <prvAddCurrentTaskToDelayedList+0x50>
    242c:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    2430:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2434:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    2438:	90 91 df 30 	lds	r25, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    243c:	6e 5f       	subi	r22, 0xFE	; 254
    243e:	7f 4f       	sbci	r23, 0xFF	; 255
    2440:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <vListInsert>
    2444:	21 c0       	rjmp	.+66     	; 0x2488 <prvAddCurrentTaskToDelayedList+0x92>
    2446:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    244a:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    244e:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2452:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2456:	6e 5f       	subi	r22, 0xFE	; 254
    2458:	7f 4f       	sbci	r23, 0xFF	; 255
    245a:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <vListInsert>
    245e:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2462:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2466:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    246a:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    246e:	c8 16       	cp	r12, r24
    2470:	d9 06       	cpc	r13, r25
    2472:	ea 06       	cpc	r14, r26
    2474:	fb 06       	cpc	r15, r27
    2476:	40 f4       	brcc	.+16     	; 0x2488 <prvAddCurrentTaskToDelayedList+0x92>
    2478:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    247c:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    2480:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    2484:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    2488:	ff 90       	pop	r15
    248a:	ef 90       	pop	r14
    248c:	df 90       	pop	r13
    248e:	cf 90       	pop	r12
    2490:	08 95       	ret

00002492 <xTaskGenericCreate>:
    2492:	4f 92       	push	r4
    2494:	5f 92       	push	r5
    2496:	6f 92       	push	r6
    2498:	7f 92       	push	r7
    249a:	8f 92       	push	r8
    249c:	9f 92       	push	r9
    249e:	af 92       	push	r10
    24a0:	bf 92       	push	r11
    24a2:	cf 92       	push	r12
    24a4:	df 92       	push	r13
    24a6:	ef 92       	push	r14
    24a8:	ff 92       	push	r15
    24aa:	0f 93       	push	r16
    24ac:	1f 93       	push	r17
    24ae:	cf 93       	push	r28
    24b0:	df 93       	push	r29
    24b2:	5c 01       	movw	r10, r24
    24b4:	4b 01       	movw	r8, r22
    24b6:	3a 01       	movw	r6, r20
    24b8:	29 01       	movw	r4, r18
    24ba:	88 e2       	ldi	r24, 0x28	; 40
    24bc:	90 e0       	ldi	r25, 0x00	; 0
    24be:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <pvPortMalloc>
    24c2:	ec 01       	movw	r28, r24
    24c4:	89 2b       	or	r24, r25
    24c6:	09 f4       	brne	.+2      	; 0x24ca <xTaskGenericCreate+0x38>
    24c8:	d4 c0       	rjmp	.+424    	; 0x2672 <xTaskGenericCreate+0x1e0>
    24ca:	c1 14       	cp	r12, r1
    24cc:	d1 04       	cpc	r13, r1
    24ce:	09 f0       	breq	.+2      	; 0x24d2 <xTaskGenericCreate+0x40>
    24d0:	cc c0       	rjmp	.+408    	; 0x266a <xTaskGenericCreate+0x1d8>
    24d2:	c3 01       	movw	r24, r6
    24d4:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <pvPortMalloc>
    24d8:	8b 8f       	std	Y+27, r24	; 0x1b
    24da:	9c 8f       	std	Y+28, r25	; 0x1c
    24dc:	00 97       	sbiw	r24, 0x00	; 0
    24de:	21 f4       	brne	.+8      	; 0x24e8 <xTaskGenericCreate+0x56>
    24e0:	ce 01       	movw	r24, r28
    24e2:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <vPortFree>
    24e6:	c5 c0       	rjmp	.+394    	; 0x2672 <xTaskGenericCreate+0x1e0>
    24e8:	a3 01       	movw	r20, r6
    24ea:	61 e1       	ldi	r22, 0x11	; 17
    24ec:	70 e0       	ldi	r23, 0x00	; 0
    24ee:	0e 94 30 23 	call	0x4660	; 0x4660 <memset>
    24f2:	93 01       	movw	r18, r6
    24f4:	21 50       	subi	r18, 0x01	; 1
    24f6:	31 09       	sbc	r19, r1
    24f8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    24fa:	9c 8d       	ldd	r25, Y+28	; 0x1c
    24fc:	3c 01       	movw	r6, r24
    24fe:	62 0e       	add	r6, r18
    2500:	73 1e       	adc	r7, r19
    2502:	4a e0       	ldi	r20, 0x0A	; 10
    2504:	50 e0       	ldi	r21, 0x00	; 0
    2506:	b4 01       	movw	r22, r8
    2508:	ce 01       	movw	r24, r28
    250a:	4d 96       	adiw	r24, 0x1d	; 29
    250c:	0e 94 37 23 	call	0x466e	; 0x466e <strncpy>
    2510:	1e a2       	std	Y+38, r1	; 0x26
    2512:	10 2f       	mov	r17, r16
    2514:	04 30       	cpi	r16, 0x04	; 4
    2516:	08 f0       	brcs	.+2      	; 0x251a <xTaskGenericCreate+0x88>
    2518:	13 e0       	ldi	r17, 0x03	; 3
    251a:	1a 8f       	std	Y+26, r17	; 0x1a
    251c:	1f a3       	std	Y+39, r17	; 0x27
    251e:	6e 01       	movw	r12, r28
    2520:	22 e0       	ldi	r18, 0x02	; 2
    2522:	c2 0e       	add	r12, r18
    2524:	d1 1c       	adc	r13, r1
    2526:	c6 01       	movw	r24, r12
    2528:	0e 94 5b 0d 	call	0x1ab6	; 0x1ab6 <vListInitialiseItem>
    252c:	ce 01       	movw	r24, r28
    252e:	0e 96       	adiw	r24, 0x0e	; 14
    2530:	0e 94 5b 0d 	call	0x1ab6	; 0x1ab6 <vListInitialiseItem>
    2534:	ca 87       	std	Y+10, r28	; 0x0a
    2536:	db 87       	std	Y+11, r29	; 0x0b
    2538:	84 e0       	ldi	r24, 0x04	; 4
    253a:	90 e0       	ldi	r25, 0x00	; 0
    253c:	a0 e0       	ldi	r26, 0x00	; 0
    253e:	b0 e0       	ldi	r27, 0x00	; 0
    2540:	81 1b       	sub	r24, r17
    2542:	91 09       	sbc	r25, r1
    2544:	a1 09       	sbc	r26, r1
    2546:	b1 09       	sbc	r27, r1
    2548:	8e 87       	std	Y+14, r24	; 0x0e
    254a:	9f 87       	std	Y+15, r25	; 0x0f
    254c:	a8 8b       	std	Y+16, r26	; 0x10
    254e:	b9 8b       	std	Y+17, r27	; 0x11
    2550:	ce 8b       	std	Y+22, r28	; 0x16
    2552:	df 8b       	std	Y+23, r29	; 0x17
    2554:	a2 01       	movw	r20, r4
    2556:	b5 01       	movw	r22, r10
    2558:	c3 01       	movw	r24, r6
    255a:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <pxPortInitialiseStack>
    255e:	88 83       	st	Y, r24
    2560:	99 83       	std	Y+1, r25	; 0x01
    2562:	e1 14       	cp	r14, r1
    2564:	f1 04       	cpc	r15, r1
    2566:	19 f0       	breq	.+6      	; 0x256e <xTaskGenericCreate+0xdc>
    2568:	f7 01       	movw	r30, r14
    256a:	c0 83       	st	Z, r28
    256c:	d1 83       	std	Z+1, r29	; 0x01
    256e:	0f b6       	in	r0, 0x3f	; 63
    2570:	f8 94       	cli
    2572:	0f 92       	push	r0
    2574:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2578:	8f 5f       	subi	r24, 0xFF	; 255
    257a:	80 93 d0 30 	sts	0x30D0, r24	; 0x8030d0 <uxCurrentNumberOfTasks>
    257e:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2582:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2586:	89 2b       	or	r24, r25
    2588:	89 f5       	brne	.+98     	; 0x25ec <xTaskGenericCreate+0x15a>
    258a:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    258e:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    2592:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2596:	81 30       	cpi	r24, 0x01	; 1
    2598:	c1 f5       	brne	.+112    	; 0x260a <xTaskGenericCreate+0x178>
    259a:	88 ef       	ldi	r24, 0xF8	; 248
    259c:	90 e3       	ldi	r25, 0x30	; 48
    259e:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInitialise>
    25a2:	83 e0       	ldi	r24, 0x03	; 3
    25a4:	91 e3       	ldi	r25, 0x31	; 49
    25a6:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInitialise>
    25aa:	8e e0       	ldi	r24, 0x0E	; 14
    25ac:	91 e3       	ldi	r25, 0x31	; 49
    25ae:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInitialise>
    25b2:	89 e1       	ldi	r24, 0x19	; 25
    25b4:	91 e3       	ldi	r25, 0x31	; 49
    25b6:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInitialise>
    25ba:	8d ee       	ldi	r24, 0xED	; 237
    25bc:	90 e3       	ldi	r25, 0x30	; 48
    25be:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInitialise>
    25c2:	82 ee       	ldi	r24, 0xE2	; 226
    25c4:	90 e3       	ldi	r25, 0x30	; 48
    25c6:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInitialise>
    25ca:	83 ed       	ldi	r24, 0xD3	; 211
    25cc:	90 e3       	ldi	r25, 0x30	; 48
    25ce:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vListInitialise>
    25d2:	8d ee       	ldi	r24, 0xED	; 237
    25d4:	90 e3       	ldi	r25, 0x30	; 48
    25d6:	80 93 e0 30 	sts	0x30E0, r24	; 0x8030e0 <pxDelayedTaskList>
    25da:	90 93 e1 30 	sts	0x30E1, r25	; 0x8030e1 <pxDelayedTaskList+0x1>
    25de:	82 ee       	ldi	r24, 0xE2	; 226
    25e0:	90 e3       	ldi	r25, 0x30	; 48
    25e2:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    25e6:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    25ea:	0f c0       	rjmp	.+30     	; 0x260a <xTaskGenericCreate+0x178>
    25ec:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    25f0:	81 11       	cpse	r24, r1
    25f2:	0b c0       	rjmp	.+22     	; 0x260a <xTaskGenericCreate+0x178>
    25f4:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    25f8:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    25fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    25fe:	08 17       	cp	r16, r24
    2600:	20 f0       	brcs	.+8      	; 0x260a <xTaskGenericCreate+0x178>
    2602:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    2606:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    260a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    260c:	90 91 cb 30 	lds	r25, 0x30CB	; 0x8030cb <uxTopUsedPriority>
    2610:	98 17       	cp	r25, r24
    2612:	10 f4       	brcc	.+4      	; 0x2618 <xTaskGenericCreate+0x186>
    2614:	80 93 cb 30 	sts	0x30CB, r24	; 0x8030cb <uxTopUsedPriority>
    2618:	90 91 c4 30 	lds	r25, 0x30C4	; 0x8030c4 <uxTaskNumber>
    261c:	9f 5f       	subi	r25, 0xFF	; 255
    261e:	90 93 c4 30 	sts	0x30C4, r25	; 0x8030c4 <uxTaskNumber>
    2622:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2626:	98 17       	cp	r25, r24
    2628:	10 f4       	brcc	.+4      	; 0x262e <xTaskGenericCreate+0x19c>
    262a:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    262e:	fb e0       	ldi	r31, 0x0B	; 11
    2630:	8f 9f       	mul	r24, r31
    2632:	c0 01       	movw	r24, r0
    2634:	11 24       	eor	r1, r1
    2636:	b6 01       	movw	r22, r12
    2638:	88 50       	subi	r24, 0x08	; 8
    263a:	9f 4c       	sbci	r25, 0xCF	; 207
    263c:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vListInsertEnd>
    2640:	0f 90       	pop	r0
    2642:	0f be       	out	0x3f, r0	; 63
    2644:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    2648:	88 23       	and	r24, r24
    264a:	59 f0       	breq	.+22     	; 0x2662 <xTaskGenericCreate+0x1d0>
    264c:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2650:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2654:	82 8d       	ldd	r24, Z+26	; 0x1a
    2656:	80 17       	cp	r24, r16
    2658:	30 f4       	brcc	.+12     	; 0x2666 <xTaskGenericCreate+0x1d4>
    265a:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vPortYield>
    265e:	81 e0       	ldi	r24, 0x01	; 1
    2660:	09 c0       	rjmp	.+18     	; 0x2674 <xTaskGenericCreate+0x1e2>
    2662:	81 e0       	ldi	r24, 0x01	; 1
    2664:	07 c0       	rjmp	.+14     	; 0x2674 <xTaskGenericCreate+0x1e2>
    2666:	81 e0       	ldi	r24, 0x01	; 1
    2668:	05 c0       	rjmp	.+10     	; 0x2674 <xTaskGenericCreate+0x1e2>
    266a:	cb 8e       	std	Y+27, r12	; 0x1b
    266c:	dc 8e       	std	Y+28, r13	; 0x1c
    266e:	c6 01       	movw	r24, r12
    2670:	3b cf       	rjmp	.-394    	; 0x24e8 <xTaskGenericCreate+0x56>
    2672:	8f ef       	ldi	r24, 0xFF	; 255
    2674:	df 91       	pop	r29
    2676:	cf 91       	pop	r28
    2678:	1f 91       	pop	r17
    267a:	0f 91       	pop	r16
    267c:	ff 90       	pop	r15
    267e:	ef 90       	pop	r14
    2680:	df 90       	pop	r13
    2682:	cf 90       	pop	r12
    2684:	bf 90       	pop	r11
    2686:	af 90       	pop	r10
    2688:	9f 90       	pop	r9
    268a:	8f 90       	pop	r8
    268c:	7f 90       	pop	r7
    268e:	6f 90       	pop	r6
    2690:	5f 90       	pop	r5
    2692:	4f 90       	pop	r4
    2694:	08 95       	ret

00002696 <uxTaskPriorityGet>:
    2696:	0f b6       	in	r0, 0x3f	; 63
    2698:	f8 94       	cli
    269a:	0f 92       	push	r0
    269c:	00 97       	sbiw	r24, 0x00	; 0
    269e:	21 f4       	brne	.+8      	; 0x26a8 <uxTaskPriorityGet+0x12>
    26a0:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    26a4:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    26a8:	0f 90       	pop	r0
    26aa:	0f be       	out	0x3f, r0	; 63
    26ac:	fc 01       	movw	r30, r24
    26ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    26b0:	08 95       	ret

000026b2 <vTaskStartScheduler>:
    26b2:	af 92       	push	r10
    26b4:	bf 92       	push	r11
    26b6:	cf 92       	push	r12
    26b8:	df 92       	push	r13
    26ba:	ef 92       	push	r14
    26bc:	ff 92       	push	r15
    26be:	0f 93       	push	r16
    26c0:	a1 2c       	mov	r10, r1
    26c2:	b1 2c       	mov	r11, r1
    26c4:	c1 2c       	mov	r12, r1
    26c6:	d1 2c       	mov	r13, r1
    26c8:	0f 2e       	mov	r0, r31
    26ca:	f1 ed       	ldi	r31, 0xD1	; 209
    26cc:	ef 2e       	mov	r14, r31
    26ce:	f0 e3       	ldi	r31, 0x30	; 48
    26d0:	ff 2e       	mov	r15, r31
    26d2:	f0 2d       	mov	r31, r0
    26d4:	00 e0       	ldi	r16, 0x00	; 0
    26d6:	20 e0       	ldi	r18, 0x00	; 0
    26d8:	30 e0       	ldi	r19, 0x00	; 0
    26da:	44 e6       	ldi	r20, 0x64	; 100
    26dc:	50 e0       	ldi	r21, 0x00	; 0
    26de:	6a e3       	ldi	r22, 0x3A	; 58
    26e0:	70 e2       	ldi	r23, 0x20	; 32
    26e2:	83 ef       	ldi	r24, 0xF3	; 243
    26e4:	91 e1       	ldi	r25, 0x11	; 17
    26e6:	0e 94 49 12 	call	0x2492	; 0x2492 <xTaskGenericCreate>
    26ea:	81 30       	cpi	r24, 0x01	; 1
    26ec:	69 f4       	brne	.+26     	; 0x2708 <vTaskStartScheduler+0x56>
    26ee:	f8 94       	cli
    26f0:	80 93 c9 30 	sts	0x30C9, r24	; 0x8030c9 <xSchedulerRunning>
    26f4:	10 92 cc 30 	sts	0x30CC, r1	; 0x8030cc <xTickCount>
    26f8:	10 92 cd 30 	sts	0x30CD, r1	; 0x8030cd <xTickCount+0x1>
    26fc:	10 92 ce 30 	sts	0x30CE, r1	; 0x8030ce <xTickCount+0x2>
    2700:	10 92 cf 30 	sts	0x30CF, r1	; 0x8030cf <xTickCount+0x3>
    2704:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <xPortStartScheduler>
    2708:	0f 91       	pop	r16
    270a:	ff 90       	pop	r15
    270c:	ef 90       	pop	r14
    270e:	df 90       	pop	r13
    2710:	cf 90       	pop	r12
    2712:	bf 90       	pop	r11
    2714:	af 90       	pop	r10
    2716:	08 95       	ret

00002718 <vTaskSuspendAll>:
    2718:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    271c:	8f 5f       	subi	r24, 0xFF	; 255
    271e:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>
    2722:	08 95       	ret

00002724 <xTaskGetTickCount>:
    2724:	0f b6       	in	r0, 0x3f	; 63
    2726:	f8 94       	cli
    2728:	0f 92       	push	r0
    272a:	60 91 cc 30 	lds	r22, 0x30CC	; 0x8030cc <xTickCount>
    272e:	70 91 cd 30 	lds	r23, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2732:	80 91 ce 30 	lds	r24, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2736:	90 91 cf 30 	lds	r25, 0x30CF	; 0x8030cf <xTickCount+0x3>
    273a:	0f 90       	pop	r0
    273c:	0f be       	out	0x3f, r0	; 63
    273e:	08 95       	ret

00002740 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2740:	00 97       	sbiw	r24, 0x00	; 0
    2742:	21 f4       	brne	.+8      	; 0x274c <pcTaskGetTaskName+0xc>
    2744:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2748:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    274c:	4d 96       	adiw	r24, 0x1d	; 29
    274e:	08 95       	ret

00002750 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    2750:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xIdleTaskHandle>
    2754:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <xIdleTaskHandle+0x1>
    2758:	08 95       	ret

0000275a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    275a:	ff 92       	push	r15
    275c:	0f 93       	push	r16
    275e:	1f 93       	push	r17
    2760:	cf 93       	push	r28
    2762:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2764:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2768:	81 11       	cpse	r24, r1
    276a:	ed c0       	rjmp	.+474    	; 0x2946 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    276c:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2770:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2774:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2778:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    277c:	01 96       	adiw	r24, 0x01	; 1
    277e:	a1 1d       	adc	r26, r1
    2780:	b1 1d       	adc	r27, r1
    2782:	80 93 cc 30 	sts	0x30CC, r24	; 0x8030cc <xTickCount>
    2786:	90 93 cd 30 	sts	0x30CD, r25	; 0x8030cd <xTickCount+0x1>
    278a:	a0 93 ce 30 	sts	0x30CE, r26	; 0x8030ce <xTickCount+0x2>
    278e:	b0 93 cf 30 	sts	0x30CF, r27	; 0x8030cf <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    2792:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2796:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    279a:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    279e:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    27a2:	89 2b       	or	r24, r25
    27a4:	8a 2b       	or	r24, r26
    27a6:	8b 2b       	or	r24, r27
    27a8:	f1 f5       	brne	.+124    	; 0x2826 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    27aa:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    27ae:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    27b2:	20 91 de 30 	lds	r18, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    27b6:	30 91 df 30 	lds	r19, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    27ba:	20 93 e0 30 	sts	0x30E0, r18	; 0x8030e0 <pxDelayedTaskList>
    27be:	30 93 e1 30 	sts	0x30E1, r19	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    27c2:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    27c6:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    27ca:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    27ce:	8f 5f       	subi	r24, 0xFF	; 255
    27d0:	80 93 c5 30 	sts	0x30C5, r24	; 0x8030c5 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    27d4:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    27d8:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    27dc:	80 81       	ld	r24, Z
    27de:	81 11       	cpse	r24, r1
    27e0:	0c c0       	rjmp	.+24     	; 0x27fa <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    27e2:	8f ef       	ldi	r24, 0xFF	; 255
    27e4:	9f ef       	ldi	r25, 0xFF	; 255
    27e6:	dc 01       	movw	r26, r24
    27e8:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    27ec:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    27f0:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    27f4:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    27f8:	16 c0       	rjmp	.+44     	; 0x2826 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    27fa:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    27fe:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2802:	07 80       	ldd	r0, Z+7	; 0x07
    2804:	f0 85       	ldd	r31, Z+8	; 0x08
    2806:	e0 2d       	mov	r30, r0
    2808:	00 84       	ldd	r0, Z+8	; 0x08
    280a:	f1 85       	ldd	r31, Z+9	; 0x09
    280c:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    280e:	82 81       	ldd	r24, Z+2	; 0x02
    2810:	93 81       	ldd	r25, Z+3	; 0x03
    2812:	a4 81       	ldd	r26, Z+4	; 0x04
    2814:	b5 81       	ldd	r27, Z+5	; 0x05
    2816:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    281a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    281e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2822:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2826:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    282a:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    282e:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2832:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2836:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    283a:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    283e:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2842:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2846:	48 17       	cp	r20, r24
    2848:	59 07       	cpc	r21, r25
    284a:	6a 07       	cpc	r22, r26
    284c:	7b 07       	cpc	r23, r27
    284e:	08 f4       	brcc	.+2      	; 0x2852 <vTaskIncrementTick+0xf8>
    2850:	7f c0       	rjmp	.+254    	; 0x2950 <vTaskIncrementTick+0x1f6>
    2852:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2856:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    285a:	80 81       	ld	r24, Z
    285c:	88 23       	and	r24, r24
    285e:	f9 f0       	breq	.+62     	; 0x289e <vTaskIncrementTick+0x144>
    2860:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2864:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2868:	07 80       	ldd	r0, Z+7	; 0x07
    286a:	f0 85       	ldd	r31, Z+8	; 0x08
    286c:	e0 2d       	mov	r30, r0
    286e:	c0 85       	ldd	r28, Z+8	; 0x08
    2870:	d1 85       	ldd	r29, Z+9	; 0x09
    2872:	8a 81       	ldd	r24, Y+2	; 0x02
    2874:	9b 81       	ldd	r25, Y+3	; 0x03
    2876:	ac 81       	ldd	r26, Y+4	; 0x04
    2878:	bd 81       	ldd	r27, Y+5	; 0x05
    287a:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    287e:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2882:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2886:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    288a:	48 17       	cp	r20, r24
    288c:	59 07       	cpc	r21, r25
    288e:	6a 07       	cpc	r22, r26
    2890:	7b 07       	cpc	r23, r27
    2892:	58 f1       	brcs	.+86     	; 0x28ea <vTaskIncrementTick+0x190>
    2894:	0f 2e       	mov	r0, r31
    2896:	fb e0       	ldi	r31, 0x0B	; 11
    2898:	ff 2e       	mov	r15, r31
    289a:	f0 2d       	mov	r31, r0
    289c:	2f c0       	rjmp	.+94     	; 0x28fc <vTaskIncrementTick+0x1a2>
    289e:	8f ef       	ldi	r24, 0xFF	; 255
    28a0:	9f ef       	ldi	r25, 0xFF	; 255
    28a2:	dc 01       	movw	r26, r24
    28a4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    28a8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    28ac:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    28b0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    28b4:	4d c0       	rjmp	.+154    	; 0x2950 <vTaskIncrementTick+0x1f6>
    28b6:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    28ba:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    28be:	07 80       	ldd	r0, Z+7	; 0x07
    28c0:	f0 85       	ldd	r31, Z+8	; 0x08
    28c2:	e0 2d       	mov	r30, r0
    28c4:	c0 85       	ldd	r28, Z+8	; 0x08
    28c6:	d1 85       	ldd	r29, Z+9	; 0x09
    28c8:	8a 81       	ldd	r24, Y+2	; 0x02
    28ca:	9b 81       	ldd	r25, Y+3	; 0x03
    28cc:	ac 81       	ldd	r26, Y+4	; 0x04
    28ce:	bd 81       	ldd	r27, Y+5	; 0x05
    28d0:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    28d4:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    28d8:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    28dc:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    28e0:	48 17       	cp	r20, r24
    28e2:	59 07       	cpc	r21, r25
    28e4:	6a 07       	cpc	r22, r26
    28e6:	7b 07       	cpc	r23, r27
    28e8:	48 f4       	brcc	.+18     	; 0x28fc <vTaskIncrementTick+0x1a2>
    28ea:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    28ee:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    28f2:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    28f6:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    28fa:	2a c0       	rjmp	.+84     	; 0x2950 <vTaskIncrementTick+0x1f6>
    28fc:	8e 01       	movw	r16, r28
    28fe:	0e 5f       	subi	r16, 0xFE	; 254
    2900:	1f 4f       	sbci	r17, 0xFF	; 255
    2902:	c8 01       	movw	r24, r16
    2904:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <vListRemove>
    2908:	88 8d       	ldd	r24, Y+24	; 0x18
    290a:	99 8d       	ldd	r25, Y+25	; 0x19
    290c:	89 2b       	or	r24, r25
    290e:	21 f0       	breq	.+8      	; 0x2918 <vTaskIncrementTick+0x1be>
    2910:	ce 01       	movw	r24, r28
    2912:	0e 96       	adiw	r24, 0x0e	; 14
    2914:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <vListRemove>
    2918:	8a 8d       	ldd	r24, Y+26	; 0x1a
    291a:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    291e:	98 17       	cp	r25, r24
    2920:	10 f4       	brcc	.+4      	; 0x2926 <vTaskIncrementTick+0x1cc>
    2922:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2926:	f8 9e       	mul	r15, r24
    2928:	c0 01       	movw	r24, r0
    292a:	11 24       	eor	r1, r1
    292c:	b8 01       	movw	r22, r16
    292e:	88 50       	subi	r24, 0x08	; 8
    2930:	9f 4c       	sbci	r25, 0xCF	; 207
    2932:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vListInsertEnd>
    2936:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    293a:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    293e:	80 81       	ld	r24, Z
    2940:	81 11       	cpse	r24, r1
    2942:	b9 cf       	rjmp	.-142    	; 0x28b6 <vTaskIncrementTick+0x15c>
    2944:	ac cf       	rjmp	.-168    	; 0x289e <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    2946:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    294a:	8f 5f       	subi	r24, 0xFF	; 255
    294c:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2950:	df 91       	pop	r29
    2952:	cf 91       	pop	r28
    2954:	1f 91       	pop	r17
    2956:	0f 91       	pop	r16
    2958:	ff 90       	pop	r15
    295a:	08 95       	ret

0000295c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    295c:	cf 92       	push	r12
    295e:	df 92       	push	r13
    2960:	ef 92       	push	r14
    2962:	ff 92       	push	r15
    2964:	0f 93       	push	r16
    2966:	1f 93       	push	r17
    2968:	cf 93       	push	r28
    296a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    296c:	0f b6       	in	r0, 0x3f	; 63
    296e:	f8 94       	cli
    2970:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2972:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2976:	81 50       	subi	r24, 0x01	; 1
    2978:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    297c:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2980:	81 11       	cpse	r24, r1
    2982:	60 c0       	rjmp	.+192    	; 0x2a44 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2984:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2988:	81 11       	cpse	r24, r1
    298a:	2c c0       	rjmp	.+88     	; 0x29e4 <xTaskResumeAll+0x88>
    298c:	5e c0       	rjmp	.+188    	; 0x2a4a <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    298e:	d7 01       	movw	r26, r14
    2990:	17 96       	adiw	r26, 0x07	; 7
    2992:	ed 91       	ld	r30, X+
    2994:	fc 91       	ld	r31, X
    2996:	18 97       	sbiw	r26, 0x08	; 8
    2998:	c0 85       	ldd	r28, Z+8	; 0x08
    299a:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    299c:	ce 01       	movw	r24, r28
    299e:	0e 96       	adiw	r24, 0x0e	; 14
    29a0:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    29a4:	8e 01       	movw	r16, r28
    29a6:	0e 5f       	subi	r16, 0xFE	; 254
    29a8:	1f 4f       	sbci	r17, 0xFF	; 255
    29aa:	c8 01       	movw	r24, r16
    29ac:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    29b0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    29b2:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    29b6:	98 17       	cp	r25, r24
    29b8:	10 f4       	brcc	.+4      	; 0x29be <xTaskResumeAll+0x62>
    29ba:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    29be:	d8 9e       	mul	r13, r24
    29c0:	c0 01       	movw	r24, r0
    29c2:	11 24       	eor	r1, r1
    29c4:	b8 01       	movw	r22, r16
    29c6:	88 50       	subi	r24, 0x08	; 8
    29c8:	9f 4c       	sbci	r25, 0xCF	; 207
    29ca:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    29ce:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    29d2:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    29d6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    29d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    29da:	98 17       	cp	r25, r24
    29dc:	70 f0       	brcs	.+28     	; 0x29fa <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    29de:	cc 24       	eor	r12, r12
    29e0:	c3 94       	inc	r12
    29e2:	0b c0       	rjmp	.+22     	; 0x29fa <xTaskResumeAll+0x9e>
    29e4:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    29e6:	0f 2e       	mov	r0, r31
    29e8:	f3 ed       	ldi	r31, 0xD3	; 211
    29ea:	ef 2e       	mov	r14, r31
    29ec:	f0 e3       	ldi	r31, 0x30	; 48
    29ee:	ff 2e       	mov	r15, r31
    29f0:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    29f2:	0f 2e       	mov	r0, r31
    29f4:	fb e0       	ldi	r31, 0x0B	; 11
    29f6:	df 2e       	mov	r13, r31
    29f8:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    29fa:	f7 01       	movw	r30, r14
    29fc:	80 81       	ld	r24, Z
    29fe:	81 11       	cpse	r24, r1
    2a00:	c6 cf       	rjmp	.-116    	; 0x298e <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2a02:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2a06:	88 23       	and	r24, r24
    2a08:	81 f0       	breq	.+32     	; 0x2a2a <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2a0a:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2a0e:	88 23       	and	r24, r24
    2a10:	99 f0       	breq	.+38     	; 0x2a38 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    2a12:	0e 94 ad 13 	call	0x275a	; 0x275a <vTaskIncrementTick>
						--uxMissedTicks;
    2a16:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2a1a:	81 50       	subi	r24, 0x01	; 1
    2a1c:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2a20:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2a24:	81 11       	cpse	r24, r1
    2a26:	f5 cf       	rjmp	.-22     	; 0x2a12 <xTaskResumeAll+0xb6>
    2a28:	07 c0       	rjmp	.+14     	; 0x2a38 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2a2a:	f1 e0       	ldi	r31, 0x01	; 1
    2a2c:	cf 16       	cp	r12, r31
    2a2e:	21 f0       	breq	.+8      	; 0x2a38 <xTaskResumeAll+0xdc>
    2a30:	80 91 c6 30 	lds	r24, 0x30C6	; 0x8030c6 <xMissedYield>
    2a34:	81 30       	cpi	r24, 0x01	; 1
    2a36:	41 f4       	brne	.+16     	; 0x2a48 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2a38:	10 92 c6 30 	sts	0x30C6, r1	; 0x8030c6 <xMissedYield>
					portYIELD_WITHIN_API();
    2a3c:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    2a40:	81 e0       	ldi	r24, 0x01	; 1
    2a42:	03 c0       	rjmp	.+6      	; 0x2a4a <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2a44:	80 e0       	ldi	r24, 0x00	; 0
    2a46:	01 c0       	rjmp	.+2      	; 0x2a4a <xTaskResumeAll+0xee>
    2a48:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2a4a:	0f 90       	pop	r0
    2a4c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2a4e:	df 91       	pop	r29
    2a50:	cf 91       	pop	r28
    2a52:	1f 91       	pop	r17
    2a54:	0f 91       	pop	r16
    2a56:	ff 90       	pop	r15
    2a58:	ef 90       	pop	r14
    2a5a:	df 90       	pop	r13
    2a5c:	cf 90       	pop	r12
    2a5e:	08 95       	ret

00002a60 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2a60:	cf 92       	push	r12
    2a62:	df 92       	push	r13
    2a64:	ef 92       	push	r14
    2a66:	ff 92       	push	r15
    2a68:	cf 93       	push	r28
    2a6a:	df 93       	push	r29
    2a6c:	ec 01       	movw	r28, r24
    2a6e:	6a 01       	movw	r12, r20
    2a70:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2a72:	0e 94 8c 13 	call	0x2718	; 0x2718 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2a76:	88 81       	ld	r24, Y
    2a78:	99 81       	ldd	r25, Y+1	; 0x01
    2a7a:	aa 81       	ldd	r26, Y+2	; 0x02
    2a7c:	bb 81       	ldd	r27, Y+3	; 0x03
    2a7e:	c8 0e       	add	r12, r24
    2a80:	d9 1e       	adc	r13, r25
    2a82:	ea 1e       	adc	r14, r26
    2a84:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2a86:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2a8a:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2a8e:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2a92:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2a96:	48 17       	cp	r20, r24
    2a98:	59 07       	cpc	r21, r25
    2a9a:	6a 07       	cpc	r22, r26
    2a9c:	7b 07       	cpc	r23, r27
    2a9e:	b8 f4       	brcc	.+46     	; 0x2ace <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2aa0:	c8 16       	cp	r12, r24
    2aa2:	d9 06       	cpc	r13, r25
    2aa4:	ea 06       	cpc	r14, r26
    2aa6:	fb 06       	cpc	r15, r27
    2aa8:	e0 f5       	brcc	.+120    	; 0x2b22 <vTaskDelayUntil+0xc2>
    2aaa:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2aae:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2ab2:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2ab6:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2aba:	c8 82       	st	Y, r12
    2abc:	d9 82       	std	Y+1, r13	; 0x01
    2abe:	ea 82       	std	Y+2, r14	; 0x02
    2ac0:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2ac2:	8c 15       	cp	r24, r12
    2ac4:	9d 05       	cpc	r25, r13
    2ac6:	ae 05       	cpc	r26, r14
    2ac8:	bf 05       	cpc	r27, r15
    2aca:	f8 f4       	brcc	.+62     	; 0x2b0a <vTaskDelayUntil+0xaa>
    2acc:	13 c0       	rjmp	.+38     	; 0x2af4 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2ace:	c8 16       	cp	r12, r24
    2ad0:	d9 06       	cpc	r13, r25
    2ad2:	ea 06       	cpc	r14, r26
    2ad4:	fb 06       	cpc	r15, r27
    2ad6:	00 f1       	brcs	.+64     	; 0x2b18 <vTaskDelayUntil+0xb8>
    2ad8:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2adc:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2ae0:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2ae4:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2ae8:	8c 15       	cp	r24, r12
    2aea:	9d 05       	cpc	r25, r13
    2aec:	ae 05       	cpc	r26, r14
    2aee:	bf 05       	cpc	r27, r15
    2af0:	98 f0       	brcs	.+38     	; 0x2b18 <vTaskDelayUntil+0xb8>
    2af2:	17 c0       	rjmp	.+46     	; 0x2b22 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2af4:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2af8:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2afc:	02 96       	adiw	r24, 0x02	; 2
    2afe:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2b02:	c7 01       	movw	r24, r14
    2b04:	b6 01       	movw	r22, r12
    2b06:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2b0a:	0e 94 ae 14 	call	0x295c	; 0x295c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b0e:	81 11       	cpse	r24, r1
    2b10:	0d c0       	rjmp	.+26     	; 0x2b2c <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2b12:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vPortYield>
		}
	}
    2b16:	0a c0       	rjmp	.+20     	; 0x2b2c <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2b18:	c8 82       	st	Y, r12
    2b1a:	d9 82       	std	Y+1, r13	; 0x01
    2b1c:	ea 82       	std	Y+2, r14	; 0x02
    2b1e:	fb 82       	std	Y+3, r15	; 0x03
    2b20:	e9 cf       	rjmp	.-46     	; 0x2af4 <vTaskDelayUntil+0x94>
    2b22:	c8 82       	st	Y, r12
    2b24:	d9 82       	std	Y+1, r13	; 0x01
    2b26:	ea 82       	std	Y+2, r14	; 0x02
    2b28:	fb 82       	std	Y+3, r15	; 0x03
    2b2a:	ef cf       	rjmp	.-34     	; 0x2b0a <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2b2c:	df 91       	pop	r29
    2b2e:	cf 91       	pop	r28
    2b30:	ff 90       	pop	r15
    2b32:	ef 90       	pop	r14
    2b34:	df 90       	pop	r13
    2b36:	cf 90       	pop	r12
    2b38:	08 95       	ret

00002b3a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2b3a:	cf 92       	push	r12
    2b3c:	df 92       	push	r13
    2b3e:	ef 92       	push	r14
    2b40:	ff 92       	push	r15
    2b42:	6b 01       	movw	r12, r22
    2b44:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2b46:	67 2b       	or	r22, r23
    2b48:	68 2b       	or	r22, r24
    2b4a:	69 2b       	or	r22, r25
    2b4c:	e9 f0       	breq	.+58     	; 0x2b88 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2b4e:	0e 94 8c 13 	call	0x2718	; 0x2718 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2b52:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2b56:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2b5a:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2b5e:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2b62:	c8 0e       	add	r12, r24
    2b64:	d9 1e       	adc	r13, r25
    2b66:	ea 1e       	adc	r14, r26
    2b68:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2b6a:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2b6e:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2b72:	02 96       	adiw	r24, 0x02	; 2
    2b74:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2b78:	c7 01       	movw	r24, r14
    2b7a:	b6 01       	movw	r22, r12
    2b7c:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2b80:	0e 94 ae 14 	call	0x295c	; 0x295c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b84:	81 11       	cpse	r24, r1
    2b86:	02 c0       	rjmp	.+4      	; 0x2b8c <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2b88:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vPortYield>
		}
	}
    2b8c:	ff 90       	pop	r15
    2b8e:	ef 90       	pop	r14
    2b90:	df 90       	pop	r13
    2b92:	cf 90       	pop	r12
    2b94:	08 95       	ret

00002b96 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2b96:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2b9a:	81 11       	cpse	r24, r1
    2b9c:	0c c0       	rjmp	.+24     	; 0x2bb6 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2b9e:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2ba2:	4b e0       	ldi	r20, 0x0B	; 11
    2ba4:	e4 9f       	mul	r30, r20
    2ba6:	f0 01       	movw	r30, r0
    2ba8:	11 24       	eor	r1, r1
    2baa:	e8 50       	subi	r30, 0x08	; 8
    2bac:	ff 4c       	sbci	r31, 0xCF	; 207
    2bae:	80 81       	ld	r24, Z
    2bb0:	88 23       	and	r24, r24
    2bb2:	29 f0       	breq	.+10     	; 0x2bbe <vTaskSwitchContext+0x28>
    2bb4:	14 c0       	rjmp	.+40     	; 0x2bde <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2bb6:	81 e0       	ldi	r24, 0x01	; 1
    2bb8:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    2bbc:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2bbe:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2bc0:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2bc4:	81 50       	subi	r24, 0x01	; 1
    2bc6:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2bca:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2bce:	9e 9f       	mul	r25, r30
    2bd0:	f0 01       	movw	r30, r0
    2bd2:	11 24       	eor	r1, r1
    2bd4:	e8 50       	subi	r30, 0x08	; 8
    2bd6:	ff 4c       	sbci	r31, 0xCF	; 207
    2bd8:	80 81       	ld	r24, Z
    2bda:	88 23       	and	r24, r24
    2bdc:	89 f3       	breq	.-30     	; 0x2bc0 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2bde:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2be2:	28 2f       	mov	r18, r24
    2be4:	30 e0       	ldi	r19, 0x00	; 0
    2be6:	4b e0       	ldi	r20, 0x0B	; 11
    2be8:	84 9f       	mul	r24, r20
    2bea:	c0 01       	movw	r24, r0
    2bec:	11 24       	eor	r1, r1
    2bee:	dc 01       	movw	r26, r24
    2bf0:	a8 50       	subi	r26, 0x08	; 8
    2bf2:	bf 4c       	sbci	r27, 0xCF	; 207
    2bf4:	11 96       	adiw	r26, 0x01	; 1
    2bf6:	ed 91       	ld	r30, X+
    2bf8:	fc 91       	ld	r31, X
    2bfa:	12 97       	sbiw	r26, 0x02	; 2
    2bfc:	04 80       	ldd	r0, Z+4	; 0x04
    2bfe:	f5 81       	ldd	r31, Z+5	; 0x05
    2c00:	e0 2d       	mov	r30, r0
    2c02:	11 96       	adiw	r26, 0x01	; 1
    2c04:	ed 93       	st	X+, r30
    2c06:	fc 93       	st	X, r31
    2c08:	12 97       	sbiw	r26, 0x02	; 2
    2c0a:	85 50       	subi	r24, 0x05	; 5
    2c0c:	9f 4c       	sbci	r25, 0xCF	; 207
    2c0e:	e8 17       	cp	r30, r24
    2c10:	f9 07       	cpc	r31, r25
    2c12:	61 f4       	brne	.+24     	; 0x2c2c <vTaskSwitchContext+0x96>
    2c14:	84 81       	ldd	r24, Z+4	; 0x04
    2c16:	95 81       	ldd	r25, Z+5	; 0x05
    2c18:	4b e0       	ldi	r20, 0x0B	; 11
    2c1a:	42 9f       	mul	r20, r18
    2c1c:	f0 01       	movw	r30, r0
    2c1e:	43 9f       	mul	r20, r19
    2c20:	f0 0d       	add	r31, r0
    2c22:	11 24       	eor	r1, r1
    2c24:	e8 50       	subi	r30, 0x08	; 8
    2c26:	ff 4c       	sbci	r31, 0xCF	; 207
    2c28:	81 83       	std	Z+1, r24	; 0x01
    2c2a:	92 83       	std	Z+2, r25	; 0x02
    2c2c:	8b e0       	ldi	r24, 0x0B	; 11
    2c2e:	82 9f       	mul	r24, r18
    2c30:	f0 01       	movw	r30, r0
    2c32:	83 9f       	mul	r24, r19
    2c34:	f0 0d       	add	r31, r0
    2c36:	11 24       	eor	r1, r1
    2c38:	e8 50       	subi	r30, 0x08	; 8
    2c3a:	ff 4c       	sbci	r31, 0xCF	; 207
    2c3c:	01 80       	ldd	r0, Z+1	; 0x01
    2c3e:	f2 81       	ldd	r31, Z+2	; 0x02
    2c40:	e0 2d       	mov	r30, r0
    2c42:	80 85       	ldd	r24, Z+8	; 0x08
    2c44:	91 85       	ldd	r25, Z+9	; 0x09
    2c46:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <pxCurrentTCB>
    2c4a:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <pxCurrentTCB+0x1>
    2c4e:	08 95       	ret

00002c50 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2c50:	cf 92       	push	r12
    2c52:	df 92       	push	r13
    2c54:	ef 92       	push	r14
    2c56:	ff 92       	push	r15
    2c58:	6a 01       	movw	r12, r20
    2c5a:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2c5c:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    2c60:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2c64:	62 5f       	subi	r22, 0xF2	; 242
    2c66:	7f 4f       	sbci	r23, 0xFF	; 255
    2c68:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2c6c:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2c70:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2c74:	02 96       	adiw	r24, 0x02	; 2
    2c76:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2c7a:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2c7e:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2c82:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2c86:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2c8a:	bc 01       	movw	r22, r24
    2c8c:	cd 01       	movw	r24, r26
    2c8e:	6c 0d       	add	r22, r12
    2c90:	7d 1d       	adc	r23, r13
    2c92:	8e 1d       	adc	r24, r14
    2c94:	9f 1d       	adc	r25, r15
    2c96:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2c9a:	ff 90       	pop	r15
    2c9c:	ef 90       	pop	r14
    2c9e:	df 90       	pop	r13
    2ca0:	cf 90       	pop	r12
    2ca2:	08 95       	ret

00002ca4 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2ca4:	0f 93       	push	r16
    2ca6:	1f 93       	push	r17
    2ca8:	cf 93       	push	r28
    2caa:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2cac:	dc 01       	movw	r26, r24
    2cae:	17 96       	adiw	r26, 0x07	; 7
    2cb0:	ed 91       	ld	r30, X+
    2cb2:	fc 91       	ld	r31, X
    2cb4:	18 97       	sbiw	r26, 0x08	; 8
    2cb6:	c0 85       	ldd	r28, Z+8	; 0x08
    2cb8:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2cba:	8e 01       	movw	r16, r28
    2cbc:	02 5f       	subi	r16, 0xF2	; 242
    2cbe:	1f 4f       	sbci	r17, 0xFF	; 255
    2cc0:	c8 01       	movw	r24, r16
    2cc2:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2cc6:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2cca:	81 11       	cpse	r24, r1
    2ccc:	16 c0       	rjmp	.+44     	; 0x2cfa <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2cce:	0c 50       	subi	r16, 0x0C	; 12
    2cd0:	11 09       	sbc	r17, r1
    2cd2:	c8 01       	movw	r24, r16
    2cd4:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2cd8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2cda:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2cde:	98 17       	cp	r25, r24
    2ce0:	10 f4       	brcc	.+4      	; 0x2ce6 <xTaskRemoveFromEventList+0x42>
    2ce2:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2ce6:	bb e0       	ldi	r27, 0x0B	; 11
    2ce8:	8b 9f       	mul	r24, r27
    2cea:	c0 01       	movw	r24, r0
    2cec:	11 24       	eor	r1, r1
    2cee:	b8 01       	movw	r22, r16
    2cf0:	88 50       	subi	r24, 0x08	; 8
    2cf2:	9f 4c       	sbci	r25, 0xCF	; 207
    2cf4:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vListInsertEnd>
    2cf8:	05 c0       	rjmp	.+10     	; 0x2d04 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2cfa:	b8 01       	movw	r22, r16
    2cfc:	83 ed       	ldi	r24, 0xD3	; 211
    2cfe:	90 e3       	ldi	r25, 0x30	; 48
    2d00:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2d04:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2d08:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2d0c:	81 e0       	ldi	r24, 0x01	; 1
    2d0e:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2d10:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d12:	29 17       	cp	r18, r25
    2d14:	08 f4       	brcc	.+2      	; 0x2d18 <xTaskRemoveFromEventList+0x74>
    2d16:	80 e0       	ldi	r24, 0x00	; 0
}
    2d18:	df 91       	pop	r29
    2d1a:	cf 91       	pop	r28
    2d1c:	1f 91       	pop	r17
    2d1e:	0f 91       	pop	r16
    2d20:	08 95       	ret

00002d22 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2d22:	20 91 c5 30 	lds	r18, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    2d26:	fc 01       	movw	r30, r24
    2d28:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2d2a:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2d2e:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2d32:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2d36:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2d3a:	41 83       	std	Z+1, r20	; 0x01
    2d3c:	52 83       	std	Z+2, r21	; 0x02
    2d3e:	63 83       	std	Z+3, r22	; 0x03
    2d40:	74 83       	std	Z+4, r23	; 0x04
    2d42:	08 95       	ret

00002d44 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2d44:	8f 92       	push	r8
    2d46:	9f 92       	push	r9
    2d48:	af 92       	push	r10
    2d4a:	bf 92       	push	r11
    2d4c:	cf 92       	push	r12
    2d4e:	df 92       	push	r13
    2d50:	ef 92       	push	r14
    2d52:	ff 92       	push	r15
    2d54:	0f 93       	push	r16
    2d56:	1f 93       	push	r17
    2d58:	cf 93       	push	r28
    2d5a:	df 93       	push	r29
    2d5c:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2d5e:	0f b6       	in	r0, 0x3f	; 63
    2d60:	f8 94       	cli
    2d62:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2d64:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    2d68:	90 81       	ld	r25, Z
    2d6a:	98 17       	cp	r25, r24
    2d6c:	89 f0       	breq	.+34     	; 0x2d90 <xTaskCheckForTimeOut+0x4c>
    2d6e:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2d72:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2d76:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2d7a:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2d7e:	01 81       	ldd	r16, Z+1	; 0x01
    2d80:	12 81       	ldd	r17, Z+2	; 0x02
    2d82:	23 81       	ldd	r18, Z+3	; 0x03
    2d84:	34 81       	ldd	r19, Z+4	; 0x04
    2d86:	80 17       	cp	r24, r16
    2d88:	91 07       	cpc	r25, r17
    2d8a:	a2 07       	cpc	r26, r18
    2d8c:	b3 07       	cpc	r27, r19
    2d8e:	a8 f5       	brcc	.+106    	; 0x2dfa <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2d90:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2d94:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2d98:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2d9c:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2da0:	c1 80       	ldd	r12, Z+1	; 0x01
    2da2:	d2 80       	ldd	r13, Z+2	; 0x02
    2da4:	e3 80       	ldd	r14, Z+3	; 0x03
    2da6:	f4 80       	ldd	r15, Z+4	; 0x04
    2da8:	eb 01       	movw	r28, r22
    2daa:	08 81       	ld	r16, Y
    2dac:	19 81       	ldd	r17, Y+1	; 0x01
    2dae:	2a 81       	ldd	r18, Y+2	; 0x02
    2db0:	3b 81       	ldd	r19, Y+3	; 0x03
    2db2:	8c 19       	sub	r24, r12
    2db4:	9d 09       	sbc	r25, r13
    2db6:	ae 09       	sbc	r26, r14
    2db8:	bf 09       	sbc	r27, r15
    2dba:	80 17       	cp	r24, r16
    2dbc:	91 07       	cpc	r25, r17
    2dbe:	a2 07       	cpc	r26, r18
    2dc0:	b3 07       	cpc	r27, r19
    2dc2:	e8 f4       	brcc	.+58     	; 0x2dfe <xTaskCheckForTimeOut+0xba>
    2dc4:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2dc6:	80 90 cc 30 	lds	r8, 0x30CC	; 0x8030cc <xTickCount>
    2dca:	90 90 cd 30 	lds	r9, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2dce:	a0 90 ce 30 	lds	r10, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2dd2:	b0 90 cf 30 	lds	r11, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2dd6:	b5 01       	movw	r22, r10
    2dd8:	a4 01       	movw	r20, r8
    2dda:	4c 19       	sub	r20, r12
    2ddc:	5d 09       	sbc	r21, r13
    2dde:	6e 09       	sbc	r22, r14
    2de0:	7f 09       	sbc	r23, r15
    2de2:	04 1b       	sub	r16, r20
    2de4:	15 0b       	sbc	r17, r21
    2de6:	26 0b       	sbc	r18, r22
    2de8:	37 0b       	sbc	r19, r23
    2dea:	08 83       	st	Y, r16
    2dec:	19 83       	std	Y+1, r17	; 0x01
    2dee:	2a 83       	std	Y+2, r18	; 0x02
    2df0:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2df2:	0e 94 91 16 	call	0x2d22	; 0x2d22 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2df6:	80 e0       	ldi	r24, 0x00	; 0
    2df8:	03 c0       	rjmp	.+6      	; 0x2e00 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2dfa:	81 e0       	ldi	r24, 0x01	; 1
    2dfc:	01 c0       	rjmp	.+2      	; 0x2e00 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2dfe:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2e00:	0f 90       	pop	r0
    2e02:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2e04:	df 91       	pop	r29
    2e06:	cf 91       	pop	r28
    2e08:	1f 91       	pop	r17
    2e0a:	0f 91       	pop	r16
    2e0c:	ff 90       	pop	r15
    2e0e:	ef 90       	pop	r14
    2e10:	df 90       	pop	r13
    2e12:	cf 90       	pop	r12
    2e14:	bf 90       	pop	r11
    2e16:	af 90       	pop	r10
    2e18:	9f 90       	pop	r9
    2e1a:	8f 90       	pop	r8
    2e1c:	08 95       	ret

00002e1e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2e1e:	81 e0       	ldi	r24, 0x01	; 1
    2e20:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    2e24:	08 95       	ret

00002e26 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2e26:	00 97       	sbiw	r24, 0x00	; 0
    2e28:	21 f4       	brne	.+8      	; 0x2e32 <uxTaskGetStackHighWaterMark+0xc>
    2e2a:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2e2e:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2e32:	dc 01       	movw	r26, r24
    2e34:	5b 96       	adiw	r26, 0x1b	; 27
    2e36:	ed 91       	ld	r30, X+
    2e38:	fc 91       	ld	r31, X
    2e3a:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2e3c:	80 81       	ld	r24, Z
    2e3e:	81 31       	cpi	r24, 0x11	; 17
    2e40:	41 f4       	brne	.+16     	; 0x2e52 <uxTaskGetStackHighWaterMark+0x2c>
    2e42:	31 96       	adiw	r30, 0x01	; 1
    2e44:	80 e0       	ldi	r24, 0x00	; 0
    2e46:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2e48:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2e4a:	21 91       	ld	r18, Z+
    2e4c:	21 31       	cpi	r18, 0x11	; 17
    2e4e:	e1 f3       	breq	.-8      	; 0x2e48 <uxTaskGetStackHighWaterMark+0x22>
    2e50:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2e52:	80 e0       	ldi	r24, 0x00	; 0
    2e54:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2e56:	08 95       	ret

00002e58 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2e58:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2e5c:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2e60:	08 95       	ret

00002e62 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2e62:	0f 93       	push	r16
    2e64:	1f 93       	push	r17
    2e66:	cf 93       	push	r28
    2e68:	df 93       	push	r29
    2e6a:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2e6c:	22 8d       	ldd	r18, Z+26	; 0x1a
    2e6e:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2e72:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2e76:	5a 96       	adiw	r26, 0x1a	; 26
    2e78:	8c 91       	ld	r24, X
    2e7a:	28 17       	cp	r18, r24
    2e7c:	08 f0       	brcs	.+2      	; 0x2e80 <vTaskPriorityInherit+0x1e>
    2e7e:	41 c0       	rjmp	.+130    	; 0x2f02 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2e80:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2e84:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2e88:	5a 96       	adiw	r26, 0x1a	; 26
    2e8a:	3c 91       	ld	r19, X
    2e8c:	84 e0       	ldi	r24, 0x04	; 4
    2e8e:	90 e0       	ldi	r25, 0x00	; 0
    2e90:	a0 e0       	ldi	r26, 0x00	; 0
    2e92:	b0 e0       	ldi	r27, 0x00	; 0
    2e94:	83 1b       	sub	r24, r19
    2e96:	91 09       	sbc	r25, r1
    2e98:	a1 09       	sbc	r26, r1
    2e9a:	b1 09       	sbc	r27, r1
    2e9c:	86 87       	std	Z+14, r24	; 0x0e
    2e9e:	97 87       	std	Z+15, r25	; 0x0f
    2ea0:	a0 8b       	std	Z+16, r26	; 0x10
    2ea2:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2ea4:	8b e0       	ldi	r24, 0x0B	; 11
    2ea6:	28 9f       	mul	r18, r24
    2ea8:	90 01       	movw	r18, r0
    2eaa:	11 24       	eor	r1, r1
    2eac:	28 50       	subi	r18, 0x08	; 8
    2eae:	3f 4c       	sbci	r19, 0xCF	; 207
    2eb0:	84 85       	ldd	r24, Z+12	; 0x0c
    2eb2:	95 85       	ldd	r25, Z+13	; 0x0d
    2eb4:	82 17       	cp	r24, r18
    2eb6:	93 07       	cpc	r25, r19
    2eb8:	e9 f4       	brne	.+58     	; 0x2ef4 <vTaskPriorityInherit+0x92>
    2eba:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2ebc:	ef 01       	movw	r28, r30
    2ebe:	22 96       	adiw	r28, 0x02	; 2
    2ec0:	ce 01       	movw	r24, r28
    2ec2:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2ec6:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2eca:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2ece:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ed0:	f8 01       	movw	r30, r16
    2ed2:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2ed4:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2ed8:	98 17       	cp	r25, r24
    2eda:	10 f4       	brcc	.+4      	; 0x2ee0 <vTaskPriorityInherit+0x7e>
    2edc:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2ee0:	fb e0       	ldi	r31, 0x0B	; 11
    2ee2:	8f 9f       	mul	r24, r31
    2ee4:	c0 01       	movw	r24, r0
    2ee6:	11 24       	eor	r1, r1
    2ee8:	be 01       	movw	r22, r28
    2eea:	88 50       	subi	r24, 0x08	; 8
    2eec:	9f 4c       	sbci	r25, 0xCF	; 207
    2eee:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vListInsertEnd>
    2ef2:	07 c0       	rjmp	.+14     	; 0x2f02 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2ef4:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2ef8:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2efc:	5a 96       	adiw	r26, 0x1a	; 26
    2efe:	8c 91       	ld	r24, X
    2f00:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2f02:	df 91       	pop	r29
    2f04:	cf 91       	pop	r28
    2f06:	1f 91       	pop	r17
    2f08:	0f 91       	pop	r16
    2f0a:	08 95       	ret

00002f0c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2f0c:	0f 93       	push	r16
    2f0e:	1f 93       	push	r17
    2f10:	cf 93       	push	r28
    2f12:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2f14:	00 97       	sbiw	r24, 0x00	; 0
    2f16:	49 f1       	breq	.+82     	; 0x2f6a <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2f18:	fc 01       	movw	r30, r24
    2f1a:	32 8d       	ldd	r19, Z+26	; 0x1a
    2f1c:	27 a1       	ldd	r18, Z+39	; 0x27
    2f1e:	32 17       	cp	r19, r18
    2f20:	21 f1       	breq	.+72     	; 0x2f6a <vTaskPriorityDisinherit+0x5e>
    2f22:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2f24:	8c 01       	movw	r16, r24
    2f26:	0e 5f       	subi	r16, 0xFE	; 254
    2f28:	1f 4f       	sbci	r17, 0xFF	; 255
    2f2a:	c8 01       	movw	r24, r16
    2f2c:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2f30:	8f a1       	ldd	r24, Y+39	; 0x27
    2f32:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2f34:	44 e0       	ldi	r20, 0x04	; 4
    2f36:	50 e0       	ldi	r21, 0x00	; 0
    2f38:	60 e0       	ldi	r22, 0x00	; 0
    2f3a:	70 e0       	ldi	r23, 0x00	; 0
    2f3c:	48 1b       	sub	r20, r24
    2f3e:	51 09       	sbc	r21, r1
    2f40:	61 09       	sbc	r22, r1
    2f42:	71 09       	sbc	r23, r1
    2f44:	4e 87       	std	Y+14, r20	; 0x0e
    2f46:	5f 87       	std	Y+15, r21	; 0x0f
    2f48:	68 8b       	std	Y+16, r22	; 0x10
    2f4a:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2f4c:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2f50:	98 17       	cp	r25, r24
    2f52:	10 f4       	brcc	.+4      	; 0x2f58 <vTaskPriorityDisinherit+0x4c>
    2f54:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2f58:	fb e0       	ldi	r31, 0x0B	; 11
    2f5a:	8f 9f       	mul	r24, r31
    2f5c:	c0 01       	movw	r24, r0
    2f5e:	11 24       	eor	r1, r1
    2f60:	b8 01       	movw	r22, r16
    2f62:	88 50       	subi	r24, 0x08	; 8
    2f64:	9f 4c       	sbci	r25, 0xCF	; 207
    2f66:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vListInsertEnd>
			}
		}
	}
    2f6a:	df 91       	pop	r29
    2f6c:	cf 91       	pop	r28
    2f6e:	1f 91       	pop	r17
    2f70:	0f 91       	pop	r16
    2f72:	08 95       	ret

00002f74 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2f74:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2f76:	e8 81       	ld	r30, Y
    2f78:	f9 81       	ldd	r31, Y+1	; 0x01
    2f7a:	01 90       	ld	r0, Z+
    2f7c:	f0 81       	ld	r31, Z
    2f7e:	e0 2d       	mov	r30, r0
    2f80:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2f82:	1a 82       	std	Y+2, r1	; 0x02
    2f84:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2f86:	6f ef       	ldi	r22, 0xFF	; 255
    2f88:	7f ef       	ldi	r23, 0xFF	; 255
    2f8a:	cb 01       	movw	r24, r22
    2f8c:	0e 94 9d 15 	call	0x2b3a	; 0x2b3a <vTaskDelay>
    2f90:	fa cf       	rjmp	.-12     	; 0x2f86 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002f92 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2f92:	fc 01       	movw	r30, r24
    2f94:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2f96:	65 87       	std	Z+13, r22	; 0x0d
    2f98:	08 95       	ret

00002f9a <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2f9a:	4f 92       	push	r4
    2f9c:	5f 92       	push	r5
    2f9e:	6f 92       	push	r6
    2fa0:	7f 92       	push	r7
    2fa2:	8f 92       	push	r8
    2fa4:	9f 92       	push	r9
    2fa6:	af 92       	push	r10
    2fa8:	bf 92       	push	r11
    2faa:	cf 92       	push	r12
    2fac:	df 92       	push	r13
    2fae:	ef 92       	push	r14
    2fb0:	ff 92       	push	r15
    2fb2:	0f 93       	push	r16
    2fb4:	1f 93       	push	r17
    2fb6:	cf 93       	push	r28
    2fb8:	df 93       	push	r29
    2fba:	cd b7       	in	r28, 0x3d	; 61
    2fbc:	de b7       	in	r29, 0x3e	; 62
    2fbe:	2a 97       	sbiw	r28, 0x0a	; 10
    2fc0:	cd bf       	out	0x3d, r28	; 61
    2fc2:	de bf       	out	0x3e, r29	; 62
    2fc4:	4c 01       	movw	r8, r24
    2fc6:	29 01       	movw	r4, r18
    2fc8:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2fca:	83 e4       	ldi	r24, 0x43	; 67
    2fcc:	90 e2       	ldi	r25, 0x20	; 32
    2fce:	f4 01       	movw	r30, r8
    2fd0:	80 83       	st	Z, r24
    2fd2:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2fd4:	fb 01       	movw	r30, r22
    2fd6:	80 81       	ld	r24, Z
    2fd8:	88 23       	and	r24, r24
    2fda:	69 f0       	breq	.+26     	; 0x2ff6 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2fdc:	de 01       	movw	r26, r28
    2fde:	11 96       	adiw	r26, 0x01	; 1
    2fe0:	31 96       	adiw	r30, 0x01	; 1
    2fe2:	90 e0       	ldi	r25, 0x00	; 0
    2fe4:	02 c0       	rjmp	.+4      	; 0x2fea <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2fe6:	99 30       	cpi	r25, 0x09	; 9
    2fe8:	39 f0       	breq	.+14     	; 0x2ff8 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2fea:	9f 5f       	subi	r25, 0xFF	; 255
    2fec:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2fee:	81 91       	ld	r24, Z+
    2ff0:	81 11       	cpse	r24, r1
    2ff2:	f9 cf       	rjmp	.-14     	; 0x2fe6 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2ff4:	01 c0       	rjmp	.+2      	; 0x2ff8 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2ff6:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2ff8:	e1 e0       	ldi	r30, 0x01	; 1
    2ffa:	f0 e0       	ldi	r31, 0x00	; 0
    2ffc:	ec 0f       	add	r30, r28
    2ffe:	fd 1f       	adc	r31, r29
    3000:	e9 0f       	add	r30, r25
    3002:	f1 1d       	adc	r31, r1
    3004:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    3006:	74 01       	movw	r14, r8
    3008:	f2 e0       	ldi	r31, 0x02	; 2
    300a:	ef 0e       	add	r14, r31
    300c:	f1 1c       	adc	r15, r1
    300e:	a1 2c       	mov	r10, r1
    3010:	b1 2c       	mov	r11, r1
    3012:	c1 2c       	mov	r12, r1
    3014:	d1 2c       	mov	r13, r1
    3016:	04 2f       	mov	r16, r20
    3018:	94 01       	movw	r18, r8
    301a:	a2 01       	movw	r20, r4
    301c:	be 01       	movw	r22, r28
    301e:	6f 5f       	subi	r22, 0xFF	; 255
    3020:	7f 4f       	sbci	r23, 0xFF	; 255
    3022:	82 e9       	ldi	r24, 0x92	; 146
    3024:	93 e0       	ldi	r25, 0x03	; 3
    3026:	0e 94 49 12 	call	0x2492	; 0x2492 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    302a:	f4 01       	movw	r30, r8
    302c:	66 82       	std	Z+6, r6	; 0x06
    302e:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    3030:	40 86       	std	Z+8, r4	; 0x08
    3032:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    3034:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <last_created_task_pointer>
    3038:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    303c:	24 83       	std	Z+4, r18	; 0x04
    303e:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    3040:	80 92 26 31 	sts	0x3126, r8	; 0x803126 <last_created_task_pointer>
    3044:	90 92 27 31 	sts	0x3127, r9	; 0x803127 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    3048:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    304a:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    304c:	40 90 64 31 	lds	r4, 0x3164	; 0x803164 <portStackTopForTask>
    3050:	50 90 65 31 	lds	r5, 0x3165	; 0x803165 <portStackTopForTask+0x1>
    3054:	ff ef       	ldi	r31, 0xFF	; 255
    3056:	4f 1a       	sub	r4, r31
    3058:	5f 0a       	sbc	r5, r31
    305a:	40 92 64 31 	sts	0x3164, r4	; 0x803164 <portStackTopForTask>
    305e:	50 92 65 31 	sts	0x3165, r5	; 0x803165 <portStackTopForTask+0x1>
    3062:	f4 01       	movw	r30, r8
    3064:	42 86       	std	Z+10, r4	; 0x0a
    3066:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    3068:	16 86       	std	Z+14, r1	; 0x0e
    306a:	17 86       	std	Z+15, r1	; 0x0f
    306c:	10 8a       	std	Z+16, r1	; 0x10
    306e:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    3070:	61 14       	cp	r6, r1
    3072:	71 04       	cpc	r7, r1
    3074:	09 f4       	brne	.+2      	; 0x3078 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    3076:	44 c0       	rjmp	.+136    	; 0x3100 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    3078:	81 30       	cpi	r24, 0x01	; 1
    307a:	79 f5       	brne	.+94     	; 0x30da <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    307c:	6a e0       	ldi	r22, 0x0A	; 10
    307e:	c3 01       	movw	r24, r6
    3080:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    3084:	7c 01       	movw	r14, r24
    3086:	60 e7       	ldi	r22, 0x70	; 112
    3088:	76 e0       	ldi	r23, 0x06	; 6
    308a:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    308e:	be 01       	movw	r22, r28
    3090:	6f 5f       	subi	r22, 0xFF	; 255
    3092:	7f 4f       	sbci	r23, 0xFF	; 255
    3094:	c7 01       	movw	r24, r14
    3096:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    309a:	6a e0       	ldi	r22, 0x0A	; 10
    309c:	c7 01       	movw	r24, r14
    309e:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    30a2:	7c 01       	movw	r14, r24
    30a4:	67 e6       	ldi	r22, 0x67	; 103
    30a6:	76 e0       	ldi	r23, 0x06	; 6
    30a8:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    30ac:	6a e0       	ldi	r22, 0x0A	; 10
    30ae:	c7 01       	movw	r24, r14
    30b0:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    30b4:	7c 01       	movw	r14, r24
    30b6:	69 e5       	ldi	r22, 0x59	; 89
    30b8:	76 e0       	ldi	r23, 0x06	; 6
    30ba:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    30be:	63 e0       	ldi	r22, 0x03	; 3
    30c0:	c7 01       	movw	r24, r14
    30c2:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    30c6:	b2 01       	movw	r22, r4
    30c8:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <_ZN8emstreamlsEj>
    30cc:	62 e0       	ldi	r22, 0x02	; 2
    30ce:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    30d2:	66 e0       	ldi	r22, 0x06	; 6
    30d4:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    30d8:	13 c0       	rjmp	.+38     	; 0x3100 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    30da:	6a e0       	ldi	r22, 0x0A	; 10
    30dc:	c3 01       	movw	r24, r6
    30de:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    30e2:	4c 01       	movw	r8, r24
    30e4:	64 e4       	ldi	r22, 0x44	; 68
    30e6:	76 e0       	ldi	r23, 0x06	; 6
    30e8:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    30ec:	be 01       	movw	r22, r28
    30ee:	6f 5f       	subi	r22, 0xFF	; 255
    30f0:	7f 4f       	sbci	r23, 0xFF	; 255
    30f2:	c4 01       	movw	r24, r8
    30f4:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    30f8:	66 e0       	ldi	r22, 0x06	; 6
    30fa:	c4 01       	movw	r24, r8
    30fc:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    3100:	2a 96       	adiw	r28, 0x0a	; 10
    3102:	cd bf       	out	0x3d, r28	; 61
    3104:	de bf       	out	0x3e, r29	; 62
    3106:	df 91       	pop	r29
    3108:	cf 91       	pop	r28
    310a:	1f 91       	pop	r17
    310c:	0f 91       	pop	r16
    310e:	ff 90       	pop	r15
    3110:	ef 90       	pop	r14
    3112:	df 90       	pop	r13
    3114:	cf 90       	pop	r12
    3116:	bf 90       	pop	r11
    3118:	af 90       	pop	r10
    311a:	9f 90       	pop	r9
    311c:	8f 90       	pop	r8
    311e:	7f 90       	pop	r7
    3120:	6f 90       	pop	r6
    3122:	5f 90       	pop	r5
    3124:	4f 90       	pop	r4
    3126:	08 95       	ret

00003128 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    3128:	cf 92       	push	r12
    312a:	df 92       	push	r13
    312c:	ef 92       	push	r14
    312e:	ff 92       	push	r15
    3130:	0f 93       	push	r16
    3132:	1f 93       	push	r17
    3134:	cf 93       	push	r28
    3136:	df 93       	push	r29
    3138:	ec 01       	movw	r28, r24
    313a:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    313c:	8a 81       	ldd	r24, Y+2	; 0x02
    313e:	9b 81       	ldd	r25, Y+3	; 0x03
    3140:	0e 94 a0 13 	call	0x2740	; 0x2740 <pcTaskGetTaskName>
    3144:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    3146:	6a e0       	ldi	r22, 0x0A	; 10
    3148:	c7 01       	movw	r24, r14
    314a:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    314e:	8c 01       	movw	r16, r24
    3150:	63 e8       	ldi	r22, 0x83	; 131
    3152:	76 e0       	ldi	r23, 0x06	; 6
    3154:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    3158:	6a e0       	ldi	r22, 0x0A	; 10
    315a:	c8 01       	movw	r24, r16
    315c:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    3160:	8c 01       	movw	r16, r24
    3162:	6c e7       	ldi	r22, 0x7C	; 124
    3164:	76 e0       	ldi	r23, 0x06	; 6
    3166:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    316a:	b6 01       	movw	r22, r12
    316c:	c8 01       	movw	r24, r16
    316e:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    3172:	6a e0       	ldi	r22, 0x0A	; 10
    3174:	c8 01       	movw	r24, r16
    3176:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    317a:	8c 01       	movw	r16, r24
    317c:	66 e7       	ldi	r22, 0x76	; 118
    317e:	76 e0       	ldi	r23, 0x06	; 6
    3180:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    3184:	66 e0       	ldi	r22, 0x06	; 6
    3186:	c8 01       	movw	r24, r16
    3188:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    318c:	8a 85       	ldd	r24, Y+10	; 0x0a
    318e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3190:	e8 85       	ldd	r30, Y+8	; 0x08
    3192:	f9 85       	ldd	r31, Y+9	; 0x09
    3194:	01 e1       	ldi	r16, 0x11	; 17
    3196:	21 e0       	ldi	r18, 0x01	; 1
    3198:	a7 01       	movw	r20, r14
    319a:	bc 01       	movw	r22, r24
    319c:	8e 1b       	sub	r24, r30
    319e:	9f 0b       	sbc	r25, r31
    31a0:	0e 94 96 1b 	call	0x372c	; 0x372c <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    31a4:	8c 81       	ldd	r24, Y+4	; 0x04
    31a6:	9d 81       	ldd	r25, Y+5	; 0x05
    31a8:	00 97       	sbiw	r24, 0x00	; 0
    31aa:	19 f0       	breq	.+6      	; 0x31b2 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    31ac:	b7 01       	movw	r22, r14
    31ae:	0e 94 94 18 	call	0x3128	; 0x3128 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    31b2:	df 91       	pop	r29
    31b4:	cf 91       	pop	r28
    31b6:	1f 91       	pop	r17
    31b8:	0f 91       	pop	r16
    31ba:	ff 90       	pop	r15
    31bc:	ef 90       	pop	r14
    31be:	df 90       	pop	r13
    31c0:	cf 90       	pop	r12
    31c2:	08 95       	ret

000031c4 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    31c4:	0f 93       	push	r16
    31c6:	1f 93       	push	r17
    31c8:	cf 93       	push	r28
    31ca:	df 93       	push	r29
    31cc:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    31ce:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    31d2:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    31d6:	00 97       	sbiw	r24, 0x00	; 0
    31d8:	19 f0       	breq	.+6      	; 0x31e0 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    31da:	be 01       	movw	r22, r28
    31dc:	0e 94 94 18 	call	0x3128	; 0x3128 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    31e0:	6a e0       	ldi	r22, 0x0A	; 10
    31e2:	ce 01       	movw	r24, r28
    31e4:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    31e8:	8c 01       	movw	r16, r24
    31ea:	69 e9       	ldi	r22, 0x99	; 153
    31ec:	76 e0       	ldi	r23, 0x06	; 6
    31ee:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    31f2:	6a e0       	ldi	r22, 0x0A	; 10
    31f4:	c8 01       	movw	r24, r16
    31f6:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    31fa:	8c 01       	movw	r16, r24
    31fc:	6e e8       	ldi	r22, 0x8E	; 142
    31fe:	76 e0       	ldi	r23, 0x06	; 6
    3200:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    3204:	6a e0       	ldi	r22, 0x0A	; 10
    3206:	c8 01       	movw	r24, r16
    3208:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    320c:	8c 01       	movw	r16, r24
    320e:	68 e8       	ldi	r22, 0x88	; 136
    3210:	76 e0       	ldi	r23, 0x06	; 6
    3212:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    3216:	66 e0       	ldi	r22, 0x06	; 6
    3218:	c8 01       	movw	r24, r16
    321a:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    321e:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <portStackTopForTask>
    3222:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <portStackTopForTask+0x1>
    3226:	bc 01       	movw	r22, r24
    3228:	6f 5f       	subi	r22, 0xFF	; 255
    322a:	7f 4f       	sbci	r23, 0xFF	; 255
    322c:	01 e1       	ldi	r16, 0x11	; 17
    322e:	21 e0       	ldi	r18, 0x01	; 1
    3230:	ae 01       	movw	r20, r28
    3232:	83 56       	subi	r24, 0x63	; 99
    3234:	91 09       	sbc	r25, r1
    3236:	0e 94 96 1b 	call	0x372c	; 0x372c <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    323a:	df 91       	pop	r29
    323c:	cf 91       	pop	r28
    323e:	1f 91       	pop	r17
    3240:	0f 91       	pop	r16
    3242:	08 95       	ret

00003244 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    3244:	8f 92       	push	r8
    3246:	9f 92       	push	r9
    3248:	af 92       	push	r10
    324a:	bf 92       	push	r11
    324c:	cf 92       	push	r12
    324e:	df 92       	push	r13
    3250:	ef 92       	push	r14
    3252:	ff 92       	push	r15
    3254:	0f 93       	push	r16
    3256:	1f 93       	push	r17
    3258:	cf 93       	push	r28
    325a:	df 93       	push	r29
    325c:	ec 01       	movw	r28, r24
    325e:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    3260:	8a 81       	ldd	r24, Y+2	; 0x02
    3262:	9b 81       	ldd	r25, Y+3	; 0x03
    3264:	0e 94 a0 13 	call	0x2740	; 0x2740 <pcTaskGetTaskName>
    3268:	bc 01       	movw	r22, r24
    326a:	c8 01       	movw	r24, r16
    326c:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    3270:	d8 01       	movw	r26, r16
    3272:	ed 91       	ld	r30, X+
    3274:	fc 91       	ld	r31, X
    3276:	02 80       	ldd	r0, Z+2	; 0x02
    3278:	f3 81       	ldd	r31, Z+3	; 0x03
    327a:	e0 2d       	mov	r30, r0
    327c:	69 e0       	ldi	r22, 0x09	; 9
    327e:	c8 01       	movw	r24, r16
    3280:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    3282:	8a 81       	ldd	r24, Y+2	; 0x02
    3284:	9b 81       	ldd	r25, Y+3	; 0x03
    3286:	0e 94 a0 13 	call	0x2740	; 0x2740 <pcTaskGetTaskName>
    328a:	fc 01       	movw	r30, r24
    328c:	01 90       	ld	r0, Z+
    328e:	00 20       	and	r0, r0
    3290:	e9 f7       	brne	.-6      	; 0x328c <_ZN8frt_task12print_statusER8emstream+0x48>
    3292:	31 97       	sbiw	r30, 0x01	; 1
    3294:	e8 1b       	sub	r30, r24
    3296:	f9 0b       	sbc	r31, r25
    3298:	38 97       	sbiw	r30, 0x08	; 8
    329a:	48 f4       	brcc	.+18     	; 0x32ae <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    329c:	d8 01       	movw	r26, r16
    329e:	ed 91       	ld	r30, X+
    32a0:	fc 91       	ld	r31, X
    32a2:	02 80       	ldd	r0, Z+2	; 0x02
    32a4:	f3 81       	ldd	r31, Z+3	; 0x03
    32a6:	e0 2d       	mov	r30, r0
    32a8:	69 e0       	ldi	r22, 0x09	; 9
    32aa:	c8 01       	movw	r24, r16
    32ac:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    32ae:	ce 84       	ldd	r12, Y+14	; 0x0e
    32b0:	df 84       	ldd	r13, Y+15	; 0x0f
    32b2:	e8 88       	ldd	r14, Y+16	; 0x10
    32b4:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    32b6:	a8 84       	ldd	r10, Y+8	; 0x08
    32b8:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    32ba:	8a 81       	ldd	r24, Y+2	; 0x02
    32bc:	9b 81       	ldd	r25, Y+3	; 0x03
    32be:	0e 94 13 17 	call	0x2e26	; 0x2e26 <uxTaskGetStackHighWaterMark>
    32c2:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    32c4:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    32c6:	8a 81       	ldd	r24, Y+2	; 0x02
    32c8:	9b 81       	ldd	r25, Y+3	; 0x03
    32ca:	0e 94 4b 13 	call	0x2696	; 0x2696 <uxTaskPriorityGet>
    32ce:	68 2f       	mov	r22, r24
    32d0:	c8 01       	movw	r24, r16
    32d2:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <_ZN8emstreamlsEh>
    32d6:	6a e0       	ldi	r22, 0x0A	; 10
    32d8:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    32dc:	ec 01       	movw	r28, r24
    32de:	6e e0       	ldi	r22, 0x0E	; 14
    32e0:	77 e0       	ldi	r23, 0x07	; 7
    32e2:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
			<< get_state ()
    32e6:	68 2d       	mov	r22, r8
    32e8:	ce 01       	movw	r24, r28
    32ea:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    32ee:	6a e0       	ldi	r22, 0x0A	; 10
    32f0:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    32f4:	ec 01       	movw	r28, r24
    32f6:	6c e0       	ldi	r22, 0x0C	; 12
    32f8:	77 e0       	ldi	r23, 0x07	; 7
    32fa:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    32fe:	69 2d       	mov	r22, r9
    3300:	ce 01       	movw	r24, r28
    3302:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <_ZN8emstreamlsEh>
    3306:	6a e0       	ldi	r22, 0x0A	; 10
    3308:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    330c:	ec 01       	movw	r28, r24
    330e:	6a e0       	ldi	r22, 0x0A	; 10
    3310:	77 e0       	ldi	r23, 0x07	; 7
    3312:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    3316:	b5 01       	movw	r22, r10
    3318:	ce 01       	movw	r24, r28
    331a:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <_ZN8emstreamlsEj>
    331e:	6a e0       	ldi	r22, 0x0A	; 10
    3320:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    3324:	ec 01       	movw	r28, r24
    3326:	68 e0       	ldi	r22, 0x08	; 8
    3328:	77 e0       	ldi	r23, 0x07	; 7
    332a:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    332e:	6a e0       	ldi	r22, 0x0A	; 10
    3330:	ce 01       	movw	r24, r28
    3332:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    3336:	ec 01       	movw	r28, r24
    3338:	66 e0       	ldi	r22, 0x06	; 6
    333a:	77 e0       	ldi	r23, 0x07	; 7
    333c:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    3340:	b7 01       	movw	r22, r14
    3342:	a6 01       	movw	r20, r12
    3344:	ce 01       	movw	r24, r28
    3346:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <_ZN8emstreamlsEm>
}
    334a:	df 91       	pop	r29
    334c:	cf 91       	pop	r28
    334e:	1f 91       	pop	r17
    3350:	0f 91       	pop	r16
    3352:	ff 90       	pop	r15
    3354:	ef 90       	pop	r14
    3356:	df 90       	pop	r13
    3358:	cf 90       	pop	r12
    335a:	bf 90       	pop	r11
    335c:	af 90       	pop	r10
    335e:	9f 90       	pop	r9
    3360:	8f 90       	pop	r8
    3362:	08 95       	ret

00003364 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    3364:	cf 93       	push	r28
    3366:	df 93       	push	r29
    3368:	ec 01       	movw	r28, r24
    336a:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    336c:	db 01       	movw	r26, r22
    336e:	ed 91       	ld	r30, X+
    3370:	fc 91       	ld	r31, X
    3372:	02 80       	ldd	r0, Z+2	; 0x02
    3374:	f3 81       	ldd	r31, Z+3	; 0x03
    3376:	e0 2d       	mov	r30, r0
    3378:	be 01       	movw	r22, r28
    337a:	19 95       	eicall
	return (ser_dev);
}
    337c:	ce 01       	movw	r24, r28
    337e:	df 91       	pop	r29
    3380:	cf 91       	pop	r28
    3382:	08 95       	ret

00003384 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    3384:	0f 93       	push	r16
    3386:	1f 93       	push	r17
    3388:	cf 93       	push	r28
    338a:	df 93       	push	r29
    338c:	ec 01       	movw	r28, r24
    338e:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    3390:	bc 01       	movw	r22, r24
    3392:	c8 01       	movw	r24, r16
    3394:	0e 94 b2 19 	call	0x3364	; 0x3364 <_ZlsR8emstreamR8frt_task>
    3398:	66 e0       	ldi	r22, 0x06	; 6
    339a:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    339e:	8c 81       	ldd	r24, Y+4	; 0x04
    33a0:	9d 81       	ldd	r25, Y+5	; 0x05
    33a2:	00 97       	sbiw	r24, 0x00	; 0
    33a4:	19 f0       	breq	.+6      	; 0x33ac <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    33a6:	b8 01       	movw	r22, r16
    33a8:	0e 94 c2 19 	call	0x3384	; 0x3384 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    33ac:	df 91       	pop	r29
    33ae:	cf 91       	pop	r28
    33b0:	1f 91       	pop	r17
    33b2:	0f 91       	pop	r16
    33b4:	08 95       	ret

000033b6 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    33b6:	0f 93       	push	r16
    33b8:	1f 93       	push	r17
    33ba:	cf 93       	push	r28
    33bc:	df 93       	push	r29
    33be:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    33c0:	6a e0       	ldi	r22, 0x0A	; 10
    33c2:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    33c6:	8c 01       	movw	r16, r24
    33c8:	6b ef       	ldi	r22, 0xFB	; 251
    33ca:	76 e0       	ldi	r23, 0x06	; 6
    33cc:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    33d0:	6a e0       	ldi	r22, 0x0A	; 10
    33d2:	c8 01       	movw	r24, r16
    33d4:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    33d8:	8c 01       	movw	r16, r24
    33da:	64 ef       	ldi	r22, 0xF4	; 244
    33dc:	76 e0       	ldi	r23, 0x06	; 6
    33de:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    33e2:	66 e0       	ldi	r22, 0x06	; 6
    33e4:	c8 01       	movw	r24, r16
    33e6:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    33ea:	6a e0       	ldi	r22, 0x0A	; 10
    33ec:	ce 01       	movw	r24, r28
    33ee:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    33f2:	8c 01       	movw	r16, r24
    33f4:	63 ee       	ldi	r22, 0xE3	; 227
    33f6:	76 e0       	ldi	r23, 0x06	; 6
    33f8:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    33fc:	6a e0       	ldi	r22, 0x0A	; 10
    33fe:	c8 01       	movw	r24, r16
    3400:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    3404:	8c 01       	movw	r16, r24
    3406:	67 ed       	ldi	r22, 0xD7	; 215
    3408:	76 e0       	ldi	r23, 0x06	; 6
    340a:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    340e:	6a e0       	ldi	r22, 0x0A	; 10
    3410:	c8 01       	movw	r24, r16
    3412:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    3416:	8c 01       	movw	r16, r24
    3418:	61 ed       	ldi	r22, 0xD1	; 209
    341a:	76 e0       	ldi	r23, 0x06	; 6
    341c:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    3420:	66 e0       	ldi	r22, 0x06	; 6
    3422:	c8 01       	movw	r24, r16
    3424:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    3428:	6a e0       	ldi	r22, 0x0A	; 10
    342a:	ce 01       	movw	r24, r28
    342c:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    3430:	8c 01       	movw	r16, r24
    3432:	60 ec       	ldi	r22, 0xC0	; 192
    3434:	76 e0       	ldi	r23, 0x06	; 6
    3436:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    343a:	6a e0       	ldi	r22, 0x0A	; 10
    343c:	c8 01       	movw	r24, r16
    343e:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    3442:	8c 01       	movw	r16, r24
    3444:	64 eb       	ldi	r22, 0xB4	; 180
    3446:	76 e0       	ldi	r23, 0x06	; 6
    3448:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    344c:	6a e0       	ldi	r22, 0x0A	; 10
    344e:	c8 01       	movw	r24, r16
    3450:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    3454:	8c 01       	movw	r16, r24
    3456:	6e ea       	ldi	r22, 0xAE	; 174
    3458:	76 e0       	ldi	r23, 0x06	; 6
    345a:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    345e:	66 e0       	ldi	r22, 0x06	; 6
    3460:	c8 01       	movw	r24, r16
    3462:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    3466:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    346a:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    346e:	00 97       	sbiw	r24, 0x00	; 0
    3470:	19 f0       	breq	.+6      	; 0x3478 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    3472:	be 01       	movw	r22, r28
    3474:	0e 94 c2 19 	call	0x3384	; 0x3384 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3478:	0e 94 a8 13 	call	0x2750	; 0x2750 <xTaskGetIdleTaskHandle>
    347c:	0e 94 13 17 	call	0x2e26	; 0x2e26 <uxTaskGetStackHighWaterMark>
    3480:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    3482:	6a e0       	ldi	r22, 0x0A	; 10
    3484:	ce 01       	movw	r24, r28
    3486:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    348a:	ec 01       	movw	r28, r24
    348c:	63 ea       	ldi	r22, 0xA3	; 163
    348e:	76 e0       	ldi	r23, 0x06	; 6
    3490:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3494:	61 2f       	mov	r22, r17
    3496:	ce 01       	movw	r24, r28
    3498:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    349c:	6a e0       	ldi	r22, 0x0A	; 10
    349e:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    34a2:	ec 01       	movw	r28, r24
    34a4:	61 ea       	ldi	r22, 0xA1	; 161
    34a6:	76 e0       	ldi	r23, 0x06	; 6
    34a8:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    34ac:	64 e6       	ldi	r22, 0x64	; 100
    34ae:	70 e0       	ldi	r23, 0x00	; 0
    34b0:	ce 01       	movw	r24, r28
    34b2:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <_ZN8emstreamlsEj>
    34b6:	6a e0       	ldi	r22, 0x0A	; 10
    34b8:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    34bc:	ec 01       	movw	r28, r24
    34be:	6e e9       	ldi	r22, 0x9E	; 158
    34c0:	76 e0       	ldi	r23, 0x06	; 6
    34c2:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    34c6:	66 e0       	ldi	r22, 0x06	; 6
    34c8:	ce 01       	movw	r24, r28
    34ca:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
}
    34ce:	df 91       	pop	r29
    34d0:	cf 91       	pop	r28
    34d2:	1f 91       	pop	r17
    34d4:	0f 91       	pop	r16
    34d6:	08 95       	ret

000034d8 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    34d8:	0f 93       	push	r16
    34da:	cf 93       	push	r28
    34dc:	df 93       	push	r29
    34de:	1f 92       	push	r1
    34e0:	cd b7       	in	r28, 0x3d	; 61
    34e2:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    34e4:	00 e0       	ldi	r16, 0x00	; 0
    34e6:	2f ef       	ldi	r18, 0xFF	; 255
    34e8:	3f ef       	ldi	r19, 0xFF	; 255
    34ea:	a9 01       	movw	r20, r18
    34ec:	be 01       	movw	r22, r28
    34ee:	6f 5f       	subi	r22, 0xFF	; 255
    34f0:	7f 4f       	sbci	r23, 0xFF	; 255
    34f2:	fc 01       	movw	r30, r24
    34f4:	80 85       	ldd	r24, Z+8	; 0x08
    34f6:	91 85       	ldd	r25, Z+9	; 0x09
    34f8:	0e 94 27 11 	call	0x224e	; 0x224e <xQueueGenericReceive>
    34fc:	81 30       	cpi	r24, 0x01	; 1
    34fe:	19 f4       	brne	.+6      	; 0x3506 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    3500:	89 81       	ldd	r24, Y+1	; 0x01
    3502:	90 e0       	ldi	r25, 0x00	; 0
    3504:	02 c0       	rjmp	.+4      	; 0x350a <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3506:	8f ef       	ldi	r24, 0xFF	; 255
    3508:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    350a:	0f 90       	pop	r0
    350c:	df 91       	pop	r29
    350e:	cf 91       	pop	r28
    3510:	0f 91       	pop	r16
    3512:	08 95       	ret

00003514 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    3514:	fc 01       	movw	r30, r24
    3516:	80 85       	ldd	r24, Z+8	; 0x08
    3518:	91 85       	ldd	r25, Z+9	; 0x09
    351a:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <uxQueueMessagesWaiting>
    351e:	91 e0       	ldi	r25, 0x01	; 1
    3520:	81 11       	cpse	r24, r1
    3522:	01 c0       	rjmp	.+2      	; 0x3526 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3524:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3526:	89 2f       	mov	r24, r25
    3528:	08 95       	ret

0000352a <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    352a:	0f 93       	push	r16
    352c:	cf 93       	push	r28
    352e:	df 93       	push	r29
    3530:	1f 92       	push	r1
    3532:	cd b7       	in	r28, 0x3d	; 61
    3534:	de b7       	in	r29, 0x3e	; 62
    3536:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    3538:	fc 01       	movw	r30, r24
    353a:	22 85       	ldd	r18, Z+10	; 0x0a
    353c:	33 85       	ldd	r19, Z+11	; 0x0b
    353e:	44 85       	ldd	r20, Z+12	; 0x0c
    3540:	55 85       	ldd	r21, Z+13	; 0x0d
    3542:	00 e0       	ldi	r16, 0x00	; 0
    3544:	be 01       	movw	r22, r28
    3546:	6f 5f       	subi	r22, 0xFF	; 255
    3548:	7f 4f       	sbci	r23, 0xFF	; 255
    354a:	80 85       	ldd	r24, Z+8	; 0x08
    354c:	91 85       	ldd	r25, Z+9	; 0x09
    354e:	0e 94 8c 10 	call	0x2118	; 0x2118 <xQueueGenericSend>
    3552:	91 e0       	ldi	r25, 0x01	; 1
    3554:	81 11       	cpse	r24, r1
    3556:	01 c0       	rjmp	.+2      	; 0x355a <_ZN14frt_text_queue7putcharEc+0x30>
    3558:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    355a:	89 2f       	mov	r24, r25
    355c:	0f 90       	pop	r0
    355e:	df 91       	pop	r29
    3560:	cf 91       	pop	r28
    3562:	0f 91       	pop	r16
    3564:	08 95       	ret

00003566 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3566:	8f 92       	push	r8
    3568:	9f 92       	push	r9
    356a:	bf 92       	push	r11
    356c:	cf 92       	push	r12
    356e:	df 92       	push	r13
    3570:	ef 92       	push	r14
    3572:	ff 92       	push	r15
    3574:	0f 93       	push	r16
    3576:	1f 93       	push	r17
    3578:	cf 93       	push	r28
    357a:	df 93       	push	r29
    357c:	ec 01       	movw	r28, r24
    357e:	b6 2e       	mov	r11, r22
    3580:	4a 01       	movw	r8, r20
    3582:	68 01       	movw	r12, r16
    3584:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3586:	0e 94 ed 1c 	call	0x39da	; 0x39da <_ZN8emstreamC1Ev>
    358a:	8b e4       	ldi	r24, 0x4B	; 75
    358c:	90 e2       	ldi	r25, 0x20	; 32
    358e:	88 83       	st	Y, r24
    3590:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    3592:	8e 86       	std	Y+14, r8	; 0x0e
    3594:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3596:	40 e0       	ldi	r20, 0x00	; 0
    3598:	61 e0       	ldi	r22, 0x01	; 1
    359a:	8b 2d       	mov	r24, r11
    359c:	0e 94 5e 10 	call	0x20bc	; 0x20bc <xQueueGenericCreate>
    35a0:	88 87       	std	Y+8, r24	; 0x08
    35a2:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    35a4:	ca 86       	std	Y+10, r12	; 0x0a
    35a6:	db 86       	std	Y+11, r13	; 0x0b
    35a8:	ec 86       	std	Y+12, r14	; 0x0c
    35aa:	fd 86       	std	Y+13, r15	; 0x0d
}
    35ac:	df 91       	pop	r29
    35ae:	cf 91       	pop	r28
    35b0:	1f 91       	pop	r17
    35b2:	0f 91       	pop	r16
    35b4:	ff 90       	pop	r15
    35b6:	ef 90       	pop	r14
    35b8:	df 90       	pop	r13
    35ba:	cf 90       	pop	r12
    35bc:	bf 90       	pop	r11
    35be:	9f 90       	pop	r9
    35c0:	8f 90       	pop	r8
    35c2:	08 95       	ret

000035c4 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    35c4:	cf 92       	push	r12
    35c6:	df 92       	push	r13
    35c8:	ef 92       	push	r14
    35ca:	ff 92       	push	r15
    35cc:	cf 93       	push	r28
    35ce:	df 93       	push	r29
    35d0:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    35d2:	68 81       	ld	r22, Y
    35d4:	79 81       	ldd	r23, Y+1	; 0x01
    35d6:	8a 81       	ldd	r24, Y+2	; 0x02
    35d8:	9b 81       	ldd	r25, Y+3	; 0x03
    35da:	0f 2e       	mov	r0, r31
    35dc:	f8 ee       	ldi	r31, 0xE8	; 232
    35de:	cf 2e       	mov	r12, r31
    35e0:	f3 e0       	ldi	r31, 0x03	; 3
    35e2:	df 2e       	mov	r13, r31
    35e4:	e1 2c       	mov	r14, r1
    35e6:	f1 2c       	mov	r15, r1
    35e8:	f0 2d       	mov	r31, r0
    35ea:	a7 01       	movw	r20, r14
    35ec:	96 01       	movw	r18, r12
    35ee:	0e 94 98 22 	call	0x4530	; 0x4530 <__udivmodsi4>
    35f2:	9b 01       	movw	r18, r22
    35f4:	ac 01       	movw	r20, r24
    35f6:	60 e4       	ldi	r22, 0x40	; 64
    35f8:	72 e4       	ldi	r23, 0x42	; 66
    35fa:	8f e0       	ldi	r24, 0x0F	; 15
    35fc:	90 e0       	ldi	r25, 0x00	; 0
    35fe:	0e 94 74 22 	call	0x44e8	; 0x44e8 <__mulsi3>
    3602:	a7 01       	movw	r20, r14
    3604:	96 01       	movw	r18, r12
    3606:	0e 94 98 22 	call	0x4530	; 0x4530 <__udivmodsi4>
    360a:	69 01       	movw	r12, r18
    360c:	7a 01       	movw	r14, r20
    360e:	ac 81       	ldd	r26, Y+4	; 0x04
    3610:	bd 81       	ldd	r27, Y+5	; 0x05
    3612:	20 e4       	ldi	r18, 0x40	; 64
    3614:	32 e4       	ldi	r19, 0x42	; 66
    3616:	4f e0       	ldi	r20, 0x0F	; 15
    3618:	50 e0       	ldi	r21, 0x00	; 0
    361a:	0e 94 00 23 	call	0x4600	; 0x4600 <__muluhisi3>
    361e:	20 e0       	ldi	r18, 0x00	; 0
    3620:	38 e4       	ldi	r19, 0x48	; 72
    3622:	48 ee       	ldi	r20, 0xE8	; 232
    3624:	51 e0       	ldi	r21, 0x01	; 1
    3626:	0e 94 98 22 	call	0x4530	; 0x4530 <__udivmodsi4>
    362a:	c7 01       	movw	r24, r14
    362c:	b6 01       	movw	r22, r12
    362e:	62 0f       	add	r22, r18
    3630:	73 1f       	adc	r23, r19
    3632:	84 1f       	adc	r24, r20
    3634:	95 1f       	adc	r25, r21
}
    3636:	df 91       	pop	r29
    3638:	cf 91       	pop	r28
    363a:	ff 90       	pop	r15
    363c:	ef 90       	pop	r14
    363e:	df 90       	pop	r13
    3640:	cf 90       	pop	r12
    3642:	08 95       	ret

00003644 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3644:	cf 92       	push	r12
    3646:	df 92       	push	r13
    3648:	ef 92       	push	r14
    364a:	ff 92       	push	r15
    364c:	0f 93       	push	r16
    364e:	1f 93       	push	r17
    3650:	cf 93       	push	r28
    3652:	df 93       	push	r29
    3654:	cd b7       	in	r28, 0x3d	; 61
    3656:	de b7       	in	r29, 0x3e	; 62
    3658:	2f 97       	sbiw	r28, 0x0f	; 15
    365a:	cd bf       	out	0x3d, r28	; 61
    365c:	de bf       	out	0x3e, r29	; 62
    365e:	6c 01       	movw	r12, r24
    3660:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3662:	db 01       	movw	r26, r22
    3664:	6d 91       	ld	r22, X+
    3666:	7d 91       	ld	r23, X+
    3668:	8d 91       	ld	r24, X+
    366a:	9c 91       	ld	r25, X
    366c:	28 ee       	ldi	r18, 0xE8	; 232
    366e:	33 e0       	ldi	r19, 0x03	; 3
    3670:	40 e0       	ldi	r20, 0x00	; 0
    3672:	50 e0       	ldi	r21, 0x00	; 0
    3674:	0e 94 98 22 	call	0x4530	; 0x4530 <__udivmodsi4>
    3678:	ba 01       	movw	r22, r20
    367a:	a9 01       	movw	r20, r18
    367c:	c6 01       	movw	r24, r12
    367e:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3682:	d6 01       	movw	r26, r12
    3684:	ed 91       	ld	r30, X+
    3686:	fc 91       	ld	r31, X
    3688:	02 80       	ldd	r0, Z+2	; 0x02
    368a:	f3 81       	ldd	r31, Z+3	; 0x03
    368c:	e0 2d       	mov	r30, r0
    368e:	6e e2       	ldi	r22, 0x2E	; 46
    3690:	c6 01       	movw	r24, r12
    3692:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3694:	c8 01       	movw	r24, r16
    3696:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <_ZN10time_stamp12get_microsecEv>
    369a:	8e 01       	movw	r16, r28
    369c:	09 5f       	subi	r16, 0xF9	; 249
    369e:	1f 4f       	sbci	r17, 0xFF	; 255
    36a0:	fe 01       	movw	r30, r28
    36a2:	31 96       	adiw	r30, 0x01	; 1
    36a4:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    36a6:	2a e0       	ldi	r18, 0x0A	; 10
    36a8:	30 e0       	ldi	r19, 0x00	; 0
    36aa:	40 e0       	ldi	r20, 0x00	; 0
    36ac:	50 e0       	ldi	r21, 0x00	; 0
    36ae:	0e 94 ba 22 	call	0x4574	; 0x4574 <__divmodsi4>
    36b2:	e6 2f       	mov	r30, r22
    36b4:	28 87       	std	Y+8, r18	; 0x08
    36b6:	39 87       	std	Y+9, r19	; 0x09
    36b8:	4a 87       	std	Y+10, r20	; 0x0a
    36ba:	5b 87       	std	Y+11, r21	; 0x0b
    36bc:	68 85       	ldd	r22, Y+8	; 0x08
    36be:	79 85       	ldd	r23, Y+9	; 0x09
    36c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    36c2:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    36c4:	20 e3       	ldi	r18, 0x30	; 48
    36c6:	2e 0f       	add	r18, r30
    36c8:	d8 01       	movw	r26, r16
    36ca:	2e 93       	st	-X, r18
    36cc:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    36ce:	ae 15       	cp	r26, r14
    36d0:	bf 05       	cpc	r27, r15
    36d2:	49 f7       	brne	.-46     	; 0x36a6 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    36d4:	1f 82       	std	Y+7, r1	; 0x07
    36d6:	be 01       	movw	r22, r28
    36d8:	6f 5f       	subi	r22, 0xFF	; 255
    36da:	7f 4f       	sbci	r23, 0xFF	; 255
    36dc:	c6 01       	movw	r24, r12
    36de:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    36e2:	c6 01       	movw	r24, r12
    36e4:	2f 96       	adiw	r28, 0x0f	; 15
    36e6:	cd bf       	out	0x3d, r28	; 61
    36e8:	de bf       	out	0x3e, r29	; 62
    36ea:	df 91       	pop	r29
    36ec:	cf 91       	pop	r28
    36ee:	1f 91       	pop	r17
    36f0:	0f 91       	pop	r16
    36f2:	ff 90       	pop	r15
    36f4:	ef 90       	pop	r14
    36f6:	df 90       	pop	r13
    36f8:	cf 90       	pop	r12
    36fa:	08 95       	ret

000036fc <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    36fc:	cf 93       	push	r28
    36fe:	df 93       	push	r29
    3700:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3702:	0f b6       	in	r0, 0x3f	; 63
    3704:	f8 94       	cli
    3706:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3708:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    370c:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3710:	8c 83       	std	Y+4, r24	; 0x04
    3712:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3714:	0e 94 92 13 	call	0x2724	; 0x2724 <xTaskGetTickCount>
    3718:	68 83       	st	Y, r22
    371a:	79 83       	std	Y+1, r23	; 0x01
    371c:	8a 83       	std	Y+2, r24	; 0x02
    371e:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3720:	0f 90       	pop	r0
    3722:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3724:	ce 01       	movw	r24, r28
    3726:	df 91       	pop	r29
    3728:	cf 91       	pop	r28
    372a:	08 95       	ret

0000372c <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    372c:	5f 92       	push	r5
    372e:	6f 92       	push	r6
    3730:	7f 92       	push	r7
    3732:	8f 92       	push	r8
    3734:	9f 92       	push	r9
    3736:	af 92       	push	r10
    3738:	bf 92       	push	r11
    373a:	cf 92       	push	r12
    373c:	df 92       	push	r13
    373e:	ef 92       	push	r14
    3740:	ff 92       	push	r15
    3742:	0f 93       	push	r16
    3744:	1f 93       	push	r17
    3746:	cf 93       	push	r28
    3748:	df 93       	push	r29
    374a:	5c 01       	movw	r10, r24
    374c:	4b 01       	movw	r8, r22
    374e:	7a 01       	movw	r14, r20
    3750:	12 2f       	mov	r17, r18
    3752:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3754:	63 e0       	ldi	r22, 0x03	; 3
    3756:	ca 01       	movw	r24, r20
    3758:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    375c:	a8 14       	cp	r10, r8
    375e:	b9 04       	cpc	r11, r9
    3760:	08 f0       	brcs	.+2      	; 0x3764 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3762:	7d c0       	rjmp	.+250    	; 0x385e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3764:	65 01       	movw	r12, r10
    3766:	84 e1       	ldi	r24, 0x14	; 20
    3768:	c8 0e       	add	r12, r24
    376a:	d1 1c       	adc	r13, r1
    376c:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    376e:	6a 2c       	mov	r6, r10
    3770:	5b 2c       	mov	r5, r11
    3772:	b5 01       	movw	r22, r10
    3774:	c7 01       	movw	r24, r14
    3776:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <_ZN8emstreamlsEj>
    377a:	6a e0       	ldi	r22, 0x0A	; 10
    377c:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    3780:	60 e2       	ldi	r22, 0x20	; 32
    3782:	77 e0       	ldi	r23, 0x07	; 7
    3784:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3788:	11 23       	and	r17, r17
    378a:	09 f4       	brne	.+2      	; 0x378e <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    378c:	6d c0       	rjmp	.+218    	; 0x3868 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    378e:	00 23       	and	r16, r16
    3790:	09 f4       	brne	.+2      	; 0x3794 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3792:	6a c0       	rjmp	.+212    	; 0x3868 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3794:	6a e0       	ldi	r22, 0x0A	; 10
    3796:	c7 01       	movw	r24, r14
    3798:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    379c:	6b e1       	ldi	r22, 0x1B	; 27
    379e:	77 e0       	ldi	r23, 0x07	; 7
    37a0:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    37a4:	61 c0       	rjmp	.+194    	; 0x3868 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    37a6:	11 23       	and	r17, r17
    37a8:	71 f0       	breq	.+28     	; 0x37c6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    37aa:	01 11       	cpse	r16, r1
    37ac:	0c c0       	rjmp	.+24     	; 0x37c6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    37ae:	88 81       	ld	r24, Y
    37b0:	87 15       	cp	r24, r7
    37b2:	49 f0       	breq	.+18     	; 0x37c6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    37b4:	6a e0       	ldi	r22, 0x0A	; 10
    37b6:	c7 01       	movw	r24, r14
    37b8:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    37bc:	66 e1       	ldi	r22, 0x16	; 22
    37be:	77 e0       	ldi	r23, 0x07	; 7
    37c0:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    37c4:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    37c6:	69 91       	ld	r22, Y+
    37c8:	c7 01       	movw	r24, r14
    37ca:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    37ce:	dc 01       	movw	r26, r24
    37d0:	ed 91       	ld	r30, X+
    37d2:	fc 91       	ld	r31, X
    37d4:	02 80       	ldd	r0, Z+2	; 0x02
    37d6:	f3 81       	ldd	r31, Z+3	; 0x03
    37d8:	e0 2d       	mov	r30, r0
    37da:	60 e2       	ldi	r22, 0x20	; 32
    37dc:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    37de:	cc 16       	cp	r12, r28
    37e0:	dd 06       	cpc	r13, r29
    37e2:	09 f7       	brne	.-62     	; 0x37a6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    37e4:	11 23       	and	r17, r17
    37e6:	89 f0       	breq	.+34     	; 0x380a <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    37e8:	6a e0       	ldi	r22, 0x0A	; 10
    37ea:	c7 01       	movw	r24, r14
    37ec:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    37f0:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    37f2:	60 e1       	ldi	r22, 0x10	; 16
    37f4:	77 e0       	ldi	r23, 0x07	; 7
    37f6:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    37fa:	e8 81       	ld	r30, Y
    37fc:	f9 81       	ldd	r31, Y+1	; 0x01
    37fe:	02 80       	ldd	r0, Z+2	; 0x02
    3800:	f3 81       	ldd	r31, Z+3	; 0x03
    3802:	e0 2d       	mov	r30, r0
    3804:	60 e2       	ldi	r22, 0x20	; 32
    3806:	ce 01       	movw	r24, r28
    3808:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    380a:	c6 2d       	mov	r28, r6
    380c:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    380e:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3810:	80 ee       	ldi	r24, 0xE0	; 224
    3812:	86 0f       	add	r24, r22
    3814:	8f 35       	cpi	r24, 0x5F	; 95
    3816:	48 f4       	brcc	.+18     	; 0x382a <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3818:	d7 01       	movw	r26, r14
    381a:	ed 91       	ld	r30, X+
    381c:	fc 91       	ld	r31, X
    381e:	02 80       	ldd	r0, Z+2	; 0x02
    3820:	f3 81       	ldd	r31, Z+3	; 0x03
    3822:	e0 2d       	mov	r30, r0
    3824:	c7 01       	movw	r24, r14
    3826:	19 95       	eicall
    3828:	09 c0       	rjmp	.+18     	; 0x383c <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    382a:	d7 01       	movw	r26, r14
    382c:	ed 91       	ld	r30, X+
    382e:	fc 91       	ld	r31, X
    3830:	02 80       	ldd	r0, Z+2	; 0x02
    3832:	f3 81       	ldd	r31, Z+3	; 0x03
    3834:	e0 2d       	mov	r30, r0
    3836:	6e e2       	ldi	r22, 0x2E	; 46
    3838:	c7 01       	movw	r24, r14
    383a:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    383c:	cc 16       	cp	r12, r28
    383e:	dd 06       	cpc	r13, r29
    3840:	31 f7       	brne	.-52     	; 0x380e <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3842:	b4 e1       	ldi	r27, 0x14	; 20
    3844:	ab 0e       	add	r10, r27
    3846:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3848:	66 e0       	ldi	r22, 0x06	; 6
    384a:	c7 01       	movw	r24, r14
    384c:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    3850:	84 e1       	ldi	r24, 0x14	; 20
    3852:	c8 0e       	add	r12, r24
    3854:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3856:	a8 14       	cp	r10, r8
    3858:	b9 04       	cpc	r11, r9
    385a:	08 f4       	brcc	.+2      	; 0x385e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    385c:	88 cf       	rjmp	.-240    	; 0x376e <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    385e:	62 e0       	ldi	r22, 0x02	; 2
    3860:	c7 01       	movw	r24, r14
    3862:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
}
    3866:	03 c0       	rjmp	.+6      	; 0x386e <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3868:	c6 2d       	mov	r28, r6
    386a:	d5 2d       	mov	r29, r5
    386c:	9c cf       	rjmp	.-200    	; 0x37a6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    386e:	df 91       	pop	r29
    3870:	cf 91       	pop	r28
    3872:	1f 91       	pop	r17
    3874:	0f 91       	pop	r16
    3876:	ff 90       	pop	r15
    3878:	ef 90       	pop	r14
    387a:	df 90       	pop	r13
    387c:	cf 90       	pop	r12
    387e:	bf 90       	pop	r11
    3880:	af 90       	pop	r10
    3882:	9f 90       	pop	r9
    3884:	8f 90       	pop	r8
    3886:	7f 90       	pop	r7
    3888:	6f 90       	pop	r6
    388a:	5f 90       	pop	r5
    388c:	08 95       	ret

0000388e <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    388e:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <pvPortMalloc>
    3892:	08 95       	ret

00003894 <_Znaj>:
    3894:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <pvPortMalloc>
    3898:	08 95       	ret

0000389a <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    389a:	08 95       	ret

0000389c <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    389c:	cf 93       	push	r28
    389e:	df 93       	push	r29
    38a0:	fc 01       	movw	r30, r24
    38a2:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    38a4:	40 3a       	cpi	r20, 0xA0	; 160
    38a6:	68 e0       	ldi	r22, 0x08	; 8
    38a8:	56 07       	cpc	r21, r22
    38aa:	49 f4       	brne	.+18     	; 0x38be <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    38ac:	80 e4       	ldi	r24, 0x40	; 64
    38ae:	96 e0       	ldi	r25, 0x06	; 6
    38b0:	82 83       	std	Z+2, r24	; 0x02
    38b2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    38b4:	82 e0       	ldi	r24, 0x02	; 2
    38b6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    38b8:	83 e0       	ldi	r24, 0x03	; 3
    38ba:	85 83       	std	Z+5, r24	; 0x05
    38bc:	32 c0       	rjmp	.+100    	; 0x3922 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    38be:	40 3b       	cpi	r20, 0xB0	; 176
    38c0:	78 e0       	ldi	r23, 0x08	; 8
    38c2:	57 07       	cpc	r21, r23
    38c4:	49 f4       	brne	.+18     	; 0x38d8 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    38c6:	80 e4       	ldi	r24, 0x40	; 64
    38c8:	96 e0       	ldi	r25, 0x06	; 6
    38ca:	82 83       	std	Z+2, r24	; 0x02
    38cc:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    38ce:	86 e0       	ldi	r24, 0x06	; 6
    38d0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    38d2:	87 e0       	ldi	r24, 0x07	; 7
    38d4:	85 83       	std	Z+5, r24	; 0x05
    38d6:	25 c0       	rjmp	.+74     	; 0x3922 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    38d8:	40 3a       	cpi	r20, 0xA0	; 160
    38da:	89 e0       	ldi	r24, 0x09	; 9
    38dc:	58 07       	cpc	r21, r24
    38de:	49 f4       	brne	.+18     	; 0x38f2 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    38e0:	80 e6       	ldi	r24, 0x60	; 96
    38e2:	96 e0       	ldi	r25, 0x06	; 6
    38e4:	82 83       	std	Z+2, r24	; 0x02
    38e6:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    38e8:	82 e0       	ldi	r24, 0x02	; 2
    38ea:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    38ec:	83 e0       	ldi	r24, 0x03	; 3
    38ee:	85 83       	std	Z+5, r24	; 0x05
    38f0:	18 c0       	rjmp	.+48     	; 0x3922 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    38f2:	40 3b       	cpi	r20, 0xB0	; 176
    38f4:	69 e0       	ldi	r22, 0x09	; 9
    38f6:	56 07       	cpc	r21, r22
    38f8:	49 f4       	brne	.+18     	; 0x390c <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    38fa:	80 e6       	ldi	r24, 0x60	; 96
    38fc:	96 e0       	ldi	r25, 0x06	; 6
    38fe:	82 83       	std	Z+2, r24	; 0x02
    3900:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3902:	86 e0       	ldi	r24, 0x06	; 6
    3904:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3906:	87 e0       	ldi	r24, 0x07	; 7
    3908:	85 83       	std	Z+5, r24	; 0x05
    390a:	0b c0       	rjmp	.+22     	; 0x3922 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    390c:	40 3a       	cpi	r20, 0xA0	; 160
    390e:	5a 40       	sbci	r21, 0x0A	; 10
    3910:	41 f4       	brne	.+16     	; 0x3922 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3912:	80 e8       	ldi	r24, 0x80	; 128
    3914:	96 e0       	ldi	r25, 0x06	; 6
    3916:	82 83       	std	Z+2, r24	; 0x02
    3918:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    391a:	82 e0       	ldi	r24, 0x02	; 2
    391c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    391e:	83 e0       	ldi	r24, 0x03	; 3
    3920:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3922:	a6 83       	std	Z+6, r26	; 0x06
    3924:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3926:	cd 01       	movw	r24, r26
    3928:	01 96       	adiw	r24, 0x01	; 1
    392a:	80 87       	std	Z+8, r24	; 0x08
    392c:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    392e:	03 96       	adiw	r24, 0x03	; 3
    3930:	82 87       	std	Z+10, r24	; 0x0a
    3932:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3934:	25 81       	ldd	r18, Z+5	; 0x05
    3936:	c2 81       	ldd	r28, Z+2	; 0x02
    3938:	d3 81       	ldd	r29, Z+3	; 0x03
    393a:	4c 81       	ldd	r20, Y+4	; 0x04
    393c:	81 e0       	ldi	r24, 0x01	; 1
    393e:	90 e0       	ldi	r25, 0x00	; 0
    3940:	bc 01       	movw	r22, r24
    3942:	02 c0       	rjmp	.+4      	; 0x3948 <_ZN7base232C1EjP12USART_struct+0xac>
    3944:	66 0f       	add	r22, r22
    3946:	77 1f       	adc	r23, r23
    3948:	2a 95       	dec	r18
    394a:	e2 f7       	brpl	.-8      	; 0x3944 <_ZN7base232C1EjP12USART_struct+0xa8>
    394c:	9b 01       	movw	r18, r22
    394e:	24 2b       	or	r18, r20
    3950:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3952:	25 81       	ldd	r18, Z+5	; 0x05
    3954:	c2 81       	ldd	r28, Z+2	; 0x02
    3956:	d3 81       	ldd	r29, Z+3	; 0x03
    3958:	48 81       	ld	r20, Y
    395a:	bc 01       	movw	r22, r24
    395c:	02 c0       	rjmp	.+4      	; 0x3962 <_ZN7base232C1EjP12USART_struct+0xc6>
    395e:	66 0f       	add	r22, r22
    3960:	77 1f       	adc	r23, r23
    3962:	2a 95       	dec	r18
    3964:	e2 f7       	brpl	.-8      	; 0x395e <_ZN7base232C1EjP12USART_struct+0xc2>
    3966:	9b 01       	movw	r18, r22
    3968:	24 2b       	or	r18, r20
    396a:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    396c:	34 81       	ldd	r19, Z+4	; 0x04
    396e:	c2 81       	ldd	r28, Z+2	; 0x02
    3970:	d3 81       	ldd	r29, Z+3	; 0x03
    3972:	28 81       	ld	r18, Y
    3974:	02 c0       	rjmp	.+4      	; 0x397a <_ZN7base232C1EjP12USART_struct+0xde>
    3976:	88 0f       	add	r24, r24
    3978:	99 1f       	adc	r25, r25
    397a:	3a 95       	dec	r19
    397c:	e2 f7       	brpl	.-8      	; 0x3976 <_ZN7base232C1EjP12USART_struct+0xda>
    397e:	80 95       	com	r24
    3980:	90 95       	com	r25
    3982:	82 23       	and	r24, r18
    3984:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3986:	80 e1       	ldi	r24, 0x10	; 16
    3988:	13 96       	adiw	r26, 0x03	; 3
    398a:	8c 93       	st	X, r24
    398c:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    398e:	83 e0       	ldi	r24, 0x03	; 3
    3990:	15 96       	adiw	r26, 0x05	; 5
    3992:	8c 93       	st	X, r24
    3994:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3996:	80 ef       	ldi	r24, 0xF0	; 240
    3998:	17 96       	adiw	r26, 0x07	; 7
    399a:	8c 93       	st	X, r24
    399c:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    399e:	81 e2       	ldi	r24, 0x21	; 33
    39a0:	16 96       	adiw	r26, 0x06	; 6
    39a2:	8c 93       	st	X, r24
    39a4:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    39a6:	88 e1       	ldi	r24, 0x18	; 24
    39a8:	14 96       	adiw	r26, 0x04	; 4
    39aa:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    39ac:	80 e8       	ldi	r24, 0x80	; 128
    39ae:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    39b0:	80 e4       	ldi	r24, 0x40	; 64
    39b2:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    39b4:	80 e2       	ldi	r24, 0x20	; 32
    39b6:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    39b8:	06 80       	ldd	r0, Z+6	; 0x06
    39ba:	f7 81       	ldd	r31, Z+7	; 0x07
    39bc:	e0 2d       	mov	r30, r0
    39be:	80 81       	ld	r24, Z
    39c0:	80 81       	ld	r24, Z
}
    39c2:	df 91       	pop	r29
    39c4:	cf 91       	pop	r28
    39c6:	08 95       	ret

000039c8 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    39c8:	81 e0       	ldi	r24, 0x01	; 1
    39ca:	08 95       	ret

000039cc <_ZN8emstream7getcharEv>:
    39cc:	80 e0       	ldi	r24, 0x00	; 0
    39ce:	90 e0       	ldi	r25, 0x00	; 0
    39d0:	08 95       	ret

000039d2 <_ZN8emstream14check_for_charEv>:
    39d2:	80 e0       	ldi	r24, 0x00	; 0
    39d4:	08 95       	ret

000039d6 <_ZN8emstream12transmit_nowEv>:
    39d6:	08 95       	ret

000039d8 <_ZN8emstream12clear_screenEv>:
    39d8:	08 95       	ret

000039da <_ZN8emstreamC1Ev>:
    39da:	fc 01       	movw	r30, r24
    39dc:	8b e5       	ldi	r24, 0x5B	; 91
    39de:	90 e2       	ldi	r25, 0x20	; 32
    39e0:	80 83       	st	Z, r24
    39e2:	91 83       	std	Z+1, r25	; 0x01
    39e4:	8a e0       	ldi	r24, 0x0A	; 10
    39e6:	82 83       	std	Z+2, r24	; 0x02
    39e8:	13 82       	std	Z+3, r1	; 0x03
    39ea:	83 e0       	ldi	r24, 0x03	; 3
    39ec:	85 83       	std	Z+5, r24	; 0x05
    39ee:	14 82       	std	Z+4, r1	; 0x04
    39f0:	16 82       	std	Z+6, r1	; 0x06
    39f2:	17 82       	std	Z+7, r1	; 0x07
    39f4:	08 95       	ret

000039f6 <_ZN8emstream4putsEPKc>:
    39f6:	0f 93       	push	r16
    39f8:	1f 93       	push	r17
    39fa:	cf 93       	push	r28
    39fc:	df 93       	push	r29
    39fe:	8c 01       	movw	r16, r24
    3a00:	fb 01       	movw	r30, r22
    3a02:	dc 01       	movw	r26, r24
    3a04:	14 96       	adiw	r26, 0x04	; 4
    3a06:	8c 91       	ld	r24, X
    3a08:	81 11       	cpse	r24, r1
    3a0a:	04 c0       	rjmp	.+8      	; 0x3a14 <_ZN8emstream4putsEPKc+0x1e>
    3a0c:	60 81       	ld	r22, Z
    3a0e:	61 11       	cpse	r22, r1
    3a10:	17 c0       	rjmp	.+46     	; 0x3a40 <_ZN8emstream4putsEPKc+0x4a>
    3a12:	23 c0       	rjmp	.+70     	; 0x3a5a <_ZN8emstream4putsEPKc+0x64>
    3a14:	d8 01       	movw	r26, r16
    3a16:	14 96       	adiw	r26, 0x04	; 4
    3a18:	1c 92       	st	X, r1
    3a1a:	eb 01       	movw	r28, r22
    3a1c:	21 96       	adiw	r28, 0x01	; 1
    3a1e:	64 91       	lpm	r22, Z
    3a20:	66 23       	and	r22, r22
    3a22:	d9 f0       	breq	.+54     	; 0x3a5a <_ZN8emstream4putsEPKc+0x64>
    3a24:	d8 01       	movw	r26, r16
    3a26:	ed 91       	ld	r30, X+
    3a28:	fc 91       	ld	r31, X
    3a2a:	02 80       	ldd	r0, Z+2	; 0x02
    3a2c:	f3 81       	ldd	r31, Z+3	; 0x03
    3a2e:	e0 2d       	mov	r30, r0
    3a30:	c8 01       	movw	r24, r16
    3a32:	19 95       	eicall
    3a34:	fe 01       	movw	r30, r28
    3a36:	64 91       	lpm	r22, Z
    3a38:	21 96       	adiw	r28, 0x01	; 1
    3a3a:	61 11       	cpse	r22, r1
    3a3c:	f3 cf       	rjmp	.-26     	; 0x3a24 <_ZN8emstream4putsEPKc+0x2e>
    3a3e:	0d c0       	rjmp	.+26     	; 0x3a5a <_ZN8emstream4putsEPKc+0x64>
    3a40:	ef 01       	movw	r28, r30
    3a42:	21 96       	adiw	r28, 0x01	; 1
    3a44:	d8 01       	movw	r26, r16
    3a46:	ed 91       	ld	r30, X+
    3a48:	fc 91       	ld	r31, X
    3a4a:	02 80       	ldd	r0, Z+2	; 0x02
    3a4c:	f3 81       	ldd	r31, Z+3	; 0x03
    3a4e:	e0 2d       	mov	r30, r0
    3a50:	c8 01       	movw	r24, r16
    3a52:	19 95       	eicall
    3a54:	69 91       	ld	r22, Y+
    3a56:	61 11       	cpse	r22, r1
    3a58:	f5 cf       	rjmp	.-22     	; 0x3a44 <_ZN8emstream4putsEPKc+0x4e>
    3a5a:	df 91       	pop	r29
    3a5c:	cf 91       	pop	r28
    3a5e:	1f 91       	pop	r17
    3a60:	0f 91       	pop	r16
    3a62:	08 95       	ret

00003a64 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3a64:	cf 93       	push	r28
    3a66:	df 93       	push	r29
    3a68:	ec 01       	movw	r28, r24
	switch (new_manip)
    3a6a:	86 2f       	mov	r24, r22
    3a6c:	90 e0       	ldi	r25, 0x00	; 0
    3a6e:	8b 30       	cpi	r24, 0x0B	; 11
    3a70:	91 05       	cpc	r25, r1
    3a72:	d8 f5       	brcc	.+118    	; 0x3aea <_ZN8emstreamlsE15ser_manipulator+0x86>
    3a74:	fc 01       	movw	r30, r24
    3a76:	88 27       	eor	r24, r24
    3a78:	e6 5a       	subi	r30, 0xA6	; 166
    3a7a:	fe 4f       	sbci	r31, 0xFE	; 254
    3a7c:	8f 4f       	sbci	r24, 0xFF	; 255
    3a7e:	0c 94 d9 22 	jmp	0x45b2	; 0x45b2 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3a82:	82 e0       	ldi	r24, 0x02	; 2
    3a84:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a86:	31 c0       	rjmp	.+98     	; 0x3aea <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3a88:	88 e0       	ldi	r24, 0x08	; 8
    3a8a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a8c:	2e c0       	rjmp	.+92     	; 0x3aea <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3a8e:	8a e0       	ldi	r24, 0x0A	; 10
    3a90:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a92:	2b c0       	rjmp	.+86     	; 0x3aea <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3a94:	80 e1       	ldi	r24, 0x10	; 16
    3a96:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3a98:	28 c0       	rjmp	.+80     	; 0x3aea <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3a9a:	81 e0       	ldi	r24, 0x01	; 1
    3a9c:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3a9e:	25 c0       	rjmp	.+74     	; 0x3aea <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3aa0:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3aa2:	23 c0       	rjmp	.+70     	; 0x3aea <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3aa4:	e8 81       	ld	r30, Y
    3aa6:	f9 81       	ldd	r31, Y+1	; 0x01
    3aa8:	02 80       	ldd	r0, Z+2	; 0x02
    3aaa:	f3 81       	ldd	r31, Z+3	; 0x03
    3aac:	e0 2d       	mov	r30, r0
    3aae:	6d e0       	ldi	r22, 0x0D	; 13
    3ab0:	ce 01       	movw	r24, r28
    3ab2:	19 95       	eicall
    3ab4:	e8 81       	ld	r30, Y
    3ab6:	f9 81       	ldd	r31, Y+1	; 0x01
    3ab8:	02 80       	ldd	r0, Z+2	; 0x02
    3aba:	f3 81       	ldd	r31, Z+3	; 0x03
    3abc:	e0 2d       	mov	r30, r0
    3abe:	6a e0       	ldi	r22, 0x0A	; 10
    3ac0:	ce 01       	movw	r24, r28
    3ac2:	19 95       	eicall
			break;
    3ac4:	12 c0       	rjmp	.+36     	; 0x3aea <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3ac6:	e8 81       	ld	r30, Y
    3ac8:	f9 81       	ldd	r31, Y+1	; 0x01
    3aca:	02 84       	ldd	r0, Z+10	; 0x0a
    3acc:	f3 85       	ldd	r31, Z+11	; 0x0b
    3ace:	e0 2d       	mov	r30, r0
    3ad0:	ce 01       	movw	r24, r28
    3ad2:	19 95       	eicall
			break;
    3ad4:	0a c0       	rjmp	.+20     	; 0x3aea <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3ad6:	e8 81       	ld	r30, Y
    3ad8:	f9 81       	ldd	r31, Y+1	; 0x01
    3ada:	00 84       	ldd	r0, Z+8	; 0x08
    3adc:	f1 85       	ldd	r31, Z+9	; 0x09
    3ade:	e0 2d       	mov	r30, r0
    3ae0:	ce 01       	movw	r24, r28
    3ae2:	19 95       	eicall
			break;
    3ae4:	02 c0       	rjmp	.+4      	; 0x3aea <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3ae6:	81 e0       	ldi	r24, 0x01	; 1
    3ae8:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3aea:	ce 01       	movw	r24, r28
    3aec:	df 91       	pop	r29
    3aee:	cf 91       	pop	r28
    3af0:	08 95       	ret

00003af2 <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    3af2:	0f 93       	push	r16
    3af4:	1f 93       	push	r17
    3af6:	cf 93       	push	r28
    3af8:	df 93       	push	r29
    3afa:	cd b7       	in	r28, 0x3d	; 61
    3afc:	de b7       	in	r29, 0x3e	; 62
    3afe:	61 97       	sbiw	r28, 0x11	; 17
    3b00:	cd bf       	out	0x3d, r28	; 61
    3b02:	de bf       	out	0x3e, r29	; 62
    3b04:	8c 01       	movw	r16, r24
    3b06:	9b 01       	movw	r18, r22
	if (base != 10)
    3b08:	fc 01       	movw	r30, r24
    3b0a:	92 81       	ldd	r25, Z+2	; 0x02
    3b0c:	9a 30       	cpi	r25, 0x0A	; 10
    3b0e:	21 f0       	breq	.+8      	; 0x3b18 <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    3b10:	c8 01       	movw	r24, r16
    3b12:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <_ZN8emstreamlsEj>
    3b16:	0d c0       	rjmp	.+26     	; 0x3b32 <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    3b18:	4a e0       	ldi	r20, 0x0A	; 10
    3b1a:	be 01       	movw	r22, r28
    3b1c:	6f 5f       	subi	r22, 0xFF	; 255
    3b1e:	7f 4f       	sbci	r23, 0xFF	; 255
    3b20:	c9 01       	movw	r24, r18
    3b22:	0e 94 46 23 	call	0x468c	; 0x468c <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    3b26:	be 01       	movw	r22, r28
    3b28:	6f 5f       	subi	r22, 0xFF	; 255
    3b2a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b2c:	c8 01       	movw	r24, r16
    3b2e:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3b32:	c8 01       	movw	r24, r16
    3b34:	61 96       	adiw	r28, 0x11	; 17
    3b36:	cd bf       	out	0x3d, r28	; 61
    3b38:	de bf       	out	0x3e, r29	; 62
    3b3a:	df 91       	pop	r29
    3b3c:	cf 91       	pop	r28
    3b3e:	1f 91       	pop	r17
    3b40:	0f 91       	pop	r16
    3b42:	08 95       	ret

00003b44 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3b44:	ff 92       	push	r15
    3b46:	0f 93       	push	r16
    3b48:	1f 93       	push	r17
    3b4a:	cf 93       	push	r28
    3b4c:	df 93       	push	r29
    3b4e:	cd b7       	in	r28, 0x3d	; 61
    3b50:	de b7       	in	r29, 0x3e	; 62
    3b52:	61 97       	sbiw	r28, 0x11	; 17
    3b54:	cd bf       	out	0x3d, r28	; 61
    3b56:	de bf       	out	0x3e, r29	; 62
    3b58:	8c 01       	movw	r16, r24
    3b5a:	f6 2e       	mov	r15, r22
    3b5c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3b5e:	f8 01       	movw	r30, r16
    3b60:	42 81       	ldd	r20, Z+2	; 0x02
    3b62:	40 31       	cpi	r20, 0x10	; 16
    3b64:	21 f0       	breq	.+8      	; 0x3b6e <_ZN8emstreamlsEj+0x2a>
    3b66:	48 30       	cpi	r20, 0x08	; 8
    3b68:	11 f0       	breq	.+4      	; 0x3b6e <_ZN8emstreamlsEj+0x2a>
    3b6a:	42 30       	cpi	r20, 0x02	; 2
    3b6c:	41 f4       	brne	.+16     	; 0x3b7e <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3b6e:	69 2f       	mov	r22, r25
    3b70:	c8 01       	movw	r24, r16
    3b72:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <_ZN8emstreamlsEh>
    3b76:	6f 2d       	mov	r22, r15
    3b78:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <_ZN8emstreamlsEh>
    3b7c:	0d c0       	rjmp	.+26     	; 0x3b98 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3b7e:	50 e0       	ldi	r21, 0x00	; 0
    3b80:	be 01       	movw	r22, r28
    3b82:	6f 5f       	subi	r22, 0xFF	; 255
    3b84:	7f 4f       	sbci	r23, 0xFF	; 255
    3b86:	8f 2d       	mov	r24, r15
    3b88:	0e 94 7e 23 	call	0x46fc	; 0x46fc <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3b8c:	be 01       	movw	r22, r28
    3b8e:	6f 5f       	subi	r22, 0xFF	; 255
    3b90:	7f 4f       	sbci	r23, 0xFF	; 255
    3b92:	c8 01       	movw	r24, r16
    3b94:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3b98:	c8 01       	movw	r24, r16
    3b9a:	61 96       	adiw	r28, 0x11	; 17
    3b9c:	cd bf       	out	0x3d, r28	; 61
    3b9e:	de bf       	out	0x3e, r29	; 62
    3ba0:	df 91       	pop	r29
    3ba2:	cf 91       	pop	r28
    3ba4:	1f 91       	pop	r17
    3ba6:	0f 91       	pop	r16
    3ba8:	ff 90       	pop	r15
    3baa:	08 95       	ret

00003bac <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3bac:	df 92       	push	r13
    3bae:	ef 92       	push	r14
    3bb0:	ff 92       	push	r15
    3bb2:	0f 93       	push	r16
    3bb4:	1f 93       	push	r17
    3bb6:	cf 93       	push	r28
    3bb8:	df 93       	push	r29
    3bba:	cd b7       	in	r28, 0x3d	; 61
    3bbc:	de b7       	in	r29, 0x3e	; 62
    3bbe:	a1 97       	sbiw	r28, 0x21	; 33
    3bc0:	cd bf       	out	0x3d, r28	; 61
    3bc2:	de bf       	out	0x3e, r29	; 62
    3bc4:	8c 01       	movw	r16, r24
    3bc6:	d4 2e       	mov	r13, r20
    3bc8:	e5 2e       	mov	r14, r21
    3bca:	f6 2e       	mov	r15, r22
    3bcc:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3bce:	f8 01       	movw	r30, r16
    3bd0:	22 81       	ldd	r18, Z+2	; 0x02
    3bd2:	20 31       	cpi	r18, 0x10	; 16
    3bd4:	21 f0       	breq	.+8      	; 0x3bde <_ZN8emstreamlsEm+0x32>
    3bd6:	28 30       	cpi	r18, 0x08	; 8
    3bd8:	11 f0       	breq	.+4      	; 0x3bde <_ZN8emstreamlsEm+0x32>
    3bda:	22 30       	cpi	r18, 0x02	; 2
    3bdc:	71 f4       	brne	.+28     	; 0x3bfa <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3bde:	69 2f       	mov	r22, r25
    3be0:	c8 01       	movw	r24, r16
    3be2:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <_ZN8emstreamlsEh>
    3be6:	6f 2d       	mov	r22, r15
    3be8:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <_ZN8emstreamlsEh>
    3bec:	6e 2d       	mov	r22, r14
    3bee:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <_ZN8emstreamlsEh>
    3bf2:	6d 2d       	mov	r22, r13
    3bf4:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <_ZN8emstreamlsEh>
    3bf8:	0f c0       	rjmp	.+30     	; 0x3c18 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3bfa:	30 e0       	ldi	r19, 0x00	; 0
    3bfc:	ae 01       	movw	r20, r28
    3bfe:	4f 5f       	subi	r20, 0xFF	; 255
    3c00:	5f 4f       	sbci	r21, 0xFF	; 255
    3c02:	6d 2d       	mov	r22, r13
    3c04:	7e 2d       	mov	r23, r14
    3c06:	8f 2d       	mov	r24, r15
    3c08:	0e 94 51 23 	call	0x46a2	; 0x46a2 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3c0c:	be 01       	movw	r22, r28
    3c0e:	6f 5f       	subi	r22, 0xFF	; 255
    3c10:	7f 4f       	sbci	r23, 0xFF	; 255
    3c12:	c8 01       	movw	r24, r16
    3c14:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3c18:	c8 01       	movw	r24, r16
    3c1a:	a1 96       	adiw	r28, 0x21	; 33
    3c1c:	cd bf       	out	0x3d, r28	; 61
    3c1e:	de bf       	out	0x3e, r29	; 62
    3c20:	df 91       	pop	r29
    3c22:	cf 91       	pop	r28
    3c24:	1f 91       	pop	r17
    3c26:	0f 91       	pop	r16
    3c28:	ff 90       	pop	r15
    3c2a:	ef 90       	pop	r14
    3c2c:	df 90       	pop	r13
    3c2e:	08 95       	ret

00003c30 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3c30:	cf 92       	push	r12
    3c32:	df 92       	push	r13
    3c34:	ef 92       	push	r14
    3c36:	ff 92       	push	r15
    3c38:	0f 93       	push	r16
    3c3a:	1f 93       	push	r17
    3c3c:	cf 93       	push	r28
    3c3e:	df 93       	push	r29
    3c40:	cd b7       	in	r28, 0x3d	; 61
    3c42:	de b7       	in	r29, 0x3e	; 62
    3c44:	29 97       	sbiw	r28, 0x09	; 9
    3c46:	cd bf       	out	0x3d, r28	; 61
    3c48:	de bf       	out	0x3e, r29	; 62
    3c4a:	8c 01       	movw	r16, r24
    3c4c:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3c4e:	dc 01       	movw	r26, r24
    3c50:	13 96       	adiw	r26, 0x03	; 3
    3c52:	8c 91       	ld	r24, X
    3c54:	13 97       	sbiw	r26, 0x03	; 3
    3c56:	88 23       	and	r24, r24
    3c58:	41 f0       	breq	.+16     	; 0x3c6a <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3c5a:	ed 91       	ld	r30, X+
    3c5c:	fc 91       	ld	r31, X
    3c5e:	02 80       	ldd	r0, Z+2	; 0x02
    3c60:	f3 81       	ldd	r31, Z+3	; 0x03
    3c62:	e0 2d       	mov	r30, r0
    3c64:	c8 01       	movw	r24, r16
    3c66:	19 95       	eicall
    3c68:	56 c0       	rjmp	.+172    	; 0x3d16 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3c6a:	f8 01       	movw	r30, r16
    3c6c:	42 81       	ldd	r20, Z+2	; 0x02
    3c6e:	42 30       	cpi	r20, 0x02	; 2
    3c70:	19 f5       	brne	.+70     	; 0x3cb8 <_ZN8emstreamlsEh+0x88>
    3c72:	68 94       	set
    3c74:	cc 24       	eor	r12, r12
    3c76:	c3 f8       	bld	r12, 3
    3c78:	d1 2c       	mov	r13, r1
    3c7a:	68 94       	set
    3c7c:	ff 24       	eor	r15, r15
    3c7e:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3c80:	8e 2d       	mov	r24, r14
    3c82:	8f 21       	and	r24, r15
    3c84:	51 f0       	breq	.+20     	; 0x3c9a <_ZN8emstreamlsEh+0x6a>
    3c86:	d8 01       	movw	r26, r16
    3c88:	ed 91       	ld	r30, X+
    3c8a:	fc 91       	ld	r31, X
    3c8c:	02 80       	ldd	r0, Z+2	; 0x02
    3c8e:	f3 81       	ldd	r31, Z+3	; 0x03
    3c90:	e0 2d       	mov	r30, r0
    3c92:	61 e3       	ldi	r22, 0x31	; 49
    3c94:	c8 01       	movw	r24, r16
    3c96:	19 95       	eicall
    3c98:	09 c0       	rjmp	.+18     	; 0x3cac <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3c9a:	d8 01       	movw	r26, r16
    3c9c:	ed 91       	ld	r30, X+
    3c9e:	fc 91       	ld	r31, X
    3ca0:	02 80       	ldd	r0, Z+2	; 0x02
    3ca2:	f3 81       	ldd	r31, Z+3	; 0x03
    3ca4:	e0 2d       	mov	r30, r0
    3ca6:	60 e3       	ldi	r22, 0x30	; 48
    3ca8:	c8 01       	movw	r24, r16
    3caa:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3cac:	f6 94       	lsr	r15
    3cae:	b1 e0       	ldi	r27, 0x01	; 1
    3cb0:	cb 1a       	sub	r12, r27
    3cb2:	d1 08       	sbc	r13, r1
    3cb4:	29 f7       	brne	.-54     	; 0x3c80 <_ZN8emstreamlsEh+0x50>
    3cb6:	2f c0       	rjmp	.+94     	; 0x3d16 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3cb8:	40 31       	cpi	r20, 0x10	; 16
    3cba:	f9 f4       	brne	.+62     	; 0x3cfa <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3cbc:	62 95       	swap	r22
    3cbe:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3cc0:	01 90       	ld	r0, Z+
    3cc2:	f0 81       	ld	r31, Z
    3cc4:	e0 2d       	mov	r30, r0
    3cc6:	02 80       	ldd	r0, Z+2	; 0x02
    3cc8:	f3 81       	ldd	r31, Z+3	; 0x03
    3cca:	e0 2d       	mov	r30, r0
    3ccc:	6a 30       	cpi	r22, 0x0A	; 10
    3cce:	10 f0       	brcs	.+4      	; 0x3cd4 <_ZN8emstreamlsEh+0xa4>
    3cd0:	69 5c       	subi	r22, 0xC9	; 201
    3cd2:	01 c0       	rjmp	.+2      	; 0x3cd6 <_ZN8emstreamlsEh+0xa6>
    3cd4:	60 5d       	subi	r22, 0xD0	; 208
    3cd6:	c8 01       	movw	r24, r16
    3cd8:	19 95       	eicall
		temp_char = num & 0x0F;
    3cda:	6e 2d       	mov	r22, r14
    3cdc:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3cde:	d8 01       	movw	r26, r16
    3ce0:	ed 91       	ld	r30, X+
    3ce2:	fc 91       	ld	r31, X
    3ce4:	02 80       	ldd	r0, Z+2	; 0x02
    3ce6:	f3 81       	ldd	r31, Z+3	; 0x03
    3ce8:	e0 2d       	mov	r30, r0
    3cea:	6a 30       	cpi	r22, 0x0A	; 10
    3cec:	10 f0       	brcs	.+4      	; 0x3cf2 <_ZN8emstreamlsEh+0xc2>
    3cee:	69 5c       	subi	r22, 0xC9	; 201
    3cf0:	01 c0       	rjmp	.+2      	; 0x3cf4 <_ZN8emstreamlsEh+0xc4>
    3cf2:	60 5d       	subi	r22, 0xD0	; 208
    3cf4:	c8 01       	movw	r24, r16
    3cf6:	19 95       	eicall
    3cf8:	0e c0       	rjmp	.+28     	; 0x3d16 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3cfa:	50 e0       	ldi	r21, 0x00	; 0
    3cfc:	be 01       	movw	r22, r28
    3cfe:	6f 5f       	subi	r22, 0xFF	; 255
    3d00:	7f 4f       	sbci	r23, 0xFF	; 255
    3d02:	8e 2d       	mov	r24, r14
    3d04:	90 e0       	ldi	r25, 0x00	; 0
    3d06:	0e 94 7e 23 	call	0x46fc	; 0x46fc <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3d0a:	be 01       	movw	r22, r28
    3d0c:	6f 5f       	subi	r22, 0xFF	; 255
    3d0e:	7f 4f       	sbci	r23, 0xFF	; 255
    3d10:	c8 01       	movw	r24, r16
    3d12:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3d16:	c8 01       	movw	r24, r16
    3d18:	29 96       	adiw	r28, 0x09	; 9
    3d1a:	cd bf       	out	0x3d, r28	; 61
    3d1c:	de bf       	out	0x3e, r29	; 62
    3d1e:	df 91       	pop	r29
    3d20:	cf 91       	pop	r28
    3d22:	1f 91       	pop	r17
    3d24:	0f 91       	pop	r16
    3d26:	ff 90       	pop	r15
    3d28:	ef 90       	pop	r14
    3d2a:	df 90       	pop	r13
    3d2c:	cf 90       	pop	r12
    3d2e:	08 95       	ret

00003d30 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3d30:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3d32:	50 96       	adiw	r26, 0x10	; 16
    3d34:	ed 91       	ld	r30, X+
    3d36:	fc 91       	ld	r31, X
    3d38:	51 97       	sbiw	r26, 0x11	; 17
    3d3a:	80 81       	ld	r24, Z
    3d3c:	54 96       	adiw	r26, 0x14	; 20
    3d3e:	4c 91       	ld	r20, X
    3d40:	54 97       	sbiw	r26, 0x14	; 20
    3d42:	84 23       	and	r24, r20
    3d44:	29 f0       	breq	.+10     	; 0x3d50 <_ZN5rs2327putcharEc+0x20>
    3d46:	09 c0       	rjmp	.+18     	; 0x3d5a <_ZN5rs2327putcharEc+0x2a>
    3d48:	21 50       	subi	r18, 0x01	; 1
    3d4a:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3d4c:	19 f4       	brne	.+6      	; 0x3d54 <_ZN5rs2327putcharEc+0x24>
    3d4e:	12 c0       	rjmp	.+36     	; 0x3d74 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3d50:	21 e2       	ldi	r18, 0x21	; 33
    3d52:	3e e4       	ldi	r19, 0x4E	; 78
    3d54:	90 81       	ld	r25, Z
    3d56:	94 23       	and	r25, r20
    3d58:	b9 f3       	breq	.-18     	; 0x3d48 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3d5a:	90 81       	ld	r25, Z
    3d5c:	56 96       	adiw	r26, 0x16	; 22
    3d5e:	8c 91       	ld	r24, X
    3d60:	56 97       	sbiw	r26, 0x16	; 22
    3d62:	89 2b       	or	r24, r25
    3d64:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3d66:	1e 96       	adiw	r26, 0x0e	; 14
    3d68:	ed 91       	ld	r30, X+
    3d6a:	fc 91       	ld	r31, X
    3d6c:	1f 97       	sbiw	r26, 0x0f	; 15
    3d6e:	60 83       	st	Z, r22
	return (true);
    3d70:	81 e0       	ldi	r24, 0x01	; 1
    3d72:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3d74:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3d76:	08 95       	ret

00003d78 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3d78:	cf 93       	push	r28
    3d7a:	df 93       	push	r29
    3d7c:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3d7e:	c1 8d       	ldd	r28, Z+25	; 0x19
    3d80:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3d82:	28 81       	ld	r18, Y
    3d84:	39 81       	ldd	r19, Y+1	; 0x01
    3d86:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3d88:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3d8a:	4d 91       	ld	r20, X+
    3d8c:	5c 91       	ld	r21, X
    3d8e:	24 17       	cp	r18, r20
    3d90:	35 07       	cpc	r19, r21
    3d92:	e9 f3       	breq	.-6      	; 0x3d8e <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3d94:	a7 89       	ldd	r26, Z+23	; 0x17
    3d96:	b0 8d       	ldd	r27, Z+24	; 0x18
    3d98:	0d 90       	ld	r0, X+
    3d9a:	bc 91       	ld	r27, X
    3d9c:	a0 2d       	mov	r26, r0
    3d9e:	a2 0f       	add	r26, r18
    3da0:	b3 1f       	adc	r27, r19
    3da2:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3da4:	2f 5f       	subi	r18, 0xFF	; 255
    3da6:	3f 4f       	sbci	r19, 0xFF	; 255
    3da8:	28 83       	st	Y, r18
    3daa:	39 83       	std	Y+1, r19	; 0x01
    3dac:	24 36       	cpi	r18, 0x64	; 100
    3dae:	31 05       	cpc	r19, r1
    3db0:	28 f0       	brcs	.+10     	; 0x3dbc <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3db2:	01 8c       	ldd	r0, Z+25	; 0x19
    3db4:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3db6:	e0 2d       	mov	r30, r0
    3db8:	10 82       	st	Z, r1
    3dba:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3dbc:	90 e0       	ldi	r25, 0x00	; 0
    3dbe:	df 91       	pop	r29
    3dc0:	cf 91       	pop	r28
    3dc2:	08 95       	ret

00003dc4 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3dc4:	cf 93       	push	r28
    3dc6:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3dc8:	ec 01       	movw	r28, r24
    3dca:	a9 8d       	ldd	r26, Y+25	; 0x19
    3dcc:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3dce:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3dd0:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3dd2:	81 e0       	ldi	r24, 0x01	; 1
    3dd4:	4d 91       	ld	r20, X+
    3dd6:	5c 91       	ld	r21, X
    3dd8:	20 81       	ld	r18, Z
    3dda:	31 81       	ldd	r19, Z+1	; 0x01
    3ddc:	42 17       	cp	r20, r18
    3dde:	53 07       	cpc	r21, r19
    3de0:	09 f4       	brne	.+2      	; 0x3de4 <_ZN5rs23214check_for_charEv+0x20>
    3de2:	80 e0       	ldi	r24, 0x00	; 0
}
    3de4:	df 91       	pop	r29
    3de6:	cf 91       	pop	r28
    3de8:	08 95       	ret

00003dea <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3dea:	dc 01       	movw	r26, r24
    3dec:	ed 91       	ld	r30, X+
    3dee:	fc 91       	ld	r31, X
    3df0:	02 80       	ldd	r0, Z+2	; 0x02
    3df2:	f3 81       	ldd	r31, Z+3	; 0x03
    3df4:	e0 2d       	mov	r30, r0
    3df6:	6c e0       	ldi	r22, 0x0C	; 12
    3df8:	19 95       	eicall
    3dfa:	08 95       	ret

00003dfc <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3dfc:	ef 92       	push	r14
    3dfe:	ff 92       	push	r15
    3e00:	0f 93       	push	r16
    3e02:	1f 93       	push	r17
    3e04:	cf 93       	push	r28
    3e06:	df 93       	push	r29
    3e08:	ec 01       	movw	r28, r24
    3e0a:	7b 01       	movw	r14, r22
    3e0c:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3e0e:	0e 94 ed 1c 	call	0x39da	; 0x39da <_ZN8emstreamC1Ev>
    3e12:	a8 01       	movw	r20, r16
    3e14:	b7 01       	movw	r22, r14
    3e16:	ce 01       	movw	r24, r28
    3e18:	08 96       	adiw	r24, 0x08	; 8
    3e1a:	0e 94 4e 1c 	call	0x389c	; 0x389c <_ZN7base232C1EjP12USART_struct>
    3e1e:	8b e6       	ldi	r24, 0x6B	; 107
    3e20:	90 e2       	ldi	r25, 0x20	; 32
    3e22:	88 83       	st	Y, r24
    3e24:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3e26:	00 3a       	cpi	r16, 0xA0	; 160
    3e28:	88 e0       	ldi	r24, 0x08	; 8
    3e2a:	18 07       	cpc	r17, r24
    3e2c:	69 f4       	brne	.+26     	; 0x3e48 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3e2e:	84 e4       	ldi	r24, 0x44	; 68
    3e30:	91 e3       	ldi	r25, 0x31	; 49
    3e32:	8f 8b       	std	Y+23, r24	; 0x17
    3e34:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3e36:	8a e3       	ldi	r24, 0x3A	; 58
    3e38:	91 e3       	ldi	r25, 0x31	; 49
    3e3a:	89 8f       	std	Y+25, r24	; 0x19
    3e3c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3e3e:	80 e3       	ldi	r24, 0x30	; 48
    3e40:	91 e3       	ldi	r25, 0x31	; 49
    3e42:	8b 8f       	std	Y+27, r24	; 0x1b
    3e44:	9c 8f       	std	Y+28, r25	; 0x1c
    3e46:	42 c0       	rjmp	.+132    	; 0x3ecc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3e48:	00 3b       	cpi	r16, 0xB0	; 176
    3e4a:	e8 e0       	ldi	r30, 0x08	; 8
    3e4c:	1e 07       	cpc	r17, r30
    3e4e:	69 f4       	brne	.+26     	; 0x3e6a <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3e50:	82 e4       	ldi	r24, 0x42	; 66
    3e52:	91 e3       	ldi	r25, 0x31	; 49
    3e54:	8f 8b       	std	Y+23, r24	; 0x17
    3e56:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3e58:	88 e3       	ldi	r24, 0x38	; 56
    3e5a:	91 e3       	ldi	r25, 0x31	; 49
    3e5c:	89 8f       	std	Y+25, r24	; 0x19
    3e5e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3e60:	8e e2       	ldi	r24, 0x2E	; 46
    3e62:	91 e3       	ldi	r25, 0x31	; 49
    3e64:	8b 8f       	std	Y+27, r24	; 0x1b
    3e66:	9c 8f       	std	Y+28, r25	; 0x1c
    3e68:	31 c0       	rjmp	.+98     	; 0x3ecc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3e6a:	00 3a       	cpi	r16, 0xA0	; 160
    3e6c:	f9 e0       	ldi	r31, 0x09	; 9
    3e6e:	1f 07       	cpc	r17, r31
    3e70:	69 f4       	brne	.+26     	; 0x3e8c <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3e72:	80 e4       	ldi	r24, 0x40	; 64
    3e74:	91 e3       	ldi	r25, 0x31	; 49
    3e76:	8f 8b       	std	Y+23, r24	; 0x17
    3e78:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3e7a:	86 e3       	ldi	r24, 0x36	; 54
    3e7c:	91 e3       	ldi	r25, 0x31	; 49
    3e7e:	89 8f       	std	Y+25, r24	; 0x19
    3e80:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3e82:	8c e2       	ldi	r24, 0x2C	; 44
    3e84:	91 e3       	ldi	r25, 0x31	; 49
    3e86:	8b 8f       	std	Y+27, r24	; 0x1b
    3e88:	9c 8f       	std	Y+28, r25	; 0x1c
    3e8a:	20 c0       	rjmp	.+64     	; 0x3ecc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3e8c:	00 3b       	cpi	r16, 0xB0	; 176
    3e8e:	89 e0       	ldi	r24, 0x09	; 9
    3e90:	18 07       	cpc	r17, r24
    3e92:	69 f4       	brne	.+26     	; 0x3eae <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3e94:	8e e3       	ldi	r24, 0x3E	; 62
    3e96:	91 e3       	ldi	r25, 0x31	; 49
    3e98:	8f 8b       	std	Y+23, r24	; 0x17
    3e9a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3e9c:	84 e3       	ldi	r24, 0x34	; 52
    3e9e:	91 e3       	ldi	r25, 0x31	; 49
    3ea0:	89 8f       	std	Y+25, r24	; 0x19
    3ea2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3ea4:	8a e2       	ldi	r24, 0x2A	; 42
    3ea6:	91 e3       	ldi	r25, 0x31	; 49
    3ea8:	8b 8f       	std	Y+27, r24	; 0x1b
    3eaa:	9c 8f       	std	Y+28, r25	; 0x1c
    3eac:	0f c0       	rjmp	.+30     	; 0x3ecc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3eae:	00 3a       	cpi	r16, 0xA0	; 160
    3eb0:	1a 40       	sbci	r17, 0x0A	; 10
    3eb2:	61 f4       	brne	.+24     	; 0x3ecc <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3eb4:	8c e3       	ldi	r24, 0x3C	; 60
    3eb6:	91 e3       	ldi	r25, 0x31	; 49
    3eb8:	8f 8b       	std	Y+23, r24	; 0x17
    3eba:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3ebc:	82 e3       	ldi	r24, 0x32	; 50
    3ebe:	91 e3       	ldi	r25, 0x31	; 49
    3ec0:	89 8f       	std	Y+25, r24	; 0x19
    3ec2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3ec4:	88 e2       	ldi	r24, 0x28	; 40
    3ec6:	91 e3       	ldi	r25, 0x31	; 49
    3ec8:	8b 8f       	std	Y+27, r24	; 0x1b
    3eca:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3ecc:	0f 89       	ldd	r16, Y+23	; 0x17
    3ece:	18 8d       	ldd	r17, Y+24	; 0x18
    3ed0:	84 e6       	ldi	r24, 0x64	; 100
    3ed2:	90 e0       	ldi	r25, 0x00	; 0
    3ed4:	0e 94 4a 1c 	call	0x3894	; 0x3894 <_Znaj>
    3ed8:	f8 01       	movw	r30, r16
    3eda:	80 83       	st	Z, r24
    3edc:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3ede:	e9 8d       	ldd	r30, Y+25	; 0x19
    3ee0:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3ee2:	10 82       	st	Z, r1
    3ee4:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3ee6:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3ee8:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3eea:	10 82       	st	Z, r1
    3eec:	11 82       	std	Z+1, r1	; 0x01
}
    3eee:	df 91       	pop	r29
    3ef0:	cf 91       	pop	r28
    3ef2:	1f 91       	pop	r17
    3ef4:	0f 91       	pop	r16
    3ef6:	ff 90       	pop	r15
    3ef8:	ef 90       	pop	r14
    3efa:	08 95       	ret

00003efc <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3efc:	1f 92       	push	r1
    3efe:	0f 92       	push	r0
    3f00:	0f b6       	in	r0, 0x3f	; 63
    3f02:	0f 92       	push	r0
    3f04:	11 24       	eor	r1, r1
    3f06:	08 b6       	in	r0, 0x38	; 56
    3f08:	0f 92       	push	r0
    3f0a:	18 be       	out	0x38, r1	; 56
    3f0c:	0b b6       	in	r0, 0x3b	; 59
    3f0e:	0f 92       	push	r0
    3f10:	1b be       	out	0x3b, r1	; 59
    3f12:	2f 93       	push	r18
    3f14:	3f 93       	push	r19
    3f16:	8f 93       	push	r24
    3f18:	9f 93       	push	r25
    3f1a:	ef 93       	push	r30
    3f1c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3f1e:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3f22:	e0 91 44 31 	lds	r30, 0x3144	; 0x803144 <rcvC0_buffer>
    3f26:	f0 91 45 31 	lds	r31, 0x3145	; 0x803145 <rcvC0_buffer+0x1>
    3f2a:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3f2e:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3f32:	e8 0f       	add	r30, r24
    3f34:	f9 1f       	adc	r31, r25
    3f36:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3f38:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3f3c:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3f40:	01 96       	adiw	r24, 0x01	; 1
    3f42:	84 36       	cpi	r24, 0x64	; 100
    3f44:	91 05       	cpc	r25, r1
    3f46:	60 f4       	brcc	.+24     	; 0x3f60 <__vector_25+0x64>
    3f48:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <rcvC0_write_index>
    3f4c:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3f50:	20 91 3a 31 	lds	r18, 0x313A	; 0x80313a <rcvC0_read_index>
    3f54:	30 91 3b 31 	lds	r19, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    3f58:	82 17       	cp	r24, r18
    3f5a:	93 07       	cpc	r25, r19
    3f5c:	f1 f4       	brne	.+60     	; 0x3f9a <__vector_25+0x9e>
    3f5e:	0c c0       	rjmp	.+24     	; 0x3f78 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3f60:	10 92 30 31 	sts	0x3130, r1	; 0x803130 <rcvC0_write_index>
    3f64:	10 92 31 31 	sts	0x3131, r1	; 0x803131 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3f68:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC0_read_index>
    3f6c:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    3f70:	18 16       	cp	r1, r24
    3f72:	19 06       	cpc	r1, r25
    3f74:	91 f4       	brne	.+36     	; 0x3f9a <__vector_25+0x9e>
    3f76:	0e c0       	rjmp	.+28     	; 0x3f94 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3f78:	01 96       	adiw	r24, 0x01	; 1
    3f7a:	84 36       	cpi	r24, 0x64	; 100
    3f7c:	91 05       	cpc	r25, r1
    3f7e:	28 f4       	brcc	.+10     	; 0x3f8a <__vector_25+0x8e>
    3f80:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvC0_read_index>
    3f84:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvC0_read_index+0x1>
    3f88:	08 c0       	rjmp	.+16     	; 0x3f9a <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3f8a:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvC0_read_index>
    3f8e:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvC0_read_index+0x1>
}
    3f92:	03 c0       	rjmp	.+6      	; 0x3f9a <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3f94:	81 e0       	ldi	r24, 0x01	; 1
    3f96:	90 e0       	ldi	r25, 0x00	; 0
    3f98:	f3 cf       	rjmp	.-26     	; 0x3f80 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3f9a:	ff 91       	pop	r31
    3f9c:	ef 91       	pop	r30
    3f9e:	9f 91       	pop	r25
    3fa0:	8f 91       	pop	r24
    3fa2:	3f 91       	pop	r19
    3fa4:	2f 91       	pop	r18
    3fa6:	0f 90       	pop	r0
    3fa8:	0b be       	out	0x3b, r0	; 59
    3faa:	0f 90       	pop	r0
    3fac:	08 be       	out	0x38, r0	; 56
    3fae:	0f 90       	pop	r0
    3fb0:	0f be       	out	0x3f, r0	; 63
    3fb2:	0f 90       	pop	r0
    3fb4:	1f 90       	pop	r1
    3fb6:	18 95       	reti

00003fb8 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3fb8:	1f 92       	push	r1
    3fba:	0f 92       	push	r0
    3fbc:	0f b6       	in	r0, 0x3f	; 63
    3fbe:	0f 92       	push	r0
    3fc0:	11 24       	eor	r1, r1
    3fc2:	08 b6       	in	r0, 0x38	; 56
    3fc4:	0f 92       	push	r0
    3fc6:	18 be       	out	0x38, r1	; 56
    3fc8:	0b b6       	in	r0, 0x3b	; 59
    3fca:	0f 92       	push	r0
    3fcc:	1b be       	out	0x3b, r1	; 59
    3fce:	2f 93       	push	r18
    3fd0:	3f 93       	push	r19
    3fd2:	8f 93       	push	r24
    3fd4:	9f 93       	push	r25
    3fd6:	ef 93       	push	r30
    3fd8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3fda:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3fde:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <rcvC1_buffer>
    3fe2:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <rcvC1_buffer+0x1>
    3fe6:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3fea:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3fee:	e8 0f       	add	r30, r24
    3ff0:	f9 1f       	adc	r31, r25
    3ff2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3ff4:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3ff8:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3ffc:	01 96       	adiw	r24, 0x01	; 1
    3ffe:	84 36       	cpi	r24, 0x64	; 100
    4000:	91 05       	cpc	r25, r1
    4002:	60 f4       	brcc	.+24     	; 0x401c <__stack+0x1d>
    4004:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC1_write_index>
    4008:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    400c:	20 91 38 31 	lds	r18, 0x3138	; 0x803138 <rcvC1_read_index>
    4010:	30 91 39 31 	lds	r19, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    4014:	82 17       	cp	r24, r18
    4016:	93 07       	cpc	r25, r19
    4018:	f1 f4       	brne	.+60     	; 0x4056 <__stack+0x57>
    401a:	0c c0       	rjmp	.+24     	; 0x4034 <__stack+0x35>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    401c:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC1_write_index>
    4020:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    4024:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvC1_read_index>
    4028:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    402c:	18 16       	cp	r1, r24
    402e:	19 06       	cpc	r1, r25
    4030:	91 f4       	brne	.+36     	; 0x4056 <__stack+0x57>
    4032:	0e c0       	rjmp	.+28     	; 0x4050 <__stack+0x51>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4034:	01 96       	adiw	r24, 0x01	; 1
    4036:	84 36       	cpi	r24, 0x64	; 100
    4038:	91 05       	cpc	r25, r1
    403a:	28 f4       	brcc	.+10     	; 0x4046 <__stack+0x47>
    403c:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvC1_read_index>
    4040:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvC1_read_index+0x1>
    4044:	08 c0       	rjmp	.+16     	; 0x4056 <__stack+0x57>
	rcvC1_read_index = 0;
    4046:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvC1_read_index>
    404a:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvC1_read_index+0x1>
}
    404e:	03 c0       	rjmp	.+6      	; 0x4056 <__stack+0x57>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4050:	81 e0       	ldi	r24, 0x01	; 1
    4052:	90 e0       	ldi	r25, 0x00	; 0
    4054:	f3 cf       	rjmp	.-26     	; 0x403c <__stack+0x3d>
	rcvC1_read_index = 0;
}
    4056:	ff 91       	pop	r31
    4058:	ef 91       	pop	r30
    405a:	9f 91       	pop	r25
    405c:	8f 91       	pop	r24
    405e:	3f 91       	pop	r19
    4060:	2f 91       	pop	r18
    4062:	0f 90       	pop	r0
    4064:	0b be       	out	0x3b, r0	; 59
    4066:	0f 90       	pop	r0
    4068:	08 be       	out	0x38, r0	; 56
    406a:	0f 90       	pop	r0
    406c:	0f be       	out	0x3f, r0	; 63
    406e:	0f 90       	pop	r0
    4070:	1f 90       	pop	r1
    4072:	18 95       	reti

00004074 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    4074:	1f 92       	push	r1
    4076:	0f 92       	push	r0
    4078:	0f b6       	in	r0, 0x3f	; 63
    407a:	0f 92       	push	r0
    407c:	11 24       	eor	r1, r1
    407e:	08 b6       	in	r0, 0x38	; 56
    4080:	0f 92       	push	r0
    4082:	18 be       	out	0x38, r1	; 56
    4084:	0b b6       	in	r0, 0x3b	; 59
    4086:	0f 92       	push	r0
    4088:	1b be       	out	0x3b, r1	; 59
    408a:	2f 93       	push	r18
    408c:	3f 93       	push	r19
    408e:	8f 93       	push	r24
    4090:	9f 93       	push	r25
    4092:	ef 93       	push	r30
    4094:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    4096:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    409a:	e0 91 40 31 	lds	r30, 0x3140	; 0x803140 <rcvD0_buffer>
    409e:	f0 91 41 31 	lds	r31, 0x3141	; 0x803141 <rcvD0_buffer+0x1>
    40a2:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    40a6:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    40aa:	e8 0f       	add	r30, r24
    40ac:	f9 1f       	adc	r31, r25
    40ae:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    40b0:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvD0_write_index>
    40b4:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvD0_write_index+0x1>
    40b8:	01 96       	adiw	r24, 0x01	; 1
    40ba:	84 36       	cpi	r24, 0x64	; 100
    40bc:	91 05       	cpc	r25, r1
    40be:	60 f4       	brcc	.+24     	; 0x40d8 <__vector_88+0x64>
    40c0:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvD0_write_index>
    40c4:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    40c8:	20 91 36 31 	lds	r18, 0x3136	; 0x803136 <rcvD0_read_index>
    40cc:	30 91 37 31 	lds	r19, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    40d0:	82 17       	cp	r24, r18
    40d2:	93 07       	cpc	r25, r19
    40d4:	f1 f4       	brne	.+60     	; 0x4112 <__vector_88+0x9e>
    40d6:	0c c0       	rjmp	.+24     	; 0x40f0 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    40d8:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvD0_write_index>
    40dc:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    40e0:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD0_read_index>
    40e4:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    40e8:	18 16       	cp	r1, r24
    40ea:	19 06       	cpc	r1, r25
    40ec:	91 f4       	brne	.+36     	; 0x4112 <__vector_88+0x9e>
    40ee:	0e c0       	rjmp	.+28     	; 0x410c <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    40f0:	01 96       	adiw	r24, 0x01	; 1
    40f2:	84 36       	cpi	r24, 0x64	; 100
    40f4:	91 05       	cpc	r25, r1
    40f6:	28 f4       	brcc	.+10     	; 0x4102 <__vector_88+0x8e>
    40f8:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvD0_read_index>
    40fc:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvD0_read_index+0x1>
    4100:	08 c0       	rjmp	.+16     	; 0x4112 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    4102:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvD0_read_index>
    4106:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvD0_read_index+0x1>
}
    410a:	03 c0       	rjmp	.+6      	; 0x4112 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    410c:	81 e0       	ldi	r24, 0x01	; 1
    410e:	90 e0       	ldi	r25, 0x00	; 0
    4110:	f3 cf       	rjmp	.-26     	; 0x40f8 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    4112:	ff 91       	pop	r31
    4114:	ef 91       	pop	r30
    4116:	9f 91       	pop	r25
    4118:	8f 91       	pop	r24
    411a:	3f 91       	pop	r19
    411c:	2f 91       	pop	r18
    411e:	0f 90       	pop	r0
    4120:	0b be       	out	0x3b, r0	; 59
    4122:	0f 90       	pop	r0
    4124:	08 be       	out	0x38, r0	; 56
    4126:	0f 90       	pop	r0
    4128:	0f be       	out	0x3f, r0	; 63
    412a:	0f 90       	pop	r0
    412c:	1f 90       	pop	r1
    412e:	18 95       	reti

00004130 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    4130:	1f 92       	push	r1
    4132:	0f 92       	push	r0
    4134:	0f b6       	in	r0, 0x3f	; 63
    4136:	0f 92       	push	r0
    4138:	11 24       	eor	r1, r1
    413a:	08 b6       	in	r0, 0x38	; 56
    413c:	0f 92       	push	r0
    413e:	18 be       	out	0x38, r1	; 56
    4140:	0b b6       	in	r0, 0x3b	; 59
    4142:	0f 92       	push	r0
    4144:	1b be       	out	0x3b, r1	; 59
    4146:	2f 93       	push	r18
    4148:	3f 93       	push	r19
    414a:	8f 93       	push	r24
    414c:	9f 93       	push	r25
    414e:	ef 93       	push	r30
    4150:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    4152:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    4156:	e0 91 3e 31 	lds	r30, 0x313E	; 0x80313e <rcvD1_buffer>
    415a:	f0 91 3f 31 	lds	r31, 0x313F	; 0x80313f <rcvD1_buffer+0x1>
    415e:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    4162:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    4166:	e8 0f       	add	r30, r24
    4168:	f9 1f       	adc	r31, r25
    416a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    416c:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    4170:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    4174:	01 96       	adiw	r24, 0x01	; 1
    4176:	84 36       	cpi	r24, 0x64	; 100
    4178:	91 05       	cpc	r25, r1
    417a:	60 f4       	brcc	.+24     	; 0x4194 <__vector_91+0x64>
    417c:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD1_write_index>
    4180:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    4184:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <rcvD1_read_index>
    4188:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    418c:	82 17       	cp	r24, r18
    418e:	93 07       	cpc	r25, r19
    4190:	f1 f4       	brne	.+60     	; 0x41ce <__vector_91+0x9e>
    4192:	0c c0       	rjmp	.+24     	; 0x41ac <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    4194:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD1_write_index>
    4198:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    419c:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvD1_read_index>
    41a0:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    41a4:	18 16       	cp	r1, r24
    41a6:	19 06       	cpc	r1, r25
    41a8:	91 f4       	brne	.+36     	; 0x41ce <__vector_91+0x9e>
    41aa:	0e c0       	rjmp	.+28     	; 0x41c8 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    41ac:	01 96       	adiw	r24, 0x01	; 1
    41ae:	84 36       	cpi	r24, 0x64	; 100
    41b0:	91 05       	cpc	r25, r1
    41b2:	28 f4       	brcc	.+10     	; 0x41be <__vector_91+0x8e>
    41b4:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvD1_read_index>
    41b8:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvD1_read_index+0x1>
    41bc:	08 c0       	rjmp	.+16     	; 0x41ce <__vector_91+0x9e>
	rcvD1_read_index = 0;
    41be:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvD1_read_index>
    41c2:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvD1_read_index+0x1>
}
    41c6:	03 c0       	rjmp	.+6      	; 0x41ce <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    41c8:	81 e0       	ldi	r24, 0x01	; 1
    41ca:	90 e0       	ldi	r25, 0x00	; 0
    41cc:	f3 cf       	rjmp	.-26     	; 0x41b4 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    41ce:	ff 91       	pop	r31
    41d0:	ef 91       	pop	r30
    41d2:	9f 91       	pop	r25
    41d4:	8f 91       	pop	r24
    41d6:	3f 91       	pop	r19
    41d8:	2f 91       	pop	r18
    41da:	0f 90       	pop	r0
    41dc:	0b be       	out	0x3b, r0	; 59
    41de:	0f 90       	pop	r0
    41e0:	08 be       	out	0x38, r0	; 56
    41e2:	0f 90       	pop	r0
    41e4:	0f be       	out	0x3f, r0	; 63
    41e6:	0f 90       	pop	r0
    41e8:	1f 90       	pop	r1
    41ea:	18 95       	reti

000041ec <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    41ec:	1f 92       	push	r1
    41ee:	0f 92       	push	r0
    41f0:	0f b6       	in	r0, 0x3f	; 63
    41f2:	0f 92       	push	r0
    41f4:	11 24       	eor	r1, r1
    41f6:	08 b6       	in	r0, 0x38	; 56
    41f8:	0f 92       	push	r0
    41fa:	18 be       	out	0x38, r1	; 56
    41fc:	0b b6       	in	r0, 0x3b	; 59
    41fe:	0f 92       	push	r0
    4200:	1b be       	out	0x3b, r1	; 59
    4202:	2f 93       	push	r18
    4204:	3f 93       	push	r19
    4206:	8f 93       	push	r24
    4208:	9f 93       	push	r25
    420a:	ef 93       	push	r30
    420c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    420e:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    4212:	e0 91 3c 31 	lds	r30, 0x313C	; 0x80313c <rcvE0_buffer>
    4216:	f0 91 3d 31 	lds	r31, 0x313D	; 0x80313d <rcvE0_buffer+0x1>
    421a:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    421e:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    4222:	e8 0f       	add	r30, r24
    4224:	f9 1f       	adc	r31, r25
    4226:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    4228:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    422c:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    4230:	01 96       	adiw	r24, 0x01	; 1
    4232:	84 36       	cpi	r24, 0x64	; 100
    4234:	91 05       	cpc	r25, r1
    4236:	60 f4       	brcc	.+24     	; 0x4250 <__vector_58+0x64>
    4238:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvE0_write_index>
    423c:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4240:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <rcvE0_read_index>
    4244:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    4248:	82 17       	cp	r24, r18
    424a:	93 07       	cpc	r25, r19
    424c:	f1 f4       	brne	.+60     	; 0x428a <__vector_58+0x9e>
    424e:	0c c0       	rjmp	.+24     	; 0x4268 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    4250:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvE0_write_index>
    4254:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4258:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <rcvE0_read_index>
    425c:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    4260:	18 16       	cp	r1, r24
    4262:	19 06       	cpc	r1, r25
    4264:	91 f4       	brne	.+36     	; 0x428a <__vector_58+0x9e>
    4266:	0e c0       	rjmp	.+28     	; 0x4284 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4268:	01 96       	adiw	r24, 0x01	; 1
    426a:	84 36       	cpi	r24, 0x64	; 100
    426c:	91 05       	cpc	r25, r1
    426e:	28 f4       	brcc	.+10     	; 0x427a <__vector_58+0x8e>
    4270:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <rcvE0_read_index>
    4274:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <rcvE0_read_index+0x1>
    4278:	08 c0       	rjmp	.+16     	; 0x428a <__vector_58+0x9e>
	rcvE0_read_index = 0;
    427a:	10 92 32 31 	sts	0x3132, r1	; 0x803132 <rcvE0_read_index>
    427e:	10 92 33 31 	sts	0x3133, r1	; 0x803133 <rcvE0_read_index+0x1>
}
    4282:	03 c0       	rjmp	.+6      	; 0x428a <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4284:	81 e0       	ldi	r24, 0x01	; 1
    4286:	90 e0       	ldi	r25, 0x00	; 0
    4288:	f3 cf       	rjmp	.-26     	; 0x4270 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    428a:	ff 91       	pop	r31
    428c:	ef 91       	pop	r30
    428e:	9f 91       	pop	r25
    4290:	8f 91       	pop	r24
    4292:	3f 91       	pop	r19
    4294:	2f 91       	pop	r18
    4296:	0f 90       	pop	r0
    4298:	0b be       	out	0x3b, r0	; 59
    429a:	0f 90       	pop	r0
    429c:	08 be       	out	0x38, r0	; 56
    429e:	0f 90       	pop	r0
    42a0:	0f be       	out	0x3f, r0	; 63
    42a2:	0f 90       	pop	r0
    42a4:	1f 90       	pop	r1
    42a6:	18 95       	reti

000042a8 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    42a8:	0f 93       	push	r16
    42aa:	cf 93       	push	r28
    42ac:	df 93       	push	r29
    42ae:	1f 92       	push	r1
    42b0:	cd b7       	in	r28, 0x3d	; 61
    42b2:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    42b4:	2f b7       	in	r18, 0x3f	; 63
    42b6:	29 83       	std	Y+1, r18	; 0x01
	cli();
    42b8:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    42ba:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    42bc:	fc 01       	movw	r30, r24
    42be:	08 ed       	ldi	r16, 0xD8	; 216
    42c0:	04 bf       	out	0x34, r16	; 52
    42c2:	60 83       	st	Z, r22

	SREG = saved_sreg;
    42c4:	89 81       	ldd	r24, Y+1	; 0x01
    42c6:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    42c8:	0f 90       	pop	r0
    42ca:	df 91       	pop	r29
    42cc:	cf 91       	pop	r28
    42ce:	0f 91       	pop	r16
    42d0:	08 95       	ret

000042d2 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    42d2:	0f 93       	push	r16
    42d4:	1f 93       	push	r17
    42d6:	cf 93       	push	r28
    42d8:	df 93       	push	r29
    42da:	cd b7       	in	r28, 0x3d	; 61
    42dc:	de b7       	in	r29, 0x3e	; 62
    42de:	6d 97       	sbiw	r28, 0x1d	; 29
    42e0:	cd bf       	out	0x3d, r28	; 61
    42e2:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    42e4:	e0 e6       	ldi	r30, 0x60	; 96
    42e6:	f6 e0       	ldi	r31, 0x06	; 6
    42e8:	80 e4       	ldi	r24, 0x40	; 64
    42ea:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    42ec:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    42ee:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    42f0:	e0 e5       	ldi	r30, 0x50	; 80
    42f2:	f0 e0       	ldi	r31, 0x00	; 0
    42f4:	80 81       	ld	r24, Z
    42f6:	82 60       	ori	r24, 0x02	; 2
    42f8:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    42fa:	81 81       	ldd	r24, Z+1	; 0x01
    42fc:	81 ff       	sbrs	r24, 1
    42fe:	fd cf       	rjmp	.-6      	; 0x42fa <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    4300:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    4304:	68 7f       	andi	r22, 0xF8	; 248
    4306:	61 60       	ori	r22, 0x01	; 1
    4308:	80 e4       	ldi	r24, 0x40	; 64
    430a:	90 e0       	ldi	r25, 0x00	; 0
    430c:	0e 94 54 21 	call	0x42a8	; 0x42a8 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    4310:	e0 e5       	ldi	r30, 0x50	; 80
    4312:	f0 e0       	ldi	r31, 0x00	; 0
    4314:	80 81       	ld	r24, Z
    4316:	8e 7f       	andi	r24, 0xFE	; 254
    4318:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    431a:	9d ef       	ldi	r25, 0xFD	; 253
    431c:	88 ed       	ldi	r24, 0xD8	; 216
    431e:	08 b6       	in	r0, 0x38	; 56
    4320:	18 be       	out	0x38, r1	; 56
    4322:	84 bf       	out	0x34, r24	; 52
    4324:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    4328:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    432a:	40 eb       	ldi	r20, 0xB0	; 176
    432c:	58 e0       	ldi	r21, 0x08	; 8
    432e:	60 e0       	ldi	r22, 0x00	; 0
    4330:	70 e0       	ldi	r23, 0x00	; 0
    4332:	ce 01       	movw	r24, r28
    4334:	01 96       	adiw	r24, 0x01	; 1
    4336:	0e 94 fe 1e 	call	0x3dfc	; 0x3dfc <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    433a:	67 e0       	ldi	r22, 0x07	; 7
    433c:	ce 01       	movw	r24, r28
    433e:	01 96       	adiw	r24, 0x01	; 1
    4340:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    4344:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    4346:	67 e7       	ldi	r22, 0x77	; 119
    4348:	70 e2       	ldi	r23, 0x20	; 32
    434a:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_ZN8emstream4putsEPKc>
    434e:	66 e0       	ldi	r22, 0x06	; 6
    4350:	c8 01       	movw	r24, r16
    4352:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
    4356:	66 e0       	ldi	r22, 0x06	; 6
    4358:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    435c:	82 e1       	ldi	r24, 0x12	; 18
    435e:	90 e0       	ldi	r25, 0x00	; 0
    4360:	0e 94 47 1c 	call	0x388e	; 0x388e <_Znwj>
    4364:	8e 01       	movw	r16, r28
    4366:	0f 5f       	subi	r16, 0xFF	; 255
    4368:	1f 4f       	sbci	r17, 0xFF	; 255
    436a:	24 e0       	ldi	r18, 0x04	; 4
    436c:	31 e0       	ldi	r19, 0x01	; 1
    436e:	40 e0       	ldi	r20, 0x00	; 0
    4370:	66 e9       	ldi	r22, 0x96	; 150
    4372:	70 e2       	ldi	r23, 0x20	; 32
    4374:	0e 94 77 09 	call	0x12ee	; 0x12ee <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    4378:	82 e1       	ldi	r24, 0x12	; 18
    437a:	90 e0       	ldi	r25, 0x00	; 0
    437c:	0e 94 47 1c 	call	0x388e	; 0x388e <_Znwj>
    4380:	24 e0       	ldi	r18, 0x04	; 4
    4382:	31 e0       	ldi	r19, 0x01	; 1
    4384:	42 e0       	ldi	r20, 0x02	; 2
    4386:	6e e9       	ldi	r22, 0x9E	; 158
    4388:	70 e2       	ldi	r23, 0x20	; 32
    438a:	0e 94 4b 04 	call	0x896	; 0x896 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    438e:	82 e1       	ldi	r24, 0x12	; 18
    4390:	90 e0       	ldi	r25, 0x00	; 0
    4392:	0e 94 47 1c 	call	0x388e	; 0x388e <_Znwj>
    4396:	24 e0       	ldi	r18, 0x04	; 4
    4398:	31 e0       	ldi	r19, 0x01	; 1
    439a:	43 e0       	ldi	r20, 0x03	; 3
    439c:	65 ea       	ldi	r22, 0xA5	; 165
    439e:	70 e2       	ldi	r23, 0x20	; 32
    43a0:	0e 94 a4 04 	call	0x948	; 0x948 <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    43a4:	82 e1       	ldi	r24, 0x12	; 18
    43a6:	90 e0       	ldi	r25, 0x00	; 0
    43a8:	0e 94 47 1c 	call	0x388e	; 0x388e <_Znwj>
    43ac:	24 e0       	ldi	r18, 0x04	; 4
    43ae:	31 e0       	ldi	r19, 0x01	; 1
    43b0:	44 e0       	ldi	r20, 0x04	; 4
    43b2:	6c ea       	ldi	r22, 0xAC	; 172
    43b4:	70 e2       	ldi	r23, 0x20	; 32
    43b6:	0e 94 09 05 	call	0xa12	; 0xa12 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    43ba:	8c e6       	ldi	r24, 0x6C	; 108
    43bc:	90 e0       	ldi	r25, 0x00	; 0
    43be:	0e 94 47 1c 	call	0x388e	; 0x388e <_Znwj>
    43c2:	24 e0       	ldi	r18, 0x04	; 4
    43c4:	31 e0       	ldi	r19, 0x01	; 1
    43c6:	43 e0       	ldi	r20, 0x03	; 3
    43c8:	65 eb       	ldi	r22, 0xB5	; 181
    43ca:	70 e2       	ldi	r23, 0x20	; 32
    43cc:	0e 94 39 09 	call	0x1272	; 0x1272 <_ZN5MotorC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    43d0:	87 e0       	ldi	r24, 0x07	; 7
    43d2:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    43d6:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    43d8:	0e 94 59 13 	call	0x26b2	; 0x26b2 <vTaskStartScheduler>
	
	
	return 0;
    43dc:	80 e0       	ldi	r24, 0x00	; 0
    43de:	90 e0       	ldi	r25, 0x00	; 0
    43e0:	6d 96       	adiw	r28, 0x1d	; 29
    43e2:	cd bf       	out	0x3d, r28	; 61
    43e4:	de bf       	out	0x3e, r29	; 62
    43e6:	df 91       	pop	r29
    43e8:	cf 91       	pop	r28
    43ea:	1f 91       	pop	r17
    43ec:	0f 91       	pop	r16
    43ee:	08 95       	ret

000043f0 <_GLOBAL__sub_I_counter>:
    43f0:	0f 93       	push	r16
    43f2:	1f 93       	push	r17
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    43f4:	0a e0       	ldi	r16, 0x0A	; 10
    43f6:	10 e0       	ldi	r17, 0x00	; 0
    43f8:	20 e0       	ldi	r18, 0x00	; 0
    43fa:	30 e0       	ldi	r19, 0x00	; 0
    43fc:	40 e0       	ldi	r20, 0x00	; 0
    43fe:	50 e0       	ldi	r21, 0x00	; 0
    4400:	60 e2       	ldi	r22, 0x20	; 32
    4402:	70 e0       	ldi	r23, 0x00	; 0
    4404:	84 e5       	ldi	r24, 0x54	; 84
    4406:	91 e3       	ldi	r25, 0x31	; 49
    4408:	0e 94 b3 1a 	call	0x3566	; 0x3566 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    440c:	1f 91       	pop	r17
    440e:	0f 91       	pop	r16
    4410:	08 95       	ret

00004412 <__cmpsf2>:
    4412:	0e 94 4b 22 	call	0x4496	; 0x4496 <__fp_cmp>
    4416:	08 f4       	brcc	.+2      	; 0x441a <__cmpsf2+0x8>
    4418:	81 e0       	ldi	r24, 0x01	; 1
    441a:	08 95       	ret

0000441c <__floatunsisf>:
    441c:	e8 94       	clt
    441e:	09 c0       	rjmp	.+18     	; 0x4432 <__floatsisf+0x12>

00004420 <__floatsisf>:
    4420:	97 fb       	bst	r25, 7
    4422:	3e f4       	brtc	.+14     	; 0x4432 <__floatsisf+0x12>
    4424:	90 95       	com	r25
    4426:	80 95       	com	r24
    4428:	70 95       	com	r23
    442a:	61 95       	neg	r22
    442c:	7f 4f       	sbci	r23, 0xFF	; 255
    442e:	8f 4f       	sbci	r24, 0xFF	; 255
    4430:	9f 4f       	sbci	r25, 0xFF	; 255
    4432:	99 23       	and	r25, r25
    4434:	a9 f0       	breq	.+42     	; 0x4460 <__floatsisf+0x40>
    4436:	f9 2f       	mov	r31, r25
    4438:	96 e9       	ldi	r25, 0x96	; 150
    443a:	bb 27       	eor	r27, r27
    443c:	93 95       	inc	r25
    443e:	f6 95       	lsr	r31
    4440:	87 95       	ror	r24
    4442:	77 95       	ror	r23
    4444:	67 95       	ror	r22
    4446:	b7 95       	ror	r27
    4448:	f1 11       	cpse	r31, r1
    444a:	f8 cf       	rjmp	.-16     	; 0x443c <__floatsisf+0x1c>
    444c:	fa f4       	brpl	.+62     	; 0x448c <__floatsisf+0x6c>
    444e:	bb 0f       	add	r27, r27
    4450:	11 f4       	brne	.+4      	; 0x4456 <__floatsisf+0x36>
    4452:	60 ff       	sbrs	r22, 0
    4454:	1b c0       	rjmp	.+54     	; 0x448c <__floatsisf+0x6c>
    4456:	6f 5f       	subi	r22, 0xFF	; 255
    4458:	7f 4f       	sbci	r23, 0xFF	; 255
    445a:	8f 4f       	sbci	r24, 0xFF	; 255
    445c:	9f 4f       	sbci	r25, 0xFF	; 255
    445e:	16 c0       	rjmp	.+44     	; 0x448c <__floatsisf+0x6c>
    4460:	88 23       	and	r24, r24
    4462:	11 f0       	breq	.+4      	; 0x4468 <__floatsisf+0x48>
    4464:	96 e9       	ldi	r25, 0x96	; 150
    4466:	11 c0       	rjmp	.+34     	; 0x448a <__floatsisf+0x6a>
    4468:	77 23       	and	r23, r23
    446a:	21 f0       	breq	.+8      	; 0x4474 <__floatsisf+0x54>
    446c:	9e e8       	ldi	r25, 0x8E	; 142
    446e:	87 2f       	mov	r24, r23
    4470:	76 2f       	mov	r23, r22
    4472:	05 c0       	rjmp	.+10     	; 0x447e <__floatsisf+0x5e>
    4474:	66 23       	and	r22, r22
    4476:	71 f0       	breq	.+28     	; 0x4494 <__floatsisf+0x74>
    4478:	96 e8       	ldi	r25, 0x86	; 134
    447a:	86 2f       	mov	r24, r22
    447c:	70 e0       	ldi	r23, 0x00	; 0
    447e:	60 e0       	ldi	r22, 0x00	; 0
    4480:	2a f0       	brmi	.+10     	; 0x448c <__floatsisf+0x6c>
    4482:	9a 95       	dec	r25
    4484:	66 0f       	add	r22, r22
    4486:	77 1f       	adc	r23, r23
    4488:	88 1f       	adc	r24, r24
    448a:	da f7       	brpl	.-10     	; 0x4482 <__floatsisf+0x62>
    448c:	88 0f       	add	r24, r24
    448e:	96 95       	lsr	r25
    4490:	87 95       	ror	r24
    4492:	97 f9       	bld	r25, 7
    4494:	08 95       	ret

00004496 <__fp_cmp>:
    4496:	99 0f       	add	r25, r25
    4498:	00 08       	sbc	r0, r0
    449a:	55 0f       	add	r21, r21
    449c:	aa 0b       	sbc	r26, r26
    449e:	e0 e8       	ldi	r30, 0x80	; 128
    44a0:	fe ef       	ldi	r31, 0xFE	; 254
    44a2:	16 16       	cp	r1, r22
    44a4:	17 06       	cpc	r1, r23
    44a6:	e8 07       	cpc	r30, r24
    44a8:	f9 07       	cpc	r31, r25
    44aa:	c0 f0       	brcs	.+48     	; 0x44dc <__fp_cmp+0x46>
    44ac:	12 16       	cp	r1, r18
    44ae:	13 06       	cpc	r1, r19
    44b0:	e4 07       	cpc	r30, r20
    44b2:	f5 07       	cpc	r31, r21
    44b4:	98 f0       	brcs	.+38     	; 0x44dc <__fp_cmp+0x46>
    44b6:	62 1b       	sub	r22, r18
    44b8:	73 0b       	sbc	r23, r19
    44ba:	84 0b       	sbc	r24, r20
    44bc:	95 0b       	sbc	r25, r21
    44be:	39 f4       	brne	.+14     	; 0x44ce <__fp_cmp+0x38>
    44c0:	0a 26       	eor	r0, r26
    44c2:	61 f0       	breq	.+24     	; 0x44dc <__fp_cmp+0x46>
    44c4:	23 2b       	or	r18, r19
    44c6:	24 2b       	or	r18, r20
    44c8:	25 2b       	or	r18, r21
    44ca:	21 f4       	brne	.+8      	; 0x44d4 <__fp_cmp+0x3e>
    44cc:	08 95       	ret
    44ce:	0a 26       	eor	r0, r26
    44d0:	09 f4       	brne	.+2      	; 0x44d4 <__fp_cmp+0x3e>
    44d2:	a1 40       	sbci	r26, 0x01	; 1
    44d4:	a6 95       	lsr	r26
    44d6:	8f ef       	ldi	r24, 0xFF	; 255
    44d8:	81 1d       	adc	r24, r1
    44da:	81 1d       	adc	r24, r1
    44dc:	08 95       	ret

000044de <__gesf2>:
    44de:	0e 94 4b 22 	call	0x4496	; 0x4496 <__fp_cmp>
    44e2:	08 f4       	brcc	.+2      	; 0x44e6 <__gesf2+0x8>
    44e4:	8f ef       	ldi	r24, 0xFF	; 255
    44e6:	08 95       	ret

000044e8 <__mulsi3>:
    44e8:	db 01       	movw	r26, r22
    44ea:	8f 93       	push	r24
    44ec:	9f 93       	push	r25
    44ee:	0e 94 00 23 	call	0x4600	; 0x4600 <__muluhisi3>
    44f2:	bf 91       	pop	r27
    44f4:	af 91       	pop	r26
    44f6:	a2 9f       	mul	r26, r18
    44f8:	80 0d       	add	r24, r0
    44fa:	91 1d       	adc	r25, r1
    44fc:	a3 9f       	mul	r26, r19
    44fe:	90 0d       	add	r25, r0
    4500:	b2 9f       	mul	r27, r18
    4502:	90 0d       	add	r25, r0
    4504:	11 24       	eor	r1, r1
    4506:	08 95       	ret

00004508 <__divmodhi4>:
    4508:	97 fb       	bst	r25, 7
    450a:	07 2e       	mov	r0, r23
    450c:	16 f4       	brtc	.+4      	; 0x4512 <__divmodhi4+0xa>
    450e:	00 94       	com	r0
    4510:	07 d0       	rcall	.+14     	; 0x4520 <__divmodhi4_neg1>
    4512:	77 fd       	sbrc	r23, 7
    4514:	09 d0       	rcall	.+18     	; 0x4528 <__divmodhi4_neg2>
    4516:	0e 94 13 23 	call	0x4626	; 0x4626 <__udivmodhi4>
    451a:	07 fc       	sbrc	r0, 7
    451c:	05 d0       	rcall	.+10     	; 0x4528 <__divmodhi4_neg2>
    451e:	3e f4       	brtc	.+14     	; 0x452e <__divmodhi4_exit>

00004520 <__divmodhi4_neg1>:
    4520:	90 95       	com	r25
    4522:	81 95       	neg	r24
    4524:	9f 4f       	sbci	r25, 0xFF	; 255
    4526:	08 95       	ret

00004528 <__divmodhi4_neg2>:
    4528:	70 95       	com	r23
    452a:	61 95       	neg	r22
    452c:	7f 4f       	sbci	r23, 0xFF	; 255

0000452e <__divmodhi4_exit>:
    452e:	08 95       	ret

00004530 <__udivmodsi4>:
    4530:	a1 e2       	ldi	r26, 0x21	; 33
    4532:	1a 2e       	mov	r1, r26
    4534:	aa 1b       	sub	r26, r26
    4536:	bb 1b       	sub	r27, r27
    4538:	fd 01       	movw	r30, r26
    453a:	0d c0       	rjmp	.+26     	; 0x4556 <__udivmodsi4_ep>

0000453c <__udivmodsi4_loop>:
    453c:	aa 1f       	adc	r26, r26
    453e:	bb 1f       	adc	r27, r27
    4540:	ee 1f       	adc	r30, r30
    4542:	ff 1f       	adc	r31, r31
    4544:	a2 17       	cp	r26, r18
    4546:	b3 07       	cpc	r27, r19
    4548:	e4 07       	cpc	r30, r20
    454a:	f5 07       	cpc	r31, r21
    454c:	20 f0       	brcs	.+8      	; 0x4556 <__udivmodsi4_ep>
    454e:	a2 1b       	sub	r26, r18
    4550:	b3 0b       	sbc	r27, r19
    4552:	e4 0b       	sbc	r30, r20
    4554:	f5 0b       	sbc	r31, r21

00004556 <__udivmodsi4_ep>:
    4556:	66 1f       	adc	r22, r22
    4558:	77 1f       	adc	r23, r23
    455a:	88 1f       	adc	r24, r24
    455c:	99 1f       	adc	r25, r25
    455e:	1a 94       	dec	r1
    4560:	69 f7       	brne	.-38     	; 0x453c <__udivmodsi4_loop>
    4562:	60 95       	com	r22
    4564:	70 95       	com	r23
    4566:	80 95       	com	r24
    4568:	90 95       	com	r25
    456a:	9b 01       	movw	r18, r22
    456c:	ac 01       	movw	r20, r24
    456e:	bd 01       	movw	r22, r26
    4570:	cf 01       	movw	r24, r30
    4572:	08 95       	ret

00004574 <__divmodsi4>:
    4574:	05 2e       	mov	r0, r21
    4576:	97 fb       	bst	r25, 7
    4578:	1e f4       	brtc	.+6      	; 0x4580 <__divmodsi4+0xc>
    457a:	00 94       	com	r0
    457c:	0e 94 d1 22 	call	0x45a2	; 0x45a2 <__negsi2>
    4580:	57 fd       	sbrc	r21, 7
    4582:	07 d0       	rcall	.+14     	; 0x4592 <__divmodsi4_neg2>
    4584:	0e 94 98 22 	call	0x4530	; 0x4530 <__udivmodsi4>
    4588:	07 fc       	sbrc	r0, 7
    458a:	03 d0       	rcall	.+6      	; 0x4592 <__divmodsi4_neg2>
    458c:	4e f4       	brtc	.+18     	; 0x45a0 <__divmodsi4_exit>
    458e:	0c 94 d1 22 	jmp	0x45a2	; 0x45a2 <__negsi2>

00004592 <__divmodsi4_neg2>:
    4592:	50 95       	com	r21
    4594:	40 95       	com	r20
    4596:	30 95       	com	r19
    4598:	21 95       	neg	r18
    459a:	3f 4f       	sbci	r19, 0xFF	; 255
    459c:	4f 4f       	sbci	r20, 0xFF	; 255
    459e:	5f 4f       	sbci	r21, 0xFF	; 255

000045a0 <__divmodsi4_exit>:
    45a0:	08 95       	ret

000045a2 <__negsi2>:
    45a2:	90 95       	com	r25
    45a4:	80 95       	com	r24
    45a6:	70 95       	com	r23
    45a8:	61 95       	neg	r22
    45aa:	7f 4f       	sbci	r23, 0xFF	; 255
    45ac:	8f 4f       	sbci	r24, 0xFF	; 255
    45ae:	9f 4f       	sbci	r25, 0xFF	; 255
    45b0:	08 95       	ret

000045b2 <__tablejump2__>:
    45b2:	ee 0f       	add	r30, r30
    45b4:	ff 1f       	adc	r31, r31
    45b6:	88 1f       	adc	r24, r24
    45b8:	8b bf       	out	0x3b, r24	; 59
    45ba:	07 90       	elpm	r0, Z+
    45bc:	f6 91       	elpm	r31, Z
    45be:	e0 2d       	mov	r30, r0
    45c0:	1b be       	out	0x3b, r1	; 59
    45c2:	19 94       	eijmp

000045c4 <__mulhisi3>:
    45c4:	0e 94 ea 22 	call	0x45d4	; 0x45d4 <__umulhisi3>
    45c8:	33 23       	and	r19, r19
    45ca:	12 f4       	brpl	.+4      	; 0x45d0 <__mulhisi3+0xc>
    45cc:	8a 1b       	sub	r24, r26
    45ce:	9b 0b       	sbc	r25, r27
    45d0:	0c 94 fb 22 	jmp	0x45f6	; 0x45f6 <__usmulhisi3_tail>

000045d4 <__umulhisi3>:
    45d4:	a2 9f       	mul	r26, r18
    45d6:	b0 01       	movw	r22, r0
    45d8:	b3 9f       	mul	r27, r19
    45da:	c0 01       	movw	r24, r0
    45dc:	a3 9f       	mul	r26, r19
    45de:	70 0d       	add	r23, r0
    45e0:	81 1d       	adc	r24, r1
    45e2:	11 24       	eor	r1, r1
    45e4:	91 1d       	adc	r25, r1
    45e6:	b2 9f       	mul	r27, r18
    45e8:	70 0d       	add	r23, r0
    45ea:	81 1d       	adc	r24, r1
    45ec:	11 24       	eor	r1, r1
    45ee:	91 1d       	adc	r25, r1
    45f0:	08 95       	ret

000045f2 <__usmulhisi3>:
    45f2:	0e 94 ea 22 	call	0x45d4	; 0x45d4 <__umulhisi3>

000045f6 <__usmulhisi3_tail>:
    45f6:	b7 ff       	sbrs	r27, 7
    45f8:	08 95       	ret
    45fa:	82 1b       	sub	r24, r18
    45fc:	93 0b       	sbc	r25, r19
    45fe:	08 95       	ret

00004600 <__muluhisi3>:
    4600:	0e 94 ea 22 	call	0x45d4	; 0x45d4 <__umulhisi3>
    4604:	a5 9f       	mul	r26, r21
    4606:	90 0d       	add	r25, r0
    4608:	b4 9f       	mul	r27, r20
    460a:	90 0d       	add	r25, r0
    460c:	a4 9f       	mul	r26, r20
    460e:	80 0d       	add	r24, r0
    4610:	91 1d       	adc	r25, r1
    4612:	11 24       	eor	r1, r1
    4614:	08 95       	ret

00004616 <__mulshisi3>:
    4616:	b7 ff       	sbrs	r27, 7
    4618:	0c 94 00 23 	jmp	0x4600	; 0x4600 <__muluhisi3>

0000461c <__mulohisi3>:
    461c:	0e 94 00 23 	call	0x4600	; 0x4600 <__muluhisi3>
    4620:	82 1b       	sub	r24, r18
    4622:	93 0b       	sbc	r25, r19
    4624:	08 95       	ret

00004626 <__udivmodhi4>:
    4626:	aa 1b       	sub	r26, r26
    4628:	bb 1b       	sub	r27, r27
    462a:	51 e1       	ldi	r21, 0x11	; 17
    462c:	07 c0       	rjmp	.+14     	; 0x463c <__udivmodhi4_ep>

0000462e <__udivmodhi4_loop>:
    462e:	aa 1f       	adc	r26, r26
    4630:	bb 1f       	adc	r27, r27
    4632:	a6 17       	cp	r26, r22
    4634:	b7 07       	cpc	r27, r23
    4636:	10 f0       	brcs	.+4      	; 0x463c <__udivmodhi4_ep>
    4638:	a6 1b       	sub	r26, r22
    463a:	b7 0b       	sbc	r27, r23

0000463c <__udivmodhi4_ep>:
    463c:	88 1f       	adc	r24, r24
    463e:	99 1f       	adc	r25, r25
    4640:	5a 95       	dec	r21
    4642:	a9 f7       	brne	.-22     	; 0x462e <__udivmodhi4_loop>
    4644:	80 95       	com	r24
    4646:	90 95       	com	r25
    4648:	bc 01       	movw	r22, r24
    464a:	cd 01       	movw	r24, r26
    464c:	08 95       	ret

0000464e <memcpy>:
    464e:	fb 01       	movw	r30, r22
    4650:	dc 01       	movw	r26, r24
    4652:	02 c0       	rjmp	.+4      	; 0x4658 <memcpy+0xa>
    4654:	01 90       	ld	r0, Z+
    4656:	0d 92       	st	X+, r0
    4658:	41 50       	subi	r20, 0x01	; 1
    465a:	50 40       	sbci	r21, 0x00	; 0
    465c:	d8 f7       	brcc	.-10     	; 0x4654 <memcpy+0x6>
    465e:	08 95       	ret

00004660 <memset>:
    4660:	dc 01       	movw	r26, r24
    4662:	01 c0       	rjmp	.+2      	; 0x4666 <memset+0x6>
    4664:	6d 93       	st	X+, r22
    4666:	41 50       	subi	r20, 0x01	; 1
    4668:	50 40       	sbci	r21, 0x00	; 0
    466a:	e0 f7       	brcc	.-8      	; 0x4664 <memset+0x4>
    466c:	08 95       	ret

0000466e <strncpy>:
    466e:	fb 01       	movw	r30, r22
    4670:	dc 01       	movw	r26, r24
    4672:	41 50       	subi	r20, 0x01	; 1
    4674:	50 40       	sbci	r21, 0x00	; 0
    4676:	48 f0       	brcs	.+18     	; 0x468a <strncpy+0x1c>
    4678:	01 90       	ld	r0, Z+
    467a:	0d 92       	st	X+, r0
    467c:	00 20       	and	r0, r0
    467e:	c9 f7       	brne	.-14     	; 0x4672 <strncpy+0x4>
    4680:	01 c0       	rjmp	.+2      	; 0x4684 <strncpy+0x16>
    4682:	1d 92       	st	X+, r1
    4684:	41 50       	subi	r20, 0x01	; 1
    4686:	50 40       	sbci	r21, 0x00	; 0
    4688:	e0 f7       	brcc	.-8      	; 0x4682 <strncpy+0x14>
    468a:	08 95       	ret

0000468c <__itoa_ncheck>:
    468c:	bb 27       	eor	r27, r27
    468e:	4a 30       	cpi	r20, 0x0A	; 10
    4690:	31 f4       	brne	.+12     	; 0x469e <__itoa_ncheck+0x12>
    4692:	99 23       	and	r25, r25
    4694:	22 f4       	brpl	.+8      	; 0x469e <__itoa_ncheck+0x12>
    4696:	bd e2       	ldi	r27, 0x2D	; 45
    4698:	90 95       	com	r25
    469a:	81 95       	neg	r24
    469c:	9f 4f       	sbci	r25, 0xFF	; 255
    469e:	0c 94 8a 23 	jmp	0x4714	; 0x4714 <__utoa_common>

000046a2 <ultoa>:
    46a2:	25 32       	cpi	r18, 0x25	; 37
    46a4:	31 05       	cpc	r19, r1
    46a6:	20 f4       	brcc	.+8      	; 0x46b0 <ultoa+0xe>
    46a8:	22 30       	cpi	r18, 0x02	; 2
    46aa:	10 f0       	brcs	.+4      	; 0x46b0 <ultoa+0xe>
    46ac:	0c 94 5c 23 	jmp	0x46b8	; 0x46b8 <__ultoa_ncheck>
    46b0:	fa 01       	movw	r30, r20
    46b2:	10 82       	st	Z, r1
    46b4:	ca 01       	movw	r24, r20
    46b6:	08 95       	ret

000046b8 <__ultoa_ncheck>:
    46b8:	bb 27       	eor	r27, r27

000046ba <__ultoa_common>:
    46ba:	fa 01       	movw	r30, r20
    46bc:	a6 2f       	mov	r26, r22
    46be:	62 17       	cp	r22, r18
    46c0:	71 05       	cpc	r23, r1
    46c2:	81 05       	cpc	r24, r1
    46c4:	91 05       	cpc	r25, r1
    46c6:	33 0b       	sbc	r19, r19
    46c8:	30 fb       	bst	r19, 0
    46ca:	66 f0       	brts	.+24     	; 0x46e4 <__ultoa_common+0x2a>
    46cc:	aa 27       	eor	r26, r26
    46ce:	66 0f       	add	r22, r22
    46d0:	77 1f       	adc	r23, r23
    46d2:	88 1f       	adc	r24, r24
    46d4:	99 1f       	adc	r25, r25
    46d6:	aa 1f       	adc	r26, r26
    46d8:	a2 17       	cp	r26, r18
    46da:	10 f0       	brcs	.+4      	; 0x46e0 <__ultoa_common+0x26>
    46dc:	a2 1b       	sub	r26, r18
    46de:	63 95       	inc	r22
    46e0:	38 50       	subi	r19, 0x08	; 8
    46e2:	a9 f7       	brne	.-22     	; 0x46ce <__ultoa_common+0x14>
    46e4:	a0 5d       	subi	r26, 0xD0	; 208
    46e6:	aa 33       	cpi	r26, 0x3A	; 58
    46e8:	08 f0       	brcs	.+2      	; 0x46ec <__ultoa_common+0x32>
    46ea:	a9 5d       	subi	r26, 0xD9	; 217
    46ec:	a1 93       	st	Z+, r26
    46ee:	36 f7       	brtc	.-52     	; 0x46bc <__ultoa_common+0x2>
    46f0:	b1 11       	cpse	r27, r1
    46f2:	b1 93       	st	Z+, r27
    46f4:	10 82       	st	Z, r1
    46f6:	ca 01       	movw	r24, r20
    46f8:	0c 94 a3 23 	jmp	0x4746	; 0x4746 <strrev>

000046fc <utoa>:
    46fc:	45 32       	cpi	r20, 0x25	; 37
    46fe:	51 05       	cpc	r21, r1
    4700:	20 f4       	brcc	.+8      	; 0x470a <utoa+0xe>
    4702:	42 30       	cpi	r20, 0x02	; 2
    4704:	10 f0       	brcs	.+4      	; 0x470a <utoa+0xe>
    4706:	0c 94 89 23 	jmp	0x4712	; 0x4712 <__utoa_ncheck>
    470a:	fb 01       	movw	r30, r22
    470c:	10 82       	st	Z, r1
    470e:	cb 01       	movw	r24, r22
    4710:	08 95       	ret

00004712 <__utoa_ncheck>:
    4712:	bb 27       	eor	r27, r27

00004714 <__utoa_common>:
    4714:	fb 01       	movw	r30, r22
    4716:	55 27       	eor	r21, r21
    4718:	aa 27       	eor	r26, r26
    471a:	88 0f       	add	r24, r24
    471c:	99 1f       	adc	r25, r25
    471e:	aa 1f       	adc	r26, r26
    4720:	a4 17       	cp	r26, r20
    4722:	10 f0       	brcs	.+4      	; 0x4728 <__utoa_common+0x14>
    4724:	a4 1b       	sub	r26, r20
    4726:	83 95       	inc	r24
    4728:	50 51       	subi	r21, 0x10	; 16
    472a:	b9 f7       	brne	.-18     	; 0x471a <__utoa_common+0x6>
    472c:	a0 5d       	subi	r26, 0xD0	; 208
    472e:	aa 33       	cpi	r26, 0x3A	; 58
    4730:	08 f0       	brcs	.+2      	; 0x4734 <__utoa_common+0x20>
    4732:	a9 5d       	subi	r26, 0xD9	; 217
    4734:	a1 93       	st	Z+, r26
    4736:	00 97       	sbiw	r24, 0x00	; 0
    4738:	79 f7       	brne	.-34     	; 0x4718 <__utoa_common+0x4>
    473a:	b1 11       	cpse	r27, r1
    473c:	b1 93       	st	Z+, r27
    473e:	11 92       	st	Z+, r1
    4740:	cb 01       	movw	r24, r22
    4742:	0c 94 a3 23 	jmp	0x4746	; 0x4746 <strrev>

00004746 <strrev>:
    4746:	dc 01       	movw	r26, r24
    4748:	fc 01       	movw	r30, r24
    474a:	67 2f       	mov	r22, r23
    474c:	71 91       	ld	r23, Z+
    474e:	77 23       	and	r23, r23
    4750:	e1 f7       	brne	.-8      	; 0x474a <strrev+0x4>
    4752:	32 97       	sbiw	r30, 0x02	; 2
    4754:	04 c0       	rjmp	.+8      	; 0x475e <strrev+0x18>
    4756:	7c 91       	ld	r23, X
    4758:	6d 93       	st	X+, r22
    475a:	70 83       	st	Z, r23
    475c:	62 91       	ld	r22, -Z
    475e:	ae 17       	cp	r26, r30
    4760:	bf 07       	cpc	r27, r31
    4762:	c8 f3       	brcs	.-14     	; 0x4756 <strrev+0x10>
    4764:	08 95       	ret

00004766 <_exit>:
    4766:	f8 94       	cli

00004768 <__stop_program>:
    4768:	ff cf       	rjmp	.-2      	; 0x4768 <__stop_program>
