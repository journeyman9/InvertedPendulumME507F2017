
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000422a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000bc  00802000  0000422a  000042be  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a6  008020bc  008020bc  0000437a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000437a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000043ac  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006c0  00000000  00000000  000043ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00011f02  00000000  00000000  00004aac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006430  00000000  00000000  000169ae  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000532f  00000000  00000000  0001cdde  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001284  00000000  00000000  00022110  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000061bc  00000000  00000000  00023394  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005e25  00000000  00000000  00029550  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000578  00000000  00000000  0002f375  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a7 02 	jmp	0x54e	; 0x54e <__ctors_end>
       4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
       c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      10:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      14:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      18:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      1c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      20:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      24:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      28:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      2c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      30:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      34:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      38:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      3c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      40:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      44:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      48:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      4c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      50:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      54:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      58:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      5c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      60:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      64:	0c 94 de 1c 	jmp	0x39bc	; 0x39bc <__vector_25>
      68:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      6c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      70:	0c 94 3c 1d 	jmp	0x3a78	; 0x3a78 <__vector_28>
      74:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      78:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      7c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      80:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      84:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      88:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      8c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      90:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      94:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      98:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      9c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      c4:	0c 94 cf 0c 	jmp	0x199e	; 0x199e <__vector_49>
      c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      dc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      e8:	0c 94 56 1e 	jmp	0x3cac	; 0x3cac <__vector_58>
      ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
      fc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     100:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     104:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     108:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     10c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     110:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     114:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     118:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     11c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     120:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     124:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     128:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     12c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     130:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     134:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     138:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     13c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     140:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     144:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     148:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     14c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     150:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     154:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     158:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     15c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     160:	0c 94 9a 1d 	jmp	0x3b34	; 0x3b34 <__vector_88>
     164:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     168:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     16c:	0c 94 f8 1d 	jmp	0x3bf0	; 0x3bf0 <__vector_91>
     170:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     174:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     178:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     17c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     180:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     184:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     188:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     18c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     190:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     194:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     198:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     19c:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1a8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ac:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1b8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1bc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1c8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1cc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1d8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1dc:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1e8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1ec:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f0:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f4:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1f8:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <__bad_interrupt>
     1fc:	a1 1a       	sub	r10, r17
     1fe:	a4 1a       	sub	r10, r20
     200:	a7 1a       	sub	r10, r23
     202:	aa 1a       	sub	r10, r26
     204:	ad 1a       	sub	r10, r29
     206:	b0 1a       	sub	r11, r16
     208:	b2 1a       	sub	r11, r18
     20a:	c3 1a       	sub	r12, r19
     20c:	cb 1a       	sub	r12, r27
     20e:	d5 1a       	sub	r13, r21
     210:	d3 1a       	sub	r13, r19

00000212 <__trampolines_start>:
     212:	0c 94 4b 1a 	jmp	0x3496	; 0x3496 <_ZN8emstream12transmit_nowEv>
     216:	0c 94 a4 02 	jmp	0x548	; 0x548 <_call_static_run_method>
     21a:	0c 94 49 1a 	jmp	0x3492	; 0x3492 <_ZN8emstream14check_for_charEv>
     21e:	0c 94 44 1a 	jmp	0x3488	; 0x3488 <_ZN8emstream13ready_to_sendEv>
     222:	0c 94 b0 1a 	jmp	0x3560	; 0x3560 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     226:	0c 94 aa 1a 	jmp	0x3554	; 0x3554 <_ZN8emstreamlsE15ser_manipulator+0x30>
     22a:	0c 94 b2 1a 	jmp	0x3564	; 0x3564 <_ZN8emstreamlsE15ser_manipulator+0x40>
     22e:	0c 94 58 1f 	jmp	0x3eb0	; 0x3eb0 <_GLOBAL__sub_I_counter>
     232:	0c 94 c6 03 	jmp	0x78c	; 0x78c <_ZN13LimitSwitches3runEv>
     236:	0c 94 f5 17 	jmp	0x2fea	; 0x2fea <_ZN14frt_text_queue7putcharEc>
     23a:	0c 94 53 0f 	jmp	0x1ea6	; 0x1ea6 <prvIdleTask>
     23e:	0c 94 ad 19 	jmp	0x335a	; 0x335a <__cxa_pure_virtual>
     242:	0c 94 ad 1a 	jmp	0x355a	; 0x355a <_ZN8emstreamlsE15ser_manipulator+0x36>
     246:	0c 94 d5 1a 	jmp	0x35aa	; 0x35aa <_ZN8emstreamlsE15ser_manipulator+0x86>
     24a:	0c 94 1c 1c 	jmp	0x3838	; 0x3838 <_ZN5rs2327getcharEv>
     24e:	0c 94 6d 03 	jmp	0x6da	; 0x6da <_ZN15EncoderPendulum3runEv>
     252:	0c 94 a1 1a 	jmp	0x3542	; 0x3542 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     256:	0c 94 82 16 	jmp	0x2d04	; 0x2d04 <_ZN8frt_task12print_statusER8emstream>
     25a:	0c 94 d3 1a 	jmp	0x35a6	; 0x35a6 <_ZN8emstreamlsE15ser_manipulator+0x82>
     25e:	0c 94 55 1c 	jmp	0x38aa	; 0x38aa <_ZN5rs23212clear_screenEv>
     262:	0c 94 cc 17 	jmp	0x2f98	; 0x2f98 <_ZN14frt_text_queue7getcharEv>
     266:	0c 94 cb 1a 	jmp	0x3596	; 0x3596 <_ZN8emstreamlsE15ser_manipulator+0x72>
     26a:	0c 94 ab 08 	jmp	0x1156	; 0x1156 <_ZN9task_user3runEv>
     26e:	0c 94 ea 17 	jmp	0x2fd4	; 0x2fd4 <_ZN14frt_text_queue14check_for_charEv>
     272:	0c 94 df 02 	jmp	0x5be	; 0x5be <_ZN12EncoderMotor3runEv>
     276:	0c 94 42 1c 	jmp	0x3884	; 0x3884 <_ZN5rs23214check_for_charEv>
     27a:	0c 94 a7 1a 	jmp	0x354e	; 0x354e <_ZN8emstreamlsE15ser_manipulator+0x2a>
     27e:	0c 94 a4 1a 	jmp	0x3548	; 0x3548 <_ZN8emstreamlsE15ser_manipulator+0x24>
     282:	0c 94 46 1a 	jmp	0x348c	; 0x348c <_ZN8emstream7getcharEv>
     286:	0c 94 2b 04 	jmp	0x856	; 0x856 <_ZN5Motor3runEv>
     28a:	0c 94 c3 1a 	jmp	0x3586	; 0x3586 <_ZN8emstreamlsE15ser_manipulator+0x62>
     28e:	0c 94 f8 1b 	jmp	0x37f0	; 0x37f0 <_ZN5rs2327putcharEc>
     292:	0c 94 4c 1a 	jmp	0x3498	; 0x3498 <_ZN8emstream12clear_screenEv>

00000296 <__trampolines_end>:
     296:	2c 20       	and	r2, r12
     298:	54 43       	sbci	r21, 0x34	; 52
     29a:	43 30       	cpi	r20, 0x03	; 3
     29c:	43 43       	sbci	r20, 0x33	; 51
     29e:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a1 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a1:	2f 00                                               /.

000002a3 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a3:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b1 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b1:	54 69 6d 65 3a 20 00                                Time: .

000002b8 <_ZZN9task_user11show_statusEvE3__c_0>:
     2b8:	44 65 63 20 20 36 20 32 30 31 37 00                 Dec  6 2017.

000002c4 <_ZZN9task_user11show_statusEvE3__c>:
     2c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e3 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e3:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f2 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f2:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     302:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000030d <_ZZN9task_user18print_help_messageEvE3__c_8>:
     30d:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     31d:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032b <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32b:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33b:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34b:	6d 61 74 69 6f 6e 00                                mation.

00000352 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     352:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     362:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000373 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     373:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     383:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038b <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38b:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39b:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003a7 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3a7:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3b7:	68 65 20 41 56 52 00                                he AVR.

000003be <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3be:	20 68 65 6c 70 00                                    help.

000003c4 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e3 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e3:	1b 5b 33 30 6d 00                                   .[30m.

000003e9 <_ZZN9task_user18print_help_messageEvE3__c>:
     3e9:	1b 5b 34 36 6d 00                                   .[46m.

000003ef <_ZZN9task_user3runEvE3__c_3>:
     3ef:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     3ff:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000040c <_ZZN9task_user3runEvE3__c_2>:
     40c:	3a 57 54 46 3f 00                                   :WTF?.

00000412 <_ZZN9task_user3runEvE3__c_1>:
     412:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     422:	65 00                                               e.

00000424 <_ZZN9task_user3runEvE3__c_0>:
     424:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000432 <_ZZN9task_user3runEvE3__c>:
     432:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     442:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000450 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     450:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045a <_ZZN8frt_task15emergency_resetEvE3__c>:
     45a:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000469 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     469:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     479:	61 73 6b 20 00                                      ask .

0000047e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     47e:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

0000048c <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     48c:	20 63 72 65 61 74 65 64 00                           created.

00000495 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     495:	54 61 73 6b 20 00                                   Task .

0000049b <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49b:	1b 5b 32 32 6d 00                                   .[22m.

000004a1 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a1:	54 61 73 6b 3a 20 00                                Task: .

000004a8 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4a8:	1b 5b 31 6d 00                                      .[1m.

000004ad <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4ad:	1b 5b 32 32 6d 00                                   .[22m.

000004b3 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b3:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004be <_ZZ17print_task_stacksP8emstreamE3__c>:
     4be:	1b 5b 31 6d 00                                      .[1m.

000004c3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c3:	09 09 00                                            ...

000004c6 <_ZZ15print_task_listP8emstreamE3__c_8>:
     4c6:	2f 00                                               /.

000004c8 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4c8:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d3 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d3:	09 2d 2d 2d 2d 00                                   .----.

000004d9 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4d9:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e5 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e5:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004f6 <_ZZ15print_task_listP8emstreamE3__c_3>:
     4f6:	09 52 75 6e 73 00                                   .Runs.

000004fc <_ZZ15print_task_listP8emstreamE3__c_2>:
     4fc:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000508 <_ZZ15print_task_listP8emstreamE3__c_1>:
     508:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000519 <_ZZ15print_task_listP8emstreamE3__c_0>:
     519:	09 53 74 61 63 6b 00                                .Stack.

00000520 <_ZZ15print_task_listP8emstreamE3__c>:
     520:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052b <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52b:	09 00                                               ..

0000052d <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     52d:	09 00                                               ..

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     52f:	2f 00                                               /.

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     533:	09 00                                               ..

00000535 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     535:	1b 5b 32 32 6d 00                                   .[22m.

0000053b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53b:	1b 5b 31 6d 00                                      .[1m.

00000540 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     540:	1b 5b 31 6d 00                                      .[1m.

00000545 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     545:	20 20 00                                              .

00000548 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     548:	0e 94 1a 15 	call	0x2a34	; 0x2a34 <_ZN8frt_task22_call_users_run_methodEPS_>

0000054c <__ctors_start>:
     54c:	58 1f       	adc	r21, r24

0000054e <__ctors_end>:
     54e:	11 24       	eor	r1, r1
     550:	1f be       	out	0x3f, r1	; 63
     552:	cf ef       	ldi	r28, 0xFF	; 255
     554:	cd bf       	out	0x3d, r28	; 61
     556:	df e3       	ldi	r29, 0x3F	; 63
     558:	de bf       	out	0x3e, r29	; 62
     55a:	00 e0       	ldi	r16, 0x00	; 0
     55c:	0c bf       	out	0x3c, r16	; 60
     55e:	18 be       	out	0x38, r1	; 56
     560:	19 be       	out	0x39, r1	; 57
     562:	1a be       	out	0x3a, r1	; 58
     564:	1b be       	out	0x3b, r1	; 59

00000566 <__do_copy_data>:
     566:	10 e2       	ldi	r17, 0x20	; 32
     568:	a0 e0       	ldi	r26, 0x00	; 0
     56a:	b0 e2       	ldi	r27, 0x20	; 32
     56c:	ea e2       	ldi	r30, 0x2A	; 42
     56e:	f2 e4       	ldi	r31, 0x42	; 66
     570:	00 e0       	ldi	r16, 0x00	; 0
     572:	0b bf       	out	0x3b, r16	; 59
     574:	02 c0       	rjmp	.+4      	; 0x57a <__do_copy_data+0x14>
     576:	07 90       	elpm	r0, Z+
     578:	0d 92       	st	X+, r0
     57a:	ac 3b       	cpi	r26, 0xBC	; 188
     57c:	b1 07       	cpc	r27, r17
     57e:	d9 f7       	brne	.-10     	; 0x576 <__do_copy_data+0x10>
     580:	1b be       	out	0x3b, r1	; 59

00000582 <__do_clear_bss>:
     582:	21 e3       	ldi	r18, 0x31	; 49
     584:	ac eb       	ldi	r26, 0xBC	; 188
     586:	b0 e2       	ldi	r27, 0x20	; 32
     588:	01 c0       	rjmp	.+2      	; 0x58c <.do_clear_bss_start>

0000058a <.do_clear_bss_loop>:
     58a:	1d 92       	st	X+, r1

0000058c <.do_clear_bss_start>:
     58c:	a2 36       	cpi	r26, 0x62	; 98
     58e:	b2 07       	cpc	r27, r18
     590:	e1 f7       	brne	.-8      	; 0x58a <.do_clear_bss_loop>

00000592 <__do_global_ctors>:
     592:	12 e0       	ldi	r17, 0x02	; 2
     594:	c7 ea       	ldi	r28, 0xA7	; 167
     596:	d2 e0       	ldi	r29, 0x02	; 2
     598:	00 e0       	ldi	r16, 0x00	; 0
     59a:	06 c0       	rjmp	.+12     	; 0x5a8 <__do_global_ctors+0x16>
     59c:	21 97       	sbiw	r28, 0x01	; 1
     59e:	01 09       	sbc	r16, r1
     5a0:	80 2f       	mov	r24, r16
     5a2:	fe 01       	movw	r30, r28
     5a4:	0e 94 39 20 	call	0x4072	; 0x4072 <__tablejump2__>
     5a8:	c6 3a       	cpi	r28, 0xA6	; 166
     5aa:	d1 07       	cpc	r29, r17
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	08 07       	cpc	r16, r24
     5b0:	a9 f7       	brne	.-22     	; 0x59c <__do_global_ctors+0xa>
     5b2:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <main>
     5b6:	0c 94 13 21 	jmp	0x4226	; 0x4226 <_exit>

000005ba <__bad_interrupt>:
     5ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005be <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
     5c2:	00 d0       	rcall	.+0      	; 0x5c4 <_ZN12EncoderMotor3runEv+0x6>
     5c4:	1f 92       	push	r1
     5c6:	cd b7       	in	r28, 0x3d	; 61
     5c8:	de b7       	in	r29, 0x3e	; 62
     5ca:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5cc:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <xTaskGetTickCount>
     5d0:	69 83       	std	Y+1, r22	; 0x01
     5d2:	7a 83       	std	Y+2, r23	; 0x02
     5d4:	8b 83       	std	Y+3, r24	; 0x03
     5d6:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     5d8:	e0 e8       	ldi	r30, 0x80	; 128
     5da:	f6 e0       	ldi	r31, 0x06	; 6
     5dc:	8c e0       	ldi	r24, 0x0C	; 12
     5de:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e0:	82 89       	ldd	r24, Z+18	; 0x12
     5e2:	83 60       	ori	r24, 0x03	; 3
     5e4:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5e6:	83 89       	ldd	r24, Z+19	; 0x13
     5e8:	83 60       	ori	r24, 0x03	; 3
     5ea:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     5ec:	e0 e8       	ldi	r30, 0x80	; 128
     5ee:	f1 e0       	ldi	r31, 0x01	; 1
     5f0:	82 e7       	ldi	r24, 0x72	; 114
     5f2:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f4:	89 e0       	ldi	r24, 0x09	; 9
     5f6:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5f8:	e0 e0       	ldi	r30, 0x00	; 0
     5fa:	f9 e0       	ldi	r31, 0x09	; 9
     5fc:	88 e6       	ldi	r24, 0x68	; 104
     5fe:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     600:	8f ef       	ldi	r24, 0xFF	; 255
     602:	9f ef       	ldi	r25, 0xFF	; 255
     604:	86 a3       	std	Z+38, r24	; 0x26
     606:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     608:	81 e0       	ldi	r24, 0x01	; 1
     60a:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     60c:	0f 2e       	mov	r0, r31
     60e:	a1 2c       	mov	r10, r1
     610:	f9 e0       	ldi	r31, 0x09	; 9
     612:	bf 2e       	mov	r11, r31
     614:	f0 2d       	mov	r31, r0
     616:	f5 01       	movw	r30, r10
     618:	00 a1       	ldd	r16, Z+32	; 0x20
     61a:	11 a1       	ldd	r17, Z+33	; 0x21
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     61c:	0f b6       	in	r0, 0x3f	; 63
     61e:	f8 94       	cli
     620:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     622:	0f 90       	pop	r0
     624:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     626:	0f b6       	in	r0, 0x3f	; 63
     628:	f8 94       	cli
     62a:	0f 92       	push	r0
			the_data = new_data;
     62c:	c8 01       	movw	r24, r16
     62e:	01 2e       	mov	r0, r17
     630:	00 0c       	add	r0, r0
     632:	aa 0b       	sbc	r26, r26
     634:	bb 0b       	sbc	r27, r27
     636:	ac 01       	movw	r20, r24
     638:	bd 01       	movw	r22, r26
     63a:	44 0f       	add	r20, r20
     63c:	55 1f       	adc	r21, r21
     63e:	66 1f       	adc	r22, r22
     640:	77 1f       	adc	r23, r23
     642:	3a 01       	movw	r6, r20
     644:	4b 01       	movw	r8, r22
     646:	68 0e       	add	r6, r24
     648:	79 1e       	adc	r7, r25
     64a:	8a 1e       	adc	r8, r26
     64c:	9b 1e       	adc	r9, r27
     64e:	c4 01       	movw	r24, r8
     650:	b3 01       	movw	r22, r6
     652:	24 e6       	ldi	r18, 0x64	; 100
     654:	30 e0       	ldi	r19, 0x00	; 0
     656:	40 e0       	ldi	r20, 0x00	; 0
     658:	50 e0       	ldi	r21, 0x00	; 0
     65a:	0e 94 1a 20 	call	0x4034	; 0x4034 <__divmodsi4>
     65e:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <linear_offset>
     662:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <linear_offset+0x1>
     666:	28 1b       	sub	r18, r24
     668:	39 0b       	sbc	r19, r25
     66a:	20 93 4e 31 	sts	0x314E, r18	; 0x80314e <linear_position>
     66e:	30 93 4f 31 	sts	0x314F, r19	; 0x80314f <linear_position+0x1>
			portEXIT_CRITICAL ();
     672:	0f 90       	pop	r0
     674:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     676:	0f b6       	in	r0, 0x3f	; 63
     678:	f8 94       	cli
     67a:	0f 92       	push	r0
			the_data = new_data;
     67c:	c8 01       	movw	r24, r16
     67e:	8c 19       	sub	r24, r12
     680:	9d 09       	sbc	r25, r13
     682:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <thdMotor>
     686:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <thdMotor+0x1>
			portEXIT_CRITICAL ();
     68a:	0f 90       	pop	r0
     68c:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     68e:	f7 01       	movw	r30, r14
     690:	86 85       	ldd	r24, Z+14	; 0x0e
     692:	97 85       	ldd	r25, Z+15	; 0x0f
     694:	a0 89       	ldd	r26, Z+16	; 0x10
     696:	b1 89       	ldd	r27, Z+17	; 0x11
     698:	01 96       	adiw	r24, 0x01	; 1
     69a:	a1 1d       	adc	r26, r1
     69c:	b1 1d       	adc	r27, r1
     69e:	86 87       	std	Z+14, r24	; 0x0e
     6a0:	97 87       	std	Z+15, r25	; 0x0f
     6a2:	a0 8b       	std	Z+16, r26	; 0x10
     6a4:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     6a6:	41 e0       	ldi	r20, 0x01	; 1
     6a8:	50 e0       	ldi	r21, 0x00	; 0
     6aa:	60 e0       	ldi	r22, 0x00	; 0
     6ac:	70 e0       	ldi	r23, 0x00	; 0
     6ae:	ce 01       	movw	r24, r28
     6b0:	01 96       	adiw	r24, 0x01	; 1
     6b2:	0e 94 90 12 	call	0x2520	; 0x2520 <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     6b6:	68 01       	movw	r12, r16
     6b8:	ae cf       	rjmp	.-164    	; 0x616 <_ZN12EncoderMotor3runEv+0x58>

000006ba <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     6ba:	0f 93       	push	r16
     6bc:	1f 93       	push	r17
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
     6c2:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     6c4:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <_ZN8frt_taskC1EPKchjP8emstream>
     6c8:	8a e0       	ldi	r24, 0x0A	; 10
     6ca:	90 e2       	ldi	r25, 0x20	; 32
     6cc:	88 83       	st	Y, r24
     6ce:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     6d0:	df 91       	pop	r29
     6d2:	cf 91       	pop	r28
     6d4:	1f 91       	pop	r17
     6d6:	0f 91       	pop	r16
     6d8:	08 95       	ret

000006da <_ZN15EncoderPendulum3runEv>:
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void)
{
     6da:	cf 93       	push	r28
     6dc:	df 93       	push	r29
     6de:	00 d0       	rcall	.+0      	; 0x6e0 <_ZN15EncoderPendulum3runEv+0x6>
     6e0:	1f 92       	push	r1
     6e2:	cd b7       	in	r28, 0x3d	; 61
     6e4:	de b7       	in	r29, 0x3e	; 62
     6e6:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     6e8:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <xTaskGetTickCount>
     6ec:	69 83       	std	Y+1, r22	; 0x01
     6ee:	7a 83       	std	Y+2, r23	; 0x02
     6f0:	8b 83       	std	Y+3, r24	; 0x03
     6f2:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     6f4:	e0 e8       	ldi	r30, 0x80	; 128
     6f6:	f6 e0       	ldi	r31, 0x06	; 6
     6f8:	83 e0       	ldi	r24, 0x03	; 3
     6fa:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     6fc:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     6fe:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     700:	e0 e8       	ldi	r30, 0x80	; 128
     702:	f1 e0       	ldi	r31, 0x01	; 1
     704:	80 e7       	ldi	r24, 0x70	; 112
     706:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     708:	89 e0       	ldi	r24, 0x09	; 9
     70a:	82 87       	std	Z+10, r24	; 0x0a
	
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     70c:	e0 e4       	ldi	r30, 0x40	; 64
     70e:	f8 e0       	ldi	r31, 0x08	; 8
     710:	8a e6       	ldi	r24, 0x6A	; 106
     712:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     714:	80 ea       	ldi	r24, 0xA0	; 160
     716:	95 e0       	ldi	r25, 0x05	; 5
     718:	86 a3       	std	Z+38, r24	; 0x26
     71a:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     71c:	81 e0       	ldi	r24, 0x01	; 1
     71e:	80 83       	st	Z, r24
	
	int16_t count; // contains the current encoder value
	
	while(1)
	{
		count = TCC1.CNT; // read value from hardware counter
     720:	68 94       	set
     722:	ee 24       	eor	r14, r14
     724:	e6 f8       	bld	r14, 6
     726:	ff 24       	eor	r15, r15
     728:	f3 f8       	bld	r15, 3
     72a:	f7 01       	movw	r30, r14
     72c:	80 a1       	ldd	r24, Z+32	; 0x20
     72e:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     730:	0f b6       	in	r0, 0x3f	; 63
     732:	f8 94       	cli
     734:	0f 92       	push	r0
			the_data = new_data;
     736:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <thPendulum>
     73a:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <thPendulum+0x1>
			portEXIT_CRITICAL ();
     73e:	0f 90       	pop	r0
     740:	0f be       	out	0x3f, r0	; 63
		//theta_pendulum = ( (int32_t) count*100/4);			// count/(4*360)*360 degrees * 100
		
		thPendulum.put(count); // push angular position [ticks] to pendulum controller task
		
		// Increment counter for debugging
		runs++;
     742:	f8 01       	movw	r30, r16
     744:	86 85       	ldd	r24, Z+14	; 0x0e
     746:	97 85       	ldd	r25, Z+15	; 0x0f
     748:	a0 89       	ldd	r26, Z+16	; 0x10
     74a:	b1 89       	ldd	r27, Z+17	; 0x11
     74c:	01 96       	adiw	r24, 0x01	; 1
     74e:	a1 1d       	adc	r26, r1
     750:	b1 1d       	adc	r27, r1
     752:	86 87       	std	Z+14, r24	; 0x0e
     754:	97 87       	std	Z+15, r25	; 0x0f
     756:	a0 8b       	std	Z+16, r26	; 0x10
     758:	b1 8b       	std	Z+17, r27	; 0x11
     75a:	41 e0       	ldi	r20, 0x01	; 1
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	60 e0       	ldi	r22, 0x00	; 0
     760:	70 e0       	ldi	r23, 0x00	; 0
     762:	ce 01       	movw	r24, r28
     764:	01 96       	adiw	r24, 0x01	; 1
     766:	0e 94 90 12 	call	0x2520	; 0x2520 <vTaskDelayUntil>
     76a:	df cf       	rjmp	.-66     	; 0x72a <_ZN15EncoderPendulum3runEv+0x50>

0000076c <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     76c:	0f 93       	push	r16
     76e:	1f 93       	push	r17
     770:	cf 93       	push	r28
     772:	df 93       	push	r29
     774:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     776:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <_ZN8frt_taskC1EPKchjP8emstream>
     77a:	82 e1       	ldi	r24, 0x12	; 18
     77c:	90 e2       	ldi	r25, 0x20	; 32
     77e:	88 83       	st	Y, r24
     780:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     782:	df 91       	pop	r29
     784:	cf 91       	pop	r28
     786:	1f 91       	pop	r17
     788:	0f 91       	pop	r16
     78a:	08 95       	ret

0000078c <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     78c:	cf 93       	push	r28
     78e:	df 93       	push	r29
     790:	00 d0       	rcall	.+0      	; 0x792 <_ZN13LimitSwitches3runEv+0x6>
     792:	1f 92       	push	r1
     794:	cd b7       	in	r28, 0x3d	; 61
     796:	de b7       	in	r29, 0x3e	; 62
     798:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     79a:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <xTaskGetTickCount>
     79e:	69 83       	std	Y+1, r22	; 0x01
     7a0:	7a 83       	std	Y+2, r23	; 0x02
     7a2:	8b 83       	std	Y+3, r24	; 0x03
     7a4:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     7a6:	e0 e6       	ldi	r30, 0x60	; 96
     7a8:	f6 e0       	ldi	r31, 0x06	; 6
     7aa:	81 e0       	ldi	r24, 0x01	; 1
     7ac:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     7ae:	84 e0       	ldi	r24, 0x04	; 4
     7b0:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     7b2:	88 e1       	ldi	r24, 0x18	; 24
     7b4:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     7b6:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     7b8:	08 e6       	ldi	r16, 0x68	; 104
     7ba:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     7bc:	dd 24       	eor	r13, r13
     7be:	d3 94       	inc	r13
     7c0:	f8 01       	movw	r30, r16
     7c2:	80 81       	ld	r24, Z
     7c4:	80 fd       	sbrc	r24, 0
     7c6:	08 c0       	rjmp	.+16     	; 0x7d8 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7c8:	0f b6       	in	r0, 0x3f	; 63
     7ca:	f8 94       	cli
     7cc:	0f 92       	push	r0
			the_data = new_data;
     7ce:	d0 92 49 31 	sts	0x3149, r13	; 0x803149 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7d2:	0f 90       	pop	r0
     7d4:	0f be       	out	0x3f, r0	; 63
     7d6:	07 c0       	rjmp	.+14     	; 0x7e6 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7d8:	0f b6       	in	r0, 0x3f	; 63
     7da:	f8 94       	cli
     7dc:	0f 92       	push	r0
			the_data = new_data;
     7de:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7e2:	0f 90       	pop	r0
     7e4:	0f be       	out	0x3f, r0	; 63
			leftLimitSwitch.put(leftLimit);

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     7e6:	f8 01       	movw	r30, r16
     7e8:	80 81       	ld	r24, Z
     7ea:	82 fd       	sbrc	r24, 2
     7ec:	08 c0       	rjmp	.+16     	; 0x7fe <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7ee:	0f b6       	in	r0, 0x3f	; 63
     7f0:	f8 94       	cli
     7f2:	0f 92       	push	r0
			the_data = new_data;
     7f4:	d0 92 48 31 	sts	0x3148, r13	; 0x803148 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     7f8:	0f 90       	pop	r0
     7fa:	0f be       	out	0x3f, r0	; 63
     7fc:	07 c0       	rjmp	.+14     	; 0x80c <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7fe:	0f b6       	in	r0, 0x3f	; 63
     800:	f8 94       	cli
     802:	0f 92       	push	r0
			the_data = new_data;
     804:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     808:	0f 90       	pop	r0
     80a:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     80c:	f7 01       	movw	r30, r14
     80e:	86 85       	ldd	r24, Z+14	; 0x0e
     810:	97 85       	ldd	r25, Z+15	; 0x0f
     812:	a0 89       	ldd	r26, Z+16	; 0x10
     814:	b1 89       	ldd	r27, Z+17	; 0x11
     816:	01 96       	adiw	r24, 0x01	; 1
     818:	a1 1d       	adc	r26, r1
     81a:	b1 1d       	adc	r27, r1
     81c:	86 87       	std	Z+14, r24	; 0x0e
     81e:	97 87       	std	Z+15, r25	; 0x0f
     820:	a0 8b       	std	Z+16, r26	; 0x10
     822:	b1 8b       	std	Z+17, r27	; 0x11
     824:	41 e0       	ldi	r20, 0x01	; 1
     826:	50 e0       	ldi	r21, 0x00	; 0
     828:	60 e0       	ldi	r22, 0x00	; 0
     82a:	70 e0       	ldi	r23, 0x00	; 0
     82c:	ce 01       	movw	r24, r28
     82e:	01 96       	adiw	r24, 0x01	; 1
     830:	0e 94 90 12 	call	0x2520	; 0x2520 <vTaskDelayUntil>
     834:	c5 cf       	rjmp	.-118    	; 0x7c0 <_ZN13LimitSwitches3runEv+0x34>

00000836 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     836:	0f 93       	push	r16
     838:	1f 93       	push	r17
     83a:	cf 93       	push	r28
     83c:	df 93       	push	r29
     83e:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     840:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <_ZN8frt_taskC1EPKchjP8emstream>
     844:	8a e1       	ldi	r24, 0x1A	; 26
     846:	90 e2       	ldi	r25, 0x20	; 32
     848:	88 83       	st	Y, r24
     84a:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     84c:	df 91       	pop	r29
     84e:	cf 91       	pop	r28
     850:	1f 91       	pop	r17
     852:	0f 91       	pop	r16
     854:	08 95       	ret

00000856 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     856:	cf 93       	push	r28
     858:	df 93       	push	r29
     85a:	cd b7       	in	r28, 0x3d	; 61
     85c:	de b7       	in	r29, 0x3e	; 62
     85e:	6c 97       	sbiw	r28, 0x1c	; 28
     860:	cd bf       	out	0x3d, r28	; 61
     862:	de bf       	out	0x3e, r29	; 62
     864:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     866:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <xTaskGetTickCount>
     86a:	69 83       	std	Y+1, r22	; 0x01
     86c:	7a 83       	std	Y+2, r23	; 0x02
     86e:	8b 83       	std	Y+3, r24	; 0x03
     870:	9c 83       	std	Y+4, r25	; 0x04

	dt = 1; // [ms]
     872:	f8 01       	movw	r30, r16
     874:	fe 96       	adiw	r30, 0x3e	; 62
     876:	81 e0       	ldi	r24, 0x01	; 1
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	a0 e0       	ldi	r26, 0x00	; 0
     87c:	b0 e0       	ldi	r27, 0x00	; 0
     87e:	80 83       	st	Z, r24
     880:	91 83       	std	Z+1, r25	; 0x01
     882:	a2 83       	std	Z+2, r26	; 0x02
     884:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     886:	d8 01       	movw	r26, r16
     888:	dc 96       	adiw	r26, 0x3c	; 60
     88a:	8d 93       	st	X+, r24
     88c:	9c 93       	st	X, r25
     88e:	dd 97       	sbiw	r26, 0x3d	; 61
	
	// Initialize PWM 
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     890:	a0 e4       	ldi	r26, 0x40	; 64
     892:	b6 e0       	ldi	r27, 0x06	; 6
     894:	87 e0       	ldi	r24, 0x07	; 7
     896:	11 96       	adiw	r26, 0x01	; 1
     898:	8c 93       	st	X, r24
     89a:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     89c:	84 e0       	ldi	r24, 0x04	; 4
     89e:	15 96       	adiw	r26, 0x05	; 5
     8a0:	8c 93       	st	X, r24
     8a2:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     8a4:	e0 e0       	ldi	r30, 0x00	; 0
     8a6:	f8 e0       	ldi	r31, 0x08	; 8
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     8ac:	83 e0       	ldi	r24, 0x03	; 3
     8ae:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     8b0:	a6 a3       	std	Z+38, r26	; 0x26
     8b2:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     8b4:	10 a6       	std	Z+40, r1	; 0x28
     8b6:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     8b8:	12 a6       	std	Z+42, r1	; 0x2a
     8ba:	13 a6       	std	Z+43, r1	; 0x2b
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     8bc:	81 81       	ldd	r24, Z+1	; 0x01
     8be:	80 63       	ori	r24, 0x30	; 48
     8c0:	81 83       	std	Z+1, r24	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     8c2:	0f b6       	in	r0, 0x3f	; 63
     8c4:	f8 94       	cli
     8c6:	0f 92       	push	r0
			the_data = new_data;
     8c8:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <linear_offset>
     8cc:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <linear_offset+0x1>
			portEXIT_CRITICAL ();
     8d0:	0f 90       	pop	r0
     8d2:	0f be       	out	0x3f, r0	; 63
	linear_offset.put(0);								// Initialize motor offset	
	int16_t left_home;									// Initialize left distance to calculate center
	int16_t position_set;								// Setpoint of cart's position
	int16_t KP_pos = 100;								// P gain for cart position				
	int16_t position_error = 0;							// positional error	
	int16_t position_midpoint = 0;						// midpoint calculated from homing sequence
     8d4:	1b 8e       	std	Y+27, r1	; 0x1b
     8d6:	1c 8e       	std	Y+28, r1	; 0x1c
				omegam_set = -10;	// [ticks/ms]
			
				if (leftLimitSwitch.get())
				{
					left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     8d8:	58 01       	movw	r10, r16
     8da:	b0 e5       	ldi	r27, 0x50	; 80
     8dc:	ab 0e       	add	r10, r27
     8de:	b1 1c       	adc	r11, r1
					output_correct = 0;
     8e0:	68 01       	movw	r12, r16
     8e2:	ee e5       	ldi	r30, 0x5E	; 94
     8e4:	ce 0e       	add	r12, r30
     8e6:	d1 1c       	adc	r13, r1
		switch (state)
		{
			// Home right
			case(0) :
				//*p_serial << "Start Calibration Sequence? [Y/N]" << endl;
				omegam_set = 10;	// [ticks/ms]
     8e8:	0f 2e       	mov	r0, r31
     8ea:	fa e0       	ldi	r31, 0x0A	; 10
     8ec:	2f 2e       	mov	r2, r31
     8ee:	31 2c       	mov	r3, r1
     8f0:	f0 2d       	mov	r31, r0
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     8f2:	98 01       	movw	r18, r16
     8f4:	28 5b       	subi	r18, 0xB8	; 184
     8f6:	3f 4f       	sbci	r19, 0xFF	; 255
     8f8:	29 8b       	std	Y+17, r18	; 0x11
     8fa:	3a 8b       	std	Y+18, r19	; 0x12
		_Ki = .7*256;
     8fc:	c8 01       	movw	r24, r16
     8fe:	84 5b       	subi	r24, 0xB4	; 180
     900:	9f 4f       	sbci	r25, 0xFF	; 255
     902:	8d 83       	std	Y+5, r24	; 0x05
     904:	9e 83       	std	Y+6, r25	; 0x06
		_Kd = 0;
     906:	d8 01       	movw	r26, r16
     908:	a6 5b       	subi	r26, 0xB6	; 182
     90a:	bf 4f       	sbci	r27, 0xFF	; 255
     90c:	ab 8b       	std	Y+19, r26	; 0x13
     90e:	bc 8b       	std	Y+20, r27	; 0x14
		antiwind_gain = .75*256;
     910:	f8 01       	movw	r30, r16
     912:	ec 59       	subi	r30, 0x9C	; 156
     914:	ff 4f       	sbci	r31, 0xFF	; 255
     916:	ef 83       	std	Y+7, r30	; 0x07
     918:	f8 87       	std	Y+8, r31	; 0x08
		
		_max = 1600;
     91a:	24 50       	subi	r18, 0x04	; 4
     91c:	31 09       	sbc	r19, r1
     91e:	29 87       	std	Y+9, r18	; 0x09
     920:	3a 87       	std	Y+10, r19	; 0x0a
		_min = -1600;
     922:	06 97       	sbiw	r24, 0x06	; 6
     924:	8d 87       	std	Y+13, r24	; 0x0d
     926:	9e 87       	std	Y+14, r25	; 0x0e
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     928:	52 96       	adiw	r26, 0x12	; 18
     92a:	ad 8b       	std	Y+21, r26	; 0x15
     92c:	be 8b       	std	Y+22, r27	; 0x16

		// Integral term
		error_int = error - antiwind_correct;
     92e:	48 01       	movw	r8, r16
     930:	b6 e6       	ldi	r27, 0x66	; 102
     932:	8b 0e       	add	r8, r27
     934:	91 1c       	adc	r9, r1
     936:	34 96       	adiw	r30, 0x04	; 4
     938:	ef 8b       	std	Y+23, r30	; 0x17
     93a:	f8 8f       	std	Y+24, r31	; 0x18
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     93c:	26 50       	subi	r18, 0x06	; 6
     93e:	31 09       	sbc	r19, r1
     940:	2b 87       	std	Y+11, r18	; 0x0b
     942:	3c 87       	std	Y+12, r19	; 0x0c
	int16_t KP_angle = -1000;
	int16_t angle_set = 720;							// vertical setpoint for pendulum
	
	while(1){
		// Increment counter for debugging
		runs++;
     944:	f8 01       	movw	r30, r16
     946:	86 85       	ldd	r24, Z+14	; 0x0e
     948:	97 85       	ldd	r25, Z+15	; 0x0f
     94a:	a0 89       	ldd	r26, Z+16	; 0x10
     94c:	b1 89       	ldd	r27, Z+17	; 0x11
     94e:	01 96       	adiw	r24, 0x01	; 1
     950:	a1 1d       	adc	r26, r1
     952:	b1 1d       	adc	r27, r1
     954:	86 87       	std	Z+14, r24	; 0x0e
     956:	97 87       	std	Z+15, r25	; 0x0f
     958:	a0 8b       	std	Z+16, r26	; 0x10
     95a:	b1 8b       	std	Z+17, r27	; 0x11
		
		switch (state)
     95c:	84 85       	ldd	r24, Z+12	; 0x0c
     95e:	81 30       	cpi	r24, 0x01	; 1
     960:	09 f4       	brne	.+2      	; 0x964 <_ZN5Motor3runEv+0x10e>
     962:	33 c0       	rjmp	.+102    	; 0x9ca <_ZN5Motor3runEv+0x174>
     964:	38 f0       	brcs	.+14     	; 0x974 <_ZN5Motor3runEv+0x11e>
     966:	82 30       	cpi	r24, 0x02	; 2
     968:	09 f4       	brne	.+2      	; 0x96c <_ZN5Motor3runEv+0x116>
     96a:	57 c0       	rjmp	.+174    	; 0xa1a <_ZN5Motor3runEv+0x1c4>
     96c:	83 30       	cpi	r24, 0x03	; 3
     96e:	09 f4       	brne	.+2      	; 0x972 <_ZN5Motor3runEv+0x11c>
     970:	8f c0       	rjmp	.+286    	; 0xa90 <_ZN5Motor3runEv+0x23a>
     972:	cc c0       	rjmp	.+408    	; 0xb0c <_ZN5Motor3runEv+0x2b6>
		{
			// Home right
			case(0) :
				//*p_serial << "Start Calibration Sequence? [Y/N]" << endl;
				omegam_set = 10;	// [ticks/ms]
     974:	22 8e       	std	Z+26, r2	; 0x1a
     976:	33 8e       	std	Z+27, r3	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     978:	0f b6       	in	r0, 0x3f	; 63
     97a:	f8 94       	cli
     97c:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     97e:	0f 90       	pop	r0
     980:	0f be       	out	0x3f, r0	; 63

				if (rightLimitSwitch.get())
     982:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rightLimitSwitch>
     986:	88 23       	and	r24, r24
     988:	09 f4       	brne	.+2      	; 0x98c <_ZN5Motor3runEv+0x136>
     98a:	c0 c0       	rjmp	.+384    	; 0xb0c <_ZN5Motor3runEv+0x2b6>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     98c:	0f b6       	in	r0, 0x3f	; 63
     98e:	f8 94       	cli
     990:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     992:	0f 90       	pop	r0
     994:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     996:	0f b6       	in	r0, 0x3f	; 63
     998:	f8 94       	cli
     99a:	0f 92       	push	r0
			the_data = new_data;
     99c:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <linear_position>
     9a0:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <linear_position+0x1>
     9a4:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <linear_offset>
     9a8:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <linear_offset+0x1>
			portEXIT_CRITICAL ();
     9ac:	0f 90       	pop	r0
     9ae:	0f be       	out	0x3f, r0	; 63
				{
					linear_offset.put(linear_position.get());					// set the offset
					_integral = 0;
     9b0:	f5 01       	movw	r30, r10
     9b2:	10 82       	st	Z, r1
     9b4:	11 82       	std	Z+1, r1	; 0x01
     9b6:	12 82       	std	Z+2, r1	; 0x02
     9b8:	13 82       	std	Z+3, r1	; 0x03
					output_correct = 0;
     9ba:	d6 01       	movw	r26, r12
     9bc:	1d 92       	st	X+, r1
     9be:	1c 92       	st	X, r1
					transition_to(1);									// if right Limit Switch is triggered 
     9c0:	61 e0       	ldi	r22, 0x01	; 1
     9c2:	c8 01       	movw	r24, r16
     9c4:	0e 94 29 15 	call	0x2a52	; 0x2a52 <_ZN8frt_task13transition_toEh>
     9c8:	a1 c0       	rjmp	.+322    	; 0xb0c <_ZN5Motor3runEv+0x2b6>
				}
				break;
				
			// Home left
			case(1) :
				omegam_set = -10;	// [ticks/ms]
     9ca:	86 ef       	ldi	r24, 0xF6	; 246
     9cc:	9f ef       	ldi	r25, 0xFF	; 255
     9ce:	f8 01       	movw	r30, r16
     9d0:	82 8f       	std	Z+26, r24	; 0x1a
     9d2:	93 8f       	std	Z+27, r25	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     9d4:	0f b6       	in	r0, 0x3f	; 63
     9d6:	f8 94       	cli
     9d8:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     9da:	0f 90       	pop	r0
     9dc:	0f be       	out	0x3f, r0	; 63
			
				if (leftLimitSwitch.get())
     9de:	80 91 49 31 	lds	r24, 0x3149	; 0x803149 <leftLimitSwitch>
     9e2:	88 23       	and	r24, r24
     9e4:	09 f4       	brne	.+2      	; 0x9e8 <_ZN5Motor3runEv+0x192>
     9e6:	92 c0       	rjmp	.+292    	; 0xb0c <_ZN5Motor3runEv+0x2b6>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     9e8:	0f b6       	in	r0, 0x3f	; 63
     9ea:	f8 94       	cli
     9ec:	0f 92       	push	r0
			temporary_copy = the_data;
     9ee:	20 91 4e 31 	lds	r18, 0x314E	; 0x80314e <linear_position>
     9f2:	30 91 4f 31 	lds	r19, 0x314F	; 0x80314f <linear_position+0x1>
     9f6:	29 8f       	std	Y+25, r18	; 0x19
     9f8:	3a 8f       	std	Y+26, r19	; 0x1a
			portEXIT_CRITICAL ();
     9fa:	0f 90       	pop	r0
     9fc:	0f be       	out	0x3f, r0	; 63
				{
					left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     9fe:	d5 01       	movw	r26, r10
     a00:	1d 92       	st	X+, r1
     a02:	1d 92       	st	X+, r1
     a04:	1d 92       	st	X+, r1
     a06:	1c 92       	st	X, r1
     a08:	13 97       	sbiw	r26, 0x03	; 3
					output_correct = 0;
     a0a:	f6 01       	movw	r30, r12
     a0c:	10 82       	st	Z, r1
     a0e:	11 82       	std	Z+1, r1	; 0x01
					transition_to(2);									// if left limit switch is triggered
     a10:	62 e0       	ldi	r22, 0x02	; 2
     a12:	c8 01       	movw	r24, r16
     a14:	0e 94 29 15 	call	0x2a52	; 0x2a52 <_ZN8frt_task13transition_toEh>
     a18:	79 c0       	rjmp	.+242    	; 0xb0c <_ZN5Motor3runEv+0x2b6>
				}					
				break;
			
			// Center Cart - Position Loop included
			case(2) :
				position_midpoint = left_home/2;
     a1a:	69 8d       	ldd	r22, Y+25	; 0x19
     a1c:	7a 8d       	ldd	r23, Y+26	; 0x1a
     a1e:	77 23       	and	r23, r23
     a20:	14 f4       	brge	.+4      	; 0xa26 <_ZN5Motor3runEv+0x1d0>
     a22:	6f 5f       	subi	r22, 0xFF	; 255
     a24:	7f 4f       	sbci	r23, 0xFF	; 255
     a26:	9b 01       	movw	r18, r22
     a28:	35 95       	asr	r19
     a2a:	27 95       	ror	r18
     a2c:	2f 87       	std	Y+15, r18	; 0x0f
     a2e:	38 8b       	std	Y+16, r19	; 0x10
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     a30:	0f b6       	in	r0, 0x3f	; 63
     a32:	f8 94       	cli
     a34:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     a36:	0f 90       	pop	r0
     a38:	0f be       	out	0x3f, r0	; 63
				position_set = position_midpoint;
				position_error = position_set - linear_position.get();  // 
				omegam_set = position_error*KP_pos/1000;
     a3a:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <linear_position>
     a3e:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <linear_position+0x1>
     a42:	28 1b       	sub	r18, r24
     a44:	39 0b       	sbc	r19, r25
     a46:	44 e6       	ldi	r20, 0x64	; 100
     a48:	42 9f       	mul	r20, r18
     a4a:	c0 01       	movw	r24, r0
     a4c:	43 9f       	mul	r20, r19
     a4e:	90 0d       	add	r25, r0
     a50:	11 24       	eor	r1, r1
     a52:	68 ee       	ldi	r22, 0xE8	; 232
     a54:	73 e0       	ldi	r23, 0x03	; 3
     a56:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <__divmodhi4>
     a5a:	d8 01       	movw	r26, r16
     a5c:	5a 96       	adiw	r26, 0x1a	; 26
     a5e:	6d 93       	st	X+, r22
     a60:	7c 93       	st	X, r23
     a62:	5b 97       	sbiw	r26, 0x1b	; 27
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     a64:	0f b6       	in	r0, 0x3f	; 63
     a66:	f8 94       	cli
     a68:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     a6a:	0f 90       	pop	r0
     a6c:	0f be       	out	0x3f, r0	; 63
				
				if(thPendulum.get() == angle_set)
     a6e:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <thPendulum>
     a72:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <thPendulum+0x1>
     a76:	80 3d       	cpi	r24, 0xD0	; 208
     a78:	92 40       	sbci	r25, 0x02	; 2
     a7a:	09 f0       	breq	.+2      	; 0xa7e <_ZN5Motor3runEv+0x228>
     a7c:	43 c0       	rjmp	.+134    	; 0xb04 <_ZN5Motor3runEv+0x2ae>
				{
					transition_to(3);
     a7e:	63 e0       	ldi	r22, 0x03	; 3
     a80:	c8 01       	movw	r24, r16
     a82:	0e 94 29 15 	call	0x2a52	; 0x2a52 <_ZN8frt_task13transition_toEh>
				}					
				break;
			
			// Center Cart - Position Loop included
			case(2) :
				position_midpoint = left_home/2;
     a86:	ef 85       	ldd	r30, Y+15	; 0x0f
     a88:	f8 89       	ldd	r31, Y+16	; 0x10
     a8a:	eb 8f       	std	Y+27, r30	; 0x1b
     a8c:	fc 8f       	std	Y+28, r31	; 0x1c
     a8e:	3e c0       	rjmp	.+124    	; 0xb0c <_ZN5Motor3runEv+0x2b6>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     a90:	0f b6       	in	r0, 0x3f	; 63
     a92:	f8 94       	cli
     a94:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     a96:	0f 90       	pop	r0
     a98:	0f be       	out	0x3f, r0	; 63
			break;
			
			// Pendulum Balance
			case(3) :
				angle_error = angle_set - thPendulum.get();
				position_set = position_midpoint + angle_error*KP_angle/1000;
     a9a:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <thPendulum>
     a9e:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <thPendulum+0x1>
     aa2:	20 ed       	ldi	r18, 0xD0	; 208
     aa4:	32 e0       	ldi	r19, 0x02	; 2
     aa6:	28 1b       	sub	r18, r24
     aa8:	39 0b       	sbc	r19, r25
     aaa:	48 e1       	ldi	r20, 0x18	; 24
     aac:	5c ef       	ldi	r21, 0xFC	; 252
     aae:	24 9f       	mul	r18, r20
     ab0:	c0 01       	movw	r24, r0
     ab2:	25 9f       	mul	r18, r21
     ab4:	90 0d       	add	r25, r0
     ab6:	34 9f       	mul	r19, r20
     ab8:	90 0d       	add	r25, r0
     aba:	11 24       	eor	r1, r1
     abc:	28 ee       	ldi	r18, 0xE8	; 232
     abe:	33 e0       	ldi	r19, 0x03	; 3
     ac0:	b9 01       	movw	r22, r18
     ac2:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <__divmodhi4>
     ac6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     ac8:	9c 8d       	ldd	r25, Y+28	; 0x1c
     aca:	86 0f       	add	r24, r22
     acc:	97 1f       	adc	r25, r23
     ace:	8f 87       	std	Y+15, r24	; 0x0f
     ad0:	98 8b       	std	Y+16, r25	; 0x10
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     ad2:	0f b6       	in	r0, 0x3f	; 63
     ad4:	f8 94       	cli
     ad6:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     ad8:	0f 90       	pop	r0
     ada:	0f be       	out	0x3f, r0	; 63
				position_error = position_set - linear_position.get();  // 
				omegam_set = position_error*KP_pos/1000;
     adc:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <linear_position>
     ae0:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <linear_position+0x1>
     ae4:	4f 85       	ldd	r20, Y+15	; 0x0f
     ae6:	58 89       	ldd	r21, Y+16	; 0x10
     ae8:	48 1b       	sub	r20, r24
     aea:	59 0b       	sbc	r21, r25
     aec:	64 e6       	ldi	r22, 0x64	; 100
     aee:	64 9f       	mul	r22, r20
     af0:	c0 01       	movw	r24, r0
     af2:	65 9f       	mul	r22, r21
     af4:	90 0d       	add	r25, r0
     af6:	11 24       	eor	r1, r1
     af8:	b9 01       	movw	r22, r18
     afa:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <__divmodhi4>
     afe:	62 8f       	std	Z+26, r22	; 0x1a
     b00:	73 8f       	std	Z+27, r23	; 0x1b
				
			//transition_to(4);											// If user sets pendulum "Inverted" and presses go
			break;
     b02:	04 c0       	rjmp	.+8      	; 0xb0c <_ZN5Motor3runEv+0x2b6>
				}					
				break;
			
			// Center Cart - Position Loop included
			case(2) :
				position_midpoint = left_home/2;
     b04:	ef 85       	ldd	r30, Y+15	; 0x0f
     b06:	f8 89       	ldd	r31, Y+16	; 0x10
     b08:	eb 8f       	std	Y+27, r30	; 0x1b
     b0a:	fc 8f       	std	Y+28, r31	; 0x1c
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b0c:	0f b6       	in	r0, 0x3f	; 63
     b0e:	f8 94       	cli
     b10:	0f 92       	push	r0
			temporary_copy = the_data;
     b12:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <thdMotor>
     b16:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <thdMotor+0x1>
			portEXIT_CRITICAL ();
     b1a:	0f 90       	pop	r0
     b1c:	0f be       	out	0x3f, r0	; 63
				//break;													// PWM  = 0
		
		};

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     b1e:	d8 01       	movw	r26, r16
     b20:	5e 96       	adiw	r26, 0x1e	; 30
     b22:	8d 93       	st	X+, r24
     b24:	9c 93       	st	X, r25
     b26:	5f 97       	sbiw	r26, 0x1f	; 31
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     b28:	e9 89       	ldd	r30, Y+17	; 0x11
     b2a:	fa 89       	ldd	r31, Y+18	; 0x12
     b2c:	20 82       	st	Z, r2
     b2e:	31 82       	std	Z+1, r3	; 0x01
		_Ki = .7*256;
     b30:	23 eb       	ldi	r18, 0xB3	; 179
     b32:	30 e0       	ldi	r19, 0x00	; 0
     b34:	ad 81       	ldd	r26, Y+5	; 0x05
     b36:	be 81       	ldd	r27, Y+6	; 0x06
     b38:	2d 93       	st	X+, r18
     b3a:	3c 93       	st	X, r19
		_Kd = 0;
     b3c:	eb 89       	ldd	r30, Y+19	; 0x13
     b3e:	fc 89       	ldd	r31, Y+20	; 0x14
     b40:	10 82       	st	Z, r1
     b42:	11 82       	std	Z+1, r1	; 0x01
		antiwind_gain = .75*256;
     b44:	20 ec       	ldi	r18, 0xC0	; 192
     b46:	30 e0       	ldi	r19, 0x00	; 0
     b48:	af 81       	ldd	r26, Y+7	; 0x07
     b4a:	b8 85       	ldd	r27, Y+8	; 0x08
     b4c:	2d 93       	st	X+, r18
     b4e:	3c 93       	st	X, r19
		
		_max = 1600;
     b50:	20 e4       	ldi	r18, 0x40	; 64
     b52:	36 e0       	ldi	r19, 0x06	; 6
     b54:	e9 85       	ldd	r30, Y+9	; 0x09
     b56:	fa 85       	ldd	r31, Y+10	; 0x0a
     b58:	20 83       	st	Z, r18
     b5a:	31 83       	std	Z+1, r19	; 0x01
		_min = -1600;
     b5c:	20 ec       	ldi	r18, 0xC0	; 192
     b5e:	39 ef       	ldi	r19, 0xF9	; 249
     b60:	ad 85       	ldd	r26, Y+13	; 0x0d
     b62:	be 85       	ldd	r27, Y+14	; 0x0e
     b64:	2d 93       	st	X+, r18
     b66:	3c 93       	st	X, r19
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     b68:	f8 01       	movw	r30, r16
     b6a:	e2 8c       	ldd	r14, Z+26	; 0x1a
     b6c:	f3 8c       	ldd	r15, Z+27	; 0x1b
     b6e:	e8 1a       	sub	r14, r24
     b70:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     b72:	b7 01       	movw	r22, r14
     b74:	c1 01       	movw	r24, r2
     b76:	0e 94 56 07 	call	0xeac	; 0xeac <_ZN7satmath20signed_saturated_mulEii>
     b7a:	2b 01       	movw	r4, r22
     b7c:	3c 01       	movw	r6, r24
     b7e:	ad 89       	ldd	r26, Y+21	; 0x15
     b80:	be 89       	ldd	r27, Y+22	; 0x16
     b82:	6d 93       	st	X+, r22
     b84:	7c 93       	st	X, r23

		// Integral term
		error_int = error - antiwind_correct;
     b86:	f4 01       	movw	r30, r8
     b88:	80 81       	ld	r24, Z
     b8a:	91 81       	ldd	r25, Z+1	; 0x01
     b8c:	97 01       	movw	r18, r14
     b8e:	28 1b       	sub	r18, r24
     b90:	39 0b       	sbc	r19, r25
     b92:	c9 01       	movw	r24, r18
     b94:	af 89       	ldd	r26, Y+23	; 0x17
     b96:	b8 8d       	ldd	r27, Y+24	; 0x18
     b98:	2d 93       	st	X+, r18
     b9a:	3c 93       	st	X, r19
		error_int_gain = (_Ki * error_int);
     b9c:	ed 81       	ldd	r30, Y+5	; 0x05
     b9e:	fe 81       	ldd	r31, Y+6	; 0x06
     ba0:	20 81       	ld	r18, Z
     ba2:	31 81       	ldd	r19, Z+1	; 0x01
     ba4:	82 9f       	mul	r24, r18
     ba6:	d0 01       	movw	r26, r0
     ba8:	83 9f       	mul	r24, r19
     baa:	b0 0d       	add	r27, r0
     bac:	92 9f       	mul	r25, r18
     bae:	b0 0d       	add	r27, r0
     bb0:	11 24       	eor	r1, r1
     bb2:	f8 01       	movw	r30, r16
     bb4:	e6 59       	subi	r30, 0x96	; 150
     bb6:	ff 4f       	sbci	r31, 0xFF	; 255
     bb8:	a0 83       	st	Z, r26
     bba:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     bbc:	eb 85       	ldd	r30, Y+11	; 0x0b
     bbe:	fc 85       	ldd	r31, Y+12	; 0x0c
     bc0:	20 81       	ld	r18, Z
     bc2:	31 81       	ldd	r19, Z+1	; 0x01
     bc4:	42 81       	ldd	r20, Z+2	; 0x02
     bc6:	53 81       	ldd	r21, Z+3	; 0x03
     bc8:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <__mulshisi3>
     bcc:	9b 01       	movw	r18, r22
     bce:	ac 01       	movw	r20, r24
     bd0:	99 23       	and	r25, r25
     bd2:	24 f4       	brge	.+8      	; 0xbdc <_ZN5Motor3runEv+0x386>
     bd4:	21 50       	subi	r18, 0x01	; 1
     bd6:	3f 4f       	sbci	r19, 0xFF	; 255
     bd8:	4f 4f       	sbci	r20, 0xFF	; 255
     bda:	5f 4f       	sbci	r21, 0xFF	; 255
     bdc:	bb 27       	eor	r27, r27
     bde:	57 fd       	sbrc	r21, 7
     be0:	ba 95       	dec	r27
     be2:	a5 2f       	mov	r26, r21
     be4:	94 2f       	mov	r25, r20
     be6:	83 2f       	mov	r24, r19
     be8:	f5 01       	movw	r30, r10
     bea:	40 81       	ld	r20, Z
     bec:	51 81       	ldd	r21, Z+1	; 0x01
     bee:	62 81       	ldd	r22, Z+2	; 0x02
     bf0:	73 81       	ldd	r23, Z+3	; 0x03
     bf2:	84 0f       	add	r24, r20
     bf4:	95 1f       	adc	r25, r21
     bf6:	a6 1f       	adc	r26, r22
     bf8:	b7 1f       	adc	r27, r23
		if(_integral > 1000000000)
     bfa:	81 30       	cpi	r24, 0x01	; 1
     bfc:	fa ec       	ldi	r31, 0xCA	; 202
     bfe:	9f 07       	cpc	r25, r31
     c00:	fa e9       	ldi	r31, 0x9A	; 154
     c02:	af 07       	cpc	r26, r31
     c04:	fb e3       	ldi	r31, 0x3B	; 59
     c06:	bf 07       	cpc	r27, r31
     c08:	54 f0       	brlt	.+20     	; 0xc1e <_ZN5Motor3runEv+0x3c8>
		{
			_integral = 1000000000;
     c0a:	80 e0       	ldi	r24, 0x00	; 0
     c0c:	9a ec       	ldi	r25, 0xCA	; 202
     c0e:	aa e9       	ldi	r26, 0x9A	; 154
     c10:	bb e3       	ldi	r27, 0x3B	; 59
     c12:	f5 01       	movw	r30, r10
     c14:	80 83       	st	Z, r24
     c16:	91 83       	std	Z+1, r25	; 0x01
     c18:	a2 83       	std	Z+2, r26	; 0x02
     c1a:	b3 83       	std	Z+3, r27	; 0x03
     c1c:	17 c0       	rjmp	.+46     	; 0xc4c <_ZN5Motor3runEv+0x3f6>
		}
		else if(_integral < -1000000000)
     c1e:	81 15       	cp	r24, r1
     c20:	f6 e3       	ldi	r31, 0x36	; 54
     c22:	9f 07       	cpc	r25, r31
     c24:	f5 e6       	ldi	r31, 0x65	; 101
     c26:	af 07       	cpc	r26, r31
     c28:	f4 ec       	ldi	r31, 0xC4	; 196
     c2a:	bf 07       	cpc	r27, r31
     c2c:	34 f0       	brlt	.+12     	; 0xc3a <_ZN5Motor3runEv+0x3e4>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     c2e:	f5 01       	movw	r30, r10
     c30:	80 83       	st	Z, r24
     c32:	91 83       	std	Z+1, r25	; 0x01
     c34:	a2 83       	std	Z+2, r26	; 0x02
     c36:	b3 83       	std	Z+3, r27	; 0x03
     c38:	09 c0       	rjmp	.+18     	; 0xc4c <_ZN5Motor3runEv+0x3f6>
		{
			_integral = 1000000000;
		}
		else if(_integral < -1000000000)
		{
			_integral = -1000000000;
     c3a:	80 e0       	ldi	r24, 0x00	; 0
     c3c:	96 e3       	ldi	r25, 0x36	; 54
     c3e:	a5 e6       	ldi	r26, 0x65	; 101
     c40:	b4 ec       	ldi	r27, 0xC4	; 196
     c42:	f5 01       	movw	r30, r10
     c44:	80 83       	st	Z, r24
     c46:	91 83       	std	Z+1, r25	; 0x01
     c48:	a2 83       	std	Z+2, r26	; 0x02
     c4a:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
     c4c:	d5 01       	movw	r26, r10
     c4e:	6d 91       	ld	r22, X+
     c50:	7c 91       	ld	r23, X
     c52:	c2 01       	movw	r24, r4
     c54:	0e 94 3a 07 	call	0xe74	; 0xe74 <_ZN7satmath20signed_saturated_addEii>
     c58:	f8 01       	movw	r30, r16
     c5a:	e0 5a       	subi	r30, 0xA0	; 160
     c5c:	ff 4f       	sbci	r31, 0xFF	; 255
     c5e:	80 83       	st	Z, r24
     c60:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
     c62:	f6 01       	movw	r30, r12
     c64:	80 83       	st	Z, r24
     c66:	91 83       	std	Z+1, r25	; 0x01
		// Restrict to max/min
		if( output_correct > _max )
     c68:	a9 85       	ldd	r26, Y+9	; 0x09
     c6a:	ba 85       	ldd	r27, Y+10	; 0x0a
     c6c:	2d 91       	ld	r18, X+
     c6e:	3c 91       	ld	r19, X
     c70:	28 17       	cp	r18, r24
     c72:	39 07       	cpc	r19, r25
     c74:	1c f4       	brge	.+6      	; 0xc7c <_ZN5Motor3runEv+0x426>
		output_correct = _max;
     c76:	20 83       	st	Z, r18
     c78:	31 83       	std	Z+1, r19	; 0x01
     c7a:	0a c0       	rjmp	.+20     	; 0xc90 <_ZN5Motor3runEv+0x43a>
		else if( output_correct < _min )
     c7c:	ed 85       	ldd	r30, Y+13	; 0x0d
     c7e:	fe 85       	ldd	r31, Y+14	; 0x0e
     c80:	20 81       	ld	r18, Z
     c82:	31 81       	ldd	r19, Z+1	; 0x01
     c84:	82 17       	cp	r24, r18
     c86:	93 07       	cpc	r25, r19
     c88:	1c f4       	brge	.+6      	; 0xc90 <_ZN5Motor3runEv+0x43a>
		output_correct = _min;
     c8a:	d6 01       	movw	r26, r12
     c8c:	2d 93       	st	X+, r18
     c8e:	3c 93       	st	X, r19

		// Save error to previous error
		_pre_error = error;
     c90:	f8 01       	movw	r30, r16
     c92:	e2 5b       	subi	r30, 0xB2	; 178
     c94:	ff 4f       	sbci	r31, 0xFF	; 255
     c96:	e0 82       	st	Z, r14
     c98:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
     c9a:	f6 01       	movw	r30, r12
     c9c:	20 81       	ld	r18, Z
     c9e:	31 81       	ldd	r19, Z+1	; 0x01
     ca0:	82 1b       	sub	r24, r18
     ca2:	93 0b       	sbc	r25, r19
     ca4:	f8 01       	movw	r30, r16
     ca6:	ee 59       	subi	r30, 0x9E	; 158
     ca8:	ff 4f       	sbci	r31, 0xFF	; 255
     caa:	80 83       	st	Z, r24
     cac:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
     cae:	af 81       	ldd	r26, Y+7	; 0x07
     cb0:	b8 85       	ldd	r27, Y+8	; 0x08
     cb2:	4d 91       	ld	r20, X+
     cb4:	5c 91       	ld	r21, X
     cb6:	84 9f       	mul	r24, r20
     cb8:	90 01       	movw	r18, r0
     cba:	85 9f       	mul	r24, r21
     cbc:	30 0d       	add	r19, r0
     cbe:	94 9f       	mul	r25, r20
     cc0:	30 0d       	add	r19, r0
     cc2:	11 24       	eor	r1, r1
     cc4:	33 23       	and	r19, r19
     cc6:	14 f4       	brge	.+4      	; 0xccc <_ZN5Motor3runEv+0x476>
     cc8:	21 50       	subi	r18, 0x01	; 1
     cca:	3f 4f       	sbci	r19, 0xFF	; 255
     ccc:	83 2f       	mov	r24, r19
     cce:	88 0f       	add	r24, r24
     cd0:	88 0b       	sbc	r24, r24
     cd2:	f4 01       	movw	r30, r8
     cd4:	30 83       	st	Z, r19
     cd6:	81 83       	std	Z+1, r24	; 0x01
		
		
			if(runs%50 == 0){
     cd8:	d8 01       	movw	r26, r16
     cda:	1e 96       	adiw	r26, 0x0e	; 14
     cdc:	6d 91       	ld	r22, X+
     cde:	7d 91       	ld	r23, X+
     ce0:	8d 91       	ld	r24, X+
     ce2:	9c 91       	ld	r25, X
     ce4:	51 97       	sbiw	r26, 0x11	; 17
     ce6:	22 e3       	ldi	r18, 0x32	; 50
     ce8:	30 e0       	ldi	r19, 0x00	; 0
     cea:	40 e0       	ldi	r20, 0x00	; 0
     cec:	50 e0       	ldi	r21, 0x00	; 0
     cee:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <__udivmodsi4>
     cf2:	67 2b       	or	r22, r23
     cf4:	68 2b       	or	r22, r24
     cf6:	69 2b       	or	r22, r25
     cf8:	81 f4       	brne	.+32     	; 0xd1a <_ZN5Motor3runEv+0x4c4>
				//*p_serial << omegam_set << endl;
				//*p_serial << thPendulum.get() << endl;
				//*p_serial << "right: " << rightLimitSwitch.get() << endl;
				//*p_serial << "left: " << leftLimitSwitch.get() << endl;
				//*p_serial << "linear pos: " << linear_position.get() << endl;
				*p_serial << "linear set: " << position_set << endl;
     cfa:	f8 01       	movw	r30, r16
     cfc:	e6 80       	ldd	r14, Z+6	; 0x06
     cfe:	f7 80       	ldd	r15, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     d00:	6e e1       	ldi	r22, 0x1E	; 30
     d02:	70 e2       	ldi	r23, 0x20	; 32
     d04:	c7 01       	movw	r24, r14
     d06:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
     d0a:	6f 85       	ldd	r22, Y+15	; 0x0f
     d0c:	78 89       	ldd	r23, Y+16	; 0x10
     d0e:	c7 01       	movw	r24, r14
     d10:	0e 94 d9 1a 	call	0x35b2	; 0x35b2 <_ZN8emstreamlsEi>
     d14:	66 e0       	ldi	r22, 0x06	; 6
     d16:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
		
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		*/
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     d1a:	d8 01       	movw	r26, r16
     d1c:	98 96       	adiw	r26, 0x28	; 40
     d1e:	1d 92       	st	X+, r1
     d20:	1c 92       	st	X, r1
     d22:	99 97       	sbiw	r26, 0x29	; 41
		Im_set = Tset/K_T;
     d24:	92 96       	adiw	r26, 0x22	; 34
     d26:	8d 91       	ld	r24, X+
     d28:	9c 91       	ld	r25, X
     d2a:	93 97       	sbiw	r26, 0x23	; 35
     d2c:	60 e0       	ldi	r22, 0x00	; 0
     d2e:	70 e0       	ldi	r23, 0x00	; 0
     d30:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <__divmodhi4>
     d34:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
     d36:	07 2e       	mov	r0, r23
     d38:	00 0c       	add	r0, r0
     d3a:	88 0b       	sbc	r24, r24
     d3c:	99 0b       	sbc	r25, r25
     d3e:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <__floatsisf>
     d42:	2b 01       	movw	r4, r22
     d44:	3c 01       	movw	r6, r24
     d46:	23 e3       	ldi	r18, 0x33	; 51
     d48:	33 e3       	ldi	r19, 0x33	; 51
     d4a:	4b e8       	ldi	r20, 0x8B	; 139
     d4c:	51 e4       	ldi	r21, 0x41	; 65
     d4e:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <__gesf2>
     d52:	18 16       	cp	r1, r24
     d54:	34 f4       	brge	.+12     	; 0xd62 <_ZN5Motor3runEv+0x50c>
			Im_set = 17.4;
     d56:	81 e1       	ldi	r24, 0x11	; 17
     d58:	90 e0       	ldi	r25, 0x00	; 0
     d5a:	f8 01       	movw	r30, r16
     d5c:	84 a3       	std	Z+36, r24	; 0x24
     d5e:	95 a3       	std	Z+37, r25	; 0x25
     d60:	15 c0       	rjmp	.+42     	; 0xd8c <_ZN5Motor3runEv+0x536>
		} else if(Im_set < -17.4) {
     d62:	23 e3       	ldi	r18, 0x33	; 51
     d64:	33 e3       	ldi	r19, 0x33	; 51
     d66:	4b e8       	ldi	r20, 0x8B	; 139
     d68:	51 ec       	ldi	r21, 0xC1	; 193
     d6a:	c3 01       	movw	r24, r6
     d6c:	b2 01       	movw	r22, r4
     d6e:	0e 94 69 1f 	call	0x3ed2	; 0x3ed2 <__cmpsf2>
     d72:	88 23       	and	r24, r24
     d74:	34 f0       	brlt	.+12     	; 0xd82 <_ZN5Motor3runEv+0x52c>
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		*/
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
     d76:	d8 01       	movw	r26, r16
     d78:	94 96       	adiw	r26, 0x24	; 36
     d7a:	ed 92       	st	X+, r14
     d7c:	fc 92       	st	X, r15
     d7e:	95 97       	sbiw	r26, 0x25	; 37
     d80:	05 c0       	rjmp	.+10     	; 0xd8c <_ZN5Motor3runEv+0x536>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
     d82:	8f ee       	ldi	r24, 0xEF	; 239
     d84:	9f ef       	ldi	r25, 0xFF	; 255
     d86:	f8 01       	movw	r30, r16
     d88:	84 a3       	std	Z+36, r24	; 0x24
     d8a:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     d8c:	d8 01       	movw	r26, r16
     d8e:	d6 96       	adiw	r26, 0x36	; 54
     d90:	1d 92       	st	X+, r1
     d92:	1c 92       	st	X, r1
     d94:	d7 97       	sbiw	r26, 0x37	; 55
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     d96:	d2 96       	adiw	r26, 0x32	; 50
     d98:	1d 92       	st	X+, r1
     d9a:	1c 92       	st	X, r1
     d9c:	d3 97       	sbiw	r26, 0x33	; 51
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     d9e:	d4 96       	adiw	r26, 0x34	; 52
     da0:	1d 92       	st	X+, r1
     da2:	1c 92       	st	X, r1
     da4:	d5 97       	sbiw	r26, 0x35	; 53

		V_m = V_R + V_E;
     da6:	d0 96       	adiw	r26, 0x30	; 48
     da8:	8d 91       	ld	r24, X+
     daa:	9c 91       	ld	r25, X
     dac:	d1 97       	sbiw	r26, 0x31	; 49

		// Saturater for voltage
		if (V_m > 24) {
     dae:	89 31       	cpi	r24, 0x19	; 25
     db0:	91 05       	cpc	r25, r1
     db2:	3c f0       	brlt	.+14     	; 0xdc2 <_ZN5Motor3runEv+0x56c>
			V_m = 24;
     db4:	88 e1       	ldi	r24, 0x18	; 24
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	d8 96       	adiw	r26, 0x38	; 56
     dba:	8d 93       	st	X+, r24
     dbc:	9c 93       	st	X, r25
     dbe:	d9 97       	sbiw	r26, 0x39	; 57
     dc0:	0f c0       	rjmp	.+30     	; 0xde0 <_ZN5Motor3runEv+0x58a>
		} else if(V_m < -24) {
     dc2:	88 3e       	cpi	r24, 0xE8	; 232
     dc4:	bf ef       	ldi	r27, 0xFF	; 255
     dc6:	9b 07       	cpc	r25, r27
     dc8:	24 f0       	brlt	.+8      	; 0xdd2 <_ZN5Motor3runEv+0x57c>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
     dca:	f8 01       	movw	r30, r16
     dcc:	80 af       	std	Z+56, r24	; 0x38
     dce:	91 af       	std	Z+57, r25	; 0x39
     dd0:	07 c0       	rjmp	.+14     	; 0xde0 <_ZN5Motor3runEv+0x58a>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
     dd2:	88 ee       	ldi	r24, 0xE8	; 232
     dd4:	9f ef       	ldi	r25, 0xFF	; 255
     dd6:	d8 01       	movw	r26, r16
     dd8:	d8 96       	adiw	r26, 0x38	; 56
     dda:	8d 93       	st	X+, r24
     ddc:	9c 93       	st	X, r25
     dde:	d9 97       	sbiw	r26, 0x39	; 57
		}

		
		// PWM function to command motor
		if (output_correct >= 0)
     de0:	f6 01       	movw	r30, r12
     de2:	80 81       	ld	r24, Z
     de4:	91 81       	ldd	r25, Z+1	; 0x01
     de6:	99 23       	and	r25, r25
     de8:	3c f0       	brlt	.+14     	; 0xdf8 <_ZN5Motor3runEv+0x5a2>
		{
			TCC0.CCA = output_correct;
     dea:	e0 e0       	ldi	r30, 0x00	; 0
     dec:	f8 e0       	ldi	r31, 0x08	; 8
     dee:	80 a7       	std	Z+40, r24	; 0x28
     df0:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
     df2:	12 a6       	std	Z+42, r1	; 0x2a
     df4:	13 a6       	std	Z+43, r1	; 0x2b
     df6:	0c c0       	rjmp	.+24     	; 0xe10 <_ZN5Motor3runEv+0x5ba>
		}
		else if (output_correct < 0)
		{
			TCC0.CCA = 0;
     df8:	e0 e0       	ldi	r30, 0x00	; 0
     dfa:	f8 e0       	ldi	r31, 0x08	; 8
     dfc:	10 a6       	std	Z+40, r1	; 0x28
     dfe:	11 a6       	std	Z+41, r1	; 0x29
			TCC0.CCB = -output_correct;
     e00:	d6 01       	movw	r26, r12
     e02:	8d 91       	ld	r24, X+
     e04:	9c 91       	ld	r25, X
     e06:	91 95       	neg	r25
     e08:	81 95       	neg	r24
     e0a:	91 09       	sbc	r25, r1
     e0c:	82 a7       	std	Z+42, r24	; 0x2a
     e0e:	93 a7       	std	Z+43, r25	; 0x2b

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
     e10:	eb 85       	ldd	r30, Y+11	; 0x0b
     e12:	fc 85       	ldd	r31, Y+12	; 0x0c
     e14:	20 81       	ld	r18, Z
     e16:	31 81       	ldd	r19, Z+1	; 0x01
     e18:	42 81       	ldd	r20, Z+2	; 0x02
     e1a:	53 81       	ldd	r21, Z+3	; 0x03
     e1c:	a8 ee       	ldi	r26, 0xE8	; 232
     e1e:	b3 e0       	ldi	r27, 0x03	; 3
     e20:	0e 94 60 20 	call	0x40c0	; 0x40c0 <__muluhisi3>
     e24:	68 3e       	cpi	r22, 0xE8	; 232
     e26:	f3 e0       	ldi	r31, 0x03	; 3
     e28:	7f 07       	cpc	r23, r31
     e2a:	81 05       	cpc	r24, r1
     e2c:	91 05       	cpc	r25, r1
     e2e:	48 f0       	brcs	.+18     	; 0xe42 <_ZN5Motor3runEv+0x5ec>
     e30:	28 ee       	ldi	r18, 0xE8	; 232
     e32:	33 e0       	ldi	r19, 0x03	; 3
     e34:	40 e0       	ldi	r20, 0x00	; 0
     e36:	50 e0       	ldi	r21, 0x00	; 0
     e38:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <__udivmodsi4>
     e3c:	ba 01       	movw	r22, r20
     e3e:	a9 01       	movw	r20, r18
     e40:	04 c0       	rjmp	.+8      	; 0xe4a <_ZN5Motor3runEv+0x5f4>
     e42:	41 e0       	ldi	r20, 0x01	; 1
     e44:	50 e0       	ldi	r21, 0x00	; 0
     e46:	60 e0       	ldi	r22, 0x00	; 0
     e48:	70 e0       	ldi	r23, 0x00	; 0
     e4a:	ce 01       	movw	r24, r28
     e4c:	01 96       	adiw	r24, 0x01	; 1
     e4e:	0e 94 90 12 	call	0x2520	; 0x2520 <vTaskDelayUntil>
     e52:	78 cd       	rjmp	.-1296   	; 0x944 <_ZN5Motor3runEv+0xee>

00000e54 <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
     e54:	0f 93       	push	r16
     e56:	1f 93       	push	r17
     e58:	cf 93       	push	r28
     e5a:	df 93       	push	r29
     e5c:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     e5e:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <_ZN8frt_taskC1EPKchjP8emstream>
     e62:	8f e2       	ldi	r24, 0x2F	; 47
     e64:	90 e2       	ldi	r25, 0x20	; 32
     e66:	88 83       	st	Y, r24
     e68:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     e6a:	df 91       	pop	r29
     e6c:	cf 91       	pop	r28
     e6e:	1f 91       	pop	r17
     e70:	0f 91       	pop	r16
     e72:	08 95       	ret

00000e74 <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
     e74:	9c 01       	movw	r18, r24
     e76:	93 2f       	mov	r25, r19
     e78:	99 1f       	adc	r25, r25
     e7a:	99 27       	eor	r25, r25
     e7c:	99 1f       	adc	r25, r25
     e7e:	89 2f       	mov	r24, r25
     e80:	90 e0       	ldi	r25, 0x00	; 0
     e82:	81 50       	subi	r24, 0x01	; 1
     e84:	90 48       	sbci	r25, 0x80	; 128
     e86:	43 2f       	mov	r20, r19
     e88:	40 95       	com	r20
     e8a:	44 1f       	adc	r20, r20
     e8c:	44 27       	eor	r20, r20
     e8e:	44 1f       	adc	r20, r20
     e90:	fc 01       	movw	r30, r24
     e92:	e2 1b       	sub	r30, r18
     e94:	f3 0b       	sbc	r31, r19
     e96:	51 e0       	ldi	r21, 0x01	; 1
     e98:	e6 17       	cp	r30, r22
     e9a:	f7 07       	cpc	r31, r23
     e9c:	0c f0       	brlt	.+2      	; 0xea0 <_ZN7satmath20signed_saturated_addEii+0x2c>
     e9e:	50 e0       	ldi	r21, 0x00	; 0
     ea0:	45 17       	cp	r20, r21
     ea2:	19 f0       	breq	.+6      	; 0xeaa <_ZN7satmath20signed_saturated_addEii+0x36>
     ea4:	c9 01       	movw	r24, r18
     ea6:	86 0f       	add	r24, r22
     ea8:	97 1f       	adc	r25, r23
     eaa:	08 95       	ret

00000eac <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     eac:	81 15       	cp	r24, r1
     eae:	20 e8       	ldi	r18, 0x80	; 128
     eb0:	92 07       	cpc	r25, r18
     eb2:	21 f4       	brne	.+8      	; 0xebc <_ZN7satmath20signed_saturated_mulEii+0x10>
     eb4:	61 15       	cp	r22, r1
     eb6:	20 e8       	ldi	r18, 0x80	; 128
     eb8:	72 07       	cpc	r23, r18
     eba:	29 f0       	breq	.+10     	; 0xec6 <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
     ebc:	9c 01       	movw	r18, r24
     ebe:	db 01       	movw	r26, r22
     ec0:	0e 94 42 20 	call	0x4084	; 0x4084 <__mulhisi3>
     ec4:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     ec6:	6f ef       	ldi	r22, 0xFF	; 255
     ec8:	7f ef       	ldi	r23, 0xFF	; 255
     eca:	8f ef       	ldi	r24, 0xFF	; 255
     ecc:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
     ece:	08 95       	ret

00000ed0 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     ed0:	0f 93       	push	r16
     ed2:	1f 93       	push	r17
     ed4:	cf 93       	push	r28
     ed6:	df 93       	push	r29
     ed8:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     eda:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <_ZN8frt_taskC1EPKchjP8emstream>
     ede:	87 e3       	ldi	r24, 0x37	; 55
     ee0:	90 e2       	ldi	r25, 0x20	; 32
     ee2:	88 83       	st	Y, r24
     ee4:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     ee6:	df 91       	pop	r29
     ee8:	cf 91       	pop	r28
     eea:	1f 91       	pop	r17
     eec:	0f 91       	pop	r16
     eee:	08 95       	ret

00000ef0 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     ef0:	0f 93       	push	r16
     ef2:	1f 93       	push	r17
     ef4:	cf 93       	push	r28
     ef6:	df 93       	push	r29
     ef8:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     efa:	6a e0       	ldi	r22, 0x0A	; 10
     efc:	8e 81       	ldd	r24, Y+6	; 0x06
     efe:	9f 81       	ldd	r25, Y+7	; 0x07
     f00:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
     f04:	8c 01       	movw	r16, r24
     f06:	69 ee       	ldi	r22, 0xE9	; 233
     f08:	73 e0       	ldi	r23, 0x03	; 3
     f0a:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
     f0e:	6a e0       	ldi	r22, 0x0A	; 10
     f10:	c8 01       	movw	r24, r16
     f12:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
     f16:	8c 01       	movw	r16, r24
     f18:	63 ee       	ldi	r22, 0xE3	; 227
     f1a:	73 e0       	ldi	r23, 0x03	; 3
     f1c:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
     f20:	67 e0       	ldi	r22, 0x07	; 7
     f22:	c8 01       	movw	r24, r16
     f24:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     f28:	6a e0       	ldi	r22, 0x0A	; 10
     f2a:	8e 81       	ldd	r24, Y+6	; 0x06
     f2c:	9f 81       	ldd	r25, Y+7	; 0x07
     f2e:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
     f32:	8c 01       	movw	r16, r24
     f34:	64 ec       	ldi	r22, 0xC4	; 196
     f36:	73 e0       	ldi	r23, 0x03	; 3
     f38:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
     f3c:	6a e0       	ldi	r22, 0x0A	; 10
     f3e:	c8 01       	movw	r24, r16
     f40:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
     f44:	8c 01       	movw	r16, r24
     f46:	6e eb       	ldi	r22, 0xBE	; 190
     f48:	73 e0       	ldi	r23, 0x03	; 3
     f4a:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
     f4e:	66 e0       	ldi	r22, 0x06	; 6
     f50:	c8 01       	movw	r24, r16
     f52:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     f56:	6a e0       	ldi	r22, 0x0A	; 10
     f58:	8e 81       	ldd	r24, Y+6	; 0x06
     f5a:	9f 81       	ldd	r25, Y+7	; 0x07
     f5c:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
     f60:	8c 01       	movw	r16, r24
     f62:	67 ea       	ldi	r22, 0xA7	; 167
     f64:	73 e0       	ldi	r23, 0x03	; 3
     f66:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
     f6a:	66 e0       	ldi	r22, 0x06	; 6
     f6c:	c8 01       	movw	r24, r16
     f6e:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     f72:	6a e0       	ldi	r22, 0x0A	; 10
     f74:	8e 81       	ldd	r24, Y+6	; 0x06
     f76:	9f 81       	ldd	r25, Y+7	; 0x07
     f78:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
     f7c:	8c 01       	movw	r16, r24
     f7e:	6b e8       	ldi	r22, 0x8B	; 139
     f80:	73 e0       	ldi	r23, 0x03	; 3
     f82:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
     f86:	66 e0       	ldi	r22, 0x06	; 6
     f88:	c8 01       	movw	r24, r16
     f8a:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     f8e:	6a e0       	ldi	r22, 0x0A	; 10
     f90:	8e 81       	ldd	r24, Y+6	; 0x06
     f92:	9f 81       	ldd	r25, Y+7	; 0x07
     f94:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
     f98:	8c 01       	movw	r16, r24
     f9a:	63 e7       	ldi	r22, 0x73	; 115
     f9c:	73 e0       	ldi	r23, 0x03	; 3
     f9e:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
     fa2:	66 e0       	ldi	r22, 0x06	; 6
     fa4:	c8 01       	movw	r24, r16
     fa6:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     faa:	6a e0       	ldi	r22, 0x0A	; 10
     fac:	8e 81       	ldd	r24, Y+6	; 0x06
     fae:	9f 81       	ldd	r25, Y+7	; 0x07
     fb0:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
     fb4:	8c 01       	movw	r16, r24
     fb6:	62 e5       	ldi	r22, 0x52	; 82
     fb8:	73 e0       	ldi	r23, 0x03	; 3
     fba:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
     fbe:	66 e0       	ldi	r22, 0x06	; 6
     fc0:	c8 01       	movw	r24, r16
     fc2:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     fc6:	6a e0       	ldi	r22, 0x0A	; 10
     fc8:	8e 81       	ldd	r24, Y+6	; 0x06
     fca:	9f 81       	ldd	r25, Y+7	; 0x07
     fcc:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
     fd0:	8c 01       	movw	r16, r24
     fd2:	6b e2       	ldi	r22, 0x2B	; 43
     fd4:	73 e0       	ldi	r23, 0x03	; 3
     fd6:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
     fda:	66 e0       	ldi	r22, 0x06	; 6
     fdc:	c8 01       	movw	r24, r16
     fde:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     fe2:	6a e0       	ldi	r22, 0x0A	; 10
     fe4:	8e 81       	ldd	r24, Y+6	; 0x06
     fe6:	9f 81       	ldd	r25, Y+7	; 0x07
     fe8:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
     fec:	8c 01       	movw	r16, r24
     fee:	6d e0       	ldi	r22, 0x0D	; 13
     ff0:	73 e0       	ldi	r23, 0x03	; 3
     ff2:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
     ff6:	66 e0       	ldi	r22, 0x06	; 6
     ff8:	c8 01       	movw	r24, r16
     ffa:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     ffe:	6a e0       	ldi	r22, 0x0A	; 10
    1000:	8e 81       	ldd	r24, Y+6	; 0x06
    1002:	9f 81       	ldd	r25, Y+7	; 0x07
    1004:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    1008:	8c 01       	movw	r16, r24
    100a:	62 ef       	ldi	r22, 0xF2	; 242
    100c:	72 e0       	ldi	r23, 0x02	; 2
    100e:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    1012:	66 e0       	ldi	r22, 0x06	; 6
    1014:	c8 01       	movw	r24, r16
    1016:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    101a:	6a e0       	ldi	r22, 0x0A	; 10
    101c:	8e 81       	ldd	r24, Y+6	; 0x06
    101e:	9f 81       	ldd	r25, Y+7	; 0x07
    1020:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    1024:	ec 01       	movw	r28, r24
    1026:	63 ee       	ldi	r22, 0xE3	; 227
    1028:	72 e0       	ldi	r23, 0x02	; 2
    102a:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    102e:	66 e0       	ldi	r22, 0x06	; 6
    1030:	ce 01       	movw	r24, r28
    1032:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
}
    1036:	df 91       	pop	r29
    1038:	cf 91       	pop	r28
    103a:	1f 91       	pop	r17
    103c:	0f 91       	pop	r16
    103e:	08 95       	ret

00001040 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    1040:	af 92       	push	r10
    1042:	bf 92       	push	r11
    1044:	cf 92       	push	r12
    1046:	df 92       	push	r13
    1048:	ef 92       	push	r14
    104a:	ff 92       	push	r15
    104c:	0f 93       	push	r16
    104e:	1f 93       	push	r17
    1050:	cf 93       	push	r28
    1052:	df 93       	push	r29
    1054:	00 d0       	rcall	.+0      	; 0x1056 <_ZN9task_user11show_statusEv+0x16>
    1056:	00 d0       	rcall	.+0      	; 0x1058 <_ZN9task_user11show_statusEv+0x18>
    1058:	cd b7       	in	r28, 0x3d	; 61
    105a:	de b7       	in	r29, 0x3e	; 62
    105c:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    105e:	19 82       	std	Y+1, r1	; 0x01
    1060:	1a 82       	std	Y+2, r1	; 0x02
    1062:	1b 82       	std	Y+3, r1	; 0x03
    1064:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1066:	1d 82       	std	Y+5, r1	; 0x05
    1068:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    106a:	0e 94 a5 0a 	call	0x154a	; 0x154a <xPortGetFreeHeapSize>
    106e:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    1070:	ce 01       	movw	r24, r28
    1072:	01 96       	adiw	r24, 0x01	; 1
    1074:	0e 94 de 18 	call	0x31bc	; 0x31bc <_ZN10time_stamp10set_to_nowEv>
    1078:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    107a:	66 e0       	ldi	r22, 0x06	; 6
    107c:	f8 01       	movw	r30, r16
    107e:	86 81       	ldd	r24, Z+6	; 0x06
    1080:	97 81       	ldd	r25, Z+7	; 0x07
    1082:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    1086:	6a e0       	ldi	r22, 0x0A	; 10
    1088:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    108c:	7c 01       	movw	r14, r24
    108e:	64 ec       	ldi	r22, 0xC4	; 196
    1090:	72 e0       	ldi	r23, 0x02	; 2
    1092:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    1096:	6a e0       	ldi	r22, 0x0A	; 10
    1098:	c7 01       	movw	r24, r14
    109a:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    109e:	7c 01       	movw	r14, r24
    10a0:	68 eb       	ldi	r22, 0xB8	; 184
    10a2:	72 e0       	ldi	r23, 0x02	; 2
    10a4:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    10a8:	66 e0       	ldi	r22, 0x06	; 6
    10aa:	c7 01       	movw	r24, r14
    10ac:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    10b0:	6a e0       	ldi	r22, 0x0A	; 10
    10b2:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    10b6:	7c 01       	movw	r14, r24
    10b8:	61 eb       	ldi	r22, 0xB1	; 177
    10ba:	72 e0       	ldi	r23, 0x02	; 2
    10bc:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    10c0:	b5 01       	movw	r22, r10
    10c2:	c7 01       	movw	r24, r14
    10c4:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    10c8:	6a e0       	ldi	r22, 0x0A	; 10
    10ca:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    10ce:	7c 01       	movw	r14, r24
    10d0:	63 ea       	ldi	r22, 0xA3	; 163
    10d2:	72 e0       	ldi	r23, 0x02	; 2
    10d4:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    10d8:	b6 01       	movw	r22, r12
    10da:	c7 01       	movw	r24, r14
    10dc:	0e 94 02 1b 	call	0x3604	; 0x3604 <_ZN8emstreamlsEj>
    10e0:	6a e0       	ldi	r22, 0x0A	; 10
    10e2:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    10e6:	7c 01       	movw	r14, r24
    10e8:	61 ea       	ldi	r22, 0xA1	; 161
    10ea:	72 e0       	ldi	r23, 0x02	; 2
    10ec:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    10f0:	4f ef       	ldi	r20, 0xFF	; 255
    10f2:	5f e0       	ldi	r21, 0x0F	; 15
    10f4:	60 e0       	ldi	r22, 0x00	; 0
    10f6:	70 e0       	ldi	r23, 0x00	; 0
    10f8:	c7 01       	movw	r24, r14
    10fa:	0e 94 36 1b 	call	0x366c	; 0x366c <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    10fe:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1102:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1106:	6a e0       	ldi	r22, 0x0A	; 10
    1108:	f8 01       	movw	r30, r16
    110a:	86 81       	ldd	r24, Z+6	; 0x06
    110c:	97 81       	ldd	r25, Z+7	; 0x07
    110e:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    1112:	7c 01       	movw	r14, r24
    1114:	66 e9       	ldi	r22, 0x96	; 150
    1116:	72 e0       	ldi	r23, 0x02	; 2
    1118:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    111c:	b6 01       	movw	r22, r12
    111e:	c7 01       	movw	r24, r14
    1120:	0e 94 02 1b 	call	0x3604	; 0x3604 <_ZN8emstreamlsEj>
    1124:	66 e0       	ldi	r22, 0x06	; 6
    1126:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    112a:	66 e0       	ldi	r22, 0x06	; 6
    112c:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1130:	f8 01       	movw	r30, r16
    1132:	86 81       	ldd	r24, Z+6	; 0x06
    1134:	97 81       	ldd	r25, Z+7	; 0x07
    1136:	0e 94 3b 17 	call	0x2e76	; 0x2e76 <_Z15print_task_listP8emstream>
}
    113a:	26 96       	adiw	r28, 0x06	; 6
    113c:	cd bf       	out	0x3d, r28	; 61
    113e:	de bf       	out	0x3e, r29	; 62
    1140:	df 91       	pop	r29
    1142:	cf 91       	pop	r28
    1144:	1f 91       	pop	r17
    1146:	0f 91       	pop	r16
    1148:	ff 90       	pop	r15
    114a:	ef 90       	pop	r14
    114c:	df 90       	pop	r13
    114e:	cf 90       	pop	r12
    1150:	bf 90       	pop	r11
    1152:	af 90       	pop	r10
    1154:	08 95       	ret

00001156 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1156:	cf 93       	push	r28
    1158:	df 93       	push	r29
    115a:	00 d0       	rcall	.+0      	; 0x115c <_ZN9task_user3runEv+0x6>
    115c:	00 d0       	rcall	.+0      	; 0x115e <_ZN9task_user3runEv+0x8>
    115e:	cd b7       	in	r28, 0x3d	; 61
    1160:	de b7       	in	r29, 0x3e	; 62
    1162:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1164:	19 82       	std	Y+1, r1	; 0x01
    1166:	1a 82       	std	Y+2, r1	; 0x02
    1168:	1b 82       	std	Y+3, r1	; 0x03
    116a:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    116c:	1d 82       	std	Y+5, r1	; 0x05
    116e:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1170:	6a e0       	ldi	r22, 0x0A	; 10
    1172:	dc 01       	movw	r26, r24
    1174:	16 96       	adiw	r26, 0x06	; 6
    1176:	8d 91       	ld	r24, X+
    1178:	9c 91       	ld	r25, X
    117a:	17 97       	sbiw	r26, 0x07	; 7
    117c:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    1180:	7c 01       	movw	r14, r24
    1182:	62 e3       	ldi	r22, 0x32	; 50
    1184:	74 e0       	ldi	r23, 0x04	; 4
    1186:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    118a:	66 e0       	ldi	r22, 0x06	; 6
    118c:	c7 01       	movw	r24, r14
    118e:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1192:	f8 01       	movw	r30, r16
    1194:	84 85       	ldd	r24, Z+12	; 0x0c
    1196:	88 23       	and	r24, r24
    1198:	21 f0       	breq	.+8      	; 0x11a2 <_ZN9task_user3runEv+0x4c>
    119a:	81 30       	cpi	r24, 0x01	; 1
    119c:	09 f4       	brne	.+2      	; 0x11a0 <_ZN9task_user3runEv+0x4a>
    119e:	5d c0       	rjmp	.+186    	; 0x125a <_ZN9task_user3runEv+0x104>
    11a0:	d8 c0       	rjmp	.+432    	; 0x1352 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    11a2:	86 81       	ldd	r24, Z+6	; 0x06
    11a4:	97 81       	ldd	r25, Z+7	; 0x07
    11a6:	dc 01       	movw	r26, r24
    11a8:	ed 91       	ld	r30, X+
    11aa:	fc 91       	ld	r31, X
    11ac:	04 80       	ldd	r0, Z+4	; 0x04
    11ae:	f5 81       	ldd	r31, Z+5	; 0x05
    11b0:	e0 2d       	mov	r30, r0
    11b2:	19 95       	eicall
    11b4:	88 23       	and	r24, r24
    11b6:	a9 f1       	breq	.+106    	; 0x1222 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    11b8:	f8 01       	movw	r30, r16
    11ba:	86 81       	ldd	r24, Z+6	; 0x06
    11bc:	97 81       	ldd	r25, Z+7	; 0x07
    11be:	dc 01       	movw	r26, r24
    11c0:	ed 91       	ld	r30, X+
    11c2:	fc 91       	ld	r31, X
    11c4:	06 80       	ldd	r0, Z+6	; 0x06
    11c6:	f7 81       	ldd	r31, Z+7	; 0x07
    11c8:	e0 2d       	mov	r30, r0
    11ca:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    11cc:	99 27       	eor	r25, r25
    11ce:	81 30       	cpi	r24, 0x01	; 1
    11d0:	91 05       	cpc	r25, r1
    11d2:	f9 f0       	breq	.+62     	; 0x1212 <_ZN9task_user3runEv+0xbc>
    11d4:	03 97       	sbiw	r24, 0x03	; 3
    11d6:	09 f0       	breq	.+2      	; 0x11da <_ZN9task_user3runEv+0x84>
    11d8:	d8 c0       	rjmp	.+432    	; 0x138a <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    11da:	6a e0       	ldi	r22, 0x0A	; 10
    11dc:	f8 01       	movw	r30, r16
    11de:	86 81       	ldd	r24, Z+6	; 0x06
    11e0:	97 81       	ldd	r25, Z+7	; 0x07
    11e2:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    11e6:	8c 01       	movw	r16, r24
    11e8:	64 e2       	ldi	r22, 0x24	; 36
    11ea:	74 e0       	ldi	r23, 0x04	; 4
    11ec:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    11f0:	66 e0       	ldi	r22, 0x06	; 6
    11f2:	c8 01       	movw	r24, r16
    11f4:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    11f8:	93 e0       	ldi	r25, 0x03	; 3
    11fa:	88 ed       	ldi	r24, 0xD8	; 216
    11fc:	08 b6       	in	r0, 0x38	; 56
    11fe:	18 be       	out	0x38, r1	; 56
    1200:	84 bf       	out	0x34, r24	; 52
    1202:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1206:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    120a:	81 fd       	sbrc	r24, 1
    120c:	fc cf       	rjmp	.-8      	; 0x1206 <_ZN9task_user3runEv+0xb0>
    120e:	08 be       	out	0x38, r0	; 56
    1210:	ff cf       	rjmp	.-2      	; 0x1210 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1212:	c8 01       	movw	r24, r16
    1214:	0e 94 78 07 	call	0xef0	; 0xef0 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1218:	61 e0       	ldi	r22, 0x01	; 1
    121a:	c8 01       	movw	r24, r16
    121c:	0e 94 29 15 	call	0x2a52	; 0x2a52 <_ZN8frt_task13transition_toEh>
							break;
    1220:	b4 c0       	rjmp	.+360    	; 0x138a <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1222:	80 e5       	ldi	r24, 0x50	; 80
    1224:	91 e3       	ldi	r25, 0x31	; 49
    1226:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <_ZN14frt_text_queue14check_for_charEv>
    122a:	88 23       	and	r24, r24
    122c:	09 f4       	brne	.+2      	; 0x1230 <_ZN9task_user3runEv+0xda>
    122e:	ad c0       	rjmp	.+346    	; 0x138a <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1230:	d8 01       	movw	r26, r16
    1232:	16 96       	adiw	r26, 0x06	; 6
    1234:	ed 91       	ld	r30, X+
    1236:	fc 91       	ld	r31, X
    1238:	17 97       	sbiw	r26, 0x07	; 7
    123a:	01 90       	ld	r0, Z+
    123c:	f0 81       	ld	r31, Z
    123e:	e0 2d       	mov	r30, r0
    1240:	e2 80       	ldd	r14, Z+2	; 0x02
    1242:	f3 80       	ldd	r15, Z+3	; 0x03
    1244:	80 e5       	ldi	r24, 0x50	; 80
    1246:	91 e3       	ldi	r25, 0x31	; 49
    1248:	0e 94 cc 17 	call	0x2f98	; 0x2f98 <_ZN14frt_text_queue7getcharEv>
    124c:	68 2f       	mov	r22, r24
    124e:	f8 01       	movw	r30, r16
    1250:	86 81       	ldd	r24, Z+6	; 0x06
    1252:	97 81       	ldd	r25, Z+7	; 0x07
    1254:	f7 01       	movw	r30, r14
    1256:	19 95       	eicall
    1258:	98 c0       	rjmp	.+304    	; 0x138a <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    125a:	86 81       	ldd	r24, Z+6	; 0x06
    125c:	97 81       	ldd	r25, Z+7	; 0x07
    125e:	dc 01       	movw	r26, r24
    1260:	ed 91       	ld	r30, X+
    1262:	fc 91       	ld	r31, X
    1264:	04 80       	ldd	r0, Z+4	; 0x04
    1266:	f5 81       	ldd	r31, Z+5	; 0x05
    1268:	e0 2d       	mov	r30, r0
    126a:	19 95       	eicall
    126c:	88 23       	and	r24, r24
    126e:	09 f4       	brne	.+2      	; 0x1272 <_ZN9task_user3runEv+0x11c>
    1270:	8c c0       	rjmp	.+280    	; 0x138a <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1272:	f8 01       	movw	r30, r16
    1274:	86 81       	ldd	r24, Z+6	; 0x06
    1276:	97 81       	ldd	r25, Z+7	; 0x07
    1278:	dc 01       	movw	r26, r24
    127a:	ed 91       	ld	r30, X+
    127c:	fc 91       	ld	r31, X
    127e:	06 80       	ldd	r0, Z+6	; 0x06
    1280:	f7 81       	ldd	r31, Z+7	; 0x07
    1282:	e0 2d       	mov	r30, r0
    1284:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1286:	9c 01       	movw	r18, r24
    1288:	33 27       	eor	r19, r19
    128a:	28 36       	cpi	r18, 0x68	; 104
    128c:	31 05       	cpc	r19, r1
    128e:	59 f1       	breq	.+86     	; 0x12e6 <_ZN9task_user3runEv+0x190>
    1290:	3c f4       	brge	.+14     	; 0x12a0 <_ZN9task_user3runEv+0x14a>
    1292:	2b 31       	cpi	r18, 0x1B	; 27
    1294:	31 05       	cpc	r19, r1
    1296:	59 f1       	breq	.+86     	; 0x12ee <_ZN9task_user3runEv+0x198>
    1298:	25 36       	cpi	r18, 0x65	; 101
    129a:	31 05       	cpc	r19, r1
    129c:	41 f1       	breq	.+80     	; 0x12ee <_ZN9task_user3runEv+0x198>
    129e:	3b c0       	rjmp	.+118    	; 0x1316 <_ZN9task_user3runEv+0x1c0>
    12a0:	23 37       	cpi	r18, 0x73	; 115
    12a2:	31 05       	cpc	r19, r1
    12a4:	c1 f0       	breq	.+48     	; 0x12d6 <_ZN9task_user3runEv+0x180>
    12a6:	26 37       	cpi	r18, 0x76	; 118
    12a8:	31 05       	cpc	r19, r1
    12aa:	89 f0       	breq	.+34     	; 0x12ce <_ZN9task_user3runEv+0x178>
    12ac:	2e 36       	cpi	r18, 0x6E	; 110
    12ae:	31 05       	cpc	r19, r1
    12b0:	91 f5       	brne	.+100    	; 0x1316 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    12b2:	ce 01       	movw	r24, r28
    12b4:	01 96       	adiw	r24, 0x01	; 1
    12b6:	0e 94 de 18 	call	0x31bc	; 0x31bc <_ZN10time_stamp10set_to_nowEv>
    12ba:	bc 01       	movw	r22, r24
    12bc:	f8 01       	movw	r30, r16
    12be:	86 81       	ldd	r24, Z+6	; 0x06
    12c0:	97 81       	ldd	r25, Z+7	; 0x07
    12c2:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZlsR8emstreamR10time_stamp>
    12c6:	66 e0       	ldi	r22, 0x06	; 6
    12c8:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
							break;
    12cc:	5e c0       	rjmp	.+188    	; 0x138a <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    12ce:	c8 01       	movw	r24, r16
    12d0:	0e 94 20 08 	call	0x1040	; 0x1040 <_ZN9task_user11show_statusEv>
							break;
    12d4:	5a c0       	rjmp	.+180    	; 0x138a <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    12d6:	d8 01       	movw	r26, r16
    12d8:	16 96       	adiw	r26, 0x06	; 6
    12da:	8d 91       	ld	r24, X+
    12dc:	9c 91       	ld	r25, X
    12de:	17 97       	sbiw	r26, 0x07	; 7
    12e0:	0e 94 42 16 	call	0x2c84	; 0x2c84 <_Z17print_task_stacksP8emstream>
							break;
    12e4:	52 c0       	rjmp	.+164    	; 0x138a <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    12e6:	c8 01       	movw	r24, r16
    12e8:	0e 94 78 07 	call	0xef0	; 0xef0 <_ZN9task_user18print_help_messageEv>
							break;
    12ec:	4e c0       	rjmp	.+156    	; 0x138a <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    12ee:	6a e0       	ldi	r22, 0x0A	; 10
    12f0:	f8 01       	movw	r30, r16
    12f2:	86 81       	ldd	r24, Z+6	; 0x06
    12f4:	97 81       	ldd	r25, Z+7	; 0x07
    12f6:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    12fa:	7c 01       	movw	r14, r24
    12fc:	62 e1       	ldi	r22, 0x12	; 18
    12fe:	74 e0       	ldi	r23, 0x04	; 4
    1300:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    1304:	66 e0       	ldi	r22, 0x06	; 6
    1306:	c7 01       	movw	r24, r14
    1308:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    130c:	60 e0       	ldi	r22, 0x00	; 0
    130e:	c8 01       	movw	r24, r16
    1310:	0e 94 29 15 	call	0x2a52	; 0x2a52 <_ZN8frt_task13transition_toEh>
							break;
    1314:	3a c0       	rjmp	.+116    	; 0x138a <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1316:	f8 01       	movw	r30, r16
    1318:	a6 81       	ldd	r26, Z+6	; 0x06
    131a:	b7 81       	ldd	r27, Z+7	; 0x07
    131c:	ed 91       	ld	r30, X+
    131e:	fc 91       	ld	r31, X
    1320:	11 97       	sbiw	r26, 0x01	; 1
    1322:	02 80       	ldd	r0, Z+2	; 0x02
    1324:	f3 81       	ldd	r31, Z+3	; 0x03
    1326:	e0 2d       	mov	r30, r0
    1328:	68 2f       	mov	r22, r24
    132a:	cd 01       	movw	r24, r26
    132c:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    132e:	6a e0       	ldi	r22, 0x0A	; 10
    1330:	d8 01       	movw	r26, r16
    1332:	16 96       	adiw	r26, 0x06	; 6
    1334:	8d 91       	ld	r24, X+
    1336:	9c 91       	ld	r25, X
    1338:	17 97       	sbiw	r26, 0x07	; 7
    133a:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    133e:	7c 01       	movw	r14, r24
    1340:	6c e0       	ldi	r22, 0x0C	; 12
    1342:	74 e0       	ldi	r23, 0x04	; 4
    1344:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    1348:	66 e0       	ldi	r22, 0x06	; 6
    134a:	c7 01       	movw	r24, r14
    134c:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1350:	1c c0       	rjmp	.+56     	; 0x138a <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1352:	6a e0       	ldi	r22, 0x0A	; 10
    1354:	f8 01       	movw	r30, r16
    1356:	86 81       	ldd	r24, Z+6	; 0x06
    1358:	97 81       	ldd	r25, Z+7	; 0x07
    135a:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    135e:	8c 01       	movw	r16, r24
    1360:	6f ee       	ldi	r22, 0xEF	; 239
    1362:	73 e0       	ldi	r23, 0x03	; 3
    1364:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    1368:	66 e0       	ldi	r22, 0x06	; 6
    136a:	c8 01       	movw	r24, r16
    136c:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1370:	93 e0       	ldi	r25, 0x03	; 3
    1372:	88 ed       	ldi	r24, 0xD8	; 216
    1374:	08 b6       	in	r0, 0x38	; 56
    1376:	18 be       	out	0x38, r1	; 56
    1378:	84 bf       	out	0x34, r24	; 52
    137a:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    137e:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1382:	81 fd       	sbrc	r24, 1
    1384:	fc cf       	rjmp	.-8      	; 0x137e <_ZN9task_user3runEv+0x228>
    1386:	08 be       	out	0x38, r0	; 56
    1388:	ff cf       	rjmp	.-2      	; 0x1388 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    138a:	f8 01       	movw	r30, r16
    138c:	86 85       	ldd	r24, Z+14	; 0x0e
    138e:	97 85       	ldd	r25, Z+15	; 0x0f
    1390:	a0 89       	ldd	r26, Z+16	; 0x10
    1392:	b1 89       	ldd	r27, Z+17	; 0x11
    1394:	01 96       	adiw	r24, 0x01	; 1
    1396:	a1 1d       	adc	r26, r1
    1398:	b1 1d       	adc	r27, r1
    139a:	86 87       	std	Z+14, r24	; 0x0e
    139c:	97 87       	std	Z+15, r25	; 0x0f
    139e:	a0 8b       	std	Z+16, r26	; 0x10
    13a0:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    13a2:	61 e0       	ldi	r22, 0x01	; 1
    13a4:	70 e0       	ldi	r23, 0x00	; 0
    13a6:	80 e0       	ldi	r24, 0x00	; 0
    13a8:	90 e0       	ldi	r25, 0x00	; 0
    13aa:	0e 94 fd 12 	call	0x25fa	; 0x25fa <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    13ae:	f1 ce       	rjmp	.-542    	; 0x1192 <_ZN9task_user3runEv+0x3c>

000013b0 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    13b0:	0f 93       	push	r16
    13b2:	1f 93       	push	r17
    13b4:	cf 93       	push	r28
    13b6:	df 93       	push	r29
    13b8:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    13ba:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    13be:	80 91 bc 20 	lds	r24, 0x20BC	; 0x8020bc <__data_end>
    13c2:	81 11       	cpse	r24, r1
    13c4:	1d c0       	rjmp	.+58     	; 0x1400 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    13c6:	a1 ec       	ldi	r26, 0xC1	; 193
    13c8:	b0 e2       	ldi	r27, 0x20	; 32
    13ca:	e5 ec       	ldi	r30, 0xC5	; 197
    13cc:	f0 e2       	ldi	r31, 0x20	; 32
    13ce:	ed 93       	st	X+, r30
    13d0:	fc 93       	st	X, r31
    13d2:	11 97       	sbiw	r26, 0x01	; 1
    13d4:	12 96       	adiw	r26, 0x02	; 2
    13d6:	1d 92       	st	X+, r1
    13d8:	1c 92       	st	X, r1
    13da:	13 97       	sbiw	r26, 0x03	; 3
    13dc:	ad eb       	ldi	r26, 0xBD	; 189
    13de:	b0 e2       	ldi	r27, 0x20	; 32
    13e0:	8f ef       	ldi	r24, 0xFF	; 255
    13e2:	9f e0       	ldi	r25, 0x0F	; 15
    13e4:	12 96       	adiw	r26, 0x02	; 2
    13e6:	8d 93       	st	X+, r24
    13e8:	9c 93       	st	X, r25
    13ea:	13 97       	sbiw	r26, 0x03	; 3
    13ec:	1d 92       	st	X+, r1
    13ee:	1c 92       	st	X, r1
    13f0:	11 97       	sbiw	r26, 0x01	; 1
    13f2:	82 83       	std	Z+2, r24	; 0x02
    13f4:	93 83       	std	Z+3, r25	; 0x03
    13f6:	a0 83       	st	Z, r26
    13f8:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    13fa:	81 e0       	ldi	r24, 0x01	; 1
    13fc:	80 93 bc 20 	sts	0x20BC, r24	; 0x8020bc <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1400:	20 97       	sbiw	r28, 0x00	; 0
    1402:	09 f4       	brne	.+2      	; 0x1406 <pvPortMalloc+0x56>
    1404:	5f c0       	rjmp	.+190    	; 0x14c4 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1406:	9e 01       	movw	r18, r28
    1408:	2b 5f       	subi	r18, 0xFB	; 251
    140a:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    140c:	24 96       	adiw	r28, 0x04	; 4
    140e:	ce 3f       	cpi	r28, 0xFE	; 254
    1410:	df 40       	sbci	r29, 0x0F	; 15
    1412:	08 f0       	brcs	.+2      	; 0x1416 <pvPortMalloc+0x66>
    1414:	5a c0       	rjmp	.+180    	; 0x14ca <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1416:	e0 91 c1 20 	lds	r30, 0x20C1	; 0x8020c1 <xStart>
    141a:	f0 91 c2 20 	lds	r31, 0x20C2	; 0x8020c2 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    141e:	a1 ec       	ldi	r26, 0xC1	; 193
    1420:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1422:	02 c0       	rjmp	.+4      	; 0x1428 <pvPortMalloc+0x78>
    1424:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1426:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1428:	82 81       	ldd	r24, Z+2	; 0x02
    142a:	93 81       	ldd	r25, Z+3	; 0x03
    142c:	82 17       	cp	r24, r18
    142e:	93 07       	cpc	r25, r19
    1430:	20 f4       	brcc	.+8      	; 0x143a <pvPortMalloc+0x8a>
    1432:	80 81       	ld	r24, Z
    1434:	91 81       	ldd	r25, Z+1	; 0x01
    1436:	00 97       	sbiw	r24, 0x00	; 0
    1438:	a9 f7       	brne	.-22     	; 0x1424 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    143a:	c0 e2       	ldi	r28, 0x20	; 32
    143c:	ed 3b       	cpi	r30, 0xBD	; 189
    143e:	fc 07       	cpc	r31, r28
    1440:	09 f4       	brne	.+2      	; 0x1444 <pvPortMalloc+0x94>
    1442:	46 c0       	rjmp	.+140    	; 0x14d0 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1444:	cd 91       	ld	r28, X+
    1446:	dc 91       	ld	r29, X
    1448:	11 97       	sbiw	r26, 0x01	; 1
    144a:	8e 01       	movw	r16, r28
    144c:	0b 5f       	subi	r16, 0xFB	; 251
    144e:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1450:	80 81       	ld	r24, Z
    1452:	91 81       	ldd	r25, Z+1	; 0x01
    1454:	8d 93       	st	X+, r24
    1456:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1458:	82 81       	ldd	r24, Z+2	; 0x02
    145a:	93 81       	ldd	r25, Z+3	; 0x03
    145c:	82 1b       	sub	r24, r18
    145e:	93 0b       	sbc	r25, r19
    1460:	8b 30       	cpi	r24, 0x0B	; 11
    1462:	91 05       	cpc	r25, r1
    1464:	10 f1       	brcs	.+68     	; 0x14aa <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1466:	bf 01       	movw	r22, r30
    1468:	62 0f       	add	r22, r18
    146a:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    146c:	db 01       	movw	r26, r22
    146e:	12 96       	adiw	r26, 0x02	; 2
    1470:	8d 93       	st	X+, r24
    1472:	9c 93       	st	X, r25
    1474:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1476:	22 83       	std	Z+2, r18	; 0x02
    1478:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    147a:	12 96       	adiw	r26, 0x02	; 2
    147c:	4d 91       	ld	r20, X+
    147e:	5c 91       	ld	r21, X
    1480:	13 97       	sbiw	r26, 0x03	; 3
    1482:	81 ec       	ldi	r24, 0xC1	; 193
    1484:	90 e2       	ldi	r25, 0x20	; 32
    1486:	01 c0       	rjmp	.+2      	; 0x148a <pvPortMalloc+0xda>
    1488:	cd 01       	movw	r24, r26
    148a:	ec 01       	movw	r28, r24
    148c:	a8 81       	ld	r26, Y
    148e:	b9 81       	ldd	r27, Y+1	; 0x01
    1490:	12 96       	adiw	r26, 0x02	; 2
    1492:	2d 91       	ld	r18, X+
    1494:	3c 91       	ld	r19, X
    1496:	13 97       	sbiw	r26, 0x03	; 3
    1498:	24 17       	cp	r18, r20
    149a:	35 07       	cpc	r19, r21
    149c:	a8 f3       	brcs	.-22     	; 0x1488 <pvPortMalloc+0xd8>
    149e:	eb 01       	movw	r28, r22
    14a0:	a8 83       	st	Y, r26
    14a2:	b9 83       	std	Y+1, r27	; 0x01
    14a4:	dc 01       	movw	r26, r24
    14a6:	6d 93       	st	X+, r22
    14a8:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    14aa:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    14ae:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    14b2:	22 81       	ldd	r18, Z+2	; 0x02
    14b4:	33 81       	ldd	r19, Z+3	; 0x03
    14b6:	82 1b       	sub	r24, r18
    14b8:	93 0b       	sbc	r25, r19
    14ba:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    14be:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    14c2:	08 c0       	rjmp	.+16     	; 0x14d4 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    14c4:	00 e0       	ldi	r16, 0x00	; 0
    14c6:	10 e0       	ldi	r17, 0x00	; 0
    14c8:	05 c0       	rjmp	.+10     	; 0x14d4 <pvPortMalloc+0x124>
    14ca:	00 e0       	ldi	r16, 0x00	; 0
    14cc:	10 e0       	ldi	r17, 0x00	; 0
    14ce:	02 c0       	rjmp	.+4      	; 0x14d4 <pvPortMalloc+0x124>
    14d0:	00 e0       	ldi	r16, 0x00	; 0
    14d2:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    14d4:	0e 94 0e 12 	call	0x241c	; 0x241c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    14d8:	c8 01       	movw	r24, r16
    14da:	df 91       	pop	r29
    14dc:	cf 91       	pop	r28
    14de:	1f 91       	pop	r17
    14e0:	0f 91       	pop	r16
    14e2:	08 95       	ret

000014e4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    14e4:	0f 93       	push	r16
    14e6:	1f 93       	push	r17
    14e8:	cf 93       	push	r28
    14ea:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    14ec:	00 97       	sbiw	r24, 0x00	; 0
    14ee:	41 f1       	breq	.+80     	; 0x1540 <vPortFree+0x5c>
    14f0:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    14f2:	8c 01       	movw	r16, r24
    14f4:	05 50       	subi	r16, 0x05	; 5
    14f6:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    14f8:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    14fc:	f8 01       	movw	r30, r16
    14fe:	42 81       	ldd	r20, Z+2	; 0x02
    1500:	53 81       	ldd	r21, Z+3	; 0x03
    1502:	a1 ec       	ldi	r26, 0xC1	; 193
    1504:	b0 e2       	ldi	r27, 0x20	; 32
    1506:	01 c0       	rjmp	.+2      	; 0x150a <vPortFree+0x26>
    1508:	df 01       	movw	r26, r30
    150a:	ed 91       	ld	r30, X+
    150c:	fc 91       	ld	r31, X
    150e:	11 97       	sbiw	r26, 0x01	; 1
    1510:	22 81       	ldd	r18, Z+2	; 0x02
    1512:	33 81       	ldd	r19, Z+3	; 0x03
    1514:	24 17       	cp	r18, r20
    1516:	35 07       	cpc	r19, r21
    1518:	b8 f3       	brcs	.-18     	; 0x1508 <vPortFree+0x24>
    151a:	25 97       	sbiw	r28, 0x05	; 5
    151c:	e8 83       	st	Y, r30
    151e:	f9 83       	std	Y+1, r31	; 0x01
    1520:	0d 93       	st	X+, r16
    1522:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1524:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1528:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    152c:	8a 81       	ldd	r24, Y+2	; 0x02
    152e:	9b 81       	ldd	r25, Y+3	; 0x03
    1530:	82 0f       	add	r24, r18
    1532:	93 1f       	adc	r25, r19
    1534:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1538:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    153c:	0e 94 0e 12 	call	0x241c	; 0x241c <xTaskResumeAll>
	}
}
    1540:	df 91       	pop	r29
    1542:	cf 91       	pop	r28
    1544:	1f 91       	pop	r17
    1546:	0f 91       	pop	r16
    1548:	08 95       	ret

0000154a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    154a:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    154e:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1552:	08 95       	ret

00001554 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1554:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1556:	03 96       	adiw	r24, 0x03	; 3
    1558:	81 83       	std	Z+1, r24	; 0x01
    155a:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    155c:	4f ef       	ldi	r20, 0xFF	; 255
    155e:	5f ef       	ldi	r21, 0xFF	; 255
    1560:	ba 01       	movw	r22, r20
    1562:	43 83       	std	Z+3, r20	; 0x03
    1564:	54 83       	std	Z+4, r21	; 0x04
    1566:	65 83       	std	Z+5, r22	; 0x05
    1568:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    156a:	87 83       	std	Z+7, r24	; 0x07
    156c:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    156e:	81 87       	std	Z+9, r24	; 0x09
    1570:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1572:	10 82       	st	Z, r1
    1574:	08 95       	ret

00001576 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1576:	fc 01       	movw	r30, r24
    1578:	12 86       	std	Z+10, r1	; 0x0a
    157a:	13 86       	std	Z+11, r1	; 0x0b
    157c:	08 95       	ret

0000157e <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	fc 01       	movw	r30, r24
    1584:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1586:	21 81       	ldd	r18, Z+1	; 0x01
    1588:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    158a:	e9 01       	movw	r28, r18
    158c:	8c 81       	ldd	r24, Y+4	; 0x04
    158e:	9d 81       	ldd	r25, Y+5	; 0x05
    1590:	14 96       	adiw	r26, 0x04	; 4
    1592:	8d 93       	st	X+, r24
    1594:	9c 93       	st	X, r25
    1596:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1598:	81 81       	ldd	r24, Z+1	; 0x01
    159a:	92 81       	ldd	r25, Z+2	; 0x02
    159c:	16 96       	adiw	r26, 0x06	; 6
    159e:	8d 93       	st	X+, r24
    15a0:	9c 93       	st	X, r25
    15a2:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    15a4:	8c 81       	ldd	r24, Y+4	; 0x04
    15a6:	9d 81       	ldd	r25, Y+5	; 0x05
    15a8:	ec 01       	movw	r28, r24
    15aa:	6e 83       	std	Y+6, r22	; 0x06
    15ac:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    15ae:	e9 01       	movw	r28, r18
    15b0:	6c 83       	std	Y+4, r22	; 0x04
    15b2:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    15b4:	61 83       	std	Z+1, r22	; 0x01
    15b6:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    15b8:	1a 96       	adiw	r26, 0x0a	; 10
    15ba:	ed 93       	st	X+, r30
    15bc:	fc 93       	st	X, r31
    15be:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    15c0:	80 81       	ld	r24, Z
    15c2:	8f 5f       	subi	r24, 0xFF	; 255
    15c4:	80 83       	st	Z, r24
}
    15c6:	df 91       	pop	r29
    15c8:	cf 91       	pop	r28
    15ca:	08 95       	ret

000015cc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    15cc:	0f 93       	push	r16
    15ce:	1f 93       	push	r17
    15d0:	cf 93       	push	r28
    15d2:	df 93       	push	r29
    15d4:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    15d6:	08 81       	ld	r16, Y
    15d8:	19 81       	ldd	r17, Y+1	; 0x01
    15da:	2a 81       	ldd	r18, Y+2	; 0x02
    15dc:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    15de:	0f 3f       	cpi	r16, 0xFF	; 255
    15e0:	4f ef       	ldi	r20, 0xFF	; 255
    15e2:	14 07       	cpc	r17, r20
    15e4:	24 07       	cpc	r18, r20
    15e6:	34 07       	cpc	r19, r20
    15e8:	31 f4       	brne	.+12     	; 0x15f6 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    15ea:	dc 01       	movw	r26, r24
    15ec:	19 96       	adiw	r26, 0x09	; 9
    15ee:	ed 91       	ld	r30, X+
    15f0:	fc 91       	ld	r31, X
    15f2:	1a 97       	sbiw	r26, 0x0a	; 10
    15f4:	1f c0       	rjmp	.+62     	; 0x1634 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    15f6:	fc 01       	movw	r30, r24
    15f8:	33 96       	adiw	r30, 0x03	; 3
    15fa:	dc 01       	movw	r26, r24
    15fc:	17 96       	adiw	r26, 0x07	; 7
    15fe:	4d 91       	ld	r20, X+
    1600:	5c 91       	ld	r21, X
    1602:	18 97       	sbiw	r26, 0x08	; 8
    1604:	da 01       	movw	r26, r20
    1606:	4d 91       	ld	r20, X+
    1608:	5d 91       	ld	r21, X+
    160a:	6d 91       	ld	r22, X+
    160c:	7c 91       	ld	r23, X
    160e:	04 17       	cp	r16, r20
    1610:	15 07       	cpc	r17, r21
    1612:	26 07       	cpc	r18, r22
    1614:	37 07       	cpc	r19, r23
    1616:	70 f0       	brcs	.+28     	; 0x1634 <vListInsert+0x68>
    1618:	04 80       	ldd	r0, Z+4	; 0x04
    161a:	f5 81       	ldd	r31, Z+5	; 0x05
    161c:	e0 2d       	mov	r30, r0
    161e:	a4 81       	ldd	r26, Z+4	; 0x04
    1620:	b5 81       	ldd	r27, Z+5	; 0x05
    1622:	4d 91       	ld	r20, X+
    1624:	5d 91       	ld	r21, X+
    1626:	6d 91       	ld	r22, X+
    1628:	7c 91       	ld	r23, X
    162a:	04 17       	cp	r16, r20
    162c:	15 07       	cpc	r17, r21
    162e:	26 07       	cpc	r18, r22
    1630:	37 07       	cpc	r19, r23
    1632:	90 f7       	brcc	.-28     	; 0x1618 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1634:	a4 81       	ldd	r26, Z+4	; 0x04
    1636:	b5 81       	ldd	r27, Z+5	; 0x05
    1638:	ac 83       	std	Y+4, r26	; 0x04
    163a:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    163c:	16 96       	adiw	r26, 0x06	; 6
    163e:	cd 93       	st	X+, r28
    1640:	dc 93       	st	X, r29
    1642:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1644:	ee 83       	std	Y+6, r30	; 0x06
    1646:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1648:	c4 83       	std	Z+4, r28	; 0x04
    164a:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    164c:	8a 87       	std	Y+10, r24	; 0x0a
    164e:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1650:	fc 01       	movw	r30, r24
    1652:	20 81       	ld	r18, Z
    1654:	2f 5f       	subi	r18, 0xFF	; 255
    1656:	20 83       	st	Z, r18
}
    1658:	df 91       	pop	r29
    165a:	cf 91       	pop	r28
    165c:	1f 91       	pop	r17
    165e:	0f 91       	pop	r16
    1660:	08 95       	ret

00001662 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1662:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1664:	a4 81       	ldd	r26, Z+4	; 0x04
    1666:	b5 81       	ldd	r27, Z+5	; 0x05
    1668:	86 81       	ldd	r24, Z+6	; 0x06
    166a:	97 81       	ldd	r25, Z+7	; 0x07
    166c:	16 96       	adiw	r26, 0x06	; 6
    166e:	8d 93       	st	X+, r24
    1670:	9c 93       	st	X, r25
    1672:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1674:	a6 81       	ldd	r26, Z+6	; 0x06
    1676:	b7 81       	ldd	r27, Z+7	; 0x07
    1678:	84 81       	ldd	r24, Z+4	; 0x04
    167a:	95 81       	ldd	r25, Z+5	; 0x05
    167c:	14 96       	adiw	r26, 0x04	; 4
    167e:	8d 93       	st	X+, r24
    1680:	9c 93       	st	X, r25
    1682:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1684:	a2 85       	ldd	r26, Z+10	; 0x0a
    1686:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1688:	11 96       	adiw	r26, 0x01	; 1
    168a:	8d 91       	ld	r24, X+
    168c:	9c 91       	ld	r25, X
    168e:	12 97       	sbiw	r26, 0x02	; 2
    1690:	e8 17       	cp	r30, r24
    1692:	f9 07       	cpc	r31, r25
    1694:	31 f4       	brne	.+12     	; 0x16a2 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1696:	86 81       	ldd	r24, Z+6	; 0x06
    1698:	97 81       	ldd	r25, Z+7	; 0x07
    169a:	11 96       	adiw	r26, 0x01	; 1
    169c:	8d 93       	st	X+, r24
    169e:	9c 93       	st	X, r25
    16a0:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    16a2:	12 86       	std	Z+10, r1	; 0x0a
    16a4:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    16a6:	8c 91       	ld	r24, X
    16a8:	81 50       	subi	r24, 0x01	; 1
    16aa:	8c 93       	st	X, r24
    16ac:	08 95       	ret

000016ae <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    16ae:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <portStackTopForTask>
    16b2:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <portStackTopForTask+0x1>
    16b6:	31 e1       	ldi	r19, 0x11	; 17
    16b8:	fc 01       	movw	r30, r24
    16ba:	30 83       	st	Z, r19
    16bc:	31 97       	sbiw	r30, 0x01	; 1
    16be:	22 e2       	ldi	r18, 0x22	; 34
    16c0:	20 83       	st	Z, r18
    16c2:	31 97       	sbiw	r30, 0x01	; 1
    16c4:	a3 e3       	ldi	r26, 0x33	; 51
    16c6:	a0 83       	st	Z, r26
    16c8:	31 97       	sbiw	r30, 0x01	; 1
    16ca:	60 83       	st	Z, r22
    16cc:	31 97       	sbiw	r30, 0x01	; 1
    16ce:	70 83       	st	Z, r23
    16d0:	31 97       	sbiw	r30, 0x01	; 1
    16d2:	10 82       	st	Z, r1
    16d4:	31 97       	sbiw	r30, 0x01	; 1
    16d6:	10 82       	st	Z, r1
    16d8:	31 97       	sbiw	r30, 0x01	; 1
    16da:	60 e8       	ldi	r22, 0x80	; 128
    16dc:	60 83       	st	Z, r22
    16de:	31 97       	sbiw	r30, 0x01	; 1
    16e0:	10 82       	st	Z, r1
    16e2:	31 97       	sbiw	r30, 0x01	; 1
    16e4:	10 82       	st	Z, r1
    16e6:	31 97       	sbiw	r30, 0x01	; 1
    16e8:	10 82       	st	Z, r1
    16ea:	31 97       	sbiw	r30, 0x01	; 1
    16ec:	62 e0       	ldi	r22, 0x02	; 2
    16ee:	60 83       	st	Z, r22
    16f0:	31 97       	sbiw	r30, 0x01	; 1
    16f2:	63 e0       	ldi	r22, 0x03	; 3
    16f4:	60 83       	st	Z, r22
    16f6:	31 97       	sbiw	r30, 0x01	; 1
    16f8:	64 e0       	ldi	r22, 0x04	; 4
    16fa:	60 83       	st	Z, r22
    16fc:	31 97       	sbiw	r30, 0x01	; 1
    16fe:	65 e0       	ldi	r22, 0x05	; 5
    1700:	60 83       	st	Z, r22
    1702:	31 97       	sbiw	r30, 0x01	; 1
    1704:	66 e0       	ldi	r22, 0x06	; 6
    1706:	60 83       	st	Z, r22
    1708:	31 97       	sbiw	r30, 0x01	; 1
    170a:	67 e0       	ldi	r22, 0x07	; 7
    170c:	60 83       	st	Z, r22
    170e:	31 97       	sbiw	r30, 0x01	; 1
    1710:	68 e0       	ldi	r22, 0x08	; 8
    1712:	60 83       	st	Z, r22
    1714:	31 97       	sbiw	r30, 0x01	; 1
    1716:	69 e0       	ldi	r22, 0x09	; 9
    1718:	60 83       	st	Z, r22
    171a:	31 97       	sbiw	r30, 0x01	; 1
    171c:	60 e1       	ldi	r22, 0x10	; 16
    171e:	60 83       	st	Z, r22
    1720:	31 97       	sbiw	r30, 0x01	; 1
    1722:	30 83       	st	Z, r19
    1724:	31 97       	sbiw	r30, 0x01	; 1
    1726:	32 e1       	ldi	r19, 0x12	; 18
    1728:	30 83       	st	Z, r19
    172a:	31 97       	sbiw	r30, 0x01	; 1
    172c:	33 e1       	ldi	r19, 0x13	; 19
    172e:	30 83       	st	Z, r19
    1730:	31 97       	sbiw	r30, 0x01	; 1
    1732:	34 e1       	ldi	r19, 0x14	; 20
    1734:	30 83       	st	Z, r19
    1736:	31 97       	sbiw	r30, 0x01	; 1
    1738:	35 e1       	ldi	r19, 0x15	; 21
    173a:	30 83       	st	Z, r19
    173c:	31 97       	sbiw	r30, 0x01	; 1
    173e:	36 e1       	ldi	r19, 0x16	; 22
    1740:	30 83       	st	Z, r19
    1742:	31 97       	sbiw	r30, 0x01	; 1
    1744:	37 e1       	ldi	r19, 0x17	; 23
    1746:	30 83       	st	Z, r19
    1748:	31 97       	sbiw	r30, 0x01	; 1
    174a:	38 e1       	ldi	r19, 0x18	; 24
    174c:	30 83       	st	Z, r19
    174e:	31 97       	sbiw	r30, 0x01	; 1
    1750:	39 e1       	ldi	r19, 0x19	; 25
    1752:	30 83       	st	Z, r19
    1754:	31 97       	sbiw	r30, 0x01	; 1
    1756:	30 e2       	ldi	r19, 0x20	; 32
    1758:	30 83       	st	Z, r19
    175a:	31 97       	sbiw	r30, 0x01	; 1
    175c:	31 e2       	ldi	r19, 0x21	; 33
    175e:	30 83       	st	Z, r19
    1760:	31 97       	sbiw	r30, 0x01	; 1
    1762:	20 83       	st	Z, r18
    1764:	31 97       	sbiw	r30, 0x01	; 1
    1766:	23 e2       	ldi	r18, 0x23	; 35
    1768:	20 83       	st	Z, r18
    176a:	31 97       	sbiw	r30, 0x01	; 1
    176c:	40 83       	st	Z, r20
    176e:	31 97       	sbiw	r30, 0x01	; 1
    1770:	50 83       	st	Z, r21
    1772:	31 97       	sbiw	r30, 0x01	; 1
    1774:	26 e2       	ldi	r18, 0x26	; 38
    1776:	20 83       	st	Z, r18
    1778:	31 97       	sbiw	r30, 0x01	; 1
    177a:	27 e2       	ldi	r18, 0x27	; 39
    177c:	20 83       	st	Z, r18
    177e:	31 97       	sbiw	r30, 0x01	; 1
    1780:	28 e2       	ldi	r18, 0x28	; 40
    1782:	20 83       	st	Z, r18
    1784:	31 97       	sbiw	r30, 0x01	; 1
    1786:	29 e2       	ldi	r18, 0x29	; 41
    1788:	20 83       	st	Z, r18
    178a:	31 97       	sbiw	r30, 0x01	; 1
    178c:	20 e3       	ldi	r18, 0x30	; 48
    178e:	20 83       	st	Z, r18
    1790:	31 97       	sbiw	r30, 0x01	; 1
    1792:	21 e3       	ldi	r18, 0x31	; 49
    1794:	20 83       	st	Z, r18
    1796:	89 97       	sbiw	r24, 0x29	; 41
    1798:	08 95       	ret

0000179a <xPortStartScheduler>:
    179a:	8c e7       	ldi	r24, 0x7C	; 124
    179c:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    17a0:	8f ef       	ldi	r24, 0xFF	; 255
    17a2:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    17a6:	81 e0       	ldi	r24, 0x01	; 1
    17a8:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    17ac:	91 e1       	ldi	r25, 0x11	; 17
    17ae:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    17b2:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    17b6:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    17ba:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    17be:	cd 91       	ld	r28, X+
    17c0:	cd bf       	out	0x3d, r28	; 61
    17c2:	dd 91       	ld	r29, X+
    17c4:	de bf       	out	0x3e, r29	; 62
    17c6:	ff 91       	pop	r31
    17c8:	ef 91       	pop	r30
    17ca:	df 91       	pop	r29
    17cc:	cf 91       	pop	r28
    17ce:	bf 91       	pop	r27
    17d0:	af 91       	pop	r26
    17d2:	9f 91       	pop	r25
    17d4:	8f 91       	pop	r24
    17d6:	7f 91       	pop	r23
    17d8:	6f 91       	pop	r22
    17da:	5f 91       	pop	r21
    17dc:	4f 91       	pop	r20
    17de:	3f 91       	pop	r19
    17e0:	2f 91       	pop	r18
    17e2:	1f 91       	pop	r17
    17e4:	0f 91       	pop	r16
    17e6:	ff 90       	pop	r15
    17e8:	ef 90       	pop	r14
    17ea:	df 90       	pop	r13
    17ec:	cf 90       	pop	r12
    17ee:	bf 90       	pop	r11
    17f0:	af 90       	pop	r10
    17f2:	9f 90       	pop	r9
    17f4:	8f 90       	pop	r8
    17f6:	7f 90       	pop	r7
    17f8:	6f 90       	pop	r6
    17fa:	5f 90       	pop	r5
    17fc:	4f 90       	pop	r4
    17fe:	3f 90       	pop	r3
    1800:	2f 90       	pop	r2
    1802:	1f 90       	pop	r1
    1804:	0f 90       	pop	r0
    1806:	0c be       	out	0x3c, r0	; 60
    1808:	0f 90       	pop	r0
    180a:	0b be       	out	0x3b, r0	; 59
    180c:	0f 90       	pop	r0
    180e:	0f be       	out	0x3f, r0	; 63
    1810:	0f 90       	pop	r0
    1812:	08 95       	ret
    1814:	08 95       	ret

00001816 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1816:	0f 92       	push	r0
    1818:	0f b6       	in	r0, 0x3f	; 63
    181a:	f8 94       	cli
    181c:	0f 92       	push	r0
    181e:	0b b6       	in	r0, 0x3b	; 59
    1820:	0f 92       	push	r0
    1822:	0c b6       	in	r0, 0x3c	; 60
    1824:	0f 92       	push	r0
    1826:	1f 92       	push	r1
    1828:	11 24       	eor	r1, r1
    182a:	2f 92       	push	r2
    182c:	3f 92       	push	r3
    182e:	4f 92       	push	r4
    1830:	5f 92       	push	r5
    1832:	6f 92       	push	r6
    1834:	7f 92       	push	r7
    1836:	8f 92       	push	r8
    1838:	9f 92       	push	r9
    183a:	af 92       	push	r10
    183c:	bf 92       	push	r11
    183e:	cf 92       	push	r12
    1840:	df 92       	push	r13
    1842:	ef 92       	push	r14
    1844:	ff 92       	push	r15
    1846:	0f 93       	push	r16
    1848:	1f 93       	push	r17
    184a:	2f 93       	push	r18
    184c:	3f 93       	push	r19
    184e:	4f 93       	push	r20
    1850:	5f 93       	push	r21
    1852:	6f 93       	push	r22
    1854:	7f 93       	push	r23
    1856:	8f 93       	push	r24
    1858:	9f 93       	push	r25
    185a:	af 93       	push	r26
    185c:	bf 93       	push	r27
    185e:	cf 93       	push	r28
    1860:	df 93       	push	r29
    1862:	ef 93       	push	r30
    1864:	ff 93       	push	r31
    1866:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    186a:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    186e:	0d b6       	in	r0, 0x3d	; 61
    1870:	0d 92       	st	X+, r0
    1872:	0e b6       	in	r0, 0x3e	; 62
    1874:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1876:	0e 94 2b 13 	call	0x2656	; 0x2656 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    187a:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    187e:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1882:	cd 91       	ld	r28, X+
    1884:	cd bf       	out	0x3d, r28	; 61
    1886:	dd 91       	ld	r29, X+
    1888:	de bf       	out	0x3e, r29	; 62
    188a:	ff 91       	pop	r31
    188c:	ef 91       	pop	r30
    188e:	df 91       	pop	r29
    1890:	cf 91       	pop	r28
    1892:	bf 91       	pop	r27
    1894:	af 91       	pop	r26
    1896:	9f 91       	pop	r25
    1898:	8f 91       	pop	r24
    189a:	7f 91       	pop	r23
    189c:	6f 91       	pop	r22
    189e:	5f 91       	pop	r21
    18a0:	4f 91       	pop	r20
    18a2:	3f 91       	pop	r19
    18a4:	2f 91       	pop	r18
    18a6:	1f 91       	pop	r17
    18a8:	0f 91       	pop	r16
    18aa:	ff 90       	pop	r15
    18ac:	ef 90       	pop	r14
    18ae:	df 90       	pop	r13
    18b0:	cf 90       	pop	r12
    18b2:	bf 90       	pop	r11
    18b4:	af 90       	pop	r10
    18b6:	9f 90       	pop	r9
    18b8:	8f 90       	pop	r8
    18ba:	7f 90       	pop	r7
    18bc:	6f 90       	pop	r6
    18be:	5f 90       	pop	r5
    18c0:	4f 90       	pop	r4
    18c2:	3f 90       	pop	r3
    18c4:	2f 90       	pop	r2
    18c6:	1f 90       	pop	r1
    18c8:	0f 90       	pop	r0
    18ca:	0c be       	out	0x3c, r0	; 60
    18cc:	0f 90       	pop	r0
    18ce:	0b be       	out	0x3b, r0	; 59
    18d0:	0f 90       	pop	r0
    18d2:	0f be       	out	0x3f, r0	; 63
    18d4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    18d6:	08 95       	ret

000018d8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    18d8:	0f 92       	push	r0
    18da:	0f b6       	in	r0, 0x3f	; 63
    18dc:	f8 94       	cli
    18de:	0f 92       	push	r0
    18e0:	0b b6       	in	r0, 0x3b	; 59
    18e2:	0f 92       	push	r0
    18e4:	0c b6       	in	r0, 0x3c	; 60
    18e6:	0f 92       	push	r0
    18e8:	1f 92       	push	r1
    18ea:	11 24       	eor	r1, r1
    18ec:	2f 92       	push	r2
    18ee:	3f 92       	push	r3
    18f0:	4f 92       	push	r4
    18f2:	5f 92       	push	r5
    18f4:	6f 92       	push	r6
    18f6:	7f 92       	push	r7
    18f8:	8f 92       	push	r8
    18fa:	9f 92       	push	r9
    18fc:	af 92       	push	r10
    18fe:	bf 92       	push	r11
    1900:	cf 92       	push	r12
    1902:	df 92       	push	r13
    1904:	ef 92       	push	r14
    1906:	ff 92       	push	r15
    1908:	0f 93       	push	r16
    190a:	1f 93       	push	r17
    190c:	2f 93       	push	r18
    190e:	3f 93       	push	r19
    1910:	4f 93       	push	r20
    1912:	5f 93       	push	r21
    1914:	6f 93       	push	r22
    1916:	7f 93       	push	r23
    1918:	8f 93       	push	r24
    191a:	9f 93       	push	r25
    191c:	af 93       	push	r26
    191e:	bf 93       	push	r27
    1920:	cf 93       	push	r28
    1922:	df 93       	push	r29
    1924:	ef 93       	push	r30
    1926:	ff 93       	push	r31
    1928:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    192c:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1930:	0d b6       	in	r0, 0x3d	; 61
    1932:	0d 92       	st	X+, r0
    1934:	0e b6       	in	r0, 0x3e	; 62
    1936:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1938:	0e 94 0d 11 	call	0x221a	; 0x221a <vTaskIncrementTick>
	vTaskSwitchContext();
    193c:	0e 94 2b 13 	call	0x2656	; 0x2656 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1940:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1944:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1948:	cd 91       	ld	r28, X+
    194a:	cd bf       	out	0x3d, r28	; 61
    194c:	dd 91       	ld	r29, X+
    194e:	de bf       	out	0x3e, r29	; 62
    1950:	ff 91       	pop	r31
    1952:	ef 91       	pop	r30
    1954:	df 91       	pop	r29
    1956:	cf 91       	pop	r28
    1958:	bf 91       	pop	r27
    195a:	af 91       	pop	r26
    195c:	9f 91       	pop	r25
    195e:	8f 91       	pop	r24
    1960:	7f 91       	pop	r23
    1962:	6f 91       	pop	r22
    1964:	5f 91       	pop	r21
    1966:	4f 91       	pop	r20
    1968:	3f 91       	pop	r19
    196a:	2f 91       	pop	r18
    196c:	1f 91       	pop	r17
    196e:	0f 91       	pop	r16
    1970:	ff 90       	pop	r15
    1972:	ef 90       	pop	r14
    1974:	df 90       	pop	r13
    1976:	cf 90       	pop	r12
    1978:	bf 90       	pop	r11
    197a:	af 90       	pop	r10
    197c:	9f 90       	pop	r9
    197e:	8f 90       	pop	r8
    1980:	7f 90       	pop	r7
    1982:	6f 90       	pop	r6
    1984:	5f 90       	pop	r5
    1986:	4f 90       	pop	r4
    1988:	3f 90       	pop	r3
    198a:	2f 90       	pop	r2
    198c:	1f 90       	pop	r1
    198e:	0f 90       	pop	r0
    1990:	0c be       	out	0x3c, r0	; 60
    1992:	0f 90       	pop	r0
    1994:	0b be       	out	0x3b, r0	; 59
    1996:	0f 90       	pop	r0
    1998:	0f be       	out	0x3f, r0	; 63
    199a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    199c:	08 95       	ret

0000199e <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    199e:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    19a2:	18 95       	reti

000019a4 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19a4:	cf 93       	push	r28
    19a6:	df 93       	push	r29
    19a8:	ec 01       	movw	r28, r24
    19aa:	88 a1       	ldd	r24, Y+32	; 0x20
    19ac:	81 11       	cpse	r24, r1
    19ae:	0b c0       	rjmp	.+22     	; 0x19c6 <prvCopyDataToQueue+0x22>
    19b0:	88 81       	ld	r24, Y
    19b2:	99 81       	ldd	r25, Y+1	; 0x01
    19b4:	89 2b       	or	r24, r25
    19b6:	e1 f5       	brne	.+120    	; 0x1a30 <prvCopyDataToQueue+0x8c>
    19b8:	8a 81       	ldd	r24, Y+2	; 0x02
    19ba:	9b 81       	ldd	r25, Y+3	; 0x03
    19bc:	0e 94 e6 14 	call	0x29cc	; 0x29cc <vTaskPriorityDisinherit>
    19c0:	1a 82       	std	Y+2, r1	; 0x02
    19c2:	1b 82       	std	Y+3, r1	; 0x03
    19c4:	35 c0       	rjmp	.+106    	; 0x1a30 <prvCopyDataToQueue+0x8c>
    19c6:	41 11       	cpse	r20, r1
    19c8:	17 c0       	rjmp	.+46     	; 0x19f8 <prvCopyDataToQueue+0x54>
    19ca:	48 2f       	mov	r20, r24
    19cc:	50 e0       	ldi	r21, 0x00	; 0
    19ce:	8c 81       	ldd	r24, Y+4	; 0x04
    19d0:	9d 81       	ldd	r25, Y+5	; 0x05
    19d2:	0e 94 87 20 	call	0x410e	; 0x410e <memcpy>
    19d6:	28 a1       	ldd	r18, Y+32	; 0x20
    19d8:	8c 81       	ldd	r24, Y+4	; 0x04
    19da:	9d 81       	ldd	r25, Y+5	; 0x05
    19dc:	82 0f       	add	r24, r18
    19de:	91 1d       	adc	r25, r1
    19e0:	8c 83       	std	Y+4, r24	; 0x04
    19e2:	9d 83       	std	Y+5, r25	; 0x05
    19e4:	2a 81       	ldd	r18, Y+2	; 0x02
    19e6:	3b 81       	ldd	r19, Y+3	; 0x03
    19e8:	82 17       	cp	r24, r18
    19ea:	93 07       	cpc	r25, r19
    19ec:	08 f1       	brcs	.+66     	; 0x1a30 <prvCopyDataToQueue+0x8c>
    19ee:	88 81       	ld	r24, Y
    19f0:	99 81       	ldd	r25, Y+1	; 0x01
    19f2:	8c 83       	std	Y+4, r24	; 0x04
    19f4:	9d 83       	std	Y+5, r25	; 0x05
    19f6:	1c c0       	rjmp	.+56     	; 0x1a30 <prvCopyDataToQueue+0x8c>
    19f8:	48 2f       	mov	r20, r24
    19fa:	50 e0       	ldi	r21, 0x00	; 0
    19fc:	8e 81       	ldd	r24, Y+6	; 0x06
    19fe:	9f 81       	ldd	r25, Y+7	; 0x07
    1a00:	0e 94 87 20 	call	0x410e	; 0x410e <memcpy>
    1a04:	88 a1       	ldd	r24, Y+32	; 0x20
    1a06:	90 e0       	ldi	r25, 0x00	; 0
    1a08:	91 95       	neg	r25
    1a0a:	81 95       	neg	r24
    1a0c:	91 09       	sbc	r25, r1
    1a0e:	2e 81       	ldd	r18, Y+6	; 0x06
    1a10:	3f 81       	ldd	r19, Y+7	; 0x07
    1a12:	28 0f       	add	r18, r24
    1a14:	39 1f       	adc	r19, r25
    1a16:	2e 83       	std	Y+6, r18	; 0x06
    1a18:	3f 83       	std	Y+7, r19	; 0x07
    1a1a:	48 81       	ld	r20, Y
    1a1c:	59 81       	ldd	r21, Y+1	; 0x01
    1a1e:	24 17       	cp	r18, r20
    1a20:	35 07       	cpc	r19, r21
    1a22:	30 f4       	brcc	.+12     	; 0x1a30 <prvCopyDataToQueue+0x8c>
    1a24:	2a 81       	ldd	r18, Y+2	; 0x02
    1a26:	3b 81       	ldd	r19, Y+3	; 0x03
    1a28:	82 0f       	add	r24, r18
    1a2a:	93 1f       	adc	r25, r19
    1a2c:	8e 83       	std	Y+6, r24	; 0x06
    1a2e:	9f 83       	std	Y+7, r25	; 0x07
    1a30:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a32:	8f 5f       	subi	r24, 0xFF	; 255
    1a34:	8e 8f       	std	Y+30, r24	; 0x1e
    1a36:	df 91       	pop	r29
    1a38:	cf 91       	pop	r28
    1a3a:	08 95       	ret

00001a3c <prvCopyDataFromQueue>:
    1a3c:	fc 01       	movw	r30, r24
    1a3e:	80 81       	ld	r24, Z
    1a40:	91 81       	ldd	r25, Z+1	; 0x01
    1a42:	00 97       	sbiw	r24, 0x00	; 0
    1a44:	a1 f0       	breq	.+40     	; 0x1a6e <prvCopyDataFromQueue+0x32>
    1a46:	40 a1       	ldd	r20, Z+32	; 0x20
    1a48:	50 e0       	ldi	r21, 0x00	; 0
    1a4a:	26 81       	ldd	r18, Z+6	; 0x06
    1a4c:	37 81       	ldd	r19, Z+7	; 0x07
    1a4e:	24 0f       	add	r18, r20
    1a50:	35 1f       	adc	r19, r21
    1a52:	26 83       	std	Z+6, r18	; 0x06
    1a54:	37 83       	std	Z+7, r19	; 0x07
    1a56:	a2 81       	ldd	r26, Z+2	; 0x02
    1a58:	b3 81       	ldd	r27, Z+3	; 0x03
    1a5a:	2a 17       	cp	r18, r26
    1a5c:	3b 07       	cpc	r19, r27
    1a5e:	10 f0       	brcs	.+4      	; 0x1a64 <prvCopyDataFromQueue+0x28>
    1a60:	86 83       	std	Z+6, r24	; 0x06
    1a62:	97 83       	std	Z+7, r25	; 0x07
    1a64:	cb 01       	movw	r24, r22
    1a66:	66 81       	ldd	r22, Z+6	; 0x06
    1a68:	77 81       	ldd	r23, Z+7	; 0x07
    1a6a:	0e 94 87 20 	call	0x410e	; 0x410e <memcpy>
    1a6e:	08 95       	ret

00001a70 <prvUnlockQueue>:
    1a70:	0f 93       	push	r16
    1a72:	1f 93       	push	r17
    1a74:	cf 93       	push	r28
    1a76:	df 93       	push	r29
    1a78:	ec 01       	movw	r28, r24
    1a7a:	0f b6       	in	r0, 0x3f	; 63
    1a7c:	f8 94       	cli
    1a7e:	0f 92       	push	r0
    1a80:	8a a1       	ldd	r24, Y+34	; 0x22
    1a82:	18 16       	cp	r1, r24
    1a84:	b4 f4       	brge	.+44     	; 0x1ab2 <prvUnlockQueue+0x42>
    1a86:	8b 89       	ldd	r24, Y+19	; 0x13
    1a88:	81 11       	cpse	r24, r1
    1a8a:	05 c0       	rjmp	.+10     	; 0x1a96 <prvUnlockQueue+0x26>
    1a8c:	12 c0       	rjmp	.+36     	; 0x1ab2 <prvUnlockQueue+0x42>
    1a8e:	8b 89       	ldd	r24, Y+19	; 0x13
    1a90:	81 11       	cpse	r24, r1
    1a92:	04 c0       	rjmp	.+8      	; 0x1a9c <prvUnlockQueue+0x2c>
    1a94:	0e c0       	rjmp	.+28     	; 0x1ab2 <prvUnlockQueue+0x42>
    1a96:	8e 01       	movw	r16, r28
    1a98:	0d 5e       	subi	r16, 0xED	; 237
    1a9a:	1f 4f       	sbci	r17, 0xFF	; 255
    1a9c:	c8 01       	movw	r24, r16
    1a9e:	0e 94 b2 13 	call	0x2764	; 0x2764 <xTaskRemoveFromEventList>
    1aa2:	81 11       	cpse	r24, r1
    1aa4:	0e 94 6f 14 	call	0x28de	; 0x28de <vTaskMissedYield>
    1aa8:	8a a1       	ldd	r24, Y+34	; 0x22
    1aaa:	81 50       	subi	r24, 0x01	; 1
    1aac:	8a a3       	std	Y+34, r24	; 0x22
    1aae:	18 16       	cp	r1, r24
    1ab0:	74 f3       	brlt	.-36     	; 0x1a8e <prvUnlockQueue+0x1e>
    1ab2:	8f ef       	ldi	r24, 0xFF	; 255
    1ab4:	8a a3       	std	Y+34, r24	; 0x22
    1ab6:	0f 90       	pop	r0
    1ab8:	0f be       	out	0x3f, r0	; 63
    1aba:	0f b6       	in	r0, 0x3f	; 63
    1abc:	f8 94       	cli
    1abe:	0f 92       	push	r0
    1ac0:	89 a1       	ldd	r24, Y+33	; 0x21
    1ac2:	18 16       	cp	r1, r24
    1ac4:	b4 f4       	brge	.+44     	; 0x1af2 <prvUnlockQueue+0x82>
    1ac6:	88 85       	ldd	r24, Y+8	; 0x08
    1ac8:	81 11       	cpse	r24, r1
    1aca:	05 c0       	rjmp	.+10     	; 0x1ad6 <prvUnlockQueue+0x66>
    1acc:	12 c0       	rjmp	.+36     	; 0x1af2 <prvUnlockQueue+0x82>
    1ace:	88 85       	ldd	r24, Y+8	; 0x08
    1ad0:	81 11       	cpse	r24, r1
    1ad2:	04 c0       	rjmp	.+8      	; 0x1adc <prvUnlockQueue+0x6c>
    1ad4:	0e c0       	rjmp	.+28     	; 0x1af2 <prvUnlockQueue+0x82>
    1ad6:	8e 01       	movw	r16, r28
    1ad8:	08 5f       	subi	r16, 0xF8	; 248
    1ada:	1f 4f       	sbci	r17, 0xFF	; 255
    1adc:	c8 01       	movw	r24, r16
    1ade:	0e 94 b2 13 	call	0x2764	; 0x2764 <xTaskRemoveFromEventList>
    1ae2:	81 11       	cpse	r24, r1
    1ae4:	0e 94 6f 14 	call	0x28de	; 0x28de <vTaskMissedYield>
    1ae8:	89 a1       	ldd	r24, Y+33	; 0x21
    1aea:	81 50       	subi	r24, 0x01	; 1
    1aec:	89 a3       	std	Y+33, r24	; 0x21
    1aee:	18 16       	cp	r1, r24
    1af0:	74 f3       	brlt	.-36     	; 0x1ace <prvUnlockQueue+0x5e>
    1af2:	8f ef       	ldi	r24, 0xFF	; 255
    1af4:	89 a3       	std	Y+33, r24	; 0x21
    1af6:	0f 90       	pop	r0
    1af8:	0f be       	out	0x3f, r0	; 63
    1afa:	df 91       	pop	r29
    1afc:	cf 91       	pop	r28
    1afe:	1f 91       	pop	r17
    1b00:	0f 91       	pop	r16
    1b02:	08 95       	ret

00001b04 <xQueueGenericReset>:
    1b04:	1f 93       	push	r17
    1b06:	cf 93       	push	r28
    1b08:	df 93       	push	r29
    1b0a:	61 30       	cpi	r22, 0x01	; 1
    1b0c:	59 f0       	breq	.+22     	; 0x1b24 <xQueueGenericReset+0x20>
    1b0e:	fc 01       	movw	r30, r24
    1b10:	23 89       	ldd	r18, Z+19	; 0x13
    1b12:	30 85       	ldd	r19, Z+8	; 0x08
    1b14:	31 11       	cpse	r19, r1
    1b16:	2c c0       	rjmp	.+88     	; 0x1b70 <xQueueGenericReset+0x6c>
    1b18:	11 e0       	ldi	r17, 0x01	; 1
    1b1a:	21 11       	cpse	r18, r1
    1b1c:	10 e0       	ldi	r17, 0x00	; 0
    1b1e:	21 11       	cpse	r18, r1
    1b20:	28 c0       	rjmp	.+80     	; 0x1b72 <xQueueGenericReset+0x6e>
    1b22:	01 c0       	rjmp	.+2      	; 0x1b26 <xQueueGenericReset+0x22>
    1b24:	11 e0       	ldi	r17, 0x01	; 1
    1b26:	ec 01       	movw	r28, r24
    1b28:	48 81       	ld	r20, Y
    1b2a:	59 81       	ldd	r21, Y+1	; 0x01
    1b2c:	28 a1       	ldd	r18, Y+32	; 0x20
    1b2e:	30 e0       	ldi	r19, 0x00	; 0
    1b30:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1b32:	62 9f       	mul	r22, r18
    1b34:	c0 01       	movw	r24, r0
    1b36:	63 9f       	mul	r22, r19
    1b38:	90 0d       	add	r25, r0
    1b3a:	11 24       	eor	r1, r1
    1b3c:	ba 01       	movw	r22, r20
    1b3e:	68 0f       	add	r22, r24
    1b40:	79 1f       	adc	r23, r25
    1b42:	6a 83       	std	Y+2, r22	; 0x02
    1b44:	7b 83       	std	Y+3, r23	; 0x03
    1b46:	1e 8e       	std	Y+30, r1	; 0x1e
    1b48:	4c 83       	std	Y+4, r20	; 0x04
    1b4a:	5d 83       	std	Y+5, r21	; 0x05
    1b4c:	82 1b       	sub	r24, r18
    1b4e:	93 0b       	sbc	r25, r19
    1b50:	84 0f       	add	r24, r20
    1b52:	95 1f       	adc	r25, r21
    1b54:	8e 83       	std	Y+6, r24	; 0x06
    1b56:	9f 83       	std	Y+7, r25	; 0x07
    1b58:	8f ef       	ldi	r24, 0xFF	; 255
    1b5a:	89 a3       	std	Y+33, r24	; 0x21
    1b5c:	8a a3       	std	Y+34, r24	; 0x22
    1b5e:	ce 01       	movw	r24, r28
    1b60:	08 96       	adiw	r24, 0x08	; 8
    1b62:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListInitialise>
    1b66:	ce 01       	movw	r24, r28
    1b68:	43 96       	adiw	r24, 0x13	; 19
    1b6a:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListInitialise>
    1b6e:	01 c0       	rjmp	.+2      	; 0x1b72 <xQueueGenericReset+0x6e>
    1b70:	10 e0       	ldi	r17, 0x00	; 0
    1b72:	81 2f       	mov	r24, r17
    1b74:	df 91       	pop	r29
    1b76:	cf 91       	pop	r28
    1b78:	1f 91       	pop	r17
    1b7a:	08 95       	ret

00001b7c <xQueueGenericCreate>:
    1b7c:	0f 93       	push	r16
    1b7e:	1f 93       	push	r17
    1b80:	cf 93       	push	r28
    1b82:	df 93       	push	r29
    1b84:	88 23       	and	r24, r24
    1b86:	01 f1       	breq	.+64     	; 0x1bc8 <xQueueGenericCreate+0x4c>
    1b88:	06 2f       	mov	r16, r22
    1b8a:	18 2f       	mov	r17, r24
    1b8c:	83 e2       	ldi	r24, 0x23	; 35
    1b8e:	90 e0       	ldi	r25, 0x00	; 0
    1b90:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <pvPortMalloc>
    1b94:	ec 01       	movw	r28, r24
    1b96:	89 2b       	or	r24, r25
    1b98:	c9 f0       	breq	.+50     	; 0x1bcc <xQueueGenericCreate+0x50>
    1b9a:	10 9f       	mul	r17, r16
    1b9c:	c0 01       	movw	r24, r0
    1b9e:	11 24       	eor	r1, r1
    1ba0:	01 96       	adiw	r24, 0x01	; 1
    1ba2:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <pvPortMalloc>
    1ba6:	88 83       	st	Y, r24
    1ba8:	99 83       	std	Y+1, r25	; 0x01
    1baa:	89 2b       	or	r24, r25
    1bac:	39 f0       	breq	.+14     	; 0x1bbc <xQueueGenericCreate+0x40>
    1bae:	1f 8f       	std	Y+31, r17	; 0x1f
    1bb0:	08 a3       	std	Y+32, r16	; 0x20
    1bb2:	61 e0       	ldi	r22, 0x01	; 1
    1bb4:	ce 01       	movw	r24, r28
    1bb6:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <xQueueGenericReset>
    1bba:	08 c0       	rjmp	.+16     	; 0x1bcc <xQueueGenericCreate+0x50>
    1bbc:	ce 01       	movw	r24, r28
    1bbe:	0e 94 72 0a 	call	0x14e4	; 0x14e4 <vPortFree>
    1bc2:	c0 e0       	ldi	r28, 0x00	; 0
    1bc4:	d0 e0       	ldi	r29, 0x00	; 0
    1bc6:	02 c0       	rjmp	.+4      	; 0x1bcc <xQueueGenericCreate+0x50>
    1bc8:	c0 e0       	ldi	r28, 0x00	; 0
    1bca:	d0 e0       	ldi	r29, 0x00	; 0
    1bcc:	ce 01       	movw	r24, r28
    1bce:	df 91       	pop	r29
    1bd0:	cf 91       	pop	r28
    1bd2:	1f 91       	pop	r17
    1bd4:	0f 91       	pop	r16
    1bd6:	08 95       	ret

00001bd8 <xQueueGenericSend>:
    1bd8:	af 92       	push	r10
    1bda:	bf 92       	push	r11
    1bdc:	cf 92       	push	r12
    1bde:	df 92       	push	r13
    1be0:	ef 92       	push	r14
    1be2:	ff 92       	push	r15
    1be4:	0f 93       	push	r16
    1be6:	1f 93       	push	r17
    1be8:	cf 93       	push	r28
    1bea:	df 93       	push	r29
    1bec:	cd b7       	in	r28, 0x3d	; 61
    1bee:	de b7       	in	r29, 0x3e	; 62
    1bf0:	29 97       	sbiw	r28, 0x09	; 9
    1bf2:	cd bf       	out	0x3d, r28	; 61
    1bf4:	de bf       	out	0x3e, r29	; 62
    1bf6:	7c 01       	movw	r14, r24
    1bf8:	5b 01       	movw	r10, r22
    1bfa:	2e 83       	std	Y+6, r18	; 0x06
    1bfc:	3f 83       	std	Y+7, r19	; 0x07
    1bfe:	48 87       	std	Y+8, r20	; 0x08
    1c00:	59 87       	std	Y+9, r21	; 0x09
    1c02:	10 e0       	ldi	r17, 0x00	; 0
    1c04:	6c 01       	movw	r12, r24
    1c06:	88 e0       	ldi	r24, 0x08	; 8
    1c08:	c8 0e       	add	r12, r24
    1c0a:	d1 1c       	adc	r13, r1
    1c0c:	0f b6       	in	r0, 0x3f	; 63
    1c0e:	f8 94       	cli
    1c10:	0f 92       	push	r0
    1c12:	f7 01       	movw	r30, r14
    1c14:	96 8d       	ldd	r25, Z+30	; 0x1e
    1c16:	87 8d       	ldd	r24, Z+31	; 0x1f
    1c18:	98 17       	cp	r25, r24
    1c1a:	a8 f4       	brcc	.+42     	; 0x1c46 <xQueueGenericSend+0x6e>
    1c1c:	40 2f       	mov	r20, r16
    1c1e:	b5 01       	movw	r22, r10
    1c20:	c7 01       	movw	r24, r14
    1c22:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <prvCopyDataToQueue>
    1c26:	f7 01       	movw	r30, r14
    1c28:	83 89       	ldd	r24, Z+19	; 0x13
    1c2a:	88 23       	and	r24, r24
    1c2c:	41 f0       	breq	.+16     	; 0x1c3e <xQueueGenericSend+0x66>
    1c2e:	c7 01       	movw	r24, r14
    1c30:	43 96       	adiw	r24, 0x13	; 19
    1c32:	0e 94 b2 13 	call	0x2764	; 0x2764 <xTaskRemoveFromEventList>
    1c36:	81 30       	cpi	r24, 0x01	; 1
    1c38:	11 f4       	brne	.+4      	; 0x1c3e <xQueueGenericSend+0x66>
    1c3a:	0e 94 0b 0c 	call	0x1816	; 0x1816 <vPortYield>
    1c3e:	0f 90       	pop	r0
    1c40:	0f be       	out	0x3f, r0	; 63
    1c42:	81 e0       	ldi	r24, 0x01	; 1
    1c44:	56 c0       	rjmp	.+172    	; 0x1cf2 <xQueueGenericSend+0x11a>
    1c46:	8e 81       	ldd	r24, Y+6	; 0x06
    1c48:	9f 81       	ldd	r25, Y+7	; 0x07
    1c4a:	a8 85       	ldd	r26, Y+8	; 0x08
    1c4c:	b9 85       	ldd	r27, Y+9	; 0x09
    1c4e:	89 2b       	or	r24, r25
    1c50:	8a 2b       	or	r24, r26
    1c52:	8b 2b       	or	r24, r27
    1c54:	21 f4       	brne	.+8      	; 0x1c5e <xQueueGenericSend+0x86>
    1c56:	0f 90       	pop	r0
    1c58:	0f be       	out	0x3f, r0	; 63
    1c5a:	80 e0       	ldi	r24, 0x00	; 0
    1c5c:	4a c0       	rjmp	.+148    	; 0x1cf2 <xQueueGenericSend+0x11a>
    1c5e:	11 11       	cpse	r17, r1
    1c60:	05 c0       	rjmp	.+10     	; 0x1c6c <xQueueGenericSend+0x94>
    1c62:	ce 01       	movw	r24, r28
    1c64:	01 96       	adiw	r24, 0x01	; 1
    1c66:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <vTaskSetTimeOutState>
    1c6a:	11 e0       	ldi	r17, 0x01	; 1
    1c6c:	0f 90       	pop	r0
    1c6e:	0f be       	out	0x3f, r0	; 63
    1c70:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
    1c74:	0f b6       	in	r0, 0x3f	; 63
    1c76:	f8 94       	cli
    1c78:	0f 92       	push	r0
    1c7a:	f7 01       	movw	r30, r14
    1c7c:	81 a1       	ldd	r24, Z+33	; 0x21
    1c7e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c80:	09 f4       	brne	.+2      	; 0x1c84 <xQueueGenericSend+0xac>
    1c82:	11 a2       	std	Z+33, r1	; 0x21
    1c84:	f7 01       	movw	r30, r14
    1c86:	82 a1       	ldd	r24, Z+34	; 0x22
    1c88:	8f 3f       	cpi	r24, 0xFF	; 255
    1c8a:	09 f4       	brne	.+2      	; 0x1c8e <xQueueGenericSend+0xb6>
    1c8c:	12 a2       	std	Z+34, r1	; 0x22
    1c8e:	0f 90       	pop	r0
    1c90:	0f be       	out	0x3f, r0	; 63
    1c92:	be 01       	movw	r22, r28
    1c94:	6a 5f       	subi	r22, 0xFA	; 250
    1c96:	7f 4f       	sbci	r23, 0xFF	; 255
    1c98:	ce 01       	movw	r24, r28
    1c9a:	01 96       	adiw	r24, 0x01	; 1
    1c9c:	0e 94 02 14 	call	0x2804	; 0x2804 <xTaskCheckForTimeOut>
    1ca0:	81 11       	cpse	r24, r1
    1ca2:	21 c0       	rjmp	.+66     	; 0x1ce6 <xQueueGenericSend+0x10e>
    1ca4:	0f b6       	in	r0, 0x3f	; 63
    1ca6:	f8 94       	cli
    1ca8:	0f 92       	push	r0
    1caa:	f7 01       	movw	r30, r14
    1cac:	96 8d       	ldd	r25, Z+30	; 0x1e
    1cae:	0f 90       	pop	r0
    1cb0:	0f be       	out	0x3f, r0	; 63
    1cb2:	87 8d       	ldd	r24, Z+31	; 0x1f
    1cb4:	98 13       	cpse	r25, r24
    1cb6:	11 c0       	rjmp	.+34     	; 0x1cda <xQueueGenericSend+0x102>
    1cb8:	4e 81       	ldd	r20, Y+6	; 0x06
    1cba:	5f 81       	ldd	r21, Y+7	; 0x07
    1cbc:	68 85       	ldd	r22, Y+8	; 0x08
    1cbe:	79 85       	ldd	r23, Y+9	; 0x09
    1cc0:	c6 01       	movw	r24, r12
    1cc2:	0e 94 88 13 	call	0x2710	; 0x2710 <vTaskPlaceOnEventList>
    1cc6:	c7 01       	movw	r24, r14
    1cc8:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <prvUnlockQueue>
    1ccc:	0e 94 0e 12 	call	0x241c	; 0x241c <xTaskResumeAll>
    1cd0:	81 11       	cpse	r24, r1
    1cd2:	9c cf       	rjmp	.-200    	; 0x1c0c <xQueueGenericSend+0x34>
    1cd4:	0e 94 0b 0c 	call	0x1816	; 0x1816 <vPortYield>
    1cd8:	99 cf       	rjmp	.-206    	; 0x1c0c <xQueueGenericSend+0x34>
    1cda:	c7 01       	movw	r24, r14
    1cdc:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <prvUnlockQueue>
    1ce0:	0e 94 0e 12 	call	0x241c	; 0x241c <xTaskResumeAll>
    1ce4:	93 cf       	rjmp	.-218    	; 0x1c0c <xQueueGenericSend+0x34>
    1ce6:	c7 01       	movw	r24, r14
    1ce8:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <prvUnlockQueue>
    1cec:	0e 94 0e 12 	call	0x241c	; 0x241c <xTaskResumeAll>
    1cf0:	80 e0       	ldi	r24, 0x00	; 0
    1cf2:	29 96       	adiw	r28, 0x09	; 9
    1cf4:	cd bf       	out	0x3d, r28	; 61
    1cf6:	de bf       	out	0x3e, r29	; 62
    1cf8:	df 91       	pop	r29
    1cfa:	cf 91       	pop	r28
    1cfc:	1f 91       	pop	r17
    1cfe:	0f 91       	pop	r16
    1d00:	ff 90       	pop	r15
    1d02:	ef 90       	pop	r14
    1d04:	df 90       	pop	r13
    1d06:	cf 90       	pop	r12
    1d08:	bf 90       	pop	r11
    1d0a:	af 90       	pop	r10
    1d0c:	08 95       	ret

00001d0e <xQueueGenericReceive>:
    1d0e:	af 92       	push	r10
    1d10:	bf 92       	push	r11
    1d12:	cf 92       	push	r12
    1d14:	df 92       	push	r13
    1d16:	ef 92       	push	r14
    1d18:	ff 92       	push	r15
    1d1a:	0f 93       	push	r16
    1d1c:	1f 93       	push	r17
    1d1e:	cf 93       	push	r28
    1d20:	df 93       	push	r29
    1d22:	cd b7       	in	r28, 0x3d	; 61
    1d24:	de b7       	in	r29, 0x3e	; 62
    1d26:	29 97       	sbiw	r28, 0x09	; 9
    1d28:	cd bf       	out	0x3d, r28	; 61
    1d2a:	de bf       	out	0x3e, r29	; 62
    1d2c:	7c 01       	movw	r14, r24
    1d2e:	5b 01       	movw	r10, r22
    1d30:	2e 83       	std	Y+6, r18	; 0x06
    1d32:	3f 83       	std	Y+7, r19	; 0x07
    1d34:	48 87       	std	Y+8, r20	; 0x08
    1d36:	59 87       	std	Y+9, r21	; 0x09
    1d38:	10 e0       	ldi	r17, 0x00	; 0
    1d3a:	6c 01       	movw	r12, r24
    1d3c:	83 e1       	ldi	r24, 0x13	; 19
    1d3e:	c8 0e       	add	r12, r24
    1d40:	d1 1c       	adc	r13, r1
    1d42:	0f b6       	in	r0, 0x3f	; 63
    1d44:	f8 94       	cli
    1d46:	0f 92       	push	r0
    1d48:	f7 01       	movw	r30, r14
    1d4a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d4c:	88 23       	and	r24, r24
    1d4e:	99 f1       	breq	.+102    	; 0x1db6 <xQueueGenericReceive+0xa8>
    1d50:	c6 80       	ldd	r12, Z+6	; 0x06
    1d52:	d7 80       	ldd	r13, Z+7	; 0x07
    1d54:	b5 01       	movw	r22, r10
    1d56:	c7 01       	movw	r24, r14
    1d58:	0e 94 1e 0d 	call	0x1a3c	; 0x1a3c <prvCopyDataFromQueue>
    1d5c:	01 11       	cpse	r16, r1
    1d5e:	1a c0       	rjmp	.+52     	; 0x1d94 <xQueueGenericReceive+0x86>
    1d60:	f7 01       	movw	r30, r14
    1d62:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d64:	81 50       	subi	r24, 0x01	; 1
    1d66:	86 8f       	std	Z+30, r24	; 0x1e
    1d68:	80 81       	ld	r24, Z
    1d6a:	91 81       	ldd	r25, Z+1	; 0x01
    1d6c:	89 2b       	or	r24, r25
    1d6e:	29 f4       	brne	.+10     	; 0x1d7a <xQueueGenericReceive+0x6c>
    1d70:	0e 94 8c 14 	call	0x2918	; 0x2918 <xTaskGetCurrentTaskHandle>
    1d74:	f7 01       	movw	r30, r14
    1d76:	82 83       	std	Z+2, r24	; 0x02
    1d78:	93 83       	std	Z+3, r25	; 0x03
    1d7a:	f7 01       	movw	r30, r14
    1d7c:	80 85       	ldd	r24, Z+8	; 0x08
    1d7e:	88 23       	and	r24, r24
    1d80:	b1 f0       	breq	.+44     	; 0x1dae <xQueueGenericReceive+0xa0>
    1d82:	c7 01       	movw	r24, r14
    1d84:	08 96       	adiw	r24, 0x08	; 8
    1d86:	0e 94 b2 13 	call	0x2764	; 0x2764 <xTaskRemoveFromEventList>
    1d8a:	81 30       	cpi	r24, 0x01	; 1
    1d8c:	81 f4       	brne	.+32     	; 0x1dae <xQueueGenericReceive+0xa0>
    1d8e:	0e 94 0b 0c 	call	0x1816	; 0x1816 <vPortYield>
    1d92:	0d c0       	rjmp	.+26     	; 0x1dae <xQueueGenericReceive+0xa0>
    1d94:	f7 01       	movw	r30, r14
    1d96:	c6 82       	std	Z+6, r12	; 0x06
    1d98:	d7 82       	std	Z+7, r13	; 0x07
    1d9a:	83 89       	ldd	r24, Z+19	; 0x13
    1d9c:	88 23       	and	r24, r24
    1d9e:	39 f0       	breq	.+14     	; 0x1dae <xQueueGenericReceive+0xa0>
    1da0:	c7 01       	movw	r24, r14
    1da2:	43 96       	adiw	r24, 0x13	; 19
    1da4:	0e 94 b2 13 	call	0x2764	; 0x2764 <xTaskRemoveFromEventList>
    1da8:	81 11       	cpse	r24, r1
    1daa:	0e 94 0b 0c 	call	0x1816	; 0x1816 <vPortYield>
    1dae:	0f 90       	pop	r0
    1db0:	0f be       	out	0x3f, r0	; 63
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	62 c0       	rjmp	.+196    	; 0x1e7a <xQueueGenericReceive+0x16c>
    1db6:	8e 81       	ldd	r24, Y+6	; 0x06
    1db8:	9f 81       	ldd	r25, Y+7	; 0x07
    1dba:	a8 85       	ldd	r26, Y+8	; 0x08
    1dbc:	b9 85       	ldd	r27, Y+9	; 0x09
    1dbe:	89 2b       	or	r24, r25
    1dc0:	8a 2b       	or	r24, r26
    1dc2:	8b 2b       	or	r24, r27
    1dc4:	21 f4       	brne	.+8      	; 0x1dce <xQueueGenericReceive+0xc0>
    1dc6:	0f 90       	pop	r0
    1dc8:	0f be       	out	0x3f, r0	; 63
    1dca:	80 e0       	ldi	r24, 0x00	; 0
    1dcc:	56 c0       	rjmp	.+172    	; 0x1e7a <xQueueGenericReceive+0x16c>
    1dce:	11 11       	cpse	r17, r1
    1dd0:	05 c0       	rjmp	.+10     	; 0x1ddc <xQueueGenericReceive+0xce>
    1dd2:	ce 01       	movw	r24, r28
    1dd4:	01 96       	adiw	r24, 0x01	; 1
    1dd6:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <vTaskSetTimeOutState>
    1dda:	11 e0       	ldi	r17, 0x01	; 1
    1ddc:	0f 90       	pop	r0
    1dde:	0f be       	out	0x3f, r0	; 63
    1de0:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
    1de4:	0f b6       	in	r0, 0x3f	; 63
    1de6:	f8 94       	cli
    1de8:	0f 92       	push	r0
    1dea:	f7 01       	movw	r30, r14
    1dec:	81 a1       	ldd	r24, Z+33	; 0x21
    1dee:	8f 3f       	cpi	r24, 0xFF	; 255
    1df0:	09 f4       	brne	.+2      	; 0x1df4 <xQueueGenericReceive+0xe6>
    1df2:	11 a2       	std	Z+33, r1	; 0x21
    1df4:	f7 01       	movw	r30, r14
    1df6:	82 a1       	ldd	r24, Z+34	; 0x22
    1df8:	8f 3f       	cpi	r24, 0xFF	; 255
    1dfa:	09 f4       	brne	.+2      	; 0x1dfe <xQueueGenericReceive+0xf0>
    1dfc:	12 a2       	std	Z+34, r1	; 0x22
    1dfe:	0f 90       	pop	r0
    1e00:	0f be       	out	0x3f, r0	; 63
    1e02:	be 01       	movw	r22, r28
    1e04:	6a 5f       	subi	r22, 0xFA	; 250
    1e06:	7f 4f       	sbci	r23, 0xFF	; 255
    1e08:	ce 01       	movw	r24, r28
    1e0a:	01 96       	adiw	r24, 0x01	; 1
    1e0c:	0e 94 02 14 	call	0x2804	; 0x2804 <xTaskCheckForTimeOut>
    1e10:	81 11       	cpse	r24, r1
    1e12:	2d c0       	rjmp	.+90     	; 0x1e6e <xQueueGenericReceive+0x160>
    1e14:	0f b6       	in	r0, 0x3f	; 63
    1e16:	f8 94       	cli
    1e18:	0f 92       	push	r0
    1e1a:	f7 01       	movw	r30, r14
    1e1c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e1e:	0f 90       	pop	r0
    1e20:	0f be       	out	0x3f, r0	; 63
    1e22:	81 11       	cpse	r24, r1
    1e24:	1e c0       	rjmp	.+60     	; 0x1e62 <xQueueGenericReceive+0x154>
    1e26:	80 81       	ld	r24, Z
    1e28:	91 81       	ldd	r25, Z+1	; 0x01
    1e2a:	89 2b       	or	r24, r25
    1e2c:	49 f4       	brne	.+18     	; 0x1e40 <xQueueGenericReceive+0x132>
    1e2e:	0f b6       	in	r0, 0x3f	; 63
    1e30:	f8 94       	cli
    1e32:	0f 92       	push	r0
    1e34:	82 81       	ldd	r24, Z+2	; 0x02
    1e36:	93 81       	ldd	r25, Z+3	; 0x03
    1e38:	0e 94 91 14 	call	0x2922	; 0x2922 <vTaskPriorityInherit>
    1e3c:	0f 90       	pop	r0
    1e3e:	0f be       	out	0x3f, r0	; 63
    1e40:	4e 81       	ldd	r20, Y+6	; 0x06
    1e42:	5f 81       	ldd	r21, Y+7	; 0x07
    1e44:	68 85       	ldd	r22, Y+8	; 0x08
    1e46:	79 85       	ldd	r23, Y+9	; 0x09
    1e48:	c6 01       	movw	r24, r12
    1e4a:	0e 94 88 13 	call	0x2710	; 0x2710 <vTaskPlaceOnEventList>
    1e4e:	c7 01       	movw	r24, r14
    1e50:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <prvUnlockQueue>
    1e54:	0e 94 0e 12 	call	0x241c	; 0x241c <xTaskResumeAll>
    1e58:	81 11       	cpse	r24, r1
    1e5a:	73 cf       	rjmp	.-282    	; 0x1d42 <xQueueGenericReceive+0x34>
    1e5c:	0e 94 0b 0c 	call	0x1816	; 0x1816 <vPortYield>
    1e60:	70 cf       	rjmp	.-288    	; 0x1d42 <xQueueGenericReceive+0x34>
    1e62:	c7 01       	movw	r24, r14
    1e64:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <prvUnlockQueue>
    1e68:	0e 94 0e 12 	call	0x241c	; 0x241c <xTaskResumeAll>
    1e6c:	6a cf       	rjmp	.-300    	; 0x1d42 <xQueueGenericReceive+0x34>
    1e6e:	c7 01       	movw	r24, r14
    1e70:	0e 94 38 0d 	call	0x1a70	; 0x1a70 <prvUnlockQueue>
    1e74:	0e 94 0e 12 	call	0x241c	; 0x241c <xTaskResumeAll>
    1e78:	80 e0       	ldi	r24, 0x00	; 0
    1e7a:	29 96       	adiw	r28, 0x09	; 9
    1e7c:	cd bf       	out	0x3d, r28	; 61
    1e7e:	de bf       	out	0x3e, r29	; 62
    1e80:	df 91       	pop	r29
    1e82:	cf 91       	pop	r28
    1e84:	1f 91       	pop	r17
    1e86:	0f 91       	pop	r16
    1e88:	ff 90       	pop	r15
    1e8a:	ef 90       	pop	r14
    1e8c:	df 90       	pop	r13
    1e8e:	cf 90       	pop	r12
    1e90:	bf 90       	pop	r11
    1e92:	af 90       	pop	r10
    1e94:	08 95       	ret

00001e96 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1e96:	0f b6       	in	r0, 0x3f	; 63
    1e98:	f8 94       	cli
    1e9a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1e9c:	fc 01       	movw	r30, r24
    1e9e:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1ea0:	0f 90       	pop	r0
    1ea2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1ea4:	08 95       	ret

00001ea6 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1ea6:	c8 ef       	ldi	r28, 0xF8	; 248
    1ea8:	d0 e3       	ldi	r29, 0x30	; 48
    1eaa:	88 81       	ld	r24, Y
    1eac:	82 30       	cpi	r24, 0x02	; 2
    1eae:	e8 f3       	brcs	.-6      	; 0x1eaa <prvIdleTask+0x4>
    1eb0:	0e 94 0b 0c 	call	0x1816	; 0x1816 <vPortYield>
    1eb4:	fa cf       	rjmp	.-12     	; 0x1eaa <prvIdleTask+0x4>

00001eb6 <prvAddCurrentTaskToDelayedList>:
    1eb6:	cf 92       	push	r12
    1eb8:	df 92       	push	r13
    1eba:	ef 92       	push	r14
    1ebc:	ff 92       	push	r15
    1ebe:	6b 01       	movw	r12, r22
    1ec0:	7c 01       	movw	r14, r24
    1ec2:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    1ec6:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1eca:	62 83       	std	Z+2, r22	; 0x02
    1ecc:	73 83       	std	Z+3, r23	; 0x03
    1ece:	84 83       	std	Z+4, r24	; 0x04
    1ed0:	95 83       	std	Z+5, r25	; 0x05
    1ed2:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    1ed6:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    1eda:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    1ede:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    1ee2:	c8 16       	cp	r12, r24
    1ee4:	d9 06       	cpc	r13, r25
    1ee6:	ea 06       	cpc	r14, r26
    1ee8:	fb 06       	cpc	r15, r27
    1eea:	68 f4       	brcc	.+26     	; 0x1f06 <prvAddCurrentTaskToDelayedList+0x50>
    1eec:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    1ef0:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1ef4:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    1ef8:	90 91 df 30 	lds	r25, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    1efc:	6e 5f       	subi	r22, 0xFE	; 254
    1efe:	7f 4f       	sbci	r23, 0xFF	; 255
    1f00:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vListInsert>
    1f04:	21 c0       	rjmp	.+66     	; 0x1f48 <prvAddCurrentTaskToDelayedList+0x92>
    1f06:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    1f0a:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1f0e:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    1f12:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    1f16:	6e 5f       	subi	r22, 0xFE	; 254
    1f18:	7f 4f       	sbci	r23, 0xFF	; 255
    1f1a:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vListInsert>
    1f1e:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1f22:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1f26:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1f2a:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1f2e:	c8 16       	cp	r12, r24
    1f30:	d9 06       	cpc	r13, r25
    1f32:	ea 06       	cpc	r14, r26
    1f34:	fb 06       	cpc	r15, r27
    1f36:	40 f4       	brcc	.+16     	; 0x1f48 <prvAddCurrentTaskToDelayedList+0x92>
    1f38:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1f3c:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1f40:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1f44:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1f48:	ff 90       	pop	r15
    1f4a:	ef 90       	pop	r14
    1f4c:	df 90       	pop	r13
    1f4e:	cf 90       	pop	r12
    1f50:	08 95       	ret

00001f52 <xTaskGenericCreate>:
    1f52:	4f 92       	push	r4
    1f54:	5f 92       	push	r5
    1f56:	6f 92       	push	r6
    1f58:	7f 92       	push	r7
    1f5a:	8f 92       	push	r8
    1f5c:	9f 92       	push	r9
    1f5e:	af 92       	push	r10
    1f60:	bf 92       	push	r11
    1f62:	cf 92       	push	r12
    1f64:	df 92       	push	r13
    1f66:	ef 92       	push	r14
    1f68:	ff 92       	push	r15
    1f6a:	0f 93       	push	r16
    1f6c:	1f 93       	push	r17
    1f6e:	cf 93       	push	r28
    1f70:	df 93       	push	r29
    1f72:	5c 01       	movw	r10, r24
    1f74:	4b 01       	movw	r8, r22
    1f76:	3a 01       	movw	r6, r20
    1f78:	29 01       	movw	r4, r18
    1f7a:	88 e2       	ldi	r24, 0x28	; 40
    1f7c:	90 e0       	ldi	r25, 0x00	; 0
    1f7e:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <pvPortMalloc>
    1f82:	ec 01       	movw	r28, r24
    1f84:	89 2b       	or	r24, r25
    1f86:	09 f4       	brne	.+2      	; 0x1f8a <xTaskGenericCreate+0x38>
    1f88:	d4 c0       	rjmp	.+424    	; 0x2132 <xTaskGenericCreate+0x1e0>
    1f8a:	c1 14       	cp	r12, r1
    1f8c:	d1 04       	cpc	r13, r1
    1f8e:	09 f0       	breq	.+2      	; 0x1f92 <xTaskGenericCreate+0x40>
    1f90:	cc c0       	rjmp	.+408    	; 0x212a <xTaskGenericCreate+0x1d8>
    1f92:	c3 01       	movw	r24, r6
    1f94:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <pvPortMalloc>
    1f98:	8b 8f       	std	Y+27, r24	; 0x1b
    1f9a:	9c 8f       	std	Y+28, r25	; 0x1c
    1f9c:	00 97       	sbiw	r24, 0x00	; 0
    1f9e:	21 f4       	brne	.+8      	; 0x1fa8 <xTaskGenericCreate+0x56>
    1fa0:	ce 01       	movw	r24, r28
    1fa2:	0e 94 72 0a 	call	0x14e4	; 0x14e4 <vPortFree>
    1fa6:	c5 c0       	rjmp	.+394    	; 0x2132 <xTaskGenericCreate+0x1e0>
    1fa8:	a3 01       	movw	r20, r6
    1faa:	61 e1       	ldi	r22, 0x11	; 17
    1fac:	70 e0       	ldi	r23, 0x00	; 0
    1fae:	0e 94 90 20 	call	0x4120	; 0x4120 <memset>
    1fb2:	93 01       	movw	r18, r6
    1fb4:	21 50       	subi	r18, 0x01	; 1
    1fb6:	31 09       	sbc	r19, r1
    1fb8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1fba:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1fbc:	3c 01       	movw	r6, r24
    1fbe:	62 0e       	add	r6, r18
    1fc0:	73 1e       	adc	r7, r19
    1fc2:	4a e0       	ldi	r20, 0x0A	; 10
    1fc4:	50 e0       	ldi	r21, 0x00	; 0
    1fc6:	b4 01       	movw	r22, r8
    1fc8:	ce 01       	movw	r24, r28
    1fca:	4d 96       	adiw	r24, 0x1d	; 29
    1fcc:	0e 94 97 20 	call	0x412e	; 0x412e <strncpy>
    1fd0:	1e a2       	std	Y+38, r1	; 0x26
    1fd2:	10 2f       	mov	r17, r16
    1fd4:	04 30       	cpi	r16, 0x04	; 4
    1fd6:	08 f0       	brcs	.+2      	; 0x1fda <xTaskGenericCreate+0x88>
    1fd8:	13 e0       	ldi	r17, 0x03	; 3
    1fda:	1a 8f       	std	Y+26, r17	; 0x1a
    1fdc:	1f a3       	std	Y+39, r17	; 0x27
    1fde:	6e 01       	movw	r12, r28
    1fe0:	22 e0       	ldi	r18, 0x02	; 2
    1fe2:	c2 0e       	add	r12, r18
    1fe4:	d1 1c       	adc	r13, r1
    1fe6:	c6 01       	movw	r24, r12
    1fe8:	0e 94 bb 0a 	call	0x1576	; 0x1576 <vListInitialiseItem>
    1fec:	ce 01       	movw	r24, r28
    1fee:	0e 96       	adiw	r24, 0x0e	; 14
    1ff0:	0e 94 bb 0a 	call	0x1576	; 0x1576 <vListInitialiseItem>
    1ff4:	ca 87       	std	Y+10, r28	; 0x0a
    1ff6:	db 87       	std	Y+11, r29	; 0x0b
    1ff8:	84 e0       	ldi	r24, 0x04	; 4
    1ffa:	90 e0       	ldi	r25, 0x00	; 0
    1ffc:	a0 e0       	ldi	r26, 0x00	; 0
    1ffe:	b0 e0       	ldi	r27, 0x00	; 0
    2000:	81 1b       	sub	r24, r17
    2002:	91 09       	sbc	r25, r1
    2004:	a1 09       	sbc	r26, r1
    2006:	b1 09       	sbc	r27, r1
    2008:	8e 87       	std	Y+14, r24	; 0x0e
    200a:	9f 87       	std	Y+15, r25	; 0x0f
    200c:	a8 8b       	std	Y+16, r26	; 0x10
    200e:	b9 8b       	std	Y+17, r27	; 0x11
    2010:	ce 8b       	std	Y+22, r28	; 0x16
    2012:	df 8b       	std	Y+23, r29	; 0x17
    2014:	a2 01       	movw	r20, r4
    2016:	b5 01       	movw	r22, r10
    2018:	c3 01       	movw	r24, r6
    201a:	0e 94 57 0b 	call	0x16ae	; 0x16ae <pxPortInitialiseStack>
    201e:	88 83       	st	Y, r24
    2020:	99 83       	std	Y+1, r25	; 0x01
    2022:	e1 14       	cp	r14, r1
    2024:	f1 04       	cpc	r15, r1
    2026:	19 f0       	breq	.+6      	; 0x202e <xTaskGenericCreate+0xdc>
    2028:	f7 01       	movw	r30, r14
    202a:	c0 83       	st	Z, r28
    202c:	d1 83       	std	Z+1, r29	; 0x01
    202e:	0f b6       	in	r0, 0x3f	; 63
    2030:	f8 94       	cli
    2032:	0f 92       	push	r0
    2034:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2038:	8f 5f       	subi	r24, 0xFF	; 255
    203a:	80 93 d0 30 	sts	0x30D0, r24	; 0x8030d0 <uxCurrentNumberOfTasks>
    203e:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2042:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2046:	89 2b       	or	r24, r25
    2048:	89 f5       	brne	.+98     	; 0x20ac <xTaskGenericCreate+0x15a>
    204a:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    204e:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    2052:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2056:	81 30       	cpi	r24, 0x01	; 1
    2058:	c1 f5       	brne	.+112    	; 0x20ca <xTaskGenericCreate+0x178>
    205a:	88 ef       	ldi	r24, 0xF8	; 248
    205c:	90 e3       	ldi	r25, 0x30	; 48
    205e:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListInitialise>
    2062:	83 e0       	ldi	r24, 0x03	; 3
    2064:	91 e3       	ldi	r25, 0x31	; 49
    2066:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListInitialise>
    206a:	8e e0       	ldi	r24, 0x0E	; 14
    206c:	91 e3       	ldi	r25, 0x31	; 49
    206e:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListInitialise>
    2072:	89 e1       	ldi	r24, 0x19	; 25
    2074:	91 e3       	ldi	r25, 0x31	; 49
    2076:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListInitialise>
    207a:	8d ee       	ldi	r24, 0xED	; 237
    207c:	90 e3       	ldi	r25, 0x30	; 48
    207e:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListInitialise>
    2082:	82 ee       	ldi	r24, 0xE2	; 226
    2084:	90 e3       	ldi	r25, 0x30	; 48
    2086:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListInitialise>
    208a:	83 ed       	ldi	r24, 0xD3	; 211
    208c:	90 e3       	ldi	r25, 0x30	; 48
    208e:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vListInitialise>
    2092:	8d ee       	ldi	r24, 0xED	; 237
    2094:	90 e3       	ldi	r25, 0x30	; 48
    2096:	80 93 e0 30 	sts	0x30E0, r24	; 0x8030e0 <pxDelayedTaskList>
    209a:	90 93 e1 30 	sts	0x30E1, r25	; 0x8030e1 <pxDelayedTaskList+0x1>
    209e:	82 ee       	ldi	r24, 0xE2	; 226
    20a0:	90 e3       	ldi	r25, 0x30	; 48
    20a2:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    20a6:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    20aa:	0f c0       	rjmp	.+30     	; 0x20ca <xTaskGenericCreate+0x178>
    20ac:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    20b0:	81 11       	cpse	r24, r1
    20b2:	0b c0       	rjmp	.+22     	; 0x20ca <xTaskGenericCreate+0x178>
    20b4:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    20b8:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    20bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    20be:	08 17       	cp	r16, r24
    20c0:	20 f0       	brcs	.+8      	; 0x20ca <xTaskGenericCreate+0x178>
    20c2:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    20c6:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    20ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    20cc:	90 91 cb 30 	lds	r25, 0x30CB	; 0x8030cb <uxTopUsedPriority>
    20d0:	98 17       	cp	r25, r24
    20d2:	10 f4       	brcc	.+4      	; 0x20d8 <xTaskGenericCreate+0x186>
    20d4:	80 93 cb 30 	sts	0x30CB, r24	; 0x8030cb <uxTopUsedPriority>
    20d8:	90 91 c4 30 	lds	r25, 0x30C4	; 0x8030c4 <uxTaskNumber>
    20dc:	9f 5f       	subi	r25, 0xFF	; 255
    20de:	90 93 c4 30 	sts	0x30C4, r25	; 0x8030c4 <uxTaskNumber>
    20e2:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    20e6:	98 17       	cp	r25, r24
    20e8:	10 f4       	brcc	.+4      	; 0x20ee <xTaskGenericCreate+0x19c>
    20ea:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    20ee:	fb e0       	ldi	r31, 0x0B	; 11
    20f0:	8f 9f       	mul	r24, r31
    20f2:	c0 01       	movw	r24, r0
    20f4:	11 24       	eor	r1, r1
    20f6:	b6 01       	movw	r22, r12
    20f8:	88 50       	subi	r24, 0x08	; 8
    20fa:	9f 4c       	sbci	r25, 0xCF	; 207
    20fc:	0e 94 bf 0a 	call	0x157e	; 0x157e <vListInsertEnd>
    2100:	0f 90       	pop	r0
    2102:	0f be       	out	0x3f, r0	; 63
    2104:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    2108:	88 23       	and	r24, r24
    210a:	59 f0       	breq	.+22     	; 0x2122 <xTaskGenericCreate+0x1d0>
    210c:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2110:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2114:	82 8d       	ldd	r24, Z+26	; 0x1a
    2116:	80 17       	cp	r24, r16
    2118:	30 f4       	brcc	.+12     	; 0x2126 <xTaskGenericCreate+0x1d4>
    211a:	0e 94 0b 0c 	call	0x1816	; 0x1816 <vPortYield>
    211e:	81 e0       	ldi	r24, 0x01	; 1
    2120:	09 c0       	rjmp	.+18     	; 0x2134 <xTaskGenericCreate+0x1e2>
    2122:	81 e0       	ldi	r24, 0x01	; 1
    2124:	07 c0       	rjmp	.+14     	; 0x2134 <xTaskGenericCreate+0x1e2>
    2126:	81 e0       	ldi	r24, 0x01	; 1
    2128:	05 c0       	rjmp	.+10     	; 0x2134 <xTaskGenericCreate+0x1e2>
    212a:	cb 8e       	std	Y+27, r12	; 0x1b
    212c:	dc 8e       	std	Y+28, r13	; 0x1c
    212e:	c6 01       	movw	r24, r12
    2130:	3b cf       	rjmp	.-394    	; 0x1fa8 <xTaskGenericCreate+0x56>
    2132:	8f ef       	ldi	r24, 0xFF	; 255
    2134:	df 91       	pop	r29
    2136:	cf 91       	pop	r28
    2138:	1f 91       	pop	r17
    213a:	0f 91       	pop	r16
    213c:	ff 90       	pop	r15
    213e:	ef 90       	pop	r14
    2140:	df 90       	pop	r13
    2142:	cf 90       	pop	r12
    2144:	bf 90       	pop	r11
    2146:	af 90       	pop	r10
    2148:	9f 90       	pop	r9
    214a:	8f 90       	pop	r8
    214c:	7f 90       	pop	r7
    214e:	6f 90       	pop	r6
    2150:	5f 90       	pop	r5
    2152:	4f 90       	pop	r4
    2154:	08 95       	ret

00002156 <uxTaskPriorityGet>:
    2156:	0f b6       	in	r0, 0x3f	; 63
    2158:	f8 94       	cli
    215a:	0f 92       	push	r0
    215c:	00 97       	sbiw	r24, 0x00	; 0
    215e:	21 f4       	brne	.+8      	; 0x2168 <uxTaskPriorityGet+0x12>
    2160:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2164:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2168:	0f 90       	pop	r0
    216a:	0f be       	out	0x3f, r0	; 63
    216c:	fc 01       	movw	r30, r24
    216e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2170:	08 95       	ret

00002172 <vTaskStartScheduler>:
    2172:	af 92       	push	r10
    2174:	bf 92       	push	r11
    2176:	cf 92       	push	r12
    2178:	df 92       	push	r13
    217a:	ef 92       	push	r14
    217c:	ff 92       	push	r15
    217e:	0f 93       	push	r16
    2180:	a1 2c       	mov	r10, r1
    2182:	b1 2c       	mov	r11, r1
    2184:	c1 2c       	mov	r12, r1
    2186:	d1 2c       	mov	r13, r1
    2188:	0f 2e       	mov	r0, r31
    218a:	f1 ed       	ldi	r31, 0xD1	; 209
    218c:	ef 2e       	mov	r14, r31
    218e:	f0 e3       	ldi	r31, 0x30	; 48
    2190:	ff 2e       	mov	r15, r31
    2192:	f0 2d       	mov	r31, r0
    2194:	00 e0       	ldi	r16, 0x00	; 0
    2196:	20 e0       	ldi	r18, 0x00	; 0
    2198:	30 e0       	ldi	r19, 0x00	; 0
    219a:	44 e6       	ldi	r20, 0x64	; 100
    219c:	50 e0       	ldi	r21, 0x00	; 0
    219e:	6b e3       	ldi	r22, 0x3B	; 59
    21a0:	70 e2       	ldi	r23, 0x20	; 32
    21a2:	83 e5       	ldi	r24, 0x53	; 83
    21a4:	9f e0       	ldi	r25, 0x0F	; 15
    21a6:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <xTaskGenericCreate>
    21aa:	81 30       	cpi	r24, 0x01	; 1
    21ac:	69 f4       	brne	.+26     	; 0x21c8 <vTaskStartScheduler+0x56>
    21ae:	f8 94       	cli
    21b0:	80 93 c9 30 	sts	0x30C9, r24	; 0x8030c9 <xSchedulerRunning>
    21b4:	10 92 cc 30 	sts	0x30CC, r1	; 0x8030cc <xTickCount>
    21b8:	10 92 cd 30 	sts	0x30CD, r1	; 0x8030cd <xTickCount+0x1>
    21bc:	10 92 ce 30 	sts	0x30CE, r1	; 0x8030ce <xTickCount+0x2>
    21c0:	10 92 cf 30 	sts	0x30CF, r1	; 0x8030cf <xTickCount+0x3>
    21c4:	0e 94 cd 0b 	call	0x179a	; 0x179a <xPortStartScheduler>
    21c8:	0f 91       	pop	r16
    21ca:	ff 90       	pop	r15
    21cc:	ef 90       	pop	r14
    21ce:	df 90       	pop	r13
    21d0:	cf 90       	pop	r12
    21d2:	bf 90       	pop	r11
    21d4:	af 90       	pop	r10
    21d6:	08 95       	ret

000021d8 <vTaskSuspendAll>:
    21d8:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    21dc:	8f 5f       	subi	r24, 0xFF	; 255
    21de:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>
    21e2:	08 95       	ret

000021e4 <xTaskGetTickCount>:
    21e4:	0f b6       	in	r0, 0x3f	; 63
    21e6:	f8 94       	cli
    21e8:	0f 92       	push	r0
    21ea:	60 91 cc 30 	lds	r22, 0x30CC	; 0x8030cc <xTickCount>
    21ee:	70 91 cd 30 	lds	r23, 0x30CD	; 0x8030cd <xTickCount+0x1>
    21f2:	80 91 ce 30 	lds	r24, 0x30CE	; 0x8030ce <xTickCount+0x2>
    21f6:	90 91 cf 30 	lds	r25, 0x30CF	; 0x8030cf <xTickCount+0x3>
    21fa:	0f 90       	pop	r0
    21fc:	0f be       	out	0x3f, r0	; 63
    21fe:	08 95       	ret

00002200 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2200:	00 97       	sbiw	r24, 0x00	; 0
    2202:	21 f4       	brne	.+8      	; 0x220c <pcTaskGetTaskName+0xc>
    2204:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2208:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    220c:	4d 96       	adiw	r24, 0x1d	; 29
    220e:	08 95       	ret

00002210 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    2210:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xIdleTaskHandle>
    2214:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <xIdleTaskHandle+0x1>
    2218:	08 95       	ret

0000221a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    221a:	ff 92       	push	r15
    221c:	0f 93       	push	r16
    221e:	1f 93       	push	r17
    2220:	cf 93       	push	r28
    2222:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2224:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2228:	81 11       	cpse	r24, r1
    222a:	ed c0       	rjmp	.+474    	; 0x2406 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    222c:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2230:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2234:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2238:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    223c:	01 96       	adiw	r24, 0x01	; 1
    223e:	a1 1d       	adc	r26, r1
    2240:	b1 1d       	adc	r27, r1
    2242:	80 93 cc 30 	sts	0x30CC, r24	; 0x8030cc <xTickCount>
    2246:	90 93 cd 30 	sts	0x30CD, r25	; 0x8030cd <xTickCount+0x1>
    224a:	a0 93 ce 30 	sts	0x30CE, r26	; 0x8030ce <xTickCount+0x2>
    224e:	b0 93 cf 30 	sts	0x30CF, r27	; 0x8030cf <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    2252:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2256:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    225a:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    225e:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2262:	89 2b       	or	r24, r25
    2264:	8a 2b       	or	r24, r26
    2266:	8b 2b       	or	r24, r27
    2268:	f1 f5       	brne	.+124    	; 0x22e6 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    226a:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    226e:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2272:	20 91 de 30 	lds	r18, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    2276:	30 91 df 30 	lds	r19, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    227a:	20 93 e0 30 	sts	0x30E0, r18	; 0x8030e0 <pxDelayedTaskList>
    227e:	30 93 e1 30 	sts	0x30E1, r19	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    2282:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    2286:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    228a:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    228e:	8f 5f       	subi	r24, 0xFF	; 255
    2290:	80 93 c5 30 	sts	0x30C5, r24	; 0x8030c5 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2294:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2298:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    229c:	80 81       	ld	r24, Z
    229e:	81 11       	cpse	r24, r1
    22a0:	0c c0       	rjmp	.+24     	; 0x22ba <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    22a2:	8f ef       	ldi	r24, 0xFF	; 255
    22a4:	9f ef       	ldi	r25, 0xFF	; 255
    22a6:	dc 01       	movw	r26, r24
    22a8:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    22ac:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    22b0:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    22b4:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    22b8:	16 c0       	rjmp	.+44     	; 0x22e6 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    22ba:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    22be:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    22c2:	07 80       	ldd	r0, Z+7	; 0x07
    22c4:	f0 85       	ldd	r31, Z+8	; 0x08
    22c6:	e0 2d       	mov	r30, r0
    22c8:	00 84       	ldd	r0, Z+8	; 0x08
    22ca:	f1 85       	ldd	r31, Z+9	; 0x09
    22cc:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    22ce:	82 81       	ldd	r24, Z+2	; 0x02
    22d0:	93 81       	ldd	r25, Z+3	; 0x03
    22d2:	a4 81       	ldd	r26, Z+4	; 0x04
    22d4:	b5 81       	ldd	r27, Z+5	; 0x05
    22d6:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    22da:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    22de:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    22e2:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    22e6:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    22ea:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    22ee:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    22f2:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    22f6:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    22fa:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    22fe:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2302:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2306:	48 17       	cp	r20, r24
    2308:	59 07       	cpc	r21, r25
    230a:	6a 07       	cpc	r22, r26
    230c:	7b 07       	cpc	r23, r27
    230e:	08 f4       	brcc	.+2      	; 0x2312 <vTaskIncrementTick+0xf8>
    2310:	7f c0       	rjmp	.+254    	; 0x2410 <vTaskIncrementTick+0x1f6>
    2312:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2316:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    231a:	80 81       	ld	r24, Z
    231c:	88 23       	and	r24, r24
    231e:	f9 f0       	breq	.+62     	; 0x235e <vTaskIncrementTick+0x144>
    2320:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2324:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2328:	07 80       	ldd	r0, Z+7	; 0x07
    232a:	f0 85       	ldd	r31, Z+8	; 0x08
    232c:	e0 2d       	mov	r30, r0
    232e:	c0 85       	ldd	r28, Z+8	; 0x08
    2330:	d1 85       	ldd	r29, Z+9	; 0x09
    2332:	8a 81       	ldd	r24, Y+2	; 0x02
    2334:	9b 81       	ldd	r25, Y+3	; 0x03
    2336:	ac 81       	ldd	r26, Y+4	; 0x04
    2338:	bd 81       	ldd	r27, Y+5	; 0x05
    233a:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    233e:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2342:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2346:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    234a:	48 17       	cp	r20, r24
    234c:	59 07       	cpc	r21, r25
    234e:	6a 07       	cpc	r22, r26
    2350:	7b 07       	cpc	r23, r27
    2352:	58 f1       	brcs	.+86     	; 0x23aa <vTaskIncrementTick+0x190>
    2354:	0f 2e       	mov	r0, r31
    2356:	fb e0       	ldi	r31, 0x0B	; 11
    2358:	ff 2e       	mov	r15, r31
    235a:	f0 2d       	mov	r31, r0
    235c:	2f c0       	rjmp	.+94     	; 0x23bc <vTaskIncrementTick+0x1a2>
    235e:	8f ef       	ldi	r24, 0xFF	; 255
    2360:	9f ef       	ldi	r25, 0xFF	; 255
    2362:	dc 01       	movw	r26, r24
    2364:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2368:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    236c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2370:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2374:	4d c0       	rjmp	.+154    	; 0x2410 <vTaskIncrementTick+0x1f6>
    2376:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    237a:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    237e:	07 80       	ldd	r0, Z+7	; 0x07
    2380:	f0 85       	ldd	r31, Z+8	; 0x08
    2382:	e0 2d       	mov	r30, r0
    2384:	c0 85       	ldd	r28, Z+8	; 0x08
    2386:	d1 85       	ldd	r29, Z+9	; 0x09
    2388:	8a 81       	ldd	r24, Y+2	; 0x02
    238a:	9b 81       	ldd	r25, Y+3	; 0x03
    238c:	ac 81       	ldd	r26, Y+4	; 0x04
    238e:	bd 81       	ldd	r27, Y+5	; 0x05
    2390:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2394:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2398:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    239c:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    23a0:	48 17       	cp	r20, r24
    23a2:	59 07       	cpc	r21, r25
    23a4:	6a 07       	cpc	r22, r26
    23a6:	7b 07       	cpc	r23, r27
    23a8:	48 f4       	brcc	.+18     	; 0x23bc <vTaskIncrementTick+0x1a2>
    23aa:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    23ae:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    23b2:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    23b6:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    23ba:	2a c0       	rjmp	.+84     	; 0x2410 <vTaskIncrementTick+0x1f6>
    23bc:	8e 01       	movw	r16, r28
    23be:	0e 5f       	subi	r16, 0xFE	; 254
    23c0:	1f 4f       	sbci	r17, 0xFF	; 255
    23c2:	c8 01       	movw	r24, r16
    23c4:	0e 94 31 0b 	call	0x1662	; 0x1662 <vListRemove>
    23c8:	88 8d       	ldd	r24, Y+24	; 0x18
    23ca:	99 8d       	ldd	r25, Y+25	; 0x19
    23cc:	89 2b       	or	r24, r25
    23ce:	21 f0       	breq	.+8      	; 0x23d8 <vTaskIncrementTick+0x1be>
    23d0:	ce 01       	movw	r24, r28
    23d2:	0e 96       	adiw	r24, 0x0e	; 14
    23d4:	0e 94 31 0b 	call	0x1662	; 0x1662 <vListRemove>
    23d8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    23da:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    23de:	98 17       	cp	r25, r24
    23e0:	10 f4       	brcc	.+4      	; 0x23e6 <vTaskIncrementTick+0x1cc>
    23e2:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    23e6:	f8 9e       	mul	r15, r24
    23e8:	c0 01       	movw	r24, r0
    23ea:	11 24       	eor	r1, r1
    23ec:	b8 01       	movw	r22, r16
    23ee:	88 50       	subi	r24, 0x08	; 8
    23f0:	9f 4c       	sbci	r25, 0xCF	; 207
    23f2:	0e 94 bf 0a 	call	0x157e	; 0x157e <vListInsertEnd>
    23f6:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    23fa:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    23fe:	80 81       	ld	r24, Z
    2400:	81 11       	cpse	r24, r1
    2402:	b9 cf       	rjmp	.-142    	; 0x2376 <vTaskIncrementTick+0x15c>
    2404:	ac cf       	rjmp	.-168    	; 0x235e <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    2406:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    240a:	8f 5f       	subi	r24, 0xFF	; 255
    240c:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2410:	df 91       	pop	r29
    2412:	cf 91       	pop	r28
    2414:	1f 91       	pop	r17
    2416:	0f 91       	pop	r16
    2418:	ff 90       	pop	r15
    241a:	08 95       	ret

0000241c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    241c:	cf 92       	push	r12
    241e:	df 92       	push	r13
    2420:	ef 92       	push	r14
    2422:	ff 92       	push	r15
    2424:	0f 93       	push	r16
    2426:	1f 93       	push	r17
    2428:	cf 93       	push	r28
    242a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    242c:	0f b6       	in	r0, 0x3f	; 63
    242e:	f8 94       	cli
    2430:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2432:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2436:	81 50       	subi	r24, 0x01	; 1
    2438:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    243c:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2440:	81 11       	cpse	r24, r1
    2442:	60 c0       	rjmp	.+192    	; 0x2504 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2444:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2448:	81 11       	cpse	r24, r1
    244a:	2c c0       	rjmp	.+88     	; 0x24a4 <xTaskResumeAll+0x88>
    244c:	5e c0       	rjmp	.+188    	; 0x250a <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    244e:	d7 01       	movw	r26, r14
    2450:	17 96       	adiw	r26, 0x07	; 7
    2452:	ed 91       	ld	r30, X+
    2454:	fc 91       	ld	r31, X
    2456:	18 97       	sbiw	r26, 0x08	; 8
    2458:	c0 85       	ldd	r28, Z+8	; 0x08
    245a:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    245c:	ce 01       	movw	r24, r28
    245e:	0e 96       	adiw	r24, 0x0e	; 14
    2460:	0e 94 31 0b 	call	0x1662	; 0x1662 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2464:	8e 01       	movw	r16, r28
    2466:	0e 5f       	subi	r16, 0xFE	; 254
    2468:	1f 4f       	sbci	r17, 0xFF	; 255
    246a:	c8 01       	movw	r24, r16
    246c:	0e 94 31 0b 	call	0x1662	; 0x1662 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2470:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2472:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2476:	98 17       	cp	r25, r24
    2478:	10 f4       	brcc	.+4      	; 0x247e <xTaskResumeAll+0x62>
    247a:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    247e:	d8 9e       	mul	r13, r24
    2480:	c0 01       	movw	r24, r0
    2482:	11 24       	eor	r1, r1
    2484:	b8 01       	movw	r22, r16
    2486:	88 50       	subi	r24, 0x08	; 8
    2488:	9f 4c       	sbci	r25, 0xCF	; 207
    248a:	0e 94 bf 0a 	call	0x157e	; 0x157e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    248e:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2492:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2496:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2498:	82 8d       	ldd	r24, Z+26	; 0x1a
    249a:	98 17       	cp	r25, r24
    249c:	70 f0       	brcs	.+28     	; 0x24ba <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    249e:	cc 24       	eor	r12, r12
    24a0:	c3 94       	inc	r12
    24a2:	0b c0       	rjmp	.+22     	; 0x24ba <xTaskResumeAll+0x9e>
    24a4:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    24a6:	0f 2e       	mov	r0, r31
    24a8:	f3 ed       	ldi	r31, 0xD3	; 211
    24aa:	ef 2e       	mov	r14, r31
    24ac:	f0 e3       	ldi	r31, 0x30	; 48
    24ae:	ff 2e       	mov	r15, r31
    24b0:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    24b2:	0f 2e       	mov	r0, r31
    24b4:	fb e0       	ldi	r31, 0x0B	; 11
    24b6:	df 2e       	mov	r13, r31
    24b8:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    24ba:	f7 01       	movw	r30, r14
    24bc:	80 81       	ld	r24, Z
    24be:	81 11       	cpse	r24, r1
    24c0:	c6 cf       	rjmp	.-116    	; 0x244e <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    24c2:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    24c6:	88 23       	and	r24, r24
    24c8:	81 f0       	breq	.+32     	; 0x24ea <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    24ca:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    24ce:	88 23       	and	r24, r24
    24d0:	99 f0       	breq	.+38     	; 0x24f8 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    24d2:	0e 94 0d 11 	call	0x221a	; 0x221a <vTaskIncrementTick>
						--uxMissedTicks;
    24d6:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    24da:	81 50       	subi	r24, 0x01	; 1
    24dc:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    24e0:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    24e4:	81 11       	cpse	r24, r1
    24e6:	f5 cf       	rjmp	.-22     	; 0x24d2 <xTaskResumeAll+0xb6>
    24e8:	07 c0       	rjmp	.+14     	; 0x24f8 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    24ea:	f1 e0       	ldi	r31, 0x01	; 1
    24ec:	cf 16       	cp	r12, r31
    24ee:	21 f0       	breq	.+8      	; 0x24f8 <xTaskResumeAll+0xdc>
    24f0:	80 91 c6 30 	lds	r24, 0x30C6	; 0x8030c6 <xMissedYield>
    24f4:	81 30       	cpi	r24, 0x01	; 1
    24f6:	41 f4       	brne	.+16     	; 0x2508 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    24f8:	10 92 c6 30 	sts	0x30C6, r1	; 0x8030c6 <xMissedYield>
					portYIELD_WITHIN_API();
    24fc:	0e 94 0b 0c 	call	0x1816	; 0x1816 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    2500:	81 e0       	ldi	r24, 0x01	; 1
    2502:	03 c0       	rjmp	.+6      	; 0x250a <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2504:	80 e0       	ldi	r24, 0x00	; 0
    2506:	01 c0       	rjmp	.+2      	; 0x250a <xTaskResumeAll+0xee>
    2508:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    250a:	0f 90       	pop	r0
    250c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    250e:	df 91       	pop	r29
    2510:	cf 91       	pop	r28
    2512:	1f 91       	pop	r17
    2514:	0f 91       	pop	r16
    2516:	ff 90       	pop	r15
    2518:	ef 90       	pop	r14
    251a:	df 90       	pop	r13
    251c:	cf 90       	pop	r12
    251e:	08 95       	ret

00002520 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2520:	cf 92       	push	r12
    2522:	df 92       	push	r13
    2524:	ef 92       	push	r14
    2526:	ff 92       	push	r15
    2528:	cf 93       	push	r28
    252a:	df 93       	push	r29
    252c:	ec 01       	movw	r28, r24
    252e:	6a 01       	movw	r12, r20
    2530:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2532:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2536:	88 81       	ld	r24, Y
    2538:	99 81       	ldd	r25, Y+1	; 0x01
    253a:	aa 81       	ldd	r26, Y+2	; 0x02
    253c:	bb 81       	ldd	r27, Y+3	; 0x03
    253e:	c8 0e       	add	r12, r24
    2540:	d9 1e       	adc	r13, r25
    2542:	ea 1e       	adc	r14, r26
    2544:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2546:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    254a:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    254e:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2552:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2556:	48 17       	cp	r20, r24
    2558:	59 07       	cpc	r21, r25
    255a:	6a 07       	cpc	r22, r26
    255c:	7b 07       	cpc	r23, r27
    255e:	b8 f4       	brcc	.+46     	; 0x258e <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2560:	c8 16       	cp	r12, r24
    2562:	d9 06       	cpc	r13, r25
    2564:	ea 06       	cpc	r14, r26
    2566:	fb 06       	cpc	r15, r27
    2568:	e0 f5       	brcc	.+120    	; 0x25e2 <vTaskDelayUntil+0xc2>
    256a:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    256e:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2572:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2576:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    257a:	c8 82       	st	Y, r12
    257c:	d9 82       	std	Y+1, r13	; 0x01
    257e:	ea 82       	std	Y+2, r14	; 0x02
    2580:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2582:	8c 15       	cp	r24, r12
    2584:	9d 05       	cpc	r25, r13
    2586:	ae 05       	cpc	r26, r14
    2588:	bf 05       	cpc	r27, r15
    258a:	f8 f4       	brcc	.+62     	; 0x25ca <vTaskDelayUntil+0xaa>
    258c:	13 c0       	rjmp	.+38     	; 0x25b4 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    258e:	c8 16       	cp	r12, r24
    2590:	d9 06       	cpc	r13, r25
    2592:	ea 06       	cpc	r14, r26
    2594:	fb 06       	cpc	r15, r27
    2596:	00 f1       	brcs	.+64     	; 0x25d8 <vTaskDelayUntil+0xb8>
    2598:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    259c:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    25a0:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    25a4:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    25a8:	8c 15       	cp	r24, r12
    25aa:	9d 05       	cpc	r25, r13
    25ac:	ae 05       	cpc	r26, r14
    25ae:	bf 05       	cpc	r27, r15
    25b0:	98 f0       	brcs	.+38     	; 0x25d8 <vTaskDelayUntil+0xb8>
    25b2:	17 c0       	rjmp	.+46     	; 0x25e2 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25b4:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    25b8:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    25bc:	02 96       	adiw	r24, 0x02	; 2
    25be:	0e 94 31 0b 	call	0x1662	; 0x1662 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    25c2:	c7 01       	movw	r24, r14
    25c4:	b6 01       	movw	r22, r12
    25c6:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    25ca:	0e 94 0e 12 	call	0x241c	; 0x241c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    25ce:	81 11       	cpse	r24, r1
    25d0:	0d c0       	rjmp	.+26     	; 0x25ec <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    25d2:	0e 94 0b 0c 	call	0x1816	; 0x1816 <vPortYield>
		}
	}
    25d6:	0a c0       	rjmp	.+20     	; 0x25ec <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    25d8:	c8 82       	st	Y, r12
    25da:	d9 82       	std	Y+1, r13	; 0x01
    25dc:	ea 82       	std	Y+2, r14	; 0x02
    25de:	fb 82       	std	Y+3, r15	; 0x03
    25e0:	e9 cf       	rjmp	.-46     	; 0x25b4 <vTaskDelayUntil+0x94>
    25e2:	c8 82       	st	Y, r12
    25e4:	d9 82       	std	Y+1, r13	; 0x01
    25e6:	ea 82       	std	Y+2, r14	; 0x02
    25e8:	fb 82       	std	Y+3, r15	; 0x03
    25ea:	ef cf       	rjmp	.-34     	; 0x25ca <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    25ec:	df 91       	pop	r29
    25ee:	cf 91       	pop	r28
    25f0:	ff 90       	pop	r15
    25f2:	ef 90       	pop	r14
    25f4:	df 90       	pop	r13
    25f6:	cf 90       	pop	r12
    25f8:	08 95       	ret

000025fa <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    25fa:	cf 92       	push	r12
    25fc:	df 92       	push	r13
    25fe:	ef 92       	push	r14
    2600:	ff 92       	push	r15
    2602:	6b 01       	movw	r12, r22
    2604:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2606:	67 2b       	or	r22, r23
    2608:	68 2b       	or	r22, r24
    260a:	69 2b       	or	r22, r25
    260c:	e9 f0       	breq	.+58     	; 0x2648 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    260e:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2612:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2616:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    261a:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    261e:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2622:	c8 0e       	add	r12, r24
    2624:	d9 1e       	adc	r13, r25
    2626:	ea 1e       	adc	r14, r26
    2628:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    262a:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    262e:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2632:	02 96       	adiw	r24, 0x02	; 2
    2634:	0e 94 31 0b 	call	0x1662	; 0x1662 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2638:	c7 01       	movw	r24, r14
    263a:	b6 01       	movw	r22, r12
    263c:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2640:	0e 94 0e 12 	call	0x241c	; 0x241c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2644:	81 11       	cpse	r24, r1
    2646:	02 c0       	rjmp	.+4      	; 0x264c <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2648:	0e 94 0b 0c 	call	0x1816	; 0x1816 <vPortYield>
		}
	}
    264c:	ff 90       	pop	r15
    264e:	ef 90       	pop	r14
    2650:	df 90       	pop	r13
    2652:	cf 90       	pop	r12
    2654:	08 95       	ret

00002656 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2656:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    265a:	81 11       	cpse	r24, r1
    265c:	0c c0       	rjmp	.+24     	; 0x2676 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    265e:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2662:	4b e0       	ldi	r20, 0x0B	; 11
    2664:	e4 9f       	mul	r30, r20
    2666:	f0 01       	movw	r30, r0
    2668:	11 24       	eor	r1, r1
    266a:	e8 50       	subi	r30, 0x08	; 8
    266c:	ff 4c       	sbci	r31, 0xCF	; 207
    266e:	80 81       	ld	r24, Z
    2670:	88 23       	and	r24, r24
    2672:	29 f0       	breq	.+10     	; 0x267e <vTaskSwitchContext+0x28>
    2674:	14 c0       	rjmp	.+40     	; 0x269e <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2676:	81 e0       	ldi	r24, 0x01	; 1
    2678:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    267c:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    267e:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2680:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2684:	81 50       	subi	r24, 0x01	; 1
    2686:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    268a:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    268e:	9e 9f       	mul	r25, r30
    2690:	f0 01       	movw	r30, r0
    2692:	11 24       	eor	r1, r1
    2694:	e8 50       	subi	r30, 0x08	; 8
    2696:	ff 4c       	sbci	r31, 0xCF	; 207
    2698:	80 81       	ld	r24, Z
    269a:	88 23       	and	r24, r24
    269c:	89 f3       	breq	.-30     	; 0x2680 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    269e:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    26a2:	28 2f       	mov	r18, r24
    26a4:	30 e0       	ldi	r19, 0x00	; 0
    26a6:	4b e0       	ldi	r20, 0x0B	; 11
    26a8:	84 9f       	mul	r24, r20
    26aa:	c0 01       	movw	r24, r0
    26ac:	11 24       	eor	r1, r1
    26ae:	dc 01       	movw	r26, r24
    26b0:	a8 50       	subi	r26, 0x08	; 8
    26b2:	bf 4c       	sbci	r27, 0xCF	; 207
    26b4:	11 96       	adiw	r26, 0x01	; 1
    26b6:	ed 91       	ld	r30, X+
    26b8:	fc 91       	ld	r31, X
    26ba:	12 97       	sbiw	r26, 0x02	; 2
    26bc:	04 80       	ldd	r0, Z+4	; 0x04
    26be:	f5 81       	ldd	r31, Z+5	; 0x05
    26c0:	e0 2d       	mov	r30, r0
    26c2:	11 96       	adiw	r26, 0x01	; 1
    26c4:	ed 93       	st	X+, r30
    26c6:	fc 93       	st	X, r31
    26c8:	12 97       	sbiw	r26, 0x02	; 2
    26ca:	85 50       	subi	r24, 0x05	; 5
    26cc:	9f 4c       	sbci	r25, 0xCF	; 207
    26ce:	e8 17       	cp	r30, r24
    26d0:	f9 07       	cpc	r31, r25
    26d2:	61 f4       	brne	.+24     	; 0x26ec <vTaskSwitchContext+0x96>
    26d4:	84 81       	ldd	r24, Z+4	; 0x04
    26d6:	95 81       	ldd	r25, Z+5	; 0x05
    26d8:	4b e0       	ldi	r20, 0x0B	; 11
    26da:	42 9f       	mul	r20, r18
    26dc:	f0 01       	movw	r30, r0
    26de:	43 9f       	mul	r20, r19
    26e0:	f0 0d       	add	r31, r0
    26e2:	11 24       	eor	r1, r1
    26e4:	e8 50       	subi	r30, 0x08	; 8
    26e6:	ff 4c       	sbci	r31, 0xCF	; 207
    26e8:	81 83       	std	Z+1, r24	; 0x01
    26ea:	92 83       	std	Z+2, r25	; 0x02
    26ec:	8b e0       	ldi	r24, 0x0B	; 11
    26ee:	82 9f       	mul	r24, r18
    26f0:	f0 01       	movw	r30, r0
    26f2:	83 9f       	mul	r24, r19
    26f4:	f0 0d       	add	r31, r0
    26f6:	11 24       	eor	r1, r1
    26f8:	e8 50       	subi	r30, 0x08	; 8
    26fa:	ff 4c       	sbci	r31, 0xCF	; 207
    26fc:	01 80       	ldd	r0, Z+1	; 0x01
    26fe:	f2 81       	ldd	r31, Z+2	; 0x02
    2700:	e0 2d       	mov	r30, r0
    2702:	80 85       	ldd	r24, Z+8	; 0x08
    2704:	91 85       	ldd	r25, Z+9	; 0x09
    2706:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <pxCurrentTCB>
    270a:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <pxCurrentTCB+0x1>
    270e:	08 95       	ret

00002710 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2710:	cf 92       	push	r12
    2712:	df 92       	push	r13
    2714:	ef 92       	push	r14
    2716:	ff 92       	push	r15
    2718:	6a 01       	movw	r12, r20
    271a:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    271c:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    2720:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2724:	62 5f       	subi	r22, 0xF2	; 242
    2726:	7f 4f       	sbci	r23, 0xFF	; 255
    2728:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    272c:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2730:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2734:	02 96       	adiw	r24, 0x02	; 2
    2736:	0e 94 31 0b 	call	0x1662	; 0x1662 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    273a:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    273e:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2742:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2746:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    274a:	bc 01       	movw	r22, r24
    274c:	cd 01       	movw	r24, r26
    274e:	6c 0d       	add	r22, r12
    2750:	7d 1d       	adc	r23, r13
    2752:	8e 1d       	adc	r24, r14
    2754:	9f 1d       	adc	r25, r15
    2756:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    275a:	ff 90       	pop	r15
    275c:	ef 90       	pop	r14
    275e:	df 90       	pop	r13
    2760:	cf 90       	pop	r12
    2762:	08 95       	ret

00002764 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2764:	0f 93       	push	r16
    2766:	1f 93       	push	r17
    2768:	cf 93       	push	r28
    276a:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    276c:	dc 01       	movw	r26, r24
    276e:	17 96       	adiw	r26, 0x07	; 7
    2770:	ed 91       	ld	r30, X+
    2772:	fc 91       	ld	r31, X
    2774:	18 97       	sbiw	r26, 0x08	; 8
    2776:	c0 85       	ldd	r28, Z+8	; 0x08
    2778:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    277a:	8e 01       	movw	r16, r28
    277c:	02 5f       	subi	r16, 0xF2	; 242
    277e:	1f 4f       	sbci	r17, 0xFF	; 255
    2780:	c8 01       	movw	r24, r16
    2782:	0e 94 31 0b 	call	0x1662	; 0x1662 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2786:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    278a:	81 11       	cpse	r24, r1
    278c:	16 c0       	rjmp	.+44     	; 0x27ba <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    278e:	0c 50       	subi	r16, 0x0C	; 12
    2790:	11 09       	sbc	r17, r1
    2792:	c8 01       	movw	r24, r16
    2794:	0e 94 31 0b 	call	0x1662	; 0x1662 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2798:	8a 8d       	ldd	r24, Y+26	; 0x1a
    279a:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    279e:	98 17       	cp	r25, r24
    27a0:	10 f4       	brcc	.+4      	; 0x27a6 <xTaskRemoveFromEventList+0x42>
    27a2:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    27a6:	bb e0       	ldi	r27, 0x0B	; 11
    27a8:	8b 9f       	mul	r24, r27
    27aa:	c0 01       	movw	r24, r0
    27ac:	11 24       	eor	r1, r1
    27ae:	b8 01       	movw	r22, r16
    27b0:	88 50       	subi	r24, 0x08	; 8
    27b2:	9f 4c       	sbci	r25, 0xCF	; 207
    27b4:	0e 94 bf 0a 	call	0x157e	; 0x157e <vListInsertEnd>
    27b8:	05 c0       	rjmp	.+10     	; 0x27c4 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    27ba:	b8 01       	movw	r22, r16
    27bc:	83 ed       	ldi	r24, 0xD3	; 211
    27be:	90 e3       	ldi	r25, 0x30	; 48
    27c0:	0e 94 bf 0a 	call	0x157e	; 0x157e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    27c4:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    27c8:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    27cc:	81 e0       	ldi	r24, 0x01	; 1
    27ce:	2a 8d       	ldd	r18, Y+26	; 0x1a
    27d0:	92 8d       	ldd	r25, Z+26	; 0x1a
    27d2:	29 17       	cp	r18, r25
    27d4:	08 f4       	brcc	.+2      	; 0x27d8 <xTaskRemoveFromEventList+0x74>
    27d6:	80 e0       	ldi	r24, 0x00	; 0
}
    27d8:	df 91       	pop	r29
    27da:	cf 91       	pop	r28
    27dc:	1f 91       	pop	r17
    27de:	0f 91       	pop	r16
    27e0:	08 95       	ret

000027e2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    27e2:	20 91 c5 30 	lds	r18, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    27e6:	fc 01       	movw	r30, r24
    27e8:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    27ea:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    27ee:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    27f2:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    27f6:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    27fa:	41 83       	std	Z+1, r20	; 0x01
    27fc:	52 83       	std	Z+2, r21	; 0x02
    27fe:	63 83       	std	Z+3, r22	; 0x03
    2800:	74 83       	std	Z+4, r23	; 0x04
    2802:	08 95       	ret

00002804 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2804:	8f 92       	push	r8
    2806:	9f 92       	push	r9
    2808:	af 92       	push	r10
    280a:	bf 92       	push	r11
    280c:	cf 92       	push	r12
    280e:	df 92       	push	r13
    2810:	ef 92       	push	r14
    2812:	ff 92       	push	r15
    2814:	0f 93       	push	r16
    2816:	1f 93       	push	r17
    2818:	cf 93       	push	r28
    281a:	df 93       	push	r29
    281c:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    281e:	0f b6       	in	r0, 0x3f	; 63
    2820:	f8 94       	cli
    2822:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2824:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    2828:	90 81       	ld	r25, Z
    282a:	98 17       	cp	r25, r24
    282c:	89 f0       	breq	.+34     	; 0x2850 <xTaskCheckForTimeOut+0x4c>
    282e:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2832:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2836:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    283a:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    283e:	01 81       	ldd	r16, Z+1	; 0x01
    2840:	12 81       	ldd	r17, Z+2	; 0x02
    2842:	23 81       	ldd	r18, Z+3	; 0x03
    2844:	34 81       	ldd	r19, Z+4	; 0x04
    2846:	80 17       	cp	r24, r16
    2848:	91 07       	cpc	r25, r17
    284a:	a2 07       	cpc	r26, r18
    284c:	b3 07       	cpc	r27, r19
    284e:	a8 f5       	brcc	.+106    	; 0x28ba <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2850:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2854:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2858:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    285c:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2860:	c1 80       	ldd	r12, Z+1	; 0x01
    2862:	d2 80       	ldd	r13, Z+2	; 0x02
    2864:	e3 80       	ldd	r14, Z+3	; 0x03
    2866:	f4 80       	ldd	r15, Z+4	; 0x04
    2868:	eb 01       	movw	r28, r22
    286a:	08 81       	ld	r16, Y
    286c:	19 81       	ldd	r17, Y+1	; 0x01
    286e:	2a 81       	ldd	r18, Y+2	; 0x02
    2870:	3b 81       	ldd	r19, Y+3	; 0x03
    2872:	8c 19       	sub	r24, r12
    2874:	9d 09       	sbc	r25, r13
    2876:	ae 09       	sbc	r26, r14
    2878:	bf 09       	sbc	r27, r15
    287a:	80 17       	cp	r24, r16
    287c:	91 07       	cpc	r25, r17
    287e:	a2 07       	cpc	r26, r18
    2880:	b3 07       	cpc	r27, r19
    2882:	e8 f4       	brcc	.+58     	; 0x28be <xTaskCheckForTimeOut+0xba>
    2884:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2886:	80 90 cc 30 	lds	r8, 0x30CC	; 0x8030cc <xTickCount>
    288a:	90 90 cd 30 	lds	r9, 0x30CD	; 0x8030cd <xTickCount+0x1>
    288e:	a0 90 ce 30 	lds	r10, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2892:	b0 90 cf 30 	lds	r11, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2896:	b5 01       	movw	r22, r10
    2898:	a4 01       	movw	r20, r8
    289a:	4c 19       	sub	r20, r12
    289c:	5d 09       	sbc	r21, r13
    289e:	6e 09       	sbc	r22, r14
    28a0:	7f 09       	sbc	r23, r15
    28a2:	04 1b       	sub	r16, r20
    28a4:	15 0b       	sbc	r17, r21
    28a6:	26 0b       	sbc	r18, r22
    28a8:	37 0b       	sbc	r19, r23
    28aa:	08 83       	st	Y, r16
    28ac:	19 83       	std	Y+1, r17	; 0x01
    28ae:	2a 83       	std	Y+2, r18	; 0x02
    28b0:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    28b2:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    28b6:	80 e0       	ldi	r24, 0x00	; 0
    28b8:	03 c0       	rjmp	.+6      	; 0x28c0 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    28ba:	81 e0       	ldi	r24, 0x01	; 1
    28bc:	01 c0       	rjmp	.+2      	; 0x28c0 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    28be:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    28c0:	0f 90       	pop	r0
    28c2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    28c4:	df 91       	pop	r29
    28c6:	cf 91       	pop	r28
    28c8:	1f 91       	pop	r17
    28ca:	0f 91       	pop	r16
    28cc:	ff 90       	pop	r15
    28ce:	ef 90       	pop	r14
    28d0:	df 90       	pop	r13
    28d2:	cf 90       	pop	r12
    28d4:	bf 90       	pop	r11
    28d6:	af 90       	pop	r10
    28d8:	9f 90       	pop	r9
    28da:	8f 90       	pop	r8
    28dc:	08 95       	ret

000028de <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    28de:	81 e0       	ldi	r24, 0x01	; 1
    28e0:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    28e4:	08 95       	ret

000028e6 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    28e6:	00 97       	sbiw	r24, 0x00	; 0
    28e8:	21 f4       	brne	.+8      	; 0x28f2 <uxTaskGetStackHighWaterMark+0xc>
    28ea:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    28ee:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    28f2:	dc 01       	movw	r26, r24
    28f4:	5b 96       	adiw	r26, 0x1b	; 27
    28f6:	ed 91       	ld	r30, X+
    28f8:	fc 91       	ld	r31, X
    28fa:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    28fc:	80 81       	ld	r24, Z
    28fe:	81 31       	cpi	r24, 0x11	; 17
    2900:	41 f4       	brne	.+16     	; 0x2912 <uxTaskGetStackHighWaterMark+0x2c>
    2902:	31 96       	adiw	r30, 0x01	; 1
    2904:	80 e0       	ldi	r24, 0x00	; 0
    2906:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2908:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    290a:	21 91       	ld	r18, Z+
    290c:	21 31       	cpi	r18, 0x11	; 17
    290e:	e1 f3       	breq	.-8      	; 0x2908 <uxTaskGetStackHighWaterMark+0x22>
    2910:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2912:	80 e0       	ldi	r24, 0x00	; 0
    2914:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2916:	08 95       	ret

00002918 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2918:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    291c:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2920:	08 95       	ret

00002922 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2922:	0f 93       	push	r16
    2924:	1f 93       	push	r17
    2926:	cf 93       	push	r28
    2928:	df 93       	push	r29
    292a:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    292c:	22 8d       	ldd	r18, Z+26	; 0x1a
    292e:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2932:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2936:	5a 96       	adiw	r26, 0x1a	; 26
    2938:	8c 91       	ld	r24, X
    293a:	28 17       	cp	r18, r24
    293c:	08 f0       	brcs	.+2      	; 0x2940 <vTaskPriorityInherit+0x1e>
    293e:	41 c0       	rjmp	.+130    	; 0x29c2 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2940:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2944:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2948:	5a 96       	adiw	r26, 0x1a	; 26
    294a:	3c 91       	ld	r19, X
    294c:	84 e0       	ldi	r24, 0x04	; 4
    294e:	90 e0       	ldi	r25, 0x00	; 0
    2950:	a0 e0       	ldi	r26, 0x00	; 0
    2952:	b0 e0       	ldi	r27, 0x00	; 0
    2954:	83 1b       	sub	r24, r19
    2956:	91 09       	sbc	r25, r1
    2958:	a1 09       	sbc	r26, r1
    295a:	b1 09       	sbc	r27, r1
    295c:	86 87       	std	Z+14, r24	; 0x0e
    295e:	97 87       	std	Z+15, r25	; 0x0f
    2960:	a0 8b       	std	Z+16, r26	; 0x10
    2962:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2964:	8b e0       	ldi	r24, 0x0B	; 11
    2966:	28 9f       	mul	r18, r24
    2968:	90 01       	movw	r18, r0
    296a:	11 24       	eor	r1, r1
    296c:	28 50       	subi	r18, 0x08	; 8
    296e:	3f 4c       	sbci	r19, 0xCF	; 207
    2970:	84 85       	ldd	r24, Z+12	; 0x0c
    2972:	95 85       	ldd	r25, Z+13	; 0x0d
    2974:	82 17       	cp	r24, r18
    2976:	93 07       	cpc	r25, r19
    2978:	e9 f4       	brne	.+58     	; 0x29b4 <vTaskPriorityInherit+0x92>
    297a:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    297c:	ef 01       	movw	r28, r30
    297e:	22 96       	adiw	r28, 0x02	; 2
    2980:	ce 01       	movw	r24, r28
    2982:	0e 94 31 0b 	call	0x1662	; 0x1662 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2986:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    298a:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    298e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2990:	f8 01       	movw	r30, r16
    2992:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2994:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2998:	98 17       	cp	r25, r24
    299a:	10 f4       	brcc	.+4      	; 0x29a0 <vTaskPriorityInherit+0x7e>
    299c:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    29a0:	fb e0       	ldi	r31, 0x0B	; 11
    29a2:	8f 9f       	mul	r24, r31
    29a4:	c0 01       	movw	r24, r0
    29a6:	11 24       	eor	r1, r1
    29a8:	be 01       	movw	r22, r28
    29aa:	88 50       	subi	r24, 0x08	; 8
    29ac:	9f 4c       	sbci	r25, 0xCF	; 207
    29ae:	0e 94 bf 0a 	call	0x157e	; 0x157e <vListInsertEnd>
    29b2:	07 c0       	rjmp	.+14     	; 0x29c2 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    29b4:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    29b8:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    29bc:	5a 96       	adiw	r26, 0x1a	; 26
    29be:	8c 91       	ld	r24, X
    29c0:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    29c2:	df 91       	pop	r29
    29c4:	cf 91       	pop	r28
    29c6:	1f 91       	pop	r17
    29c8:	0f 91       	pop	r16
    29ca:	08 95       	ret

000029cc <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    29cc:	0f 93       	push	r16
    29ce:	1f 93       	push	r17
    29d0:	cf 93       	push	r28
    29d2:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    29d4:	00 97       	sbiw	r24, 0x00	; 0
    29d6:	49 f1       	breq	.+82     	; 0x2a2a <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    29d8:	fc 01       	movw	r30, r24
    29da:	32 8d       	ldd	r19, Z+26	; 0x1a
    29dc:	27 a1       	ldd	r18, Z+39	; 0x27
    29de:	32 17       	cp	r19, r18
    29e0:	21 f1       	breq	.+72     	; 0x2a2a <vTaskPriorityDisinherit+0x5e>
    29e2:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    29e4:	8c 01       	movw	r16, r24
    29e6:	0e 5f       	subi	r16, 0xFE	; 254
    29e8:	1f 4f       	sbci	r17, 0xFF	; 255
    29ea:	c8 01       	movw	r24, r16
    29ec:	0e 94 31 0b 	call	0x1662	; 0x1662 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    29f0:	8f a1       	ldd	r24, Y+39	; 0x27
    29f2:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    29f4:	44 e0       	ldi	r20, 0x04	; 4
    29f6:	50 e0       	ldi	r21, 0x00	; 0
    29f8:	60 e0       	ldi	r22, 0x00	; 0
    29fa:	70 e0       	ldi	r23, 0x00	; 0
    29fc:	48 1b       	sub	r20, r24
    29fe:	51 09       	sbc	r21, r1
    2a00:	61 09       	sbc	r22, r1
    2a02:	71 09       	sbc	r23, r1
    2a04:	4e 87       	std	Y+14, r20	; 0x0e
    2a06:	5f 87       	std	Y+15, r21	; 0x0f
    2a08:	68 8b       	std	Y+16, r22	; 0x10
    2a0a:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2a0c:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2a10:	98 17       	cp	r25, r24
    2a12:	10 f4       	brcc	.+4      	; 0x2a18 <vTaskPriorityDisinherit+0x4c>
    2a14:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2a18:	fb e0       	ldi	r31, 0x0B	; 11
    2a1a:	8f 9f       	mul	r24, r31
    2a1c:	c0 01       	movw	r24, r0
    2a1e:	11 24       	eor	r1, r1
    2a20:	b8 01       	movw	r22, r16
    2a22:	88 50       	subi	r24, 0x08	; 8
    2a24:	9f 4c       	sbci	r25, 0xCF	; 207
    2a26:	0e 94 bf 0a 	call	0x157e	; 0x157e <vListInsertEnd>
			}
		}
	}
    2a2a:	df 91       	pop	r29
    2a2c:	cf 91       	pop	r28
    2a2e:	1f 91       	pop	r17
    2a30:	0f 91       	pop	r16
    2a32:	08 95       	ret

00002a34 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2a34:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2a36:	e8 81       	ld	r30, Y
    2a38:	f9 81       	ldd	r31, Y+1	; 0x01
    2a3a:	01 90       	ld	r0, Z+
    2a3c:	f0 81       	ld	r31, Z
    2a3e:	e0 2d       	mov	r30, r0
    2a40:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2a42:	1a 82       	std	Y+2, r1	; 0x02
    2a44:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2a46:	6f ef       	ldi	r22, 0xFF	; 255
    2a48:	7f ef       	ldi	r23, 0xFF	; 255
    2a4a:	cb 01       	movw	r24, r22
    2a4c:	0e 94 fd 12 	call	0x25fa	; 0x25fa <vTaskDelay>
    2a50:	fa cf       	rjmp	.-12     	; 0x2a46 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002a52 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2a52:	fc 01       	movw	r30, r24
    2a54:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2a56:	65 87       	std	Z+13, r22	; 0x0d
    2a58:	08 95       	ret

00002a5a <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2a5a:	4f 92       	push	r4
    2a5c:	5f 92       	push	r5
    2a5e:	6f 92       	push	r6
    2a60:	7f 92       	push	r7
    2a62:	8f 92       	push	r8
    2a64:	9f 92       	push	r9
    2a66:	af 92       	push	r10
    2a68:	bf 92       	push	r11
    2a6a:	cf 92       	push	r12
    2a6c:	df 92       	push	r13
    2a6e:	ef 92       	push	r14
    2a70:	ff 92       	push	r15
    2a72:	0f 93       	push	r16
    2a74:	1f 93       	push	r17
    2a76:	cf 93       	push	r28
    2a78:	df 93       	push	r29
    2a7a:	cd b7       	in	r28, 0x3d	; 61
    2a7c:	de b7       	in	r29, 0x3e	; 62
    2a7e:	2a 97       	sbiw	r28, 0x0a	; 10
    2a80:	cd bf       	out	0x3d, r28	; 61
    2a82:	de bf       	out	0x3e, r29	; 62
    2a84:	4c 01       	movw	r8, r24
    2a86:	29 01       	movw	r4, r18
    2a88:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2a8a:	84 e4       	ldi	r24, 0x44	; 68
    2a8c:	90 e2       	ldi	r25, 0x20	; 32
    2a8e:	f4 01       	movw	r30, r8
    2a90:	80 83       	st	Z, r24
    2a92:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2a94:	fb 01       	movw	r30, r22
    2a96:	80 81       	ld	r24, Z
    2a98:	88 23       	and	r24, r24
    2a9a:	69 f0       	breq	.+26     	; 0x2ab6 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2a9c:	de 01       	movw	r26, r28
    2a9e:	11 96       	adiw	r26, 0x01	; 1
    2aa0:	31 96       	adiw	r30, 0x01	; 1
    2aa2:	90 e0       	ldi	r25, 0x00	; 0
    2aa4:	02 c0       	rjmp	.+4      	; 0x2aaa <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2aa6:	99 30       	cpi	r25, 0x09	; 9
    2aa8:	39 f0       	breq	.+14     	; 0x2ab8 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2aaa:	9f 5f       	subi	r25, 0xFF	; 255
    2aac:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2aae:	81 91       	ld	r24, Z+
    2ab0:	81 11       	cpse	r24, r1
    2ab2:	f9 cf       	rjmp	.-14     	; 0x2aa6 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2ab4:	01 c0       	rjmp	.+2      	; 0x2ab8 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2ab6:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2ab8:	e1 e0       	ldi	r30, 0x01	; 1
    2aba:	f0 e0       	ldi	r31, 0x00	; 0
    2abc:	ec 0f       	add	r30, r28
    2abe:	fd 1f       	adc	r31, r29
    2ac0:	e9 0f       	add	r30, r25
    2ac2:	f1 1d       	adc	r31, r1
    2ac4:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2ac6:	74 01       	movw	r14, r8
    2ac8:	f2 e0       	ldi	r31, 0x02	; 2
    2aca:	ef 0e       	add	r14, r31
    2acc:	f1 1c       	adc	r15, r1
    2ace:	a1 2c       	mov	r10, r1
    2ad0:	b1 2c       	mov	r11, r1
    2ad2:	c1 2c       	mov	r12, r1
    2ad4:	d1 2c       	mov	r13, r1
    2ad6:	04 2f       	mov	r16, r20
    2ad8:	94 01       	movw	r18, r8
    2ada:	a2 01       	movw	r20, r4
    2adc:	be 01       	movw	r22, r28
    2ade:	6f 5f       	subi	r22, 0xFF	; 255
    2ae0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ae2:	84 ea       	ldi	r24, 0xA4	; 164
    2ae4:	92 e0       	ldi	r25, 0x02	; 2
    2ae6:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2aea:	f4 01       	movw	r30, r8
    2aec:	66 82       	std	Z+6, r6	; 0x06
    2aee:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2af0:	40 86       	std	Z+8, r4	; 0x08
    2af2:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2af4:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <last_created_task_pointer>
    2af8:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2afc:	24 83       	std	Z+4, r18	; 0x04
    2afe:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2b00:	80 92 26 31 	sts	0x3126, r8	; 0x803126 <last_created_task_pointer>
    2b04:	90 92 27 31 	sts	0x3127, r9	; 0x803127 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2b08:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2b0a:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2b0c:	40 90 60 31 	lds	r4, 0x3160	; 0x803160 <portStackTopForTask>
    2b10:	50 90 61 31 	lds	r5, 0x3161	; 0x803161 <portStackTopForTask+0x1>
    2b14:	ff ef       	ldi	r31, 0xFF	; 255
    2b16:	4f 1a       	sub	r4, r31
    2b18:	5f 0a       	sbc	r5, r31
    2b1a:	40 92 60 31 	sts	0x3160, r4	; 0x803160 <portStackTopForTask>
    2b1e:	50 92 61 31 	sts	0x3161, r5	; 0x803161 <portStackTopForTask+0x1>
    2b22:	f4 01       	movw	r30, r8
    2b24:	42 86       	std	Z+10, r4	; 0x0a
    2b26:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2b28:	16 86       	std	Z+14, r1	; 0x0e
    2b2a:	17 86       	std	Z+15, r1	; 0x0f
    2b2c:	10 8a       	std	Z+16, r1	; 0x10
    2b2e:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2b30:	61 14       	cp	r6, r1
    2b32:	71 04       	cpc	r7, r1
    2b34:	09 f4       	brne	.+2      	; 0x2b38 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2b36:	44 c0       	rjmp	.+136    	; 0x2bc0 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2b38:	81 30       	cpi	r24, 0x01	; 1
    2b3a:	79 f5       	brne	.+94     	; 0x2b9a <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2b3c:	6a e0       	ldi	r22, 0x0A	; 10
    2b3e:	c3 01       	movw	r24, r6
    2b40:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2b44:	7c 01       	movw	r14, r24
    2b46:	65 e9       	ldi	r22, 0x95	; 149
    2b48:	74 e0       	ldi	r23, 0x04	; 4
    2b4a:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2b4e:	be 01       	movw	r22, r28
    2b50:	6f 5f       	subi	r22, 0xFF	; 255
    2b52:	7f 4f       	sbci	r23, 0xFF	; 255
    2b54:	c7 01       	movw	r24, r14
    2b56:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2b5a:	6a e0       	ldi	r22, 0x0A	; 10
    2b5c:	c7 01       	movw	r24, r14
    2b5e:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2b62:	7c 01       	movw	r14, r24
    2b64:	6c e8       	ldi	r22, 0x8C	; 140
    2b66:	74 e0       	ldi	r23, 0x04	; 4
    2b68:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2b6c:	6a e0       	ldi	r22, 0x0A	; 10
    2b6e:	c7 01       	movw	r24, r14
    2b70:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2b74:	7c 01       	movw	r14, r24
    2b76:	6e e7       	ldi	r22, 0x7E	; 126
    2b78:	74 e0       	ldi	r23, 0x04	; 4
    2b7a:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2b7e:	63 e0       	ldi	r22, 0x03	; 3
    2b80:	c7 01       	movw	r24, r14
    2b82:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2b86:	b2 01       	movw	r22, r4
    2b88:	0e 94 02 1b 	call	0x3604	; 0x3604 <_ZN8emstreamlsEj>
    2b8c:	62 e0       	ldi	r22, 0x02	; 2
    2b8e:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2b92:	66 e0       	ldi	r22, 0x06	; 6
    2b94:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2b98:	13 c0       	rjmp	.+38     	; 0x2bc0 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2b9a:	6a e0       	ldi	r22, 0x0A	; 10
    2b9c:	c3 01       	movw	r24, r6
    2b9e:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2ba2:	4c 01       	movw	r8, r24
    2ba4:	69 e6       	ldi	r22, 0x69	; 105
    2ba6:	74 e0       	ldi	r23, 0x04	; 4
    2ba8:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2bac:	be 01       	movw	r22, r28
    2bae:	6f 5f       	subi	r22, 0xFF	; 255
    2bb0:	7f 4f       	sbci	r23, 0xFF	; 255
    2bb2:	c4 01       	movw	r24, r8
    2bb4:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2bb8:	66 e0       	ldi	r22, 0x06	; 6
    2bba:	c4 01       	movw	r24, r8
    2bbc:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2bc0:	2a 96       	adiw	r28, 0x0a	; 10
    2bc2:	cd bf       	out	0x3d, r28	; 61
    2bc4:	de bf       	out	0x3e, r29	; 62
    2bc6:	df 91       	pop	r29
    2bc8:	cf 91       	pop	r28
    2bca:	1f 91       	pop	r17
    2bcc:	0f 91       	pop	r16
    2bce:	ff 90       	pop	r15
    2bd0:	ef 90       	pop	r14
    2bd2:	df 90       	pop	r13
    2bd4:	cf 90       	pop	r12
    2bd6:	bf 90       	pop	r11
    2bd8:	af 90       	pop	r10
    2bda:	9f 90       	pop	r9
    2bdc:	8f 90       	pop	r8
    2bde:	7f 90       	pop	r7
    2be0:	6f 90       	pop	r6
    2be2:	5f 90       	pop	r5
    2be4:	4f 90       	pop	r4
    2be6:	08 95       	ret

00002be8 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2be8:	cf 92       	push	r12
    2bea:	df 92       	push	r13
    2bec:	ef 92       	push	r14
    2bee:	ff 92       	push	r15
    2bf0:	0f 93       	push	r16
    2bf2:	1f 93       	push	r17
    2bf4:	cf 93       	push	r28
    2bf6:	df 93       	push	r29
    2bf8:	ec 01       	movw	r28, r24
    2bfa:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2bfc:	8a 81       	ldd	r24, Y+2	; 0x02
    2bfe:	9b 81       	ldd	r25, Y+3	; 0x03
    2c00:	0e 94 00 11 	call	0x2200	; 0x2200 <pcTaskGetTaskName>
    2c04:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2c06:	6a e0       	ldi	r22, 0x0A	; 10
    2c08:	c7 01       	movw	r24, r14
    2c0a:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2c0e:	8c 01       	movw	r16, r24
    2c10:	68 ea       	ldi	r22, 0xA8	; 168
    2c12:	74 e0       	ldi	r23, 0x04	; 4
    2c14:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2c18:	6a e0       	ldi	r22, 0x0A	; 10
    2c1a:	c8 01       	movw	r24, r16
    2c1c:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2c20:	8c 01       	movw	r16, r24
    2c22:	61 ea       	ldi	r22, 0xA1	; 161
    2c24:	74 e0       	ldi	r23, 0x04	; 4
    2c26:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2c2a:	b6 01       	movw	r22, r12
    2c2c:	c8 01       	movw	r24, r16
    2c2e:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2c32:	6a e0       	ldi	r22, 0x0A	; 10
    2c34:	c8 01       	movw	r24, r16
    2c36:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2c3a:	8c 01       	movw	r16, r24
    2c3c:	6b e9       	ldi	r22, 0x9B	; 155
    2c3e:	74 e0       	ldi	r23, 0x04	; 4
    2c40:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2c44:	66 e0       	ldi	r22, 0x06	; 6
    2c46:	c8 01       	movw	r24, r16
    2c48:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2c4c:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c4e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2c50:	e8 85       	ldd	r30, Y+8	; 0x08
    2c52:	f9 85       	ldd	r31, Y+9	; 0x09
    2c54:	01 e1       	ldi	r16, 0x11	; 17
    2c56:	21 e0       	ldi	r18, 0x01	; 1
    2c58:	a7 01       	movw	r20, r14
    2c5a:	bc 01       	movw	r22, r24
    2c5c:	8e 1b       	sub	r24, r30
    2c5e:	9f 0b       	sbc	r25, r31
    2c60:	0e 94 f6 18 	call	0x31ec	; 0x31ec <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2c64:	8c 81       	ldd	r24, Y+4	; 0x04
    2c66:	9d 81       	ldd	r25, Y+5	; 0x05
    2c68:	00 97       	sbiw	r24, 0x00	; 0
    2c6a:	19 f0       	breq	.+6      	; 0x2c72 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2c6c:	b7 01       	movw	r22, r14
    2c6e:	0e 94 f4 15 	call	0x2be8	; 0x2be8 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2c72:	df 91       	pop	r29
    2c74:	cf 91       	pop	r28
    2c76:	1f 91       	pop	r17
    2c78:	0f 91       	pop	r16
    2c7a:	ff 90       	pop	r15
    2c7c:	ef 90       	pop	r14
    2c7e:	df 90       	pop	r13
    2c80:	cf 90       	pop	r12
    2c82:	08 95       	ret

00002c84 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2c84:	0f 93       	push	r16
    2c86:	1f 93       	push	r17
    2c88:	cf 93       	push	r28
    2c8a:	df 93       	push	r29
    2c8c:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2c8e:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    2c92:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2c96:	00 97       	sbiw	r24, 0x00	; 0
    2c98:	19 f0       	breq	.+6      	; 0x2ca0 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2c9a:	be 01       	movw	r22, r28
    2c9c:	0e 94 f4 15 	call	0x2be8	; 0x2be8 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2ca0:	6a e0       	ldi	r22, 0x0A	; 10
    2ca2:	ce 01       	movw	r24, r28
    2ca4:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2ca8:	8c 01       	movw	r16, r24
    2caa:	6e eb       	ldi	r22, 0xBE	; 190
    2cac:	74 e0       	ldi	r23, 0x04	; 4
    2cae:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2cb2:	6a e0       	ldi	r22, 0x0A	; 10
    2cb4:	c8 01       	movw	r24, r16
    2cb6:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2cba:	8c 01       	movw	r16, r24
    2cbc:	63 eb       	ldi	r22, 0xB3	; 179
    2cbe:	74 e0       	ldi	r23, 0x04	; 4
    2cc0:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2cc4:	6a e0       	ldi	r22, 0x0A	; 10
    2cc6:	c8 01       	movw	r24, r16
    2cc8:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2ccc:	8c 01       	movw	r16, r24
    2cce:	6d ea       	ldi	r22, 0xAD	; 173
    2cd0:	74 e0       	ldi	r23, 0x04	; 4
    2cd2:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2cd6:	66 e0       	ldi	r22, 0x06	; 6
    2cd8:	c8 01       	movw	r24, r16
    2cda:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2cde:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <portStackTopForTask>
    2ce2:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <portStackTopForTask+0x1>
    2ce6:	bc 01       	movw	r22, r24
    2ce8:	6f 5f       	subi	r22, 0xFF	; 255
    2cea:	7f 4f       	sbci	r23, 0xFF	; 255
    2cec:	01 e1       	ldi	r16, 0x11	; 17
    2cee:	21 e0       	ldi	r18, 0x01	; 1
    2cf0:	ae 01       	movw	r20, r28
    2cf2:	83 56       	subi	r24, 0x63	; 99
    2cf4:	91 09       	sbc	r25, r1
    2cf6:	0e 94 f6 18 	call	0x31ec	; 0x31ec <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2cfa:	df 91       	pop	r29
    2cfc:	cf 91       	pop	r28
    2cfe:	1f 91       	pop	r17
    2d00:	0f 91       	pop	r16
    2d02:	08 95       	ret

00002d04 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2d04:	8f 92       	push	r8
    2d06:	9f 92       	push	r9
    2d08:	af 92       	push	r10
    2d0a:	bf 92       	push	r11
    2d0c:	cf 92       	push	r12
    2d0e:	df 92       	push	r13
    2d10:	ef 92       	push	r14
    2d12:	ff 92       	push	r15
    2d14:	0f 93       	push	r16
    2d16:	1f 93       	push	r17
    2d18:	cf 93       	push	r28
    2d1a:	df 93       	push	r29
    2d1c:	ec 01       	movw	r28, r24
    2d1e:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2d20:	8a 81       	ldd	r24, Y+2	; 0x02
    2d22:	9b 81       	ldd	r25, Y+3	; 0x03
    2d24:	0e 94 00 11 	call	0x2200	; 0x2200 <pcTaskGetTaskName>
    2d28:	bc 01       	movw	r22, r24
    2d2a:	c8 01       	movw	r24, r16
    2d2c:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2d30:	d8 01       	movw	r26, r16
    2d32:	ed 91       	ld	r30, X+
    2d34:	fc 91       	ld	r31, X
    2d36:	02 80       	ldd	r0, Z+2	; 0x02
    2d38:	f3 81       	ldd	r31, Z+3	; 0x03
    2d3a:	e0 2d       	mov	r30, r0
    2d3c:	69 e0       	ldi	r22, 0x09	; 9
    2d3e:	c8 01       	movw	r24, r16
    2d40:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2d42:	8a 81       	ldd	r24, Y+2	; 0x02
    2d44:	9b 81       	ldd	r25, Y+3	; 0x03
    2d46:	0e 94 00 11 	call	0x2200	; 0x2200 <pcTaskGetTaskName>
    2d4a:	fc 01       	movw	r30, r24
    2d4c:	01 90       	ld	r0, Z+
    2d4e:	00 20       	and	r0, r0
    2d50:	e9 f7       	brne	.-6      	; 0x2d4c <_ZN8frt_task12print_statusER8emstream+0x48>
    2d52:	31 97       	sbiw	r30, 0x01	; 1
    2d54:	e8 1b       	sub	r30, r24
    2d56:	f9 0b       	sbc	r31, r25
    2d58:	38 97       	sbiw	r30, 0x08	; 8
    2d5a:	48 f4       	brcc	.+18     	; 0x2d6e <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2d5c:	d8 01       	movw	r26, r16
    2d5e:	ed 91       	ld	r30, X+
    2d60:	fc 91       	ld	r31, X
    2d62:	02 80       	ldd	r0, Z+2	; 0x02
    2d64:	f3 81       	ldd	r31, Z+3	; 0x03
    2d66:	e0 2d       	mov	r30, r0
    2d68:	69 e0       	ldi	r22, 0x09	; 9
    2d6a:	c8 01       	movw	r24, r16
    2d6c:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2d6e:	ce 84       	ldd	r12, Y+14	; 0x0e
    2d70:	df 84       	ldd	r13, Y+15	; 0x0f
    2d72:	e8 88       	ldd	r14, Y+16	; 0x10
    2d74:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2d76:	a8 84       	ldd	r10, Y+8	; 0x08
    2d78:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2d7a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d7c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d7e:	0e 94 73 14 	call	0x28e6	; 0x28e6 <uxTaskGetStackHighWaterMark>
    2d82:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2d84:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2d86:	8a 81       	ldd	r24, Y+2	; 0x02
    2d88:	9b 81       	ldd	r25, Y+3	; 0x03
    2d8a:	0e 94 ab 10 	call	0x2156	; 0x2156 <uxTaskPriorityGet>
    2d8e:	68 2f       	mov	r22, r24
    2d90:	c8 01       	movw	r24, r16
    2d92:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <_ZN8emstreamlsEh>
    2d96:	6a e0       	ldi	r22, 0x0A	; 10
    2d98:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2d9c:	ec 01       	movw	r28, r24
    2d9e:	63 e3       	ldi	r22, 0x33	; 51
    2da0:	75 e0       	ldi	r23, 0x05	; 5
    2da2:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2da6:	68 2d       	mov	r22, r8
    2da8:	ce 01       	movw	r24, r28
    2daa:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2dae:	6a e0       	ldi	r22, 0x0A	; 10
    2db0:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2db4:	ec 01       	movw	r28, r24
    2db6:	61 e3       	ldi	r22, 0x31	; 49
    2db8:	75 e0       	ldi	r23, 0x05	; 5
    2dba:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2dbe:	69 2d       	mov	r22, r9
    2dc0:	ce 01       	movw	r24, r28
    2dc2:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <_ZN8emstreamlsEh>
    2dc6:	6a e0       	ldi	r22, 0x0A	; 10
    2dc8:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2dcc:	ec 01       	movw	r28, r24
    2dce:	6f e2       	ldi	r22, 0x2F	; 47
    2dd0:	75 e0       	ldi	r23, 0x05	; 5
    2dd2:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2dd6:	b5 01       	movw	r22, r10
    2dd8:	ce 01       	movw	r24, r28
    2dda:	0e 94 02 1b 	call	0x3604	; 0x3604 <_ZN8emstreamlsEj>
    2dde:	6a e0       	ldi	r22, 0x0A	; 10
    2de0:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2de4:	ec 01       	movw	r28, r24
    2de6:	6d e2       	ldi	r22, 0x2D	; 45
    2de8:	75 e0       	ldi	r23, 0x05	; 5
    2dea:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2dee:	6a e0       	ldi	r22, 0x0A	; 10
    2df0:	ce 01       	movw	r24, r28
    2df2:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2df6:	ec 01       	movw	r28, r24
    2df8:	6b e2       	ldi	r22, 0x2B	; 43
    2dfa:	75 e0       	ldi	r23, 0x05	; 5
    2dfc:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2e00:	b7 01       	movw	r22, r14
    2e02:	a6 01       	movw	r20, r12
    2e04:	ce 01       	movw	r24, r28
    2e06:	0e 94 36 1b 	call	0x366c	; 0x366c <_ZN8emstreamlsEm>
}
    2e0a:	df 91       	pop	r29
    2e0c:	cf 91       	pop	r28
    2e0e:	1f 91       	pop	r17
    2e10:	0f 91       	pop	r16
    2e12:	ff 90       	pop	r15
    2e14:	ef 90       	pop	r14
    2e16:	df 90       	pop	r13
    2e18:	cf 90       	pop	r12
    2e1a:	bf 90       	pop	r11
    2e1c:	af 90       	pop	r10
    2e1e:	9f 90       	pop	r9
    2e20:	8f 90       	pop	r8
    2e22:	08 95       	ret

00002e24 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2e24:	cf 93       	push	r28
    2e26:	df 93       	push	r29
    2e28:	ec 01       	movw	r28, r24
    2e2a:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2e2c:	db 01       	movw	r26, r22
    2e2e:	ed 91       	ld	r30, X+
    2e30:	fc 91       	ld	r31, X
    2e32:	02 80       	ldd	r0, Z+2	; 0x02
    2e34:	f3 81       	ldd	r31, Z+3	; 0x03
    2e36:	e0 2d       	mov	r30, r0
    2e38:	be 01       	movw	r22, r28
    2e3a:	19 95       	eicall
	return (ser_dev);
}
    2e3c:	ce 01       	movw	r24, r28
    2e3e:	df 91       	pop	r29
    2e40:	cf 91       	pop	r28
    2e42:	08 95       	ret

00002e44 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2e44:	0f 93       	push	r16
    2e46:	1f 93       	push	r17
    2e48:	cf 93       	push	r28
    2e4a:	df 93       	push	r29
    2e4c:	ec 01       	movw	r28, r24
    2e4e:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2e50:	bc 01       	movw	r22, r24
    2e52:	c8 01       	movw	r24, r16
    2e54:	0e 94 12 17 	call	0x2e24	; 0x2e24 <_ZlsR8emstreamR8frt_task>
    2e58:	66 e0       	ldi	r22, 0x06	; 6
    2e5a:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2e5e:	8c 81       	ldd	r24, Y+4	; 0x04
    2e60:	9d 81       	ldd	r25, Y+5	; 0x05
    2e62:	00 97       	sbiw	r24, 0x00	; 0
    2e64:	19 f0       	breq	.+6      	; 0x2e6c <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2e66:	b8 01       	movw	r22, r16
    2e68:	0e 94 22 17 	call	0x2e44	; 0x2e44 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2e6c:	df 91       	pop	r29
    2e6e:	cf 91       	pop	r28
    2e70:	1f 91       	pop	r17
    2e72:	0f 91       	pop	r16
    2e74:	08 95       	ret

00002e76 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2e76:	0f 93       	push	r16
    2e78:	1f 93       	push	r17
    2e7a:	cf 93       	push	r28
    2e7c:	df 93       	push	r29
    2e7e:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2e80:	6a e0       	ldi	r22, 0x0A	; 10
    2e82:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2e86:	8c 01       	movw	r16, r24
    2e88:	60 e2       	ldi	r22, 0x20	; 32
    2e8a:	75 e0       	ldi	r23, 0x05	; 5
    2e8c:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2e90:	6a e0       	ldi	r22, 0x0A	; 10
    2e92:	c8 01       	movw	r24, r16
    2e94:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2e98:	8c 01       	movw	r16, r24
    2e9a:	69 e1       	ldi	r22, 0x19	; 25
    2e9c:	75 e0       	ldi	r23, 0x05	; 5
    2e9e:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2ea2:	66 e0       	ldi	r22, 0x06	; 6
    2ea4:	c8 01       	movw	r24, r16
    2ea6:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2eaa:	6a e0       	ldi	r22, 0x0A	; 10
    2eac:	ce 01       	movw	r24, r28
    2eae:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2eb2:	8c 01       	movw	r16, r24
    2eb4:	68 e0       	ldi	r22, 0x08	; 8
    2eb6:	75 e0       	ldi	r23, 0x05	; 5
    2eb8:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2ebc:	6a e0       	ldi	r22, 0x0A	; 10
    2ebe:	c8 01       	movw	r24, r16
    2ec0:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2ec4:	8c 01       	movw	r16, r24
    2ec6:	6c ef       	ldi	r22, 0xFC	; 252
    2ec8:	74 e0       	ldi	r23, 0x04	; 4
    2eca:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2ece:	6a e0       	ldi	r22, 0x0A	; 10
    2ed0:	c8 01       	movw	r24, r16
    2ed2:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2ed6:	8c 01       	movw	r16, r24
    2ed8:	66 ef       	ldi	r22, 0xF6	; 246
    2eda:	74 e0       	ldi	r23, 0x04	; 4
    2edc:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2ee0:	66 e0       	ldi	r22, 0x06	; 6
    2ee2:	c8 01       	movw	r24, r16
    2ee4:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2ee8:	6a e0       	ldi	r22, 0x0A	; 10
    2eea:	ce 01       	movw	r24, r28
    2eec:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2ef0:	8c 01       	movw	r16, r24
    2ef2:	65 ee       	ldi	r22, 0xE5	; 229
    2ef4:	74 e0       	ldi	r23, 0x04	; 4
    2ef6:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2efa:	6a e0       	ldi	r22, 0x0A	; 10
    2efc:	c8 01       	movw	r24, r16
    2efe:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2f02:	8c 01       	movw	r16, r24
    2f04:	69 ed       	ldi	r22, 0xD9	; 217
    2f06:	74 e0       	ldi	r23, 0x04	; 4
    2f08:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2f0c:	6a e0       	ldi	r22, 0x0A	; 10
    2f0e:	c8 01       	movw	r24, r16
    2f10:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2f14:	8c 01       	movw	r16, r24
    2f16:	63 ed       	ldi	r22, 0xD3	; 211
    2f18:	74 e0       	ldi	r23, 0x04	; 4
    2f1a:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2f1e:	66 e0       	ldi	r22, 0x06	; 6
    2f20:	c8 01       	movw	r24, r16
    2f22:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2f26:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    2f2a:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2f2e:	00 97       	sbiw	r24, 0x00	; 0
    2f30:	19 f0       	breq	.+6      	; 0x2f38 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2f32:	be 01       	movw	r22, r28
    2f34:	0e 94 22 17 	call	0x2e44	; 0x2e44 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2f38:	0e 94 08 11 	call	0x2210	; 0x2210 <xTaskGetIdleTaskHandle>
    2f3c:	0e 94 73 14 	call	0x28e6	; 0x28e6 <uxTaskGetStackHighWaterMark>
    2f40:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2f42:	6a e0       	ldi	r22, 0x0A	; 10
    2f44:	ce 01       	movw	r24, r28
    2f46:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2f4a:	ec 01       	movw	r28, r24
    2f4c:	68 ec       	ldi	r22, 0xC8	; 200
    2f4e:	74 e0       	ldi	r23, 0x04	; 4
    2f50:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2f54:	61 2f       	mov	r22, r17
    2f56:	ce 01       	movw	r24, r28
    2f58:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2f5c:	6a e0       	ldi	r22, 0x0A	; 10
    2f5e:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2f62:	ec 01       	movw	r28, r24
    2f64:	66 ec       	ldi	r22, 0xC6	; 198
    2f66:	74 e0       	ldi	r23, 0x04	; 4
    2f68:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    2f6c:	64 e6       	ldi	r22, 0x64	; 100
    2f6e:	70 e0       	ldi	r23, 0x00	; 0
    2f70:	ce 01       	movw	r24, r28
    2f72:	0e 94 02 1b 	call	0x3604	; 0x3604 <_ZN8emstreamlsEj>
    2f76:	6a e0       	ldi	r22, 0x0A	; 10
    2f78:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    2f7c:	ec 01       	movw	r28, r24
    2f7e:	63 ec       	ldi	r22, 0xC3	; 195
    2f80:	74 e0       	ldi	r23, 0x04	; 4
    2f82:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2f86:	66 e0       	ldi	r22, 0x06	; 6
    2f88:	ce 01       	movw	r24, r28
    2f8a:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
}
    2f8e:	df 91       	pop	r29
    2f90:	cf 91       	pop	r28
    2f92:	1f 91       	pop	r17
    2f94:	0f 91       	pop	r16
    2f96:	08 95       	ret

00002f98 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2f98:	0f 93       	push	r16
    2f9a:	cf 93       	push	r28
    2f9c:	df 93       	push	r29
    2f9e:	1f 92       	push	r1
    2fa0:	cd b7       	in	r28, 0x3d	; 61
    2fa2:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2fa4:	00 e0       	ldi	r16, 0x00	; 0
    2fa6:	2f ef       	ldi	r18, 0xFF	; 255
    2fa8:	3f ef       	ldi	r19, 0xFF	; 255
    2faa:	a9 01       	movw	r20, r18
    2fac:	be 01       	movw	r22, r28
    2fae:	6f 5f       	subi	r22, 0xFF	; 255
    2fb0:	7f 4f       	sbci	r23, 0xFF	; 255
    2fb2:	fc 01       	movw	r30, r24
    2fb4:	80 85       	ldd	r24, Z+8	; 0x08
    2fb6:	91 85       	ldd	r25, Z+9	; 0x09
    2fb8:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <xQueueGenericReceive>
    2fbc:	81 30       	cpi	r24, 0x01	; 1
    2fbe:	19 f4       	brne	.+6      	; 0x2fc6 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2fc0:	89 81       	ldd	r24, Y+1	; 0x01
    2fc2:	90 e0       	ldi	r25, 0x00	; 0
    2fc4:	02 c0       	rjmp	.+4      	; 0x2fca <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2fc6:	8f ef       	ldi	r24, 0xFF	; 255
    2fc8:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2fca:	0f 90       	pop	r0
    2fcc:	df 91       	pop	r29
    2fce:	cf 91       	pop	r28
    2fd0:	0f 91       	pop	r16
    2fd2:	08 95       	ret

00002fd4 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2fd4:	fc 01       	movw	r30, r24
    2fd6:	80 85       	ldd	r24, Z+8	; 0x08
    2fd8:	91 85       	ldd	r25, Z+9	; 0x09
    2fda:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <uxQueueMessagesWaiting>
    2fde:	91 e0       	ldi	r25, 0x01	; 1
    2fe0:	81 11       	cpse	r24, r1
    2fe2:	01 c0       	rjmp	.+2      	; 0x2fe6 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2fe4:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2fe6:	89 2f       	mov	r24, r25
    2fe8:	08 95       	ret

00002fea <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2fea:	0f 93       	push	r16
    2fec:	cf 93       	push	r28
    2fee:	df 93       	push	r29
    2ff0:	1f 92       	push	r1
    2ff2:	cd b7       	in	r28, 0x3d	; 61
    2ff4:	de b7       	in	r29, 0x3e	; 62
    2ff6:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2ff8:	fc 01       	movw	r30, r24
    2ffa:	22 85       	ldd	r18, Z+10	; 0x0a
    2ffc:	33 85       	ldd	r19, Z+11	; 0x0b
    2ffe:	44 85       	ldd	r20, Z+12	; 0x0c
    3000:	55 85       	ldd	r21, Z+13	; 0x0d
    3002:	00 e0       	ldi	r16, 0x00	; 0
    3004:	be 01       	movw	r22, r28
    3006:	6f 5f       	subi	r22, 0xFF	; 255
    3008:	7f 4f       	sbci	r23, 0xFF	; 255
    300a:	80 85       	ldd	r24, Z+8	; 0x08
    300c:	91 85       	ldd	r25, Z+9	; 0x09
    300e:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <xQueueGenericSend>
    3012:	91 e0       	ldi	r25, 0x01	; 1
    3014:	81 11       	cpse	r24, r1
    3016:	01 c0       	rjmp	.+2      	; 0x301a <_ZN14frt_text_queue7putcharEc+0x30>
    3018:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    301a:	89 2f       	mov	r24, r25
    301c:	0f 90       	pop	r0
    301e:	df 91       	pop	r29
    3020:	cf 91       	pop	r28
    3022:	0f 91       	pop	r16
    3024:	08 95       	ret

00003026 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3026:	8f 92       	push	r8
    3028:	9f 92       	push	r9
    302a:	bf 92       	push	r11
    302c:	cf 92       	push	r12
    302e:	df 92       	push	r13
    3030:	ef 92       	push	r14
    3032:	ff 92       	push	r15
    3034:	0f 93       	push	r16
    3036:	1f 93       	push	r17
    3038:	cf 93       	push	r28
    303a:	df 93       	push	r29
    303c:	ec 01       	movw	r28, r24
    303e:	b6 2e       	mov	r11, r22
    3040:	4a 01       	movw	r8, r20
    3042:	68 01       	movw	r12, r16
    3044:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3046:	0e 94 4d 1a 	call	0x349a	; 0x349a <_ZN8emstreamC1Ev>
    304a:	8c e4       	ldi	r24, 0x4C	; 76
    304c:	90 e2       	ldi	r25, 0x20	; 32
    304e:	88 83       	st	Y, r24
    3050:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    3052:	8e 86       	std	Y+14, r8	; 0x0e
    3054:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3056:	40 e0       	ldi	r20, 0x00	; 0
    3058:	61 e0       	ldi	r22, 0x01	; 1
    305a:	8b 2d       	mov	r24, r11
    305c:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <xQueueGenericCreate>
    3060:	88 87       	std	Y+8, r24	; 0x08
    3062:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3064:	ca 86       	std	Y+10, r12	; 0x0a
    3066:	db 86       	std	Y+11, r13	; 0x0b
    3068:	ec 86       	std	Y+12, r14	; 0x0c
    306a:	fd 86       	std	Y+13, r15	; 0x0d
}
    306c:	df 91       	pop	r29
    306e:	cf 91       	pop	r28
    3070:	1f 91       	pop	r17
    3072:	0f 91       	pop	r16
    3074:	ff 90       	pop	r15
    3076:	ef 90       	pop	r14
    3078:	df 90       	pop	r13
    307a:	cf 90       	pop	r12
    307c:	bf 90       	pop	r11
    307e:	9f 90       	pop	r9
    3080:	8f 90       	pop	r8
    3082:	08 95       	ret

00003084 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3084:	cf 92       	push	r12
    3086:	df 92       	push	r13
    3088:	ef 92       	push	r14
    308a:	ff 92       	push	r15
    308c:	cf 93       	push	r28
    308e:	df 93       	push	r29
    3090:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    3092:	68 81       	ld	r22, Y
    3094:	79 81       	ldd	r23, Y+1	; 0x01
    3096:	8a 81       	ldd	r24, Y+2	; 0x02
    3098:	9b 81       	ldd	r25, Y+3	; 0x03
    309a:	0f 2e       	mov	r0, r31
    309c:	f8 ee       	ldi	r31, 0xE8	; 232
    309e:	cf 2e       	mov	r12, r31
    30a0:	f3 e0       	ldi	r31, 0x03	; 3
    30a2:	df 2e       	mov	r13, r31
    30a4:	e1 2c       	mov	r14, r1
    30a6:	f1 2c       	mov	r15, r1
    30a8:	f0 2d       	mov	r31, r0
    30aa:	a7 01       	movw	r20, r14
    30ac:	96 01       	movw	r18, r12
    30ae:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <__udivmodsi4>
    30b2:	9b 01       	movw	r18, r22
    30b4:	ac 01       	movw	r20, r24
    30b6:	60 e4       	ldi	r22, 0x40	; 64
    30b8:	72 e4       	ldi	r23, 0x42	; 66
    30ba:	8f e0       	ldi	r24, 0x0F	; 15
    30bc:	90 e0       	ldi	r25, 0x00	; 0
    30be:	0e 94 d4 1f 	call	0x3fa8	; 0x3fa8 <__mulsi3>
    30c2:	a7 01       	movw	r20, r14
    30c4:	96 01       	movw	r18, r12
    30c6:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <__udivmodsi4>
    30ca:	69 01       	movw	r12, r18
    30cc:	7a 01       	movw	r14, r20
    30ce:	ac 81       	ldd	r26, Y+4	; 0x04
    30d0:	bd 81       	ldd	r27, Y+5	; 0x05
    30d2:	20 e4       	ldi	r18, 0x40	; 64
    30d4:	32 e4       	ldi	r19, 0x42	; 66
    30d6:	4f e0       	ldi	r20, 0x0F	; 15
    30d8:	50 e0       	ldi	r21, 0x00	; 0
    30da:	0e 94 60 20 	call	0x40c0	; 0x40c0 <__muluhisi3>
    30de:	20 e0       	ldi	r18, 0x00	; 0
    30e0:	38 e4       	ldi	r19, 0x48	; 72
    30e2:	48 ee       	ldi	r20, 0xE8	; 232
    30e4:	51 e0       	ldi	r21, 0x01	; 1
    30e6:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <__udivmodsi4>
    30ea:	c7 01       	movw	r24, r14
    30ec:	b6 01       	movw	r22, r12
    30ee:	62 0f       	add	r22, r18
    30f0:	73 1f       	adc	r23, r19
    30f2:	84 1f       	adc	r24, r20
    30f4:	95 1f       	adc	r25, r21
}
    30f6:	df 91       	pop	r29
    30f8:	cf 91       	pop	r28
    30fa:	ff 90       	pop	r15
    30fc:	ef 90       	pop	r14
    30fe:	df 90       	pop	r13
    3100:	cf 90       	pop	r12
    3102:	08 95       	ret

00003104 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3104:	cf 92       	push	r12
    3106:	df 92       	push	r13
    3108:	ef 92       	push	r14
    310a:	ff 92       	push	r15
    310c:	0f 93       	push	r16
    310e:	1f 93       	push	r17
    3110:	cf 93       	push	r28
    3112:	df 93       	push	r29
    3114:	cd b7       	in	r28, 0x3d	; 61
    3116:	de b7       	in	r29, 0x3e	; 62
    3118:	2f 97       	sbiw	r28, 0x0f	; 15
    311a:	cd bf       	out	0x3d, r28	; 61
    311c:	de bf       	out	0x3e, r29	; 62
    311e:	6c 01       	movw	r12, r24
    3120:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3122:	db 01       	movw	r26, r22
    3124:	6d 91       	ld	r22, X+
    3126:	7d 91       	ld	r23, X+
    3128:	8d 91       	ld	r24, X+
    312a:	9c 91       	ld	r25, X
    312c:	28 ee       	ldi	r18, 0xE8	; 232
    312e:	33 e0       	ldi	r19, 0x03	; 3
    3130:	40 e0       	ldi	r20, 0x00	; 0
    3132:	50 e0       	ldi	r21, 0x00	; 0
    3134:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <__udivmodsi4>
    3138:	ba 01       	movw	r22, r20
    313a:	a9 01       	movw	r20, r18
    313c:	c6 01       	movw	r24, r12
    313e:	0e 94 36 1b 	call	0x366c	; 0x366c <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3142:	d6 01       	movw	r26, r12
    3144:	ed 91       	ld	r30, X+
    3146:	fc 91       	ld	r31, X
    3148:	02 80       	ldd	r0, Z+2	; 0x02
    314a:	f3 81       	ldd	r31, Z+3	; 0x03
    314c:	e0 2d       	mov	r30, r0
    314e:	6e e2       	ldi	r22, 0x2E	; 46
    3150:	c6 01       	movw	r24, r12
    3152:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3154:	c8 01       	movw	r24, r16
    3156:	0e 94 42 18 	call	0x3084	; 0x3084 <_ZN10time_stamp12get_microsecEv>
    315a:	8e 01       	movw	r16, r28
    315c:	09 5f       	subi	r16, 0xF9	; 249
    315e:	1f 4f       	sbci	r17, 0xFF	; 255
    3160:	fe 01       	movw	r30, r28
    3162:	31 96       	adiw	r30, 0x01	; 1
    3164:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3166:	2a e0       	ldi	r18, 0x0A	; 10
    3168:	30 e0       	ldi	r19, 0x00	; 0
    316a:	40 e0       	ldi	r20, 0x00	; 0
    316c:	50 e0       	ldi	r21, 0x00	; 0
    316e:	0e 94 1a 20 	call	0x4034	; 0x4034 <__divmodsi4>
    3172:	e6 2f       	mov	r30, r22
    3174:	28 87       	std	Y+8, r18	; 0x08
    3176:	39 87       	std	Y+9, r19	; 0x09
    3178:	4a 87       	std	Y+10, r20	; 0x0a
    317a:	5b 87       	std	Y+11, r21	; 0x0b
    317c:	68 85       	ldd	r22, Y+8	; 0x08
    317e:	79 85       	ldd	r23, Y+9	; 0x09
    3180:	8a 85       	ldd	r24, Y+10	; 0x0a
    3182:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3184:	20 e3       	ldi	r18, 0x30	; 48
    3186:	2e 0f       	add	r18, r30
    3188:	d8 01       	movw	r26, r16
    318a:	2e 93       	st	-X, r18
    318c:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    318e:	ae 15       	cp	r26, r14
    3190:	bf 05       	cpc	r27, r15
    3192:	49 f7       	brne	.-46     	; 0x3166 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3194:	1f 82       	std	Y+7, r1	; 0x07
    3196:	be 01       	movw	r22, r28
    3198:	6f 5f       	subi	r22, 0xFF	; 255
    319a:	7f 4f       	sbci	r23, 0xFF	; 255
    319c:	c6 01       	movw	r24, r12
    319e:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    31a2:	c6 01       	movw	r24, r12
    31a4:	2f 96       	adiw	r28, 0x0f	; 15
    31a6:	cd bf       	out	0x3d, r28	; 61
    31a8:	de bf       	out	0x3e, r29	; 62
    31aa:	df 91       	pop	r29
    31ac:	cf 91       	pop	r28
    31ae:	1f 91       	pop	r17
    31b0:	0f 91       	pop	r16
    31b2:	ff 90       	pop	r15
    31b4:	ef 90       	pop	r14
    31b6:	df 90       	pop	r13
    31b8:	cf 90       	pop	r12
    31ba:	08 95       	ret

000031bc <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    31bc:	cf 93       	push	r28
    31be:	df 93       	push	r29
    31c0:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    31c2:	0f b6       	in	r0, 0x3f	; 63
    31c4:	f8 94       	cli
    31c6:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    31c8:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    31cc:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    31d0:	8c 83       	std	Y+4, r24	; 0x04
    31d2:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    31d4:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <xTaskGetTickCount>
    31d8:	68 83       	st	Y, r22
    31da:	79 83       	std	Y+1, r23	; 0x01
    31dc:	8a 83       	std	Y+2, r24	; 0x02
    31de:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    31e0:	0f 90       	pop	r0
    31e2:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    31e4:	ce 01       	movw	r24, r28
    31e6:	df 91       	pop	r29
    31e8:	cf 91       	pop	r28
    31ea:	08 95       	ret

000031ec <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    31ec:	5f 92       	push	r5
    31ee:	6f 92       	push	r6
    31f0:	7f 92       	push	r7
    31f2:	8f 92       	push	r8
    31f4:	9f 92       	push	r9
    31f6:	af 92       	push	r10
    31f8:	bf 92       	push	r11
    31fa:	cf 92       	push	r12
    31fc:	df 92       	push	r13
    31fe:	ef 92       	push	r14
    3200:	ff 92       	push	r15
    3202:	0f 93       	push	r16
    3204:	1f 93       	push	r17
    3206:	cf 93       	push	r28
    3208:	df 93       	push	r29
    320a:	5c 01       	movw	r10, r24
    320c:	4b 01       	movw	r8, r22
    320e:	7a 01       	movw	r14, r20
    3210:	12 2f       	mov	r17, r18
    3212:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3214:	63 e0       	ldi	r22, 0x03	; 3
    3216:	ca 01       	movw	r24, r20
    3218:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    321c:	a8 14       	cp	r10, r8
    321e:	b9 04       	cpc	r11, r9
    3220:	08 f0       	brcs	.+2      	; 0x3224 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3222:	7d c0       	rjmp	.+250    	; 0x331e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3224:	65 01       	movw	r12, r10
    3226:	84 e1       	ldi	r24, 0x14	; 20
    3228:	c8 0e       	add	r12, r24
    322a:	d1 1c       	adc	r13, r1
    322c:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    322e:	6a 2c       	mov	r6, r10
    3230:	5b 2c       	mov	r5, r11
    3232:	b5 01       	movw	r22, r10
    3234:	c7 01       	movw	r24, r14
    3236:	0e 94 02 1b 	call	0x3604	; 0x3604 <_ZN8emstreamlsEj>
    323a:	6a e0       	ldi	r22, 0x0A	; 10
    323c:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    3240:	65 e4       	ldi	r22, 0x45	; 69
    3242:	75 e0       	ldi	r23, 0x05	; 5
    3244:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3248:	11 23       	and	r17, r17
    324a:	09 f4       	brne	.+2      	; 0x324e <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    324c:	6d c0       	rjmp	.+218    	; 0x3328 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    324e:	00 23       	and	r16, r16
    3250:	09 f4       	brne	.+2      	; 0x3254 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3252:	6a c0       	rjmp	.+212    	; 0x3328 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3254:	6a e0       	ldi	r22, 0x0A	; 10
    3256:	c7 01       	movw	r24, r14
    3258:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    325c:	60 e4       	ldi	r22, 0x40	; 64
    325e:	75 e0       	ldi	r23, 0x05	; 5
    3260:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    3264:	61 c0       	rjmp	.+194    	; 0x3328 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3266:	11 23       	and	r17, r17
    3268:	71 f0       	breq	.+28     	; 0x3286 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    326a:	01 11       	cpse	r16, r1
    326c:	0c c0       	rjmp	.+24     	; 0x3286 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    326e:	88 81       	ld	r24, Y
    3270:	87 15       	cp	r24, r7
    3272:	49 f0       	breq	.+18     	; 0x3286 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3274:	6a e0       	ldi	r22, 0x0A	; 10
    3276:	c7 01       	movw	r24, r14
    3278:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    327c:	6b e3       	ldi	r22, 0x3B	; 59
    327e:	75 e0       	ldi	r23, 0x05	; 5
    3280:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3284:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3286:	69 91       	ld	r22, Y+
    3288:	c7 01       	movw	r24, r14
    328a:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    328e:	dc 01       	movw	r26, r24
    3290:	ed 91       	ld	r30, X+
    3292:	fc 91       	ld	r31, X
    3294:	02 80       	ldd	r0, Z+2	; 0x02
    3296:	f3 81       	ldd	r31, Z+3	; 0x03
    3298:	e0 2d       	mov	r30, r0
    329a:	60 e2       	ldi	r22, 0x20	; 32
    329c:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    329e:	cc 16       	cp	r12, r28
    32a0:	dd 06       	cpc	r13, r29
    32a2:	09 f7       	brne	.-62     	; 0x3266 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    32a4:	11 23       	and	r17, r17
    32a6:	89 f0       	breq	.+34     	; 0x32ca <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    32a8:	6a e0       	ldi	r22, 0x0A	; 10
    32aa:	c7 01       	movw	r24, r14
    32ac:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    32b0:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    32b2:	65 e3       	ldi	r22, 0x35	; 53
    32b4:	75 e0       	ldi	r23, 0x05	; 5
    32b6:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    32ba:	e8 81       	ld	r30, Y
    32bc:	f9 81       	ldd	r31, Y+1	; 0x01
    32be:	02 80       	ldd	r0, Z+2	; 0x02
    32c0:	f3 81       	ldd	r31, Z+3	; 0x03
    32c2:	e0 2d       	mov	r30, r0
    32c4:	60 e2       	ldi	r22, 0x20	; 32
    32c6:	ce 01       	movw	r24, r28
    32c8:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    32ca:	c6 2d       	mov	r28, r6
    32cc:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    32ce:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    32d0:	80 ee       	ldi	r24, 0xE0	; 224
    32d2:	86 0f       	add	r24, r22
    32d4:	8f 35       	cpi	r24, 0x5F	; 95
    32d6:	48 f4       	brcc	.+18     	; 0x32ea <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    32d8:	d7 01       	movw	r26, r14
    32da:	ed 91       	ld	r30, X+
    32dc:	fc 91       	ld	r31, X
    32de:	02 80       	ldd	r0, Z+2	; 0x02
    32e0:	f3 81       	ldd	r31, Z+3	; 0x03
    32e2:	e0 2d       	mov	r30, r0
    32e4:	c7 01       	movw	r24, r14
    32e6:	19 95       	eicall
    32e8:	09 c0       	rjmp	.+18     	; 0x32fc <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    32ea:	d7 01       	movw	r26, r14
    32ec:	ed 91       	ld	r30, X+
    32ee:	fc 91       	ld	r31, X
    32f0:	02 80       	ldd	r0, Z+2	; 0x02
    32f2:	f3 81       	ldd	r31, Z+3	; 0x03
    32f4:	e0 2d       	mov	r30, r0
    32f6:	6e e2       	ldi	r22, 0x2E	; 46
    32f8:	c7 01       	movw	r24, r14
    32fa:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    32fc:	cc 16       	cp	r12, r28
    32fe:	dd 06       	cpc	r13, r29
    3300:	31 f7       	brne	.-52     	; 0x32ce <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3302:	b4 e1       	ldi	r27, 0x14	; 20
    3304:	ab 0e       	add	r10, r27
    3306:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3308:	66 e0       	ldi	r22, 0x06	; 6
    330a:	c7 01       	movw	r24, r14
    330c:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    3310:	84 e1       	ldi	r24, 0x14	; 20
    3312:	c8 0e       	add	r12, r24
    3314:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3316:	a8 14       	cp	r10, r8
    3318:	b9 04       	cpc	r11, r9
    331a:	08 f4       	brcc	.+2      	; 0x331e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    331c:	88 cf       	rjmp	.-240    	; 0x322e <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    331e:	62 e0       	ldi	r22, 0x02	; 2
    3320:	c7 01       	movw	r24, r14
    3322:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
}
    3326:	03 c0       	rjmp	.+6      	; 0x332e <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3328:	c6 2d       	mov	r28, r6
    332a:	d5 2d       	mov	r29, r5
    332c:	9c cf       	rjmp	.-200    	; 0x3266 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    332e:	df 91       	pop	r29
    3330:	cf 91       	pop	r28
    3332:	1f 91       	pop	r17
    3334:	0f 91       	pop	r16
    3336:	ff 90       	pop	r15
    3338:	ef 90       	pop	r14
    333a:	df 90       	pop	r13
    333c:	cf 90       	pop	r12
    333e:	bf 90       	pop	r11
    3340:	af 90       	pop	r10
    3342:	9f 90       	pop	r9
    3344:	8f 90       	pop	r8
    3346:	7f 90       	pop	r7
    3348:	6f 90       	pop	r6
    334a:	5f 90       	pop	r5
    334c:	08 95       	ret

0000334e <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    334e:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <pvPortMalloc>
    3352:	08 95       	ret

00003354 <_Znaj>:
    3354:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <pvPortMalloc>
    3358:	08 95       	ret

0000335a <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    335a:	08 95       	ret

0000335c <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    335c:	cf 93       	push	r28
    335e:	df 93       	push	r29
    3360:	fc 01       	movw	r30, r24
    3362:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3364:	40 3a       	cpi	r20, 0xA0	; 160
    3366:	68 e0       	ldi	r22, 0x08	; 8
    3368:	56 07       	cpc	r21, r22
    336a:	49 f4       	brne	.+18     	; 0x337e <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    336c:	80 e4       	ldi	r24, 0x40	; 64
    336e:	96 e0       	ldi	r25, 0x06	; 6
    3370:	82 83       	std	Z+2, r24	; 0x02
    3372:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3374:	82 e0       	ldi	r24, 0x02	; 2
    3376:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3378:	83 e0       	ldi	r24, 0x03	; 3
    337a:	85 83       	std	Z+5, r24	; 0x05
    337c:	32 c0       	rjmp	.+100    	; 0x33e2 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    337e:	40 3b       	cpi	r20, 0xB0	; 176
    3380:	78 e0       	ldi	r23, 0x08	; 8
    3382:	57 07       	cpc	r21, r23
    3384:	49 f4       	brne	.+18     	; 0x3398 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3386:	80 e4       	ldi	r24, 0x40	; 64
    3388:	96 e0       	ldi	r25, 0x06	; 6
    338a:	82 83       	std	Z+2, r24	; 0x02
    338c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    338e:	86 e0       	ldi	r24, 0x06	; 6
    3390:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3392:	87 e0       	ldi	r24, 0x07	; 7
    3394:	85 83       	std	Z+5, r24	; 0x05
    3396:	25 c0       	rjmp	.+74     	; 0x33e2 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3398:	40 3a       	cpi	r20, 0xA0	; 160
    339a:	89 e0       	ldi	r24, 0x09	; 9
    339c:	58 07       	cpc	r21, r24
    339e:	49 f4       	brne	.+18     	; 0x33b2 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    33a0:	80 e6       	ldi	r24, 0x60	; 96
    33a2:	96 e0       	ldi	r25, 0x06	; 6
    33a4:	82 83       	std	Z+2, r24	; 0x02
    33a6:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    33a8:	82 e0       	ldi	r24, 0x02	; 2
    33aa:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    33ac:	83 e0       	ldi	r24, 0x03	; 3
    33ae:	85 83       	std	Z+5, r24	; 0x05
    33b0:	18 c0       	rjmp	.+48     	; 0x33e2 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    33b2:	40 3b       	cpi	r20, 0xB0	; 176
    33b4:	69 e0       	ldi	r22, 0x09	; 9
    33b6:	56 07       	cpc	r21, r22
    33b8:	49 f4       	brne	.+18     	; 0x33cc <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    33ba:	80 e6       	ldi	r24, 0x60	; 96
    33bc:	96 e0       	ldi	r25, 0x06	; 6
    33be:	82 83       	std	Z+2, r24	; 0x02
    33c0:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    33c2:	86 e0       	ldi	r24, 0x06	; 6
    33c4:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    33c6:	87 e0       	ldi	r24, 0x07	; 7
    33c8:	85 83       	std	Z+5, r24	; 0x05
    33ca:	0b c0       	rjmp	.+22     	; 0x33e2 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    33cc:	40 3a       	cpi	r20, 0xA0	; 160
    33ce:	5a 40       	sbci	r21, 0x0A	; 10
    33d0:	41 f4       	brne	.+16     	; 0x33e2 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    33d2:	80 e8       	ldi	r24, 0x80	; 128
    33d4:	96 e0       	ldi	r25, 0x06	; 6
    33d6:	82 83       	std	Z+2, r24	; 0x02
    33d8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    33da:	82 e0       	ldi	r24, 0x02	; 2
    33dc:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    33de:	83 e0       	ldi	r24, 0x03	; 3
    33e0:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    33e2:	a6 83       	std	Z+6, r26	; 0x06
    33e4:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    33e6:	cd 01       	movw	r24, r26
    33e8:	01 96       	adiw	r24, 0x01	; 1
    33ea:	80 87       	std	Z+8, r24	; 0x08
    33ec:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    33ee:	03 96       	adiw	r24, 0x03	; 3
    33f0:	82 87       	std	Z+10, r24	; 0x0a
    33f2:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    33f4:	25 81       	ldd	r18, Z+5	; 0x05
    33f6:	c2 81       	ldd	r28, Z+2	; 0x02
    33f8:	d3 81       	ldd	r29, Z+3	; 0x03
    33fa:	4c 81       	ldd	r20, Y+4	; 0x04
    33fc:	81 e0       	ldi	r24, 0x01	; 1
    33fe:	90 e0       	ldi	r25, 0x00	; 0
    3400:	bc 01       	movw	r22, r24
    3402:	02 c0       	rjmp	.+4      	; 0x3408 <_ZN7base232C1EjP12USART_struct+0xac>
    3404:	66 0f       	add	r22, r22
    3406:	77 1f       	adc	r23, r23
    3408:	2a 95       	dec	r18
    340a:	e2 f7       	brpl	.-8      	; 0x3404 <_ZN7base232C1EjP12USART_struct+0xa8>
    340c:	9b 01       	movw	r18, r22
    340e:	24 2b       	or	r18, r20
    3410:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3412:	25 81       	ldd	r18, Z+5	; 0x05
    3414:	c2 81       	ldd	r28, Z+2	; 0x02
    3416:	d3 81       	ldd	r29, Z+3	; 0x03
    3418:	48 81       	ld	r20, Y
    341a:	bc 01       	movw	r22, r24
    341c:	02 c0       	rjmp	.+4      	; 0x3422 <_ZN7base232C1EjP12USART_struct+0xc6>
    341e:	66 0f       	add	r22, r22
    3420:	77 1f       	adc	r23, r23
    3422:	2a 95       	dec	r18
    3424:	e2 f7       	brpl	.-8      	; 0x341e <_ZN7base232C1EjP12USART_struct+0xc2>
    3426:	9b 01       	movw	r18, r22
    3428:	24 2b       	or	r18, r20
    342a:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    342c:	34 81       	ldd	r19, Z+4	; 0x04
    342e:	c2 81       	ldd	r28, Z+2	; 0x02
    3430:	d3 81       	ldd	r29, Z+3	; 0x03
    3432:	28 81       	ld	r18, Y
    3434:	02 c0       	rjmp	.+4      	; 0x343a <_ZN7base232C1EjP12USART_struct+0xde>
    3436:	88 0f       	add	r24, r24
    3438:	99 1f       	adc	r25, r25
    343a:	3a 95       	dec	r19
    343c:	e2 f7       	brpl	.-8      	; 0x3436 <_ZN7base232C1EjP12USART_struct+0xda>
    343e:	80 95       	com	r24
    3440:	90 95       	com	r25
    3442:	82 23       	and	r24, r18
    3444:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3446:	80 e1       	ldi	r24, 0x10	; 16
    3448:	13 96       	adiw	r26, 0x03	; 3
    344a:	8c 93       	st	X, r24
    344c:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    344e:	83 e0       	ldi	r24, 0x03	; 3
    3450:	15 96       	adiw	r26, 0x05	; 5
    3452:	8c 93       	st	X, r24
    3454:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3456:	80 ef       	ldi	r24, 0xF0	; 240
    3458:	17 96       	adiw	r26, 0x07	; 7
    345a:	8c 93       	st	X, r24
    345c:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    345e:	81 e2       	ldi	r24, 0x21	; 33
    3460:	16 96       	adiw	r26, 0x06	; 6
    3462:	8c 93       	st	X, r24
    3464:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3466:	88 e1       	ldi	r24, 0x18	; 24
    3468:	14 96       	adiw	r26, 0x04	; 4
    346a:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    346c:	80 e8       	ldi	r24, 0x80	; 128
    346e:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3470:	80 e4       	ldi	r24, 0x40	; 64
    3472:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3474:	80 e2       	ldi	r24, 0x20	; 32
    3476:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3478:	06 80       	ldd	r0, Z+6	; 0x06
    347a:	f7 81       	ldd	r31, Z+7	; 0x07
    347c:	e0 2d       	mov	r30, r0
    347e:	80 81       	ld	r24, Z
    3480:	80 81       	ld	r24, Z
}
    3482:	df 91       	pop	r29
    3484:	cf 91       	pop	r28
    3486:	08 95       	ret

00003488 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3488:	81 e0       	ldi	r24, 0x01	; 1
    348a:	08 95       	ret

0000348c <_ZN8emstream7getcharEv>:
    348c:	80 e0       	ldi	r24, 0x00	; 0
    348e:	90 e0       	ldi	r25, 0x00	; 0
    3490:	08 95       	ret

00003492 <_ZN8emstream14check_for_charEv>:
    3492:	80 e0       	ldi	r24, 0x00	; 0
    3494:	08 95       	ret

00003496 <_ZN8emstream12transmit_nowEv>:
    3496:	08 95       	ret

00003498 <_ZN8emstream12clear_screenEv>:
    3498:	08 95       	ret

0000349a <_ZN8emstreamC1Ev>:
    349a:	fc 01       	movw	r30, r24
    349c:	8c e5       	ldi	r24, 0x5C	; 92
    349e:	90 e2       	ldi	r25, 0x20	; 32
    34a0:	80 83       	st	Z, r24
    34a2:	91 83       	std	Z+1, r25	; 0x01
    34a4:	8a e0       	ldi	r24, 0x0A	; 10
    34a6:	82 83       	std	Z+2, r24	; 0x02
    34a8:	13 82       	std	Z+3, r1	; 0x03
    34aa:	83 e0       	ldi	r24, 0x03	; 3
    34ac:	85 83       	std	Z+5, r24	; 0x05
    34ae:	14 82       	std	Z+4, r1	; 0x04
    34b0:	16 82       	std	Z+6, r1	; 0x06
    34b2:	17 82       	std	Z+7, r1	; 0x07
    34b4:	08 95       	ret

000034b6 <_ZN8emstream4putsEPKc>:
    34b6:	0f 93       	push	r16
    34b8:	1f 93       	push	r17
    34ba:	cf 93       	push	r28
    34bc:	df 93       	push	r29
    34be:	8c 01       	movw	r16, r24
    34c0:	fb 01       	movw	r30, r22
    34c2:	dc 01       	movw	r26, r24
    34c4:	14 96       	adiw	r26, 0x04	; 4
    34c6:	8c 91       	ld	r24, X
    34c8:	81 11       	cpse	r24, r1
    34ca:	04 c0       	rjmp	.+8      	; 0x34d4 <_ZN8emstream4putsEPKc+0x1e>
    34cc:	60 81       	ld	r22, Z
    34ce:	61 11       	cpse	r22, r1
    34d0:	17 c0       	rjmp	.+46     	; 0x3500 <_ZN8emstream4putsEPKc+0x4a>
    34d2:	23 c0       	rjmp	.+70     	; 0x351a <_ZN8emstream4putsEPKc+0x64>
    34d4:	d8 01       	movw	r26, r16
    34d6:	14 96       	adiw	r26, 0x04	; 4
    34d8:	1c 92       	st	X, r1
    34da:	eb 01       	movw	r28, r22
    34dc:	21 96       	adiw	r28, 0x01	; 1
    34de:	64 91       	lpm	r22, Z
    34e0:	66 23       	and	r22, r22
    34e2:	d9 f0       	breq	.+54     	; 0x351a <_ZN8emstream4putsEPKc+0x64>
    34e4:	d8 01       	movw	r26, r16
    34e6:	ed 91       	ld	r30, X+
    34e8:	fc 91       	ld	r31, X
    34ea:	02 80       	ldd	r0, Z+2	; 0x02
    34ec:	f3 81       	ldd	r31, Z+3	; 0x03
    34ee:	e0 2d       	mov	r30, r0
    34f0:	c8 01       	movw	r24, r16
    34f2:	19 95       	eicall
    34f4:	fe 01       	movw	r30, r28
    34f6:	64 91       	lpm	r22, Z
    34f8:	21 96       	adiw	r28, 0x01	; 1
    34fa:	61 11       	cpse	r22, r1
    34fc:	f3 cf       	rjmp	.-26     	; 0x34e4 <_ZN8emstream4putsEPKc+0x2e>
    34fe:	0d c0       	rjmp	.+26     	; 0x351a <_ZN8emstream4putsEPKc+0x64>
    3500:	ef 01       	movw	r28, r30
    3502:	21 96       	adiw	r28, 0x01	; 1
    3504:	d8 01       	movw	r26, r16
    3506:	ed 91       	ld	r30, X+
    3508:	fc 91       	ld	r31, X
    350a:	02 80       	ldd	r0, Z+2	; 0x02
    350c:	f3 81       	ldd	r31, Z+3	; 0x03
    350e:	e0 2d       	mov	r30, r0
    3510:	c8 01       	movw	r24, r16
    3512:	19 95       	eicall
    3514:	69 91       	ld	r22, Y+
    3516:	61 11       	cpse	r22, r1
    3518:	f5 cf       	rjmp	.-22     	; 0x3504 <_ZN8emstream4putsEPKc+0x4e>
    351a:	df 91       	pop	r29
    351c:	cf 91       	pop	r28
    351e:	1f 91       	pop	r17
    3520:	0f 91       	pop	r16
    3522:	08 95       	ret

00003524 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3524:	cf 93       	push	r28
    3526:	df 93       	push	r29
    3528:	ec 01       	movw	r28, r24
	switch (new_manip)
    352a:	86 2f       	mov	r24, r22
    352c:	90 e0       	ldi	r25, 0x00	; 0
    352e:	8b 30       	cpi	r24, 0x0B	; 11
    3530:	91 05       	cpc	r25, r1
    3532:	d8 f5       	brcc	.+118    	; 0x35aa <_ZN8emstreamlsE15ser_manipulator+0x86>
    3534:	fc 01       	movw	r30, r24
    3536:	88 27       	eor	r24, r24
    3538:	e2 50       	subi	r30, 0x02	; 2
    353a:	ff 4f       	sbci	r31, 0xFF	; 255
    353c:	8f 4f       	sbci	r24, 0xFF	; 255
    353e:	0c 94 39 20 	jmp	0x4072	; 0x4072 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3542:	82 e0       	ldi	r24, 0x02	; 2
    3544:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3546:	31 c0       	rjmp	.+98     	; 0x35aa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3548:	88 e0       	ldi	r24, 0x08	; 8
    354a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    354c:	2e c0       	rjmp	.+92     	; 0x35aa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    354e:	8a e0       	ldi	r24, 0x0A	; 10
    3550:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3552:	2b c0       	rjmp	.+86     	; 0x35aa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3554:	80 e1       	ldi	r24, 0x10	; 16
    3556:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3558:	28 c0       	rjmp	.+80     	; 0x35aa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    355a:	81 e0       	ldi	r24, 0x01	; 1
    355c:	8b 83       	std	Y+3, r24	; 0x03
			break;
    355e:	25 c0       	rjmp	.+74     	; 0x35aa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3560:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3562:	23 c0       	rjmp	.+70     	; 0x35aa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3564:	e8 81       	ld	r30, Y
    3566:	f9 81       	ldd	r31, Y+1	; 0x01
    3568:	02 80       	ldd	r0, Z+2	; 0x02
    356a:	f3 81       	ldd	r31, Z+3	; 0x03
    356c:	e0 2d       	mov	r30, r0
    356e:	6d e0       	ldi	r22, 0x0D	; 13
    3570:	ce 01       	movw	r24, r28
    3572:	19 95       	eicall
    3574:	e8 81       	ld	r30, Y
    3576:	f9 81       	ldd	r31, Y+1	; 0x01
    3578:	02 80       	ldd	r0, Z+2	; 0x02
    357a:	f3 81       	ldd	r31, Z+3	; 0x03
    357c:	e0 2d       	mov	r30, r0
    357e:	6a e0       	ldi	r22, 0x0A	; 10
    3580:	ce 01       	movw	r24, r28
    3582:	19 95       	eicall
			break;
    3584:	12 c0       	rjmp	.+36     	; 0x35aa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3586:	e8 81       	ld	r30, Y
    3588:	f9 81       	ldd	r31, Y+1	; 0x01
    358a:	02 84       	ldd	r0, Z+10	; 0x0a
    358c:	f3 85       	ldd	r31, Z+11	; 0x0b
    358e:	e0 2d       	mov	r30, r0
    3590:	ce 01       	movw	r24, r28
    3592:	19 95       	eicall
			break;
    3594:	0a c0       	rjmp	.+20     	; 0x35aa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3596:	e8 81       	ld	r30, Y
    3598:	f9 81       	ldd	r31, Y+1	; 0x01
    359a:	00 84       	ldd	r0, Z+8	; 0x08
    359c:	f1 85       	ldd	r31, Z+9	; 0x09
    359e:	e0 2d       	mov	r30, r0
    35a0:	ce 01       	movw	r24, r28
    35a2:	19 95       	eicall
			break;
    35a4:	02 c0       	rjmp	.+4      	; 0x35aa <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    35a6:	81 e0       	ldi	r24, 0x01	; 1
    35a8:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    35aa:	ce 01       	movw	r24, r28
    35ac:	df 91       	pop	r29
    35ae:	cf 91       	pop	r28
    35b0:	08 95       	ret

000035b2 <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    35b2:	0f 93       	push	r16
    35b4:	1f 93       	push	r17
    35b6:	cf 93       	push	r28
    35b8:	df 93       	push	r29
    35ba:	cd b7       	in	r28, 0x3d	; 61
    35bc:	de b7       	in	r29, 0x3e	; 62
    35be:	61 97       	sbiw	r28, 0x11	; 17
    35c0:	cd bf       	out	0x3d, r28	; 61
    35c2:	de bf       	out	0x3e, r29	; 62
    35c4:	8c 01       	movw	r16, r24
    35c6:	9b 01       	movw	r18, r22
	if (base != 10)
    35c8:	fc 01       	movw	r30, r24
    35ca:	92 81       	ldd	r25, Z+2	; 0x02
    35cc:	9a 30       	cpi	r25, 0x0A	; 10
    35ce:	21 f0       	breq	.+8      	; 0x35d8 <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    35d0:	c8 01       	movw	r24, r16
    35d2:	0e 94 02 1b 	call	0x3604	; 0x3604 <_ZN8emstreamlsEj>
    35d6:	0d c0       	rjmp	.+26     	; 0x35f2 <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    35d8:	4a e0       	ldi	r20, 0x0A	; 10
    35da:	be 01       	movw	r22, r28
    35dc:	6f 5f       	subi	r22, 0xFF	; 255
    35de:	7f 4f       	sbci	r23, 0xFF	; 255
    35e0:	c9 01       	movw	r24, r18
    35e2:	0e 94 a6 20 	call	0x414c	; 0x414c <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    35e6:	be 01       	movw	r22, r28
    35e8:	6f 5f       	subi	r22, 0xFF	; 255
    35ea:	7f 4f       	sbci	r23, 0xFF	; 255
    35ec:	c8 01       	movw	r24, r16
    35ee:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    35f2:	c8 01       	movw	r24, r16
    35f4:	61 96       	adiw	r28, 0x11	; 17
    35f6:	cd bf       	out	0x3d, r28	; 61
    35f8:	de bf       	out	0x3e, r29	; 62
    35fa:	df 91       	pop	r29
    35fc:	cf 91       	pop	r28
    35fe:	1f 91       	pop	r17
    3600:	0f 91       	pop	r16
    3602:	08 95       	ret

00003604 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3604:	ff 92       	push	r15
    3606:	0f 93       	push	r16
    3608:	1f 93       	push	r17
    360a:	cf 93       	push	r28
    360c:	df 93       	push	r29
    360e:	cd b7       	in	r28, 0x3d	; 61
    3610:	de b7       	in	r29, 0x3e	; 62
    3612:	61 97       	sbiw	r28, 0x11	; 17
    3614:	cd bf       	out	0x3d, r28	; 61
    3616:	de bf       	out	0x3e, r29	; 62
    3618:	8c 01       	movw	r16, r24
    361a:	f6 2e       	mov	r15, r22
    361c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    361e:	f8 01       	movw	r30, r16
    3620:	42 81       	ldd	r20, Z+2	; 0x02
    3622:	40 31       	cpi	r20, 0x10	; 16
    3624:	21 f0       	breq	.+8      	; 0x362e <_ZN8emstreamlsEj+0x2a>
    3626:	48 30       	cpi	r20, 0x08	; 8
    3628:	11 f0       	breq	.+4      	; 0x362e <_ZN8emstreamlsEj+0x2a>
    362a:	42 30       	cpi	r20, 0x02	; 2
    362c:	41 f4       	brne	.+16     	; 0x363e <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    362e:	69 2f       	mov	r22, r25
    3630:	c8 01       	movw	r24, r16
    3632:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <_ZN8emstreamlsEh>
    3636:	6f 2d       	mov	r22, r15
    3638:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <_ZN8emstreamlsEh>
    363c:	0d c0       	rjmp	.+26     	; 0x3658 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    363e:	50 e0       	ldi	r21, 0x00	; 0
    3640:	be 01       	movw	r22, r28
    3642:	6f 5f       	subi	r22, 0xFF	; 255
    3644:	7f 4f       	sbci	r23, 0xFF	; 255
    3646:	8f 2d       	mov	r24, r15
    3648:	0e 94 de 20 	call	0x41bc	; 0x41bc <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    364c:	be 01       	movw	r22, r28
    364e:	6f 5f       	subi	r22, 0xFF	; 255
    3650:	7f 4f       	sbci	r23, 0xFF	; 255
    3652:	c8 01       	movw	r24, r16
    3654:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3658:	c8 01       	movw	r24, r16
    365a:	61 96       	adiw	r28, 0x11	; 17
    365c:	cd bf       	out	0x3d, r28	; 61
    365e:	de bf       	out	0x3e, r29	; 62
    3660:	df 91       	pop	r29
    3662:	cf 91       	pop	r28
    3664:	1f 91       	pop	r17
    3666:	0f 91       	pop	r16
    3668:	ff 90       	pop	r15
    366a:	08 95       	ret

0000366c <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    366c:	df 92       	push	r13
    366e:	ef 92       	push	r14
    3670:	ff 92       	push	r15
    3672:	0f 93       	push	r16
    3674:	1f 93       	push	r17
    3676:	cf 93       	push	r28
    3678:	df 93       	push	r29
    367a:	cd b7       	in	r28, 0x3d	; 61
    367c:	de b7       	in	r29, 0x3e	; 62
    367e:	a1 97       	sbiw	r28, 0x21	; 33
    3680:	cd bf       	out	0x3d, r28	; 61
    3682:	de bf       	out	0x3e, r29	; 62
    3684:	8c 01       	movw	r16, r24
    3686:	d4 2e       	mov	r13, r20
    3688:	e5 2e       	mov	r14, r21
    368a:	f6 2e       	mov	r15, r22
    368c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    368e:	f8 01       	movw	r30, r16
    3690:	22 81       	ldd	r18, Z+2	; 0x02
    3692:	20 31       	cpi	r18, 0x10	; 16
    3694:	21 f0       	breq	.+8      	; 0x369e <_ZN8emstreamlsEm+0x32>
    3696:	28 30       	cpi	r18, 0x08	; 8
    3698:	11 f0       	breq	.+4      	; 0x369e <_ZN8emstreamlsEm+0x32>
    369a:	22 30       	cpi	r18, 0x02	; 2
    369c:	71 f4       	brne	.+28     	; 0x36ba <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    369e:	69 2f       	mov	r22, r25
    36a0:	c8 01       	movw	r24, r16
    36a2:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <_ZN8emstreamlsEh>
    36a6:	6f 2d       	mov	r22, r15
    36a8:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <_ZN8emstreamlsEh>
    36ac:	6e 2d       	mov	r22, r14
    36ae:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <_ZN8emstreamlsEh>
    36b2:	6d 2d       	mov	r22, r13
    36b4:	0e 94 78 1b 	call	0x36f0	; 0x36f0 <_ZN8emstreamlsEh>
    36b8:	0f c0       	rjmp	.+30     	; 0x36d8 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    36ba:	30 e0       	ldi	r19, 0x00	; 0
    36bc:	ae 01       	movw	r20, r28
    36be:	4f 5f       	subi	r20, 0xFF	; 255
    36c0:	5f 4f       	sbci	r21, 0xFF	; 255
    36c2:	6d 2d       	mov	r22, r13
    36c4:	7e 2d       	mov	r23, r14
    36c6:	8f 2d       	mov	r24, r15
    36c8:	0e 94 b1 20 	call	0x4162	; 0x4162 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    36cc:	be 01       	movw	r22, r28
    36ce:	6f 5f       	subi	r22, 0xFF	; 255
    36d0:	7f 4f       	sbci	r23, 0xFF	; 255
    36d2:	c8 01       	movw	r24, r16
    36d4:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    36d8:	c8 01       	movw	r24, r16
    36da:	a1 96       	adiw	r28, 0x21	; 33
    36dc:	cd bf       	out	0x3d, r28	; 61
    36de:	de bf       	out	0x3e, r29	; 62
    36e0:	df 91       	pop	r29
    36e2:	cf 91       	pop	r28
    36e4:	1f 91       	pop	r17
    36e6:	0f 91       	pop	r16
    36e8:	ff 90       	pop	r15
    36ea:	ef 90       	pop	r14
    36ec:	df 90       	pop	r13
    36ee:	08 95       	ret

000036f0 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    36f0:	cf 92       	push	r12
    36f2:	df 92       	push	r13
    36f4:	ef 92       	push	r14
    36f6:	ff 92       	push	r15
    36f8:	0f 93       	push	r16
    36fa:	1f 93       	push	r17
    36fc:	cf 93       	push	r28
    36fe:	df 93       	push	r29
    3700:	cd b7       	in	r28, 0x3d	; 61
    3702:	de b7       	in	r29, 0x3e	; 62
    3704:	29 97       	sbiw	r28, 0x09	; 9
    3706:	cd bf       	out	0x3d, r28	; 61
    3708:	de bf       	out	0x3e, r29	; 62
    370a:	8c 01       	movw	r16, r24
    370c:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    370e:	dc 01       	movw	r26, r24
    3710:	13 96       	adiw	r26, 0x03	; 3
    3712:	8c 91       	ld	r24, X
    3714:	13 97       	sbiw	r26, 0x03	; 3
    3716:	88 23       	and	r24, r24
    3718:	41 f0       	breq	.+16     	; 0x372a <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    371a:	ed 91       	ld	r30, X+
    371c:	fc 91       	ld	r31, X
    371e:	02 80       	ldd	r0, Z+2	; 0x02
    3720:	f3 81       	ldd	r31, Z+3	; 0x03
    3722:	e0 2d       	mov	r30, r0
    3724:	c8 01       	movw	r24, r16
    3726:	19 95       	eicall
    3728:	56 c0       	rjmp	.+172    	; 0x37d6 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    372a:	f8 01       	movw	r30, r16
    372c:	42 81       	ldd	r20, Z+2	; 0x02
    372e:	42 30       	cpi	r20, 0x02	; 2
    3730:	19 f5       	brne	.+70     	; 0x3778 <_ZN8emstreamlsEh+0x88>
    3732:	68 94       	set
    3734:	cc 24       	eor	r12, r12
    3736:	c3 f8       	bld	r12, 3
    3738:	d1 2c       	mov	r13, r1
    373a:	68 94       	set
    373c:	ff 24       	eor	r15, r15
    373e:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3740:	8e 2d       	mov	r24, r14
    3742:	8f 21       	and	r24, r15
    3744:	51 f0       	breq	.+20     	; 0x375a <_ZN8emstreamlsEh+0x6a>
    3746:	d8 01       	movw	r26, r16
    3748:	ed 91       	ld	r30, X+
    374a:	fc 91       	ld	r31, X
    374c:	02 80       	ldd	r0, Z+2	; 0x02
    374e:	f3 81       	ldd	r31, Z+3	; 0x03
    3750:	e0 2d       	mov	r30, r0
    3752:	61 e3       	ldi	r22, 0x31	; 49
    3754:	c8 01       	movw	r24, r16
    3756:	19 95       	eicall
    3758:	09 c0       	rjmp	.+18     	; 0x376c <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    375a:	d8 01       	movw	r26, r16
    375c:	ed 91       	ld	r30, X+
    375e:	fc 91       	ld	r31, X
    3760:	02 80       	ldd	r0, Z+2	; 0x02
    3762:	f3 81       	ldd	r31, Z+3	; 0x03
    3764:	e0 2d       	mov	r30, r0
    3766:	60 e3       	ldi	r22, 0x30	; 48
    3768:	c8 01       	movw	r24, r16
    376a:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    376c:	f6 94       	lsr	r15
    376e:	b1 e0       	ldi	r27, 0x01	; 1
    3770:	cb 1a       	sub	r12, r27
    3772:	d1 08       	sbc	r13, r1
    3774:	29 f7       	brne	.-54     	; 0x3740 <_ZN8emstreamlsEh+0x50>
    3776:	2f c0       	rjmp	.+94     	; 0x37d6 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3778:	40 31       	cpi	r20, 0x10	; 16
    377a:	f9 f4       	brne	.+62     	; 0x37ba <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    377c:	62 95       	swap	r22
    377e:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3780:	01 90       	ld	r0, Z+
    3782:	f0 81       	ld	r31, Z
    3784:	e0 2d       	mov	r30, r0
    3786:	02 80       	ldd	r0, Z+2	; 0x02
    3788:	f3 81       	ldd	r31, Z+3	; 0x03
    378a:	e0 2d       	mov	r30, r0
    378c:	6a 30       	cpi	r22, 0x0A	; 10
    378e:	10 f0       	brcs	.+4      	; 0x3794 <_ZN8emstreamlsEh+0xa4>
    3790:	69 5c       	subi	r22, 0xC9	; 201
    3792:	01 c0       	rjmp	.+2      	; 0x3796 <_ZN8emstreamlsEh+0xa6>
    3794:	60 5d       	subi	r22, 0xD0	; 208
    3796:	c8 01       	movw	r24, r16
    3798:	19 95       	eicall
		temp_char = num & 0x0F;
    379a:	6e 2d       	mov	r22, r14
    379c:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    379e:	d8 01       	movw	r26, r16
    37a0:	ed 91       	ld	r30, X+
    37a2:	fc 91       	ld	r31, X
    37a4:	02 80       	ldd	r0, Z+2	; 0x02
    37a6:	f3 81       	ldd	r31, Z+3	; 0x03
    37a8:	e0 2d       	mov	r30, r0
    37aa:	6a 30       	cpi	r22, 0x0A	; 10
    37ac:	10 f0       	brcs	.+4      	; 0x37b2 <_ZN8emstreamlsEh+0xc2>
    37ae:	69 5c       	subi	r22, 0xC9	; 201
    37b0:	01 c0       	rjmp	.+2      	; 0x37b4 <_ZN8emstreamlsEh+0xc4>
    37b2:	60 5d       	subi	r22, 0xD0	; 208
    37b4:	c8 01       	movw	r24, r16
    37b6:	19 95       	eicall
    37b8:	0e c0       	rjmp	.+28     	; 0x37d6 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    37ba:	50 e0       	ldi	r21, 0x00	; 0
    37bc:	be 01       	movw	r22, r28
    37be:	6f 5f       	subi	r22, 0xFF	; 255
    37c0:	7f 4f       	sbci	r23, 0xFF	; 255
    37c2:	8e 2d       	mov	r24, r14
    37c4:	90 e0       	ldi	r25, 0x00	; 0
    37c6:	0e 94 de 20 	call	0x41bc	; 0x41bc <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    37ca:	be 01       	movw	r22, r28
    37cc:	6f 5f       	subi	r22, 0xFF	; 255
    37ce:	7f 4f       	sbci	r23, 0xFF	; 255
    37d0:	c8 01       	movw	r24, r16
    37d2:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    37d6:	c8 01       	movw	r24, r16
    37d8:	29 96       	adiw	r28, 0x09	; 9
    37da:	cd bf       	out	0x3d, r28	; 61
    37dc:	de bf       	out	0x3e, r29	; 62
    37de:	df 91       	pop	r29
    37e0:	cf 91       	pop	r28
    37e2:	1f 91       	pop	r17
    37e4:	0f 91       	pop	r16
    37e6:	ff 90       	pop	r15
    37e8:	ef 90       	pop	r14
    37ea:	df 90       	pop	r13
    37ec:	cf 90       	pop	r12
    37ee:	08 95       	ret

000037f0 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    37f0:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    37f2:	50 96       	adiw	r26, 0x10	; 16
    37f4:	ed 91       	ld	r30, X+
    37f6:	fc 91       	ld	r31, X
    37f8:	51 97       	sbiw	r26, 0x11	; 17
    37fa:	80 81       	ld	r24, Z
    37fc:	54 96       	adiw	r26, 0x14	; 20
    37fe:	4c 91       	ld	r20, X
    3800:	54 97       	sbiw	r26, 0x14	; 20
    3802:	84 23       	and	r24, r20
    3804:	29 f0       	breq	.+10     	; 0x3810 <_ZN5rs2327putcharEc+0x20>
    3806:	09 c0       	rjmp	.+18     	; 0x381a <_ZN5rs2327putcharEc+0x2a>
    3808:	21 50       	subi	r18, 0x01	; 1
    380a:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    380c:	19 f4       	brne	.+6      	; 0x3814 <_ZN5rs2327putcharEc+0x24>
    380e:	12 c0       	rjmp	.+36     	; 0x3834 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3810:	21 e2       	ldi	r18, 0x21	; 33
    3812:	3e e4       	ldi	r19, 0x4E	; 78
    3814:	90 81       	ld	r25, Z
    3816:	94 23       	and	r25, r20
    3818:	b9 f3       	breq	.-18     	; 0x3808 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    381a:	90 81       	ld	r25, Z
    381c:	56 96       	adiw	r26, 0x16	; 22
    381e:	8c 91       	ld	r24, X
    3820:	56 97       	sbiw	r26, 0x16	; 22
    3822:	89 2b       	or	r24, r25
    3824:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3826:	1e 96       	adiw	r26, 0x0e	; 14
    3828:	ed 91       	ld	r30, X+
    382a:	fc 91       	ld	r31, X
    382c:	1f 97       	sbiw	r26, 0x0f	; 15
    382e:	60 83       	st	Z, r22
	return (true);
    3830:	81 e0       	ldi	r24, 0x01	; 1
    3832:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3834:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3836:	08 95       	ret

00003838 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3838:	cf 93       	push	r28
    383a:	df 93       	push	r29
    383c:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    383e:	c1 8d       	ldd	r28, Z+25	; 0x19
    3840:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3842:	28 81       	ld	r18, Y
    3844:	39 81       	ldd	r19, Y+1	; 0x01
    3846:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3848:	b4 8d       	ldd	r27, Z+28	; 0x1c
    384a:	4d 91       	ld	r20, X+
    384c:	5c 91       	ld	r21, X
    384e:	24 17       	cp	r18, r20
    3850:	35 07       	cpc	r19, r21
    3852:	e9 f3       	breq	.-6      	; 0x384e <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3854:	a7 89       	ldd	r26, Z+23	; 0x17
    3856:	b0 8d       	ldd	r27, Z+24	; 0x18
    3858:	0d 90       	ld	r0, X+
    385a:	bc 91       	ld	r27, X
    385c:	a0 2d       	mov	r26, r0
    385e:	a2 0f       	add	r26, r18
    3860:	b3 1f       	adc	r27, r19
    3862:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3864:	2f 5f       	subi	r18, 0xFF	; 255
    3866:	3f 4f       	sbci	r19, 0xFF	; 255
    3868:	28 83       	st	Y, r18
    386a:	39 83       	std	Y+1, r19	; 0x01
    386c:	24 36       	cpi	r18, 0x64	; 100
    386e:	31 05       	cpc	r19, r1
    3870:	28 f0       	brcs	.+10     	; 0x387c <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3872:	01 8c       	ldd	r0, Z+25	; 0x19
    3874:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3876:	e0 2d       	mov	r30, r0
    3878:	10 82       	st	Z, r1
    387a:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    387c:	90 e0       	ldi	r25, 0x00	; 0
    387e:	df 91       	pop	r29
    3880:	cf 91       	pop	r28
    3882:	08 95       	ret

00003884 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3884:	cf 93       	push	r28
    3886:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3888:	ec 01       	movw	r28, r24
    388a:	a9 8d       	ldd	r26, Y+25	; 0x19
    388c:	ba 8d       	ldd	r27, Y+26	; 0x1a
    388e:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3890:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3892:	81 e0       	ldi	r24, 0x01	; 1
    3894:	4d 91       	ld	r20, X+
    3896:	5c 91       	ld	r21, X
    3898:	20 81       	ld	r18, Z
    389a:	31 81       	ldd	r19, Z+1	; 0x01
    389c:	42 17       	cp	r20, r18
    389e:	53 07       	cpc	r21, r19
    38a0:	09 f4       	brne	.+2      	; 0x38a4 <_ZN5rs23214check_for_charEv+0x20>
    38a2:	80 e0       	ldi	r24, 0x00	; 0
}
    38a4:	df 91       	pop	r29
    38a6:	cf 91       	pop	r28
    38a8:	08 95       	ret

000038aa <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    38aa:	dc 01       	movw	r26, r24
    38ac:	ed 91       	ld	r30, X+
    38ae:	fc 91       	ld	r31, X
    38b0:	02 80       	ldd	r0, Z+2	; 0x02
    38b2:	f3 81       	ldd	r31, Z+3	; 0x03
    38b4:	e0 2d       	mov	r30, r0
    38b6:	6c e0       	ldi	r22, 0x0C	; 12
    38b8:	19 95       	eicall
    38ba:	08 95       	ret

000038bc <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    38bc:	ef 92       	push	r14
    38be:	ff 92       	push	r15
    38c0:	0f 93       	push	r16
    38c2:	1f 93       	push	r17
    38c4:	cf 93       	push	r28
    38c6:	df 93       	push	r29
    38c8:	ec 01       	movw	r28, r24
    38ca:	7b 01       	movw	r14, r22
    38cc:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    38ce:	0e 94 4d 1a 	call	0x349a	; 0x349a <_ZN8emstreamC1Ev>
    38d2:	a8 01       	movw	r20, r16
    38d4:	b7 01       	movw	r22, r14
    38d6:	ce 01       	movw	r24, r28
    38d8:	08 96       	adiw	r24, 0x08	; 8
    38da:	0e 94 ae 19 	call	0x335c	; 0x335c <_ZN7base232C1EjP12USART_struct>
    38de:	8c e6       	ldi	r24, 0x6C	; 108
    38e0:	90 e2       	ldi	r25, 0x20	; 32
    38e2:	88 83       	st	Y, r24
    38e4:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    38e6:	00 3a       	cpi	r16, 0xA0	; 160
    38e8:	88 e0       	ldi	r24, 0x08	; 8
    38ea:	18 07       	cpc	r17, r24
    38ec:	69 f4       	brne	.+26     	; 0x3908 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    38ee:	84 e4       	ldi	r24, 0x44	; 68
    38f0:	91 e3       	ldi	r25, 0x31	; 49
    38f2:	8f 8b       	std	Y+23, r24	; 0x17
    38f4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    38f6:	8a e3       	ldi	r24, 0x3A	; 58
    38f8:	91 e3       	ldi	r25, 0x31	; 49
    38fa:	89 8f       	std	Y+25, r24	; 0x19
    38fc:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    38fe:	80 e3       	ldi	r24, 0x30	; 48
    3900:	91 e3       	ldi	r25, 0x31	; 49
    3902:	8b 8f       	std	Y+27, r24	; 0x1b
    3904:	9c 8f       	std	Y+28, r25	; 0x1c
    3906:	42 c0       	rjmp	.+132    	; 0x398c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3908:	00 3b       	cpi	r16, 0xB0	; 176
    390a:	e8 e0       	ldi	r30, 0x08	; 8
    390c:	1e 07       	cpc	r17, r30
    390e:	69 f4       	brne	.+26     	; 0x392a <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3910:	82 e4       	ldi	r24, 0x42	; 66
    3912:	91 e3       	ldi	r25, 0x31	; 49
    3914:	8f 8b       	std	Y+23, r24	; 0x17
    3916:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3918:	88 e3       	ldi	r24, 0x38	; 56
    391a:	91 e3       	ldi	r25, 0x31	; 49
    391c:	89 8f       	std	Y+25, r24	; 0x19
    391e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3920:	8e e2       	ldi	r24, 0x2E	; 46
    3922:	91 e3       	ldi	r25, 0x31	; 49
    3924:	8b 8f       	std	Y+27, r24	; 0x1b
    3926:	9c 8f       	std	Y+28, r25	; 0x1c
    3928:	31 c0       	rjmp	.+98     	; 0x398c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    392a:	00 3a       	cpi	r16, 0xA0	; 160
    392c:	f9 e0       	ldi	r31, 0x09	; 9
    392e:	1f 07       	cpc	r17, r31
    3930:	69 f4       	brne	.+26     	; 0x394c <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3932:	80 e4       	ldi	r24, 0x40	; 64
    3934:	91 e3       	ldi	r25, 0x31	; 49
    3936:	8f 8b       	std	Y+23, r24	; 0x17
    3938:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    393a:	86 e3       	ldi	r24, 0x36	; 54
    393c:	91 e3       	ldi	r25, 0x31	; 49
    393e:	89 8f       	std	Y+25, r24	; 0x19
    3940:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3942:	8c e2       	ldi	r24, 0x2C	; 44
    3944:	91 e3       	ldi	r25, 0x31	; 49
    3946:	8b 8f       	std	Y+27, r24	; 0x1b
    3948:	9c 8f       	std	Y+28, r25	; 0x1c
    394a:	20 c0       	rjmp	.+64     	; 0x398c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    394c:	00 3b       	cpi	r16, 0xB0	; 176
    394e:	89 e0       	ldi	r24, 0x09	; 9
    3950:	18 07       	cpc	r17, r24
    3952:	69 f4       	brne	.+26     	; 0x396e <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3954:	8e e3       	ldi	r24, 0x3E	; 62
    3956:	91 e3       	ldi	r25, 0x31	; 49
    3958:	8f 8b       	std	Y+23, r24	; 0x17
    395a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    395c:	84 e3       	ldi	r24, 0x34	; 52
    395e:	91 e3       	ldi	r25, 0x31	; 49
    3960:	89 8f       	std	Y+25, r24	; 0x19
    3962:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3964:	8a e2       	ldi	r24, 0x2A	; 42
    3966:	91 e3       	ldi	r25, 0x31	; 49
    3968:	8b 8f       	std	Y+27, r24	; 0x1b
    396a:	9c 8f       	std	Y+28, r25	; 0x1c
    396c:	0f c0       	rjmp	.+30     	; 0x398c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    396e:	00 3a       	cpi	r16, 0xA0	; 160
    3970:	1a 40       	sbci	r17, 0x0A	; 10
    3972:	61 f4       	brne	.+24     	; 0x398c <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3974:	8c e3       	ldi	r24, 0x3C	; 60
    3976:	91 e3       	ldi	r25, 0x31	; 49
    3978:	8f 8b       	std	Y+23, r24	; 0x17
    397a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    397c:	82 e3       	ldi	r24, 0x32	; 50
    397e:	91 e3       	ldi	r25, 0x31	; 49
    3980:	89 8f       	std	Y+25, r24	; 0x19
    3982:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3984:	88 e2       	ldi	r24, 0x28	; 40
    3986:	91 e3       	ldi	r25, 0x31	; 49
    3988:	8b 8f       	std	Y+27, r24	; 0x1b
    398a:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    398c:	0f 89       	ldd	r16, Y+23	; 0x17
    398e:	18 8d       	ldd	r17, Y+24	; 0x18
    3990:	84 e6       	ldi	r24, 0x64	; 100
    3992:	90 e0       	ldi	r25, 0x00	; 0
    3994:	0e 94 aa 19 	call	0x3354	; 0x3354 <_Znaj>
    3998:	f8 01       	movw	r30, r16
    399a:	80 83       	st	Z, r24
    399c:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    399e:	e9 8d       	ldd	r30, Y+25	; 0x19
    39a0:	fa 8d       	ldd	r31, Y+26	; 0x1a
    39a2:	10 82       	st	Z, r1
    39a4:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    39a6:	eb 8d       	ldd	r30, Y+27	; 0x1b
    39a8:	fc 8d       	ldd	r31, Y+28	; 0x1c
    39aa:	10 82       	st	Z, r1
    39ac:	11 82       	std	Z+1, r1	; 0x01
}
    39ae:	df 91       	pop	r29
    39b0:	cf 91       	pop	r28
    39b2:	1f 91       	pop	r17
    39b4:	0f 91       	pop	r16
    39b6:	ff 90       	pop	r15
    39b8:	ef 90       	pop	r14
    39ba:	08 95       	ret

000039bc <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    39bc:	1f 92       	push	r1
    39be:	0f 92       	push	r0
    39c0:	0f b6       	in	r0, 0x3f	; 63
    39c2:	0f 92       	push	r0
    39c4:	11 24       	eor	r1, r1
    39c6:	08 b6       	in	r0, 0x38	; 56
    39c8:	0f 92       	push	r0
    39ca:	18 be       	out	0x38, r1	; 56
    39cc:	0b b6       	in	r0, 0x3b	; 59
    39ce:	0f 92       	push	r0
    39d0:	1b be       	out	0x3b, r1	; 59
    39d2:	2f 93       	push	r18
    39d4:	3f 93       	push	r19
    39d6:	8f 93       	push	r24
    39d8:	9f 93       	push	r25
    39da:	ef 93       	push	r30
    39dc:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    39de:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    39e2:	e0 91 44 31 	lds	r30, 0x3144	; 0x803144 <rcvC0_buffer>
    39e6:	f0 91 45 31 	lds	r31, 0x3145	; 0x803145 <rcvC0_buffer+0x1>
    39ea:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    39ee:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    39f2:	e8 0f       	add	r30, r24
    39f4:	f9 1f       	adc	r31, r25
    39f6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    39f8:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    39fc:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3a00:	01 96       	adiw	r24, 0x01	; 1
    3a02:	84 36       	cpi	r24, 0x64	; 100
    3a04:	91 05       	cpc	r25, r1
    3a06:	60 f4       	brcc	.+24     	; 0x3a20 <__vector_25+0x64>
    3a08:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <rcvC0_write_index>
    3a0c:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3a10:	20 91 3a 31 	lds	r18, 0x313A	; 0x80313a <rcvC0_read_index>
    3a14:	30 91 3b 31 	lds	r19, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    3a18:	82 17       	cp	r24, r18
    3a1a:	93 07       	cpc	r25, r19
    3a1c:	f1 f4       	brne	.+60     	; 0x3a5a <__vector_25+0x9e>
    3a1e:	0c c0       	rjmp	.+24     	; 0x3a38 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3a20:	10 92 30 31 	sts	0x3130, r1	; 0x803130 <rcvC0_write_index>
    3a24:	10 92 31 31 	sts	0x3131, r1	; 0x803131 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3a28:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC0_read_index>
    3a2c:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    3a30:	18 16       	cp	r1, r24
    3a32:	19 06       	cpc	r1, r25
    3a34:	91 f4       	brne	.+36     	; 0x3a5a <__vector_25+0x9e>
    3a36:	0e c0       	rjmp	.+28     	; 0x3a54 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3a38:	01 96       	adiw	r24, 0x01	; 1
    3a3a:	84 36       	cpi	r24, 0x64	; 100
    3a3c:	91 05       	cpc	r25, r1
    3a3e:	28 f4       	brcc	.+10     	; 0x3a4a <__vector_25+0x8e>
    3a40:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvC0_read_index>
    3a44:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvC0_read_index+0x1>
    3a48:	08 c0       	rjmp	.+16     	; 0x3a5a <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3a4a:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvC0_read_index>
    3a4e:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvC0_read_index+0x1>
}
    3a52:	03 c0       	rjmp	.+6      	; 0x3a5a <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3a54:	81 e0       	ldi	r24, 0x01	; 1
    3a56:	90 e0       	ldi	r25, 0x00	; 0
    3a58:	f3 cf       	rjmp	.-26     	; 0x3a40 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3a5a:	ff 91       	pop	r31
    3a5c:	ef 91       	pop	r30
    3a5e:	9f 91       	pop	r25
    3a60:	8f 91       	pop	r24
    3a62:	3f 91       	pop	r19
    3a64:	2f 91       	pop	r18
    3a66:	0f 90       	pop	r0
    3a68:	0b be       	out	0x3b, r0	; 59
    3a6a:	0f 90       	pop	r0
    3a6c:	08 be       	out	0x38, r0	; 56
    3a6e:	0f 90       	pop	r0
    3a70:	0f be       	out	0x3f, r0	; 63
    3a72:	0f 90       	pop	r0
    3a74:	1f 90       	pop	r1
    3a76:	18 95       	reti

00003a78 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3a78:	1f 92       	push	r1
    3a7a:	0f 92       	push	r0
    3a7c:	0f b6       	in	r0, 0x3f	; 63
    3a7e:	0f 92       	push	r0
    3a80:	11 24       	eor	r1, r1
    3a82:	08 b6       	in	r0, 0x38	; 56
    3a84:	0f 92       	push	r0
    3a86:	18 be       	out	0x38, r1	; 56
    3a88:	0b b6       	in	r0, 0x3b	; 59
    3a8a:	0f 92       	push	r0
    3a8c:	1b be       	out	0x3b, r1	; 59
    3a8e:	2f 93       	push	r18
    3a90:	3f 93       	push	r19
    3a92:	8f 93       	push	r24
    3a94:	9f 93       	push	r25
    3a96:	ef 93       	push	r30
    3a98:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3a9a:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3a9e:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <rcvC1_buffer>
    3aa2:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <rcvC1_buffer+0x1>
    3aa6:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3aaa:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3aae:	e8 0f       	add	r30, r24
    3ab0:	f9 1f       	adc	r31, r25
    3ab2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3ab4:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3ab8:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    3abc:	01 96       	adiw	r24, 0x01	; 1
    3abe:	84 36       	cpi	r24, 0x64	; 100
    3ac0:	91 05       	cpc	r25, r1
    3ac2:	60 f4       	brcc	.+24     	; 0x3adc <__vector_28+0x64>
    3ac4:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC1_write_index>
    3ac8:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3acc:	20 91 38 31 	lds	r18, 0x3138	; 0x803138 <rcvC1_read_index>
    3ad0:	30 91 39 31 	lds	r19, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    3ad4:	82 17       	cp	r24, r18
    3ad6:	93 07       	cpc	r25, r19
    3ad8:	f1 f4       	brne	.+60     	; 0x3b16 <__vector_28+0x9e>
    3ada:	0c c0       	rjmp	.+24     	; 0x3af4 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3adc:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC1_write_index>
    3ae0:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3ae4:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvC1_read_index>
    3ae8:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    3aec:	18 16       	cp	r1, r24
    3aee:	19 06       	cpc	r1, r25
    3af0:	91 f4       	brne	.+36     	; 0x3b16 <__vector_28+0x9e>
    3af2:	0e c0       	rjmp	.+28     	; 0x3b10 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3af4:	01 96       	adiw	r24, 0x01	; 1
    3af6:	84 36       	cpi	r24, 0x64	; 100
    3af8:	91 05       	cpc	r25, r1
    3afa:	28 f4       	brcc	.+10     	; 0x3b06 <__vector_28+0x8e>
    3afc:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvC1_read_index>
    3b00:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvC1_read_index+0x1>
    3b04:	08 c0       	rjmp	.+16     	; 0x3b16 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3b06:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvC1_read_index>
    3b0a:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvC1_read_index+0x1>
}
    3b0e:	03 c0       	rjmp	.+6      	; 0x3b16 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3b10:	81 e0       	ldi	r24, 0x01	; 1
    3b12:	90 e0       	ldi	r25, 0x00	; 0
    3b14:	f3 cf       	rjmp	.-26     	; 0x3afc <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3b16:	ff 91       	pop	r31
    3b18:	ef 91       	pop	r30
    3b1a:	9f 91       	pop	r25
    3b1c:	8f 91       	pop	r24
    3b1e:	3f 91       	pop	r19
    3b20:	2f 91       	pop	r18
    3b22:	0f 90       	pop	r0
    3b24:	0b be       	out	0x3b, r0	; 59
    3b26:	0f 90       	pop	r0
    3b28:	08 be       	out	0x38, r0	; 56
    3b2a:	0f 90       	pop	r0
    3b2c:	0f be       	out	0x3f, r0	; 63
    3b2e:	0f 90       	pop	r0
    3b30:	1f 90       	pop	r1
    3b32:	18 95       	reti

00003b34 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3b34:	1f 92       	push	r1
    3b36:	0f 92       	push	r0
    3b38:	0f b6       	in	r0, 0x3f	; 63
    3b3a:	0f 92       	push	r0
    3b3c:	11 24       	eor	r1, r1
    3b3e:	08 b6       	in	r0, 0x38	; 56
    3b40:	0f 92       	push	r0
    3b42:	18 be       	out	0x38, r1	; 56
    3b44:	0b b6       	in	r0, 0x3b	; 59
    3b46:	0f 92       	push	r0
    3b48:	1b be       	out	0x3b, r1	; 59
    3b4a:	2f 93       	push	r18
    3b4c:	3f 93       	push	r19
    3b4e:	8f 93       	push	r24
    3b50:	9f 93       	push	r25
    3b52:	ef 93       	push	r30
    3b54:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3b56:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3b5a:	e0 91 40 31 	lds	r30, 0x3140	; 0x803140 <rcvD0_buffer>
    3b5e:	f0 91 41 31 	lds	r31, 0x3141	; 0x803141 <rcvD0_buffer+0x1>
    3b62:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3b66:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3b6a:	e8 0f       	add	r30, r24
    3b6c:	f9 1f       	adc	r31, r25
    3b6e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3b70:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvD0_write_index>
    3b74:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvD0_write_index+0x1>
    3b78:	01 96       	adiw	r24, 0x01	; 1
    3b7a:	84 36       	cpi	r24, 0x64	; 100
    3b7c:	91 05       	cpc	r25, r1
    3b7e:	60 f4       	brcc	.+24     	; 0x3b98 <__vector_88+0x64>
    3b80:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvD0_write_index>
    3b84:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3b88:	20 91 36 31 	lds	r18, 0x3136	; 0x803136 <rcvD0_read_index>
    3b8c:	30 91 37 31 	lds	r19, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    3b90:	82 17       	cp	r24, r18
    3b92:	93 07       	cpc	r25, r19
    3b94:	f1 f4       	brne	.+60     	; 0x3bd2 <__vector_88+0x9e>
    3b96:	0c c0       	rjmp	.+24     	; 0x3bb0 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3b98:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvD0_write_index>
    3b9c:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3ba0:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD0_read_index>
    3ba4:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    3ba8:	18 16       	cp	r1, r24
    3baa:	19 06       	cpc	r1, r25
    3bac:	91 f4       	brne	.+36     	; 0x3bd2 <__vector_88+0x9e>
    3bae:	0e c0       	rjmp	.+28     	; 0x3bcc <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3bb0:	01 96       	adiw	r24, 0x01	; 1
    3bb2:	84 36       	cpi	r24, 0x64	; 100
    3bb4:	91 05       	cpc	r25, r1
    3bb6:	28 f4       	brcc	.+10     	; 0x3bc2 <__vector_88+0x8e>
    3bb8:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvD0_read_index>
    3bbc:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvD0_read_index+0x1>
    3bc0:	08 c0       	rjmp	.+16     	; 0x3bd2 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3bc2:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvD0_read_index>
    3bc6:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvD0_read_index+0x1>
}
    3bca:	03 c0       	rjmp	.+6      	; 0x3bd2 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3bcc:	81 e0       	ldi	r24, 0x01	; 1
    3bce:	90 e0       	ldi	r25, 0x00	; 0
    3bd0:	f3 cf       	rjmp	.-26     	; 0x3bb8 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3bd2:	ff 91       	pop	r31
    3bd4:	ef 91       	pop	r30
    3bd6:	9f 91       	pop	r25
    3bd8:	8f 91       	pop	r24
    3bda:	3f 91       	pop	r19
    3bdc:	2f 91       	pop	r18
    3bde:	0f 90       	pop	r0
    3be0:	0b be       	out	0x3b, r0	; 59
    3be2:	0f 90       	pop	r0
    3be4:	08 be       	out	0x38, r0	; 56
    3be6:	0f 90       	pop	r0
    3be8:	0f be       	out	0x3f, r0	; 63
    3bea:	0f 90       	pop	r0
    3bec:	1f 90       	pop	r1
    3bee:	18 95       	reti

00003bf0 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3bf0:	1f 92       	push	r1
    3bf2:	0f 92       	push	r0
    3bf4:	0f b6       	in	r0, 0x3f	; 63
    3bf6:	0f 92       	push	r0
    3bf8:	11 24       	eor	r1, r1
    3bfa:	08 b6       	in	r0, 0x38	; 56
    3bfc:	0f 92       	push	r0
    3bfe:	18 be       	out	0x38, r1	; 56
    3c00:	0b b6       	in	r0, 0x3b	; 59
    3c02:	0f 92       	push	r0
    3c04:	1b be       	out	0x3b, r1	; 59
    3c06:	2f 93       	push	r18
    3c08:	3f 93       	push	r19
    3c0a:	8f 93       	push	r24
    3c0c:	9f 93       	push	r25
    3c0e:	ef 93       	push	r30
    3c10:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3c12:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3c16:	e0 91 3e 31 	lds	r30, 0x313E	; 0x80313e <rcvD1_buffer>
    3c1a:	f0 91 3f 31 	lds	r31, 0x313F	; 0x80313f <rcvD1_buffer+0x1>
    3c1e:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    3c22:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    3c26:	e8 0f       	add	r30, r24
    3c28:	f9 1f       	adc	r31, r25
    3c2a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3c2c:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    3c30:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    3c34:	01 96       	adiw	r24, 0x01	; 1
    3c36:	84 36       	cpi	r24, 0x64	; 100
    3c38:	91 05       	cpc	r25, r1
    3c3a:	60 f4       	brcc	.+24     	; 0x3c54 <__vector_91+0x64>
    3c3c:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD1_write_index>
    3c40:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3c44:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <rcvD1_read_index>
    3c48:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    3c4c:	82 17       	cp	r24, r18
    3c4e:	93 07       	cpc	r25, r19
    3c50:	f1 f4       	brne	.+60     	; 0x3c8e <__vector_91+0x9e>
    3c52:	0c c0       	rjmp	.+24     	; 0x3c6c <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3c54:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD1_write_index>
    3c58:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3c5c:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvD1_read_index>
    3c60:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    3c64:	18 16       	cp	r1, r24
    3c66:	19 06       	cpc	r1, r25
    3c68:	91 f4       	brne	.+36     	; 0x3c8e <__vector_91+0x9e>
    3c6a:	0e c0       	rjmp	.+28     	; 0x3c88 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3c6c:	01 96       	adiw	r24, 0x01	; 1
    3c6e:	84 36       	cpi	r24, 0x64	; 100
    3c70:	91 05       	cpc	r25, r1
    3c72:	28 f4       	brcc	.+10     	; 0x3c7e <__vector_91+0x8e>
    3c74:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvD1_read_index>
    3c78:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvD1_read_index+0x1>
    3c7c:	08 c0       	rjmp	.+16     	; 0x3c8e <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3c7e:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvD1_read_index>
    3c82:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvD1_read_index+0x1>
}
    3c86:	03 c0       	rjmp	.+6      	; 0x3c8e <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3c88:	81 e0       	ldi	r24, 0x01	; 1
    3c8a:	90 e0       	ldi	r25, 0x00	; 0
    3c8c:	f3 cf       	rjmp	.-26     	; 0x3c74 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3c8e:	ff 91       	pop	r31
    3c90:	ef 91       	pop	r30
    3c92:	9f 91       	pop	r25
    3c94:	8f 91       	pop	r24
    3c96:	3f 91       	pop	r19
    3c98:	2f 91       	pop	r18
    3c9a:	0f 90       	pop	r0
    3c9c:	0b be       	out	0x3b, r0	; 59
    3c9e:	0f 90       	pop	r0
    3ca0:	08 be       	out	0x38, r0	; 56
    3ca2:	0f 90       	pop	r0
    3ca4:	0f be       	out	0x3f, r0	; 63
    3ca6:	0f 90       	pop	r0
    3ca8:	1f 90       	pop	r1
    3caa:	18 95       	reti

00003cac <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3cac:	1f 92       	push	r1
    3cae:	0f 92       	push	r0
    3cb0:	0f b6       	in	r0, 0x3f	; 63
    3cb2:	0f 92       	push	r0
    3cb4:	11 24       	eor	r1, r1
    3cb6:	08 b6       	in	r0, 0x38	; 56
    3cb8:	0f 92       	push	r0
    3cba:	18 be       	out	0x38, r1	; 56
    3cbc:	0b b6       	in	r0, 0x3b	; 59
    3cbe:	0f 92       	push	r0
    3cc0:	1b be       	out	0x3b, r1	; 59
    3cc2:	2f 93       	push	r18
    3cc4:	3f 93       	push	r19
    3cc6:	8f 93       	push	r24
    3cc8:	9f 93       	push	r25
    3cca:	ef 93       	push	r30
    3ccc:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3cce:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3cd2:	e0 91 3c 31 	lds	r30, 0x313C	; 0x80313c <rcvE0_buffer>
    3cd6:	f0 91 3d 31 	lds	r31, 0x313D	; 0x80313d <rcvE0_buffer+0x1>
    3cda:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    3cde:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    3ce2:	e8 0f       	add	r30, r24
    3ce4:	f9 1f       	adc	r31, r25
    3ce6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3ce8:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    3cec:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    3cf0:	01 96       	adiw	r24, 0x01	; 1
    3cf2:	84 36       	cpi	r24, 0x64	; 100
    3cf4:	91 05       	cpc	r25, r1
    3cf6:	60 f4       	brcc	.+24     	; 0x3d10 <__vector_58+0x64>
    3cf8:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvE0_write_index>
    3cfc:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3d00:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <rcvE0_read_index>
    3d04:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    3d08:	82 17       	cp	r24, r18
    3d0a:	93 07       	cpc	r25, r19
    3d0c:	f1 f4       	brne	.+60     	; 0x3d4a <__vector_58+0x9e>
    3d0e:	0c c0       	rjmp	.+24     	; 0x3d28 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3d10:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvE0_write_index>
    3d14:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3d18:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <rcvE0_read_index>
    3d1c:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    3d20:	18 16       	cp	r1, r24
    3d22:	19 06       	cpc	r1, r25
    3d24:	91 f4       	brne	.+36     	; 0x3d4a <__vector_58+0x9e>
    3d26:	0e c0       	rjmp	.+28     	; 0x3d44 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3d28:	01 96       	adiw	r24, 0x01	; 1
    3d2a:	84 36       	cpi	r24, 0x64	; 100
    3d2c:	91 05       	cpc	r25, r1
    3d2e:	28 f4       	brcc	.+10     	; 0x3d3a <__vector_58+0x8e>
    3d30:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <rcvE0_read_index>
    3d34:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <rcvE0_read_index+0x1>
    3d38:	08 c0       	rjmp	.+16     	; 0x3d4a <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3d3a:	10 92 32 31 	sts	0x3132, r1	; 0x803132 <rcvE0_read_index>
    3d3e:	10 92 33 31 	sts	0x3133, r1	; 0x803133 <rcvE0_read_index+0x1>
}
    3d42:	03 c0       	rjmp	.+6      	; 0x3d4a <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3d44:	81 e0       	ldi	r24, 0x01	; 1
    3d46:	90 e0       	ldi	r25, 0x00	; 0
    3d48:	f3 cf       	rjmp	.-26     	; 0x3d30 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3d4a:	ff 91       	pop	r31
    3d4c:	ef 91       	pop	r30
    3d4e:	9f 91       	pop	r25
    3d50:	8f 91       	pop	r24
    3d52:	3f 91       	pop	r19
    3d54:	2f 91       	pop	r18
    3d56:	0f 90       	pop	r0
    3d58:	0b be       	out	0x3b, r0	; 59
    3d5a:	0f 90       	pop	r0
    3d5c:	08 be       	out	0x38, r0	; 56
    3d5e:	0f 90       	pop	r0
    3d60:	0f be       	out	0x3f, r0	; 63
    3d62:	0f 90       	pop	r0
    3d64:	1f 90       	pop	r1
    3d66:	18 95       	reti

00003d68 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3d68:	0f 93       	push	r16
    3d6a:	cf 93       	push	r28
    3d6c:	df 93       	push	r29
    3d6e:	1f 92       	push	r1
    3d70:	cd b7       	in	r28, 0x3d	; 61
    3d72:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3d74:	2f b7       	in	r18, 0x3f	; 63
    3d76:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3d78:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3d7a:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3d7c:	fc 01       	movw	r30, r24
    3d7e:	08 ed       	ldi	r16, 0xD8	; 216
    3d80:	04 bf       	out	0x34, r16	; 52
    3d82:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3d84:	89 81       	ldd	r24, Y+1	; 0x01
    3d86:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3d88:	0f 90       	pop	r0
    3d8a:	df 91       	pop	r29
    3d8c:	cf 91       	pop	r28
    3d8e:	0f 91       	pop	r16
    3d90:	08 95       	ret

00003d92 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3d92:	0f 93       	push	r16
    3d94:	1f 93       	push	r17
    3d96:	cf 93       	push	r28
    3d98:	df 93       	push	r29
    3d9a:	cd b7       	in	r28, 0x3d	; 61
    3d9c:	de b7       	in	r29, 0x3e	; 62
    3d9e:	6d 97       	sbiw	r28, 0x1d	; 29
    3da0:	cd bf       	out	0x3d, r28	; 61
    3da2:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    3da4:	e0 e6       	ldi	r30, 0x60	; 96
    3da6:	f6 e0       	ldi	r31, 0x06	; 6
    3da8:	80 e4       	ldi	r24, 0x40	; 64
    3daa:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    3dac:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    3dae:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    3db0:	e0 e5       	ldi	r30, 0x50	; 80
    3db2:	f0 e0       	ldi	r31, 0x00	; 0
    3db4:	80 81       	ld	r24, Z
    3db6:	82 60       	ori	r24, 0x02	; 2
    3db8:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3dba:	81 81       	ldd	r24, Z+1	; 0x01
    3dbc:	81 ff       	sbrs	r24, 1
    3dbe:	fd cf       	rjmp	.-6      	; 0x3dba <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3dc0:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3dc4:	68 7f       	andi	r22, 0xF8	; 248
    3dc6:	61 60       	ori	r22, 0x01	; 1
    3dc8:	80 e4       	ldi	r24, 0x40	; 64
    3dca:	90 e0       	ldi	r25, 0x00	; 0
    3dcc:	0e 94 b4 1e 	call	0x3d68	; 0x3d68 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3dd0:	e0 e5       	ldi	r30, 0x50	; 80
    3dd2:	f0 e0       	ldi	r31, 0x00	; 0
    3dd4:	80 81       	ld	r24, Z
    3dd6:	8e 7f       	andi	r24, 0xFE	; 254
    3dd8:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3dda:	9d ef       	ldi	r25, 0xFD	; 253
    3ddc:	88 ed       	ldi	r24, 0xD8	; 216
    3dde:	08 b6       	in	r0, 0x38	; 56
    3de0:	18 be       	out	0x38, r1	; 56
    3de2:	84 bf       	out	0x34, r24	; 52
    3de4:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3de8:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    3dea:	40 eb       	ldi	r20, 0xB0	; 176
    3dec:	58 e0       	ldi	r21, 0x08	; 8
    3dee:	60 e0       	ldi	r22, 0x00	; 0
    3df0:	70 e0       	ldi	r23, 0x00	; 0
    3df2:	ce 01       	movw	r24, r28
    3df4:	01 96       	adiw	r24, 0x01	; 1
    3df6:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3dfa:	67 e0       	ldi	r22, 0x07	; 7
    3dfc:	ce 01       	movw	r24, r28
    3dfe:	01 96       	adiw	r24, 0x01	; 1
    3e00:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    3e04:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3e06:	68 e7       	ldi	r22, 0x78	; 120
    3e08:	70 e2       	ldi	r23, 0x20	; 32
    3e0a:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <_ZN8emstream4putsEPKc>
    3e0e:	66 e0       	ldi	r22, 0x06	; 6
    3e10:	c8 01       	movw	r24, r16
    3e12:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
    3e16:	66 e0       	ldi	r22, 0x06	; 6
    3e18:	0e 94 92 1a 	call	0x3524	; 0x3524 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3e1c:	82 e1       	ldi	r24, 0x12	; 18
    3e1e:	90 e0       	ldi	r25, 0x00	; 0
    3e20:	0e 94 a7 19 	call	0x334e	; 0x334e <_Znwj>
    3e24:	8e 01       	movw	r16, r28
    3e26:	0f 5f       	subi	r16, 0xFF	; 255
    3e28:	1f 4f       	sbci	r17, 0xFF	; 255
    3e2a:	24 e0       	ldi	r18, 0x04	; 4
    3e2c:	31 e0       	ldi	r19, 0x01	; 1
    3e2e:	40 e0       	ldi	r20, 0x00	; 0
    3e30:	67 e9       	ldi	r22, 0x97	; 151
    3e32:	70 e2       	ldi	r23, 0x20	; 32
    3e34:	0e 94 68 07 	call	0xed0	; 0xed0 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3e38:	82 e1       	ldi	r24, 0x12	; 18
    3e3a:	90 e0       	ldi	r25, 0x00	; 0
    3e3c:	0e 94 a7 19 	call	0x334e	; 0x334e <_Znwj>
    3e40:	24 e0       	ldi	r18, 0x04	; 4
    3e42:	31 e0       	ldi	r19, 0x01	; 1
    3e44:	42 e0       	ldi	r20, 0x02	; 2
    3e46:	6f e9       	ldi	r22, 0x9F	; 159
    3e48:	70 e2       	ldi	r23, 0x20	; 32
    3e4a:	0e 94 5d 03 	call	0x6ba	; 0x6ba <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3e4e:	82 e1       	ldi	r24, 0x12	; 18
    3e50:	90 e0       	ldi	r25, 0x00	; 0
    3e52:	0e 94 a7 19 	call	0x334e	; 0x334e <_Znwj>
    3e56:	24 e0       	ldi	r18, 0x04	; 4
    3e58:	31 e0       	ldi	r19, 0x01	; 1
    3e5a:	43 e0       	ldi	r20, 0x03	; 3
    3e5c:	66 ea       	ldi	r22, 0xA6	; 166
    3e5e:	70 e2       	ldi	r23, 0x20	; 32
    3e60:	0e 94 b6 03 	call	0x76c	; 0x76c <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3e64:	82 e1       	ldi	r24, 0x12	; 18
    3e66:	90 e0       	ldi	r25, 0x00	; 0
    3e68:	0e 94 a7 19 	call	0x334e	; 0x334e <_Znwj>
    3e6c:	24 e0       	ldi	r18, 0x04	; 4
    3e6e:	31 e0       	ldi	r19, 0x01	; 1
    3e70:	44 e0       	ldi	r20, 0x04	; 4
    3e72:	6d ea       	ldi	r22, 0xAD	; 173
    3e74:	70 e2       	ldi	r23, 0x20	; 32
    3e76:	0e 94 1b 04 	call	0x836	; 0x836 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    3e7a:	8c e6       	ldi	r24, 0x6C	; 108
    3e7c:	90 e0       	ldi	r25, 0x00	; 0
    3e7e:	0e 94 a7 19 	call	0x334e	; 0x334e <_Znwj>
    3e82:	24 e0       	ldi	r18, 0x04	; 4
    3e84:	31 e0       	ldi	r19, 0x01	; 1
    3e86:	43 e0       	ldi	r20, 0x03	; 3
    3e88:	66 eb       	ldi	r22, 0xB6	; 182
    3e8a:	70 e2       	ldi	r23, 0x20	; 32
    3e8c:	0e 94 2a 07 	call	0xe54	; 0xe54 <_ZN5MotorC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3e90:	87 e0       	ldi	r24, 0x07	; 7
    3e92:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3e96:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3e98:	0e 94 b9 10 	call	0x2172	; 0x2172 <vTaskStartScheduler>
	
	
	return 0;
    3e9c:	80 e0       	ldi	r24, 0x00	; 0
    3e9e:	90 e0       	ldi	r25, 0x00	; 0
    3ea0:	6d 96       	adiw	r28, 0x1d	; 29
    3ea2:	cd bf       	out	0x3d, r28	; 61
    3ea4:	de bf       	out	0x3e, r29	; 62
    3ea6:	df 91       	pop	r29
    3ea8:	cf 91       	pop	r28
    3eaa:	1f 91       	pop	r17
    3eac:	0f 91       	pop	r16
    3eae:	08 95       	ret

00003eb0 <_GLOBAL__sub_I_counter>:
    3eb0:	0f 93       	push	r16
    3eb2:	1f 93       	push	r17
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3eb4:	0a e0       	ldi	r16, 0x0A	; 10
    3eb6:	10 e0       	ldi	r17, 0x00	; 0
    3eb8:	20 e0       	ldi	r18, 0x00	; 0
    3eba:	30 e0       	ldi	r19, 0x00	; 0
    3ebc:	40 e0       	ldi	r20, 0x00	; 0
    3ebe:	50 e0       	ldi	r21, 0x00	; 0
    3ec0:	60 e2       	ldi	r22, 0x20	; 32
    3ec2:	70 e0       	ldi	r23, 0x00	; 0
    3ec4:	80 e5       	ldi	r24, 0x50	; 80
    3ec6:	91 e3       	ldi	r25, 0x31	; 49
    3ec8:	0e 94 13 18 	call	0x3026	; 0x3026 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    3ecc:	1f 91       	pop	r17
    3ece:	0f 91       	pop	r16
    3ed0:	08 95       	ret

00003ed2 <__cmpsf2>:
    3ed2:	0e 94 ab 1f 	call	0x3f56	; 0x3f56 <__fp_cmp>
    3ed6:	08 f4       	brcc	.+2      	; 0x3eda <__cmpsf2+0x8>
    3ed8:	81 e0       	ldi	r24, 0x01	; 1
    3eda:	08 95       	ret

00003edc <__floatunsisf>:
    3edc:	e8 94       	clt
    3ede:	09 c0       	rjmp	.+18     	; 0x3ef2 <__floatsisf+0x12>

00003ee0 <__floatsisf>:
    3ee0:	97 fb       	bst	r25, 7
    3ee2:	3e f4       	brtc	.+14     	; 0x3ef2 <__floatsisf+0x12>
    3ee4:	90 95       	com	r25
    3ee6:	80 95       	com	r24
    3ee8:	70 95       	com	r23
    3eea:	61 95       	neg	r22
    3eec:	7f 4f       	sbci	r23, 0xFF	; 255
    3eee:	8f 4f       	sbci	r24, 0xFF	; 255
    3ef0:	9f 4f       	sbci	r25, 0xFF	; 255
    3ef2:	99 23       	and	r25, r25
    3ef4:	a9 f0       	breq	.+42     	; 0x3f20 <__floatsisf+0x40>
    3ef6:	f9 2f       	mov	r31, r25
    3ef8:	96 e9       	ldi	r25, 0x96	; 150
    3efa:	bb 27       	eor	r27, r27
    3efc:	93 95       	inc	r25
    3efe:	f6 95       	lsr	r31
    3f00:	87 95       	ror	r24
    3f02:	77 95       	ror	r23
    3f04:	67 95       	ror	r22
    3f06:	b7 95       	ror	r27
    3f08:	f1 11       	cpse	r31, r1
    3f0a:	f8 cf       	rjmp	.-16     	; 0x3efc <__floatsisf+0x1c>
    3f0c:	fa f4       	brpl	.+62     	; 0x3f4c <__floatsisf+0x6c>
    3f0e:	bb 0f       	add	r27, r27
    3f10:	11 f4       	brne	.+4      	; 0x3f16 <__floatsisf+0x36>
    3f12:	60 ff       	sbrs	r22, 0
    3f14:	1b c0       	rjmp	.+54     	; 0x3f4c <__floatsisf+0x6c>
    3f16:	6f 5f       	subi	r22, 0xFF	; 255
    3f18:	7f 4f       	sbci	r23, 0xFF	; 255
    3f1a:	8f 4f       	sbci	r24, 0xFF	; 255
    3f1c:	9f 4f       	sbci	r25, 0xFF	; 255
    3f1e:	16 c0       	rjmp	.+44     	; 0x3f4c <__floatsisf+0x6c>
    3f20:	88 23       	and	r24, r24
    3f22:	11 f0       	breq	.+4      	; 0x3f28 <__floatsisf+0x48>
    3f24:	96 e9       	ldi	r25, 0x96	; 150
    3f26:	11 c0       	rjmp	.+34     	; 0x3f4a <__floatsisf+0x6a>
    3f28:	77 23       	and	r23, r23
    3f2a:	21 f0       	breq	.+8      	; 0x3f34 <__floatsisf+0x54>
    3f2c:	9e e8       	ldi	r25, 0x8E	; 142
    3f2e:	87 2f       	mov	r24, r23
    3f30:	76 2f       	mov	r23, r22
    3f32:	05 c0       	rjmp	.+10     	; 0x3f3e <__floatsisf+0x5e>
    3f34:	66 23       	and	r22, r22
    3f36:	71 f0       	breq	.+28     	; 0x3f54 <__floatsisf+0x74>
    3f38:	96 e8       	ldi	r25, 0x86	; 134
    3f3a:	86 2f       	mov	r24, r22
    3f3c:	70 e0       	ldi	r23, 0x00	; 0
    3f3e:	60 e0       	ldi	r22, 0x00	; 0
    3f40:	2a f0       	brmi	.+10     	; 0x3f4c <__floatsisf+0x6c>
    3f42:	9a 95       	dec	r25
    3f44:	66 0f       	add	r22, r22
    3f46:	77 1f       	adc	r23, r23
    3f48:	88 1f       	adc	r24, r24
    3f4a:	da f7       	brpl	.-10     	; 0x3f42 <__floatsisf+0x62>
    3f4c:	88 0f       	add	r24, r24
    3f4e:	96 95       	lsr	r25
    3f50:	87 95       	ror	r24
    3f52:	97 f9       	bld	r25, 7
    3f54:	08 95       	ret

00003f56 <__fp_cmp>:
    3f56:	99 0f       	add	r25, r25
    3f58:	00 08       	sbc	r0, r0
    3f5a:	55 0f       	add	r21, r21
    3f5c:	aa 0b       	sbc	r26, r26
    3f5e:	e0 e8       	ldi	r30, 0x80	; 128
    3f60:	fe ef       	ldi	r31, 0xFE	; 254
    3f62:	16 16       	cp	r1, r22
    3f64:	17 06       	cpc	r1, r23
    3f66:	e8 07       	cpc	r30, r24
    3f68:	f9 07       	cpc	r31, r25
    3f6a:	c0 f0       	brcs	.+48     	; 0x3f9c <__fp_cmp+0x46>
    3f6c:	12 16       	cp	r1, r18
    3f6e:	13 06       	cpc	r1, r19
    3f70:	e4 07       	cpc	r30, r20
    3f72:	f5 07       	cpc	r31, r21
    3f74:	98 f0       	brcs	.+38     	; 0x3f9c <__fp_cmp+0x46>
    3f76:	62 1b       	sub	r22, r18
    3f78:	73 0b       	sbc	r23, r19
    3f7a:	84 0b       	sbc	r24, r20
    3f7c:	95 0b       	sbc	r25, r21
    3f7e:	39 f4       	brne	.+14     	; 0x3f8e <__fp_cmp+0x38>
    3f80:	0a 26       	eor	r0, r26
    3f82:	61 f0       	breq	.+24     	; 0x3f9c <__fp_cmp+0x46>
    3f84:	23 2b       	or	r18, r19
    3f86:	24 2b       	or	r18, r20
    3f88:	25 2b       	or	r18, r21
    3f8a:	21 f4       	brne	.+8      	; 0x3f94 <__fp_cmp+0x3e>
    3f8c:	08 95       	ret
    3f8e:	0a 26       	eor	r0, r26
    3f90:	09 f4       	brne	.+2      	; 0x3f94 <__fp_cmp+0x3e>
    3f92:	a1 40       	sbci	r26, 0x01	; 1
    3f94:	a6 95       	lsr	r26
    3f96:	8f ef       	ldi	r24, 0xFF	; 255
    3f98:	81 1d       	adc	r24, r1
    3f9a:	81 1d       	adc	r24, r1
    3f9c:	08 95       	ret

00003f9e <__gesf2>:
    3f9e:	0e 94 ab 1f 	call	0x3f56	; 0x3f56 <__fp_cmp>
    3fa2:	08 f4       	brcc	.+2      	; 0x3fa6 <__gesf2+0x8>
    3fa4:	8f ef       	ldi	r24, 0xFF	; 255
    3fa6:	08 95       	ret

00003fa8 <__mulsi3>:
    3fa8:	db 01       	movw	r26, r22
    3faa:	8f 93       	push	r24
    3fac:	9f 93       	push	r25
    3fae:	0e 94 60 20 	call	0x40c0	; 0x40c0 <__muluhisi3>
    3fb2:	bf 91       	pop	r27
    3fb4:	af 91       	pop	r26
    3fb6:	a2 9f       	mul	r26, r18
    3fb8:	80 0d       	add	r24, r0
    3fba:	91 1d       	adc	r25, r1
    3fbc:	a3 9f       	mul	r26, r19
    3fbe:	90 0d       	add	r25, r0
    3fc0:	b2 9f       	mul	r27, r18
    3fc2:	90 0d       	add	r25, r0
    3fc4:	11 24       	eor	r1, r1
    3fc6:	08 95       	ret

00003fc8 <__divmodhi4>:
    3fc8:	97 fb       	bst	r25, 7
    3fca:	07 2e       	mov	r0, r23
    3fcc:	16 f4       	brtc	.+4      	; 0x3fd2 <__divmodhi4+0xa>
    3fce:	00 94       	com	r0
    3fd0:	07 d0       	rcall	.+14     	; 0x3fe0 <__divmodhi4_neg1>
    3fd2:	77 fd       	sbrc	r23, 7
    3fd4:	09 d0       	rcall	.+18     	; 0x3fe8 <__divmodhi4_neg2>
    3fd6:	0e 94 73 20 	call	0x40e6	; 0x40e6 <__udivmodhi4>
    3fda:	07 fc       	sbrc	r0, 7
    3fdc:	05 d0       	rcall	.+10     	; 0x3fe8 <__divmodhi4_neg2>
    3fde:	3e f4       	brtc	.+14     	; 0x3fee <__divmodhi4_exit>

00003fe0 <__divmodhi4_neg1>:
    3fe0:	90 95       	com	r25
    3fe2:	81 95       	neg	r24
    3fe4:	9f 4f       	sbci	r25, 0xFF	; 255
    3fe6:	08 95       	ret

00003fe8 <__divmodhi4_neg2>:
    3fe8:	70 95       	com	r23
    3fea:	61 95       	neg	r22
    3fec:	7f 4f       	sbci	r23, 0xFF	; 255

00003fee <__divmodhi4_exit>:
    3fee:	08 95       	ret

00003ff0 <__udivmodsi4>:
    3ff0:	a1 e2       	ldi	r26, 0x21	; 33
    3ff2:	1a 2e       	mov	r1, r26
    3ff4:	aa 1b       	sub	r26, r26
    3ff6:	bb 1b       	sub	r27, r27
    3ff8:	fd 01       	movw	r30, r26
    3ffa:	0d c0       	rjmp	.+26     	; 0x4016 <__udivmodsi4_ep>

00003ffc <__udivmodsi4_loop>:
    3ffc:	aa 1f       	adc	r26, r26
    3ffe:	bb 1f       	adc	r27, r27
    4000:	ee 1f       	adc	r30, r30
    4002:	ff 1f       	adc	r31, r31
    4004:	a2 17       	cp	r26, r18
    4006:	b3 07       	cpc	r27, r19
    4008:	e4 07       	cpc	r30, r20
    400a:	f5 07       	cpc	r31, r21
    400c:	20 f0       	brcs	.+8      	; 0x4016 <__udivmodsi4_ep>
    400e:	a2 1b       	sub	r26, r18
    4010:	b3 0b       	sbc	r27, r19
    4012:	e4 0b       	sbc	r30, r20
    4014:	f5 0b       	sbc	r31, r21

00004016 <__udivmodsi4_ep>:
    4016:	66 1f       	adc	r22, r22
    4018:	77 1f       	adc	r23, r23
    401a:	88 1f       	adc	r24, r24
    401c:	99 1f       	adc	r25, r25
    401e:	1a 94       	dec	r1
    4020:	69 f7       	brne	.-38     	; 0x3ffc <__udivmodsi4_loop>
    4022:	60 95       	com	r22
    4024:	70 95       	com	r23
    4026:	80 95       	com	r24
    4028:	90 95       	com	r25
    402a:	9b 01       	movw	r18, r22
    402c:	ac 01       	movw	r20, r24
    402e:	bd 01       	movw	r22, r26
    4030:	cf 01       	movw	r24, r30
    4032:	08 95       	ret

00004034 <__divmodsi4>:
    4034:	05 2e       	mov	r0, r21
    4036:	97 fb       	bst	r25, 7
    4038:	1e f4       	brtc	.+6      	; 0x4040 <__divmodsi4+0xc>
    403a:	00 94       	com	r0
    403c:	0e 94 31 20 	call	0x4062	; 0x4062 <__negsi2>
    4040:	57 fd       	sbrc	r21, 7
    4042:	07 d0       	rcall	.+14     	; 0x4052 <__divmodsi4_neg2>
    4044:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <__udivmodsi4>
    4048:	07 fc       	sbrc	r0, 7
    404a:	03 d0       	rcall	.+6      	; 0x4052 <__divmodsi4_neg2>
    404c:	4e f4       	brtc	.+18     	; 0x4060 <__divmodsi4_exit>
    404e:	0c 94 31 20 	jmp	0x4062	; 0x4062 <__negsi2>

00004052 <__divmodsi4_neg2>:
    4052:	50 95       	com	r21
    4054:	40 95       	com	r20
    4056:	30 95       	com	r19
    4058:	21 95       	neg	r18
    405a:	3f 4f       	sbci	r19, 0xFF	; 255
    405c:	4f 4f       	sbci	r20, 0xFF	; 255
    405e:	5f 4f       	sbci	r21, 0xFF	; 255

00004060 <__divmodsi4_exit>:
    4060:	08 95       	ret

00004062 <__negsi2>:
    4062:	90 95       	com	r25
    4064:	80 95       	com	r24
    4066:	70 95       	com	r23
    4068:	61 95       	neg	r22
    406a:	7f 4f       	sbci	r23, 0xFF	; 255
    406c:	8f 4f       	sbci	r24, 0xFF	; 255
    406e:	9f 4f       	sbci	r25, 0xFF	; 255
    4070:	08 95       	ret

00004072 <__tablejump2__>:
    4072:	ee 0f       	add	r30, r30
    4074:	ff 1f       	adc	r31, r31
    4076:	88 1f       	adc	r24, r24
    4078:	8b bf       	out	0x3b, r24	; 59
    407a:	07 90       	elpm	r0, Z+
    407c:	f6 91       	elpm	r31, Z
    407e:	e0 2d       	mov	r30, r0
    4080:	1b be       	out	0x3b, r1	; 59
    4082:	19 94       	eijmp

00004084 <__mulhisi3>:
    4084:	0e 94 4a 20 	call	0x4094	; 0x4094 <__umulhisi3>
    4088:	33 23       	and	r19, r19
    408a:	12 f4       	brpl	.+4      	; 0x4090 <__mulhisi3+0xc>
    408c:	8a 1b       	sub	r24, r26
    408e:	9b 0b       	sbc	r25, r27
    4090:	0c 94 5b 20 	jmp	0x40b6	; 0x40b6 <__usmulhisi3_tail>

00004094 <__umulhisi3>:
    4094:	a2 9f       	mul	r26, r18
    4096:	b0 01       	movw	r22, r0
    4098:	b3 9f       	mul	r27, r19
    409a:	c0 01       	movw	r24, r0
    409c:	a3 9f       	mul	r26, r19
    409e:	70 0d       	add	r23, r0
    40a0:	81 1d       	adc	r24, r1
    40a2:	11 24       	eor	r1, r1
    40a4:	91 1d       	adc	r25, r1
    40a6:	b2 9f       	mul	r27, r18
    40a8:	70 0d       	add	r23, r0
    40aa:	81 1d       	adc	r24, r1
    40ac:	11 24       	eor	r1, r1
    40ae:	91 1d       	adc	r25, r1
    40b0:	08 95       	ret

000040b2 <__usmulhisi3>:
    40b2:	0e 94 4a 20 	call	0x4094	; 0x4094 <__umulhisi3>

000040b6 <__usmulhisi3_tail>:
    40b6:	b7 ff       	sbrs	r27, 7
    40b8:	08 95       	ret
    40ba:	82 1b       	sub	r24, r18
    40bc:	93 0b       	sbc	r25, r19
    40be:	08 95       	ret

000040c0 <__muluhisi3>:
    40c0:	0e 94 4a 20 	call	0x4094	; 0x4094 <__umulhisi3>
    40c4:	a5 9f       	mul	r26, r21
    40c6:	90 0d       	add	r25, r0
    40c8:	b4 9f       	mul	r27, r20
    40ca:	90 0d       	add	r25, r0
    40cc:	a4 9f       	mul	r26, r20
    40ce:	80 0d       	add	r24, r0
    40d0:	91 1d       	adc	r25, r1
    40d2:	11 24       	eor	r1, r1
    40d4:	08 95       	ret

000040d6 <__mulshisi3>:
    40d6:	b7 ff       	sbrs	r27, 7
    40d8:	0c 94 60 20 	jmp	0x40c0	; 0x40c0 <__muluhisi3>

000040dc <__mulohisi3>:
    40dc:	0e 94 60 20 	call	0x40c0	; 0x40c0 <__muluhisi3>
    40e0:	82 1b       	sub	r24, r18
    40e2:	93 0b       	sbc	r25, r19
    40e4:	08 95       	ret

000040e6 <__udivmodhi4>:
    40e6:	aa 1b       	sub	r26, r26
    40e8:	bb 1b       	sub	r27, r27
    40ea:	51 e1       	ldi	r21, 0x11	; 17
    40ec:	07 c0       	rjmp	.+14     	; 0x40fc <__udivmodhi4_ep>

000040ee <__udivmodhi4_loop>:
    40ee:	aa 1f       	adc	r26, r26
    40f0:	bb 1f       	adc	r27, r27
    40f2:	a6 17       	cp	r26, r22
    40f4:	b7 07       	cpc	r27, r23
    40f6:	10 f0       	brcs	.+4      	; 0x40fc <__udivmodhi4_ep>
    40f8:	a6 1b       	sub	r26, r22
    40fa:	b7 0b       	sbc	r27, r23

000040fc <__udivmodhi4_ep>:
    40fc:	88 1f       	adc	r24, r24
    40fe:	99 1f       	adc	r25, r25
    4100:	5a 95       	dec	r21
    4102:	a9 f7       	brne	.-22     	; 0x40ee <__udivmodhi4_loop>
    4104:	80 95       	com	r24
    4106:	90 95       	com	r25
    4108:	bc 01       	movw	r22, r24
    410a:	cd 01       	movw	r24, r26
    410c:	08 95       	ret

0000410e <memcpy>:
    410e:	fb 01       	movw	r30, r22
    4110:	dc 01       	movw	r26, r24
    4112:	02 c0       	rjmp	.+4      	; 0x4118 <memcpy+0xa>
    4114:	01 90       	ld	r0, Z+
    4116:	0d 92       	st	X+, r0
    4118:	41 50       	subi	r20, 0x01	; 1
    411a:	50 40       	sbci	r21, 0x00	; 0
    411c:	d8 f7       	brcc	.-10     	; 0x4114 <memcpy+0x6>
    411e:	08 95       	ret

00004120 <memset>:
    4120:	dc 01       	movw	r26, r24
    4122:	01 c0       	rjmp	.+2      	; 0x4126 <memset+0x6>
    4124:	6d 93       	st	X+, r22
    4126:	41 50       	subi	r20, 0x01	; 1
    4128:	50 40       	sbci	r21, 0x00	; 0
    412a:	e0 f7       	brcc	.-8      	; 0x4124 <memset+0x4>
    412c:	08 95       	ret

0000412e <strncpy>:
    412e:	fb 01       	movw	r30, r22
    4130:	dc 01       	movw	r26, r24
    4132:	41 50       	subi	r20, 0x01	; 1
    4134:	50 40       	sbci	r21, 0x00	; 0
    4136:	48 f0       	brcs	.+18     	; 0x414a <strncpy+0x1c>
    4138:	01 90       	ld	r0, Z+
    413a:	0d 92       	st	X+, r0
    413c:	00 20       	and	r0, r0
    413e:	c9 f7       	brne	.-14     	; 0x4132 <strncpy+0x4>
    4140:	01 c0       	rjmp	.+2      	; 0x4144 <strncpy+0x16>
    4142:	1d 92       	st	X+, r1
    4144:	41 50       	subi	r20, 0x01	; 1
    4146:	50 40       	sbci	r21, 0x00	; 0
    4148:	e0 f7       	brcc	.-8      	; 0x4142 <strncpy+0x14>
    414a:	08 95       	ret

0000414c <__itoa_ncheck>:
    414c:	bb 27       	eor	r27, r27
    414e:	4a 30       	cpi	r20, 0x0A	; 10
    4150:	31 f4       	brne	.+12     	; 0x415e <__itoa_ncheck+0x12>
    4152:	99 23       	and	r25, r25
    4154:	22 f4       	brpl	.+8      	; 0x415e <__itoa_ncheck+0x12>
    4156:	bd e2       	ldi	r27, 0x2D	; 45
    4158:	90 95       	com	r25
    415a:	81 95       	neg	r24
    415c:	9f 4f       	sbci	r25, 0xFF	; 255
    415e:	0c 94 ea 20 	jmp	0x41d4	; 0x41d4 <__utoa_common>

00004162 <ultoa>:
    4162:	25 32       	cpi	r18, 0x25	; 37
    4164:	31 05       	cpc	r19, r1
    4166:	20 f4       	brcc	.+8      	; 0x4170 <ultoa+0xe>
    4168:	22 30       	cpi	r18, 0x02	; 2
    416a:	10 f0       	brcs	.+4      	; 0x4170 <ultoa+0xe>
    416c:	0c 94 bc 20 	jmp	0x4178	; 0x4178 <__ultoa_ncheck>
    4170:	fa 01       	movw	r30, r20
    4172:	10 82       	st	Z, r1
    4174:	ca 01       	movw	r24, r20
    4176:	08 95       	ret

00004178 <__ultoa_ncheck>:
    4178:	bb 27       	eor	r27, r27

0000417a <__ultoa_common>:
    417a:	fa 01       	movw	r30, r20
    417c:	a6 2f       	mov	r26, r22
    417e:	62 17       	cp	r22, r18
    4180:	71 05       	cpc	r23, r1
    4182:	81 05       	cpc	r24, r1
    4184:	91 05       	cpc	r25, r1
    4186:	33 0b       	sbc	r19, r19
    4188:	30 fb       	bst	r19, 0
    418a:	66 f0       	brts	.+24     	; 0x41a4 <__ultoa_common+0x2a>
    418c:	aa 27       	eor	r26, r26
    418e:	66 0f       	add	r22, r22
    4190:	77 1f       	adc	r23, r23
    4192:	88 1f       	adc	r24, r24
    4194:	99 1f       	adc	r25, r25
    4196:	aa 1f       	adc	r26, r26
    4198:	a2 17       	cp	r26, r18
    419a:	10 f0       	brcs	.+4      	; 0x41a0 <__ultoa_common+0x26>
    419c:	a2 1b       	sub	r26, r18
    419e:	63 95       	inc	r22
    41a0:	38 50       	subi	r19, 0x08	; 8
    41a2:	a9 f7       	brne	.-22     	; 0x418e <__ultoa_common+0x14>
    41a4:	a0 5d       	subi	r26, 0xD0	; 208
    41a6:	aa 33       	cpi	r26, 0x3A	; 58
    41a8:	08 f0       	brcs	.+2      	; 0x41ac <__ultoa_common+0x32>
    41aa:	a9 5d       	subi	r26, 0xD9	; 217
    41ac:	a1 93       	st	Z+, r26
    41ae:	36 f7       	brtc	.-52     	; 0x417c <__ultoa_common+0x2>
    41b0:	b1 11       	cpse	r27, r1
    41b2:	b1 93       	st	Z+, r27
    41b4:	10 82       	st	Z, r1
    41b6:	ca 01       	movw	r24, r20
    41b8:	0c 94 03 21 	jmp	0x4206	; 0x4206 <strrev>

000041bc <utoa>:
    41bc:	45 32       	cpi	r20, 0x25	; 37
    41be:	51 05       	cpc	r21, r1
    41c0:	20 f4       	brcc	.+8      	; 0x41ca <utoa+0xe>
    41c2:	42 30       	cpi	r20, 0x02	; 2
    41c4:	10 f0       	brcs	.+4      	; 0x41ca <utoa+0xe>
    41c6:	0c 94 e9 20 	jmp	0x41d2	; 0x41d2 <__utoa_ncheck>
    41ca:	fb 01       	movw	r30, r22
    41cc:	10 82       	st	Z, r1
    41ce:	cb 01       	movw	r24, r22
    41d0:	08 95       	ret

000041d2 <__utoa_ncheck>:
    41d2:	bb 27       	eor	r27, r27

000041d4 <__utoa_common>:
    41d4:	fb 01       	movw	r30, r22
    41d6:	55 27       	eor	r21, r21
    41d8:	aa 27       	eor	r26, r26
    41da:	88 0f       	add	r24, r24
    41dc:	99 1f       	adc	r25, r25
    41de:	aa 1f       	adc	r26, r26
    41e0:	a4 17       	cp	r26, r20
    41e2:	10 f0       	brcs	.+4      	; 0x41e8 <__utoa_common+0x14>
    41e4:	a4 1b       	sub	r26, r20
    41e6:	83 95       	inc	r24
    41e8:	50 51       	subi	r21, 0x10	; 16
    41ea:	b9 f7       	brne	.-18     	; 0x41da <__utoa_common+0x6>
    41ec:	a0 5d       	subi	r26, 0xD0	; 208
    41ee:	aa 33       	cpi	r26, 0x3A	; 58
    41f0:	08 f0       	brcs	.+2      	; 0x41f4 <__utoa_common+0x20>
    41f2:	a9 5d       	subi	r26, 0xD9	; 217
    41f4:	a1 93       	st	Z+, r26
    41f6:	00 97       	sbiw	r24, 0x00	; 0
    41f8:	79 f7       	brne	.-34     	; 0x41d8 <__utoa_common+0x4>
    41fa:	b1 11       	cpse	r27, r1
    41fc:	b1 93       	st	Z+, r27
    41fe:	11 92       	st	Z+, r1
    4200:	cb 01       	movw	r24, r22
    4202:	0c 94 03 21 	jmp	0x4206	; 0x4206 <strrev>

00004206 <strrev>:
    4206:	dc 01       	movw	r26, r24
    4208:	fc 01       	movw	r30, r24
    420a:	67 2f       	mov	r22, r23
    420c:	71 91       	ld	r23, Z+
    420e:	77 23       	and	r23, r23
    4210:	e1 f7       	brne	.-8      	; 0x420a <strrev+0x4>
    4212:	32 97       	sbiw	r30, 0x02	; 2
    4214:	04 c0       	rjmp	.+8      	; 0x421e <strrev+0x18>
    4216:	7c 91       	ld	r23, X
    4218:	6d 93       	st	X+, r22
    421a:	70 83       	st	Z, r23
    421c:	62 91       	ld	r22, -Z
    421e:	ae 17       	cp	r26, r30
    4220:	bf 07       	cpc	r27, r31
    4222:	c8 f3       	brcs	.-14     	; 0x4216 <strrev+0x10>
    4224:	08 95       	ret

00004226 <_exit>:
    4226:	f8 94       	cli

00004228 <__stop_program>:
    4228:	ff cf       	rjmp	.-2      	; 0x4228 <__stop_program>
