
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000457a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000b0  00802000  0000457a  0000460e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010aa  008020b0  008020b0  000046be  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000046be  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000046f0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006a0  00000000  00000000  00004730  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000123e8  00000000  00000000  00004dd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000062f5  00000000  00000000  000171b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005483  00000000  00000000  0001d4ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001244  00000000  00000000  00022930  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006188  00000000  00000000  00023b74  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005e09  00000000  00000000  00029cfc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000568  00000000  00000000  0002fb05  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 95 03 	jmp	0x72a	; 0x72a <__ctors_end>
       4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
       c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      10:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      14:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      18:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      1c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      20:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      24:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      28:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      2c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      30:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      34:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      38:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      3c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      40:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      44:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      48:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      4c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      50:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      54:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      58:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      5c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      60:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      64:	0c 94 91 1e 	jmp	0x3d22	; 0x3d22 <__vector_25>
      68:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      6c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      70:	0c 94 ef 1e 	jmp	0x3dde	; 0x3dde <__vector_28>
      74:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      78:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      7c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      80:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      84:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      88:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      8c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      90:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      94:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      98:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      9c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      c4:	0c 94 ab 0e 	jmp	0x1d56	; 0x1d56 <__vector_49>
      c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      e8:	0c 94 09 20 	jmp	0x4012	; 0x4012 <__vector_58>
      ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
      fc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     100:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     104:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     108:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     10c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     110:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     114:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     118:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     11c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     120:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     124:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     128:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     12c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     130:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     134:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     138:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     13c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     140:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     144:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     148:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     14c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     150:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     154:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     158:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     15c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     160:	0c 94 4d 1f 	jmp	0x3e9a	; 0x3e9a <__vector_88>
     164:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     168:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     16c:	0c 94 ab 1f 	jmp	0x3f56	; 0x3f56 <__vector_91>
     170:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     174:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     178:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     17c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     180:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     184:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     188:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     18c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     190:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     194:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     198:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     19c:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1a8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ac:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1b8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1bc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1c8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1cc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1d8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1dc:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1e8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1ec:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f0:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f4:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1f8:	0c 94 cb 03 	jmp	0x796	; 0x796 <__bad_interrupt>
     1fc:	f2 0a       	sbc	r15, r18
     1fe:	6a 0b       	sbc	r22, r26
     200:	6a 0b       	sbc	r22, r26
     202:	6a 0b       	sbc	r22, r26
     204:	6a 0b       	sbc	r22, r26
     206:	6a 0b       	sbc	r22, r26
     208:	6a 0b       	sbc	r22, r26
     20a:	6a 0b       	sbc	r22, r26
     20c:	6a 0b       	sbc	r22, r26
     20e:	6a 0b       	sbc	r22, r26
     210:	6a 0b       	sbc	r22, r26
     212:	6a 0b       	sbc	r22, r26
     214:	6a 0b       	sbc	r22, r26
     216:	6a 0b       	sbc	r22, r26
     218:	6a 0b       	sbc	r22, r26
     21a:	6a 0b       	sbc	r22, r26
     21c:	6a 0b       	sbc	r22, r26
     21e:	6a 0b       	sbc	r22, r26
     220:	6a 0b       	sbc	r22, r26
     222:	6a 0b       	sbc	r22, r26
     224:	6a 0b       	sbc	r22, r26
     226:	6a 0b       	sbc	r22, r26
     228:	6a 0b       	sbc	r22, r26
     22a:	6a 0b       	sbc	r22, r26
     22c:	6a 0b       	sbc	r22, r26
     22e:	6a 0b       	sbc	r22, r26
     230:	6a 0b       	sbc	r22, r26
     232:	6a 0b       	sbc	r22, r26
     234:	6a 0b       	sbc	r22, r26
     236:	6a 0b       	sbc	r22, r26
     238:	6a 0b       	sbc	r22, r26
     23a:	6a 0b       	sbc	r22, r26
     23c:	6a 0b       	sbc	r22, r26
     23e:	6a 0b       	sbc	r22, r26
     240:	6a 0b       	sbc	r22, r26
     242:	6a 0b       	sbc	r22, r26
     244:	6a 0b       	sbc	r22, r26
     246:	6a 0b       	sbc	r22, r26
     248:	6a 0b       	sbc	r22, r26
     24a:	6a 0b       	sbc	r22, r26
     24c:	6a 0b       	sbc	r22, r26
     24e:	6a 0b       	sbc	r22, r26
     250:	6a 0b       	sbc	r22, r26
     252:	6a 0b       	sbc	r22, r26
     254:	6a 0b       	sbc	r22, r26
     256:	6a 0b       	sbc	r22, r26
     258:	6a 0b       	sbc	r22, r26
     25a:	6a 0b       	sbc	r22, r26
     25c:	6a 0b       	sbc	r22, r26
     25e:	6a 0b       	sbc	r22, r26
     260:	6a 0b       	sbc	r22, r26
     262:	6a 0b       	sbc	r22, r26
     264:	6a 0b       	sbc	r22, r26
     266:	6a 0b       	sbc	r22, r26
     268:	6a 0b       	sbc	r22, r26
     26a:	6a 0b       	sbc	r22, r26
     26c:	6a 0b       	sbc	r22, r26
     26e:	6a 0b       	sbc	r22, r26
     270:	6a 0b       	sbc	r22, r26
     272:	6a 0b       	sbc	r22, r26
     274:	6a 0b       	sbc	r22, r26
     276:	6a 0b       	sbc	r22, r26
     278:	6a 0b       	sbc	r22, r26
     27a:	6a 0b       	sbc	r22, r26
     27c:	6a 0b       	sbc	r22, r26
     27e:	6a 0b       	sbc	r22, r26
     280:	6a 0b       	sbc	r22, r26
     282:	6a 0b       	sbc	r22, r26
     284:	6a 0b       	sbc	r22, r26
     286:	6a 0b       	sbc	r22, r26
     288:	6a 0b       	sbc	r22, r26
     28a:	06 0b       	sbc	r16, r22
     28c:	6a 0b       	sbc	r22, r26
     28e:	38 0b       	sbc	r19, r24
     290:	f2 0a       	sbc	r15, r18
     292:	6a 0b       	sbc	r22, r26
     294:	20 0b       	sbc	r18, r16
     296:	ee 0a       	sbc	r14, r30
     298:	6a 0b       	sbc	r22, r26
     29a:	6a 0b       	sbc	r22, r26
     29c:	6a 0b       	sbc	r22, r26
     29e:	6a 0b       	sbc	r22, r26
     2a0:	6a 0b       	sbc	r22, r26
     2a2:	d4 0a       	sbc	r13, r20
     2a4:	6a 0b       	sbc	r22, r26
     2a6:	6a 0b       	sbc	r22, r26
     2a8:	6a 0b       	sbc	r22, r26
     2aa:	52 0b       	sbc	r21, r18
     2ac:	e6 0a       	sbc	r14, r22
     2ae:	6a 0b       	sbc	r22, r26
     2b0:	6a 0b       	sbc	r22, r26
     2b2:	e2 0a       	sbc	r14, r18
     2b4:	7d 1c       	adc	r7, r13
     2b6:	80 1c       	adc	r8, r0
     2b8:	83 1c       	adc	r8, r3
     2ba:	86 1c       	adc	r8, r6
     2bc:	89 1c       	adc	r8, r9
     2be:	8c 1c       	adc	r8, r12
     2c0:	8e 1c       	adc	r8, r14
     2c2:	9f 1c       	adc	r9, r15
     2c4:	a7 1c       	adc	r10, r7
     2c6:	b1 1c       	adc	r11, r1
     2c8:	af 1c       	adc	r10, r15

000002ca <__trampolines_start>:
     2ca:	0c 94 27 1c 	jmp	0x384e	; 0x384e <_ZN8emstream12transmit_nowEv>
     2ce:	0c 94 e6 0a 	jmp	0x15cc	; 0x15cc <_ZN9task_user3runEv+0x170>
     2d2:	0c 94 2e 0a 	jmp	0x145c	; 0x145c <_ZN9task_user3runEv>
     2d6:	0c 94 92 03 	jmp	0x724	; 0x724 <_call_static_run_method>
     2da:	0c 94 20 0b 	jmp	0x1640	; 0x1640 <_ZN9task_user3runEv+0x1e4>
     2de:	0c 94 25 1c 	jmp	0x384a	; 0x384a <_ZN8emstream14check_for_charEv>
     2e2:	0c 94 e2 0a 	jmp	0x15c4	; 0x15c4 <_ZN9task_user3runEv+0x168>
     2e6:	0c 94 20 1c 	jmp	0x3840	; 0x3840 <_ZN8emstream13ready_to_sendEv>
     2ea:	0c 94 8c 1c 	jmp	0x3918	; 0x3918 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2ee:	0c 94 6a 0b 	jmp	0x16d4	; 0x16d4 <_ZN9task_user3runEv+0x278>
     2f2:	0c 94 86 1c 	jmp	0x390c	; 0x390c <_ZN8emstreamlsE15ser_manipulator+0x30>
     2f6:	0c 94 8e 1c 	jmp	0x391c	; 0x391c <_ZN8emstreamlsE15ser_manipulator+0x40>
     2fa:	0c 94 19 05 	jmp	0xa32	; 0xa32 <_ZN5Motor3runEv>
     2fe:	0c 94 0b 21 	jmp	0x4216	; 0x4216 <_GLOBAL__sub_I_counter>
     302:	0c 94 b4 04 	jmp	0x968	; 0x968 <_ZN13LimitSwitches3runEv>
     306:	0c 94 d1 19 	jmp	0x33a2	; 0x33a2 <_ZN14frt_text_queue7putcharEc>
     30a:	0c 94 2f 11 	jmp	0x225e	; 0x225e <prvIdleTask>
     30e:	0c 94 52 0b 	jmp	0x16a4	; 0x16a4 <_ZN9task_user3runEv+0x248>
     312:	0c 94 89 1b 	jmp	0x3712	; 0x3712 <__cxa_pure_virtual>
     316:	0c 94 89 1c 	jmp	0x3912	; 0x3912 <_ZN8emstreamlsE15ser_manipulator+0x36>
     31a:	0c 94 b1 1c 	jmp	0x3962	; 0x3962 <_ZN8emstreamlsE15ser_manipulator+0x86>
     31e:	0c 94 cf 1d 	jmp	0x3b9e	; 0x3b9e <_ZN5rs2327getcharEv>
     322:	0c 94 5b 04 	jmp	0x8b6	; 0x8b6 <_ZN15EncoderPendulum3runEv>
     326:	0c 94 06 0b 	jmp	0x160c	; 0x160c <_ZN9task_user3runEv+0x1b0>
     32a:	0c 94 7d 1c 	jmp	0x38fa	; 0x38fa <_ZN8emstreamlsE15ser_manipulator+0x1e>
     32e:	0c 94 5e 18 	jmp	0x30bc	; 0x30bc <_ZN8frt_task12print_statusER8emstream>
     332:	0c 94 af 1c 	jmp	0x395e	; 0x395e <_ZN8emstreamlsE15ser_manipulator+0x82>
     336:	0c 94 08 1e 	jmp	0x3c10	; 0x3c10 <_ZN5rs23212clear_screenEv>
     33a:	0c 94 a8 19 	jmp	0x3350	; 0x3350 <_ZN14frt_text_queue7getcharEv>
     33e:	0c 94 a7 1c 	jmp	0x394e	; 0x394e <_ZN8emstreamlsE15ser_manipulator+0x72>
     342:	0c 94 c6 19 	jmp	0x338c	; 0x338c <_ZN14frt_text_queue14check_for_charEv>
     346:	0c 94 d4 0a 	jmp	0x15a8	; 0x15a8 <_ZN9task_user3runEv+0x14c>
     34a:	0c 94 cd 03 	jmp	0x79a	; 0x79a <_ZN12EncoderMotor3runEv>
     34e:	0c 94 f5 1d 	jmp	0x3bea	; 0x3bea <_ZN5rs23214check_for_charEv>
     352:	0c 94 83 1c 	jmp	0x3906	; 0x3906 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     356:	0c 94 80 1c 	jmp	0x3900	; 0x3900 <_ZN8emstreamlsE15ser_manipulator+0x24>
     35a:	0c 94 22 1c 	jmp	0x3844	; 0x3844 <_ZN8emstream7getcharEv>
     35e:	0c 94 38 0b 	jmp	0x1670	; 0x1670 <_ZN9task_user3runEv+0x214>
     362:	0c 94 ee 0a 	jmp	0x15dc	; 0x15dc <_ZN9task_user3runEv+0x180>
     366:	0c 94 9f 1c 	jmp	0x393e	; 0x393e <_ZN8emstreamlsE15ser_manipulator+0x62>
     36a:	0c 94 f2 0a 	jmp	0x15e4	; 0x15e4 <_ZN9task_user3runEv+0x188>
     36e:	0c 94 ab 1d 	jmp	0x3b56	; 0x3b56 <_ZN5rs2327putcharEc>
     372:	0c 94 28 1c 	jmp	0x3850	; 0x3850 <_ZN8emstream12clear_screenEv>

00000376 <__trampolines_end>:
     376:	2c 20       	and	r2, r12
     378:	54 43       	sbci	r21, 0x34	; 52
     37a:	43 30       	cpi	r20, 0x03	; 3
     37c:	43 43       	sbci	r20, 0x33	; 51
     37e:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000381 <_ZZN9task_user11show_statusEvE3__c_3>:
     381:	2f 00                                               /.

00000383 <_ZZN9task_user11show_statusEvE3__c_2>:
     383:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

00000391 <_ZZN9task_user11show_statusEvE3__c_1>:
     391:	54 69 6d 65 3a 20 00                                Time: .

00000398 <_ZZN9task_user11show_statusEvE3__c_0>:
     398:	44 65 63 20 20 37 20 32 30 31 37 00                 Dec  7 2017.

000003a4 <_ZZN9task_user11show_statusEvE3__c>:
     3a4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3b4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003c3 <_ZZN9task_user18print_help_messageEvE3__c_14>:
     3c3:	20 20 20 20 72 3a 20 20 20 52 65 73 65 74 20 74         r:   Reset t
     3d3:	6f 20 49 64 6c 65 00                                o Idle.

000003da <_ZZN9task_user18print_help_messageEvE3__c_13>:
     3da:	20 20 20 20 64 3a 20 20 20 45 6d 65 72 67 65 6e         d:   Emergen
     3ea:	63 79 20 53 74 6f 70 00                             cy Stop.

000003f2 <_ZZN9task_user18print_help_messageEvE3__c_12>:
     3f2:	20 20 20 20 67 3a 20 20 20 53 77 69 6e 67 20 50         g:   Swing P
     402:	65 6e 64 75 6c 75 6d 20 55 70 72 69 67 68 74 2c     endulum Upright,
     412:	20 74 68 65 6e 20 47 6f 2e 00                        then Go..

0000041c <_ZZN9task_user18print_help_messageEvE3__c_11>:
     41c:	20 20 20 20 62 3a 20 20 20 42 65 67 69 6e 20 43         b:   Begin C
     42c:	61 6c 69 62 72 61 74 69 6f 6e 20 6f 66 20 49 6e     alibration of In
     43c:	76 65 72 74 65 64 20 50 65 6e 64 75 6c 75 6d 3f     verted Pendulum?
	...

0000044d <_ZZN9task_user18print_help_messageEvE3__c_10>:
     44d:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000045c <_ZZN9task_user18print_help_messageEvE3__c_9>:
     45c:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     46c:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000477 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     477:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     487:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000495 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     495:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     4a5:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     4b5:	6d 61 74 69 6f 6e 00                                mation.

000004bc <_ZZN9task_user18print_help_messageEvE3__c_6>:
     4bc:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     4cc:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000004dd <_ZZN9task_user18print_help_messageEvE3__c_5>:
     4dd:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4ed:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004f5 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4f5:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     505:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000511 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     511:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     521:	68 65 20 41 56 52 00                                he AVR.

00000528 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     528:	20 68 65 6c 70 00                                    help.

0000052e <_ZZN9task_user18print_help_messageEvE3__c_1>:
     52e:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     53e:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000054d <_ZZN9task_user18print_help_messageEvE3__c_0>:
     54d:	1b 5b 33 30 6d 00                                   .[30m.

00000553 <_ZZN9task_user18print_help_messageEvE3__c>:
     553:	1b 5b 34 36 6d 00                                   .[46m.

00000559 <_ZZN9task_user3runEvE3__c_7>:
     559:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     569:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000576 <_ZZN9task_user3runEvE3__c_6>:
     576:	3a 57 54 46 3f 00                                   :WTF?.

0000057c <_ZZN9task_user3runEvE3__c_5>:
     57c:	52 65 73 65 74 2c 20 74 72 79 20 48 6f 6d 69 6e     Reset, try Homin
     58c:	67 20 61 67 61 69 6e 20 62 79 20 70 72 65 73 73     g again by press
     59c:	69 6e 67 20 27 62 27 00                             ing 'b'.

000005a4 <_ZZN9task_user3runEvE3__c_4>:
     5a4:	45 4d 45 52 47 45 4e 43 59 20 53 54 4f 50 00        EMERGENCY STOP.

000005b3 <_ZZN9task_user3runEvE3__c_3>:
     5b3:	43 6f 6d 6d 65 6e 63 65 20 42 61 6c 61 6e 63 65     Commence Balance
	...

000005c4 <_ZZN9task_user3runEvE3__c_2>:
     5c4:	42 65 67 69 6e 20 48 6f 6d 69 6e 67 00              Begin Homing.

000005d1 <_ZZN9task_user3runEvE3__c_1>:
     5d1:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     5e1:	65 00                                               e.

000005e3 <_ZZN9task_user3runEvE3__c_0>:
     5e3:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000005f1 <_ZZN9task_user3runEvE3__c>:
     5f1:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 74 6f 20     Press Ctrl-A to 
     601:	67 65 74 20 74 6f 20 63 6f 6d 6d 61 6e 64 20 6d     get to command m
     611:	6f 64 65 20 66 6f 72 20 49 6e 76 65 72 74 65 64     ode for Inverted
     621:	20 50 65 6e 64 75 6c 75 6d 00                        Pendulum.

0000062b <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     62b:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000635 <_ZZN8frt_task15emergency_resetEvE3__c>:
     635:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000644 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     644:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     654:	61 73 6b 20 00                                      ask .

00000659 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     659:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000667 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     667:	20 63 72 65 61 74 65 64 00                           created.

00000670 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     670:	54 61 73 6b 20 00                                   Task .

00000676 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     676:	1b 5b 32 32 6d 00                                   .[22m.

0000067c <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     67c:	54 61 73 6b 3a 20 00                                Task: .

00000683 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     683:	1b 5b 31 6d 00                                      .[1m.

00000688 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     688:	1b 5b 32 32 6d 00                                   .[22m.

0000068e <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     68e:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

00000699 <_ZZ17print_task_stacksP8emstreamE3__c>:
     699:	1b 5b 31 6d 00                                      .[1m.

0000069e <_ZZ15print_task_listP8emstreamE3__c_9>:
     69e:	09 09 00                                            ...

000006a1 <_ZZ15print_task_listP8emstreamE3__c_8>:
     6a1:	2f 00                                               /.

000006a3 <_ZZ15print_task_listP8emstreamE3__c_7>:
     6a3:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000006ae <_ZZ15print_task_listP8emstreamE3__c_6>:
     6ae:	09 2d 2d 2d 2d 00                                   .----.

000006b4 <_ZZ15print_task_listP8emstreamE3__c_5>:
     6b4:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000006c0 <_ZZ15print_task_listP8emstreamE3__c_4>:
     6c0:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000006d1 <_ZZ15print_task_listP8emstreamE3__c_3>:
     6d1:	09 52 75 6e 73 00                                   .Runs.

000006d7 <_ZZ15print_task_listP8emstreamE3__c_2>:
     6d7:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000006e3 <_ZZ15print_task_listP8emstreamE3__c_1>:
     6e3:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000006f4 <_ZZ15print_task_listP8emstreamE3__c_0>:
     6f4:	09 53 74 61 63 6b 00                                .Stack.

000006fb <_ZZ15print_task_listP8emstreamE3__c>:
     6fb:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000706 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     706:	09 00                                               ..

00000708 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     708:	09 00                                               ..

0000070a <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     70a:	2f 00                                               /.

0000070c <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     70c:	09 00                                               ..

0000070e <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     70e:	09 00                                               ..

00000710 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     710:	1b 5b 32 32 6d 00                                   .[22m.

00000716 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     716:	1b 5b 31 6d 00                                      .[1m.

0000071b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     71b:	1b 5b 31 6d 00                                      .[1m.

00000720 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     720:	20 20 00 00                                           ..

00000724 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     724:	0e 94 f6 16 	call	0x2dec	; 0x2dec <_ZN8frt_task22_call_users_run_methodEPS_>

00000728 <__ctors_start>:
     728:	0b 21       	and	r16, r11

0000072a <__ctors_end>:
     72a:	11 24       	eor	r1, r1
     72c:	1f be       	out	0x3f, r1	; 63
     72e:	cf ef       	ldi	r28, 0xFF	; 255
     730:	cd bf       	out	0x3d, r28	; 61
     732:	df e3       	ldi	r29, 0x3F	; 63
     734:	de bf       	out	0x3e, r29	; 62
     736:	00 e0       	ldi	r16, 0x00	; 0
     738:	0c bf       	out	0x3c, r16	; 60
     73a:	18 be       	out	0x38, r1	; 56
     73c:	19 be       	out	0x39, r1	; 57
     73e:	1a be       	out	0x3a, r1	; 58
     740:	1b be       	out	0x3b, r1	; 59

00000742 <__do_copy_data>:
     742:	10 e2       	ldi	r17, 0x20	; 32
     744:	a0 e0       	ldi	r26, 0x00	; 0
     746:	b0 e2       	ldi	r27, 0x20	; 32
     748:	ea e7       	ldi	r30, 0x7A	; 122
     74a:	f5 e4       	ldi	r31, 0x45	; 69
     74c:	00 e0       	ldi	r16, 0x00	; 0
     74e:	0b bf       	out	0x3b, r16	; 59
     750:	02 c0       	rjmp	.+4      	; 0x756 <__do_copy_data+0x14>
     752:	07 90       	elpm	r0, Z+
     754:	0d 92       	st	X+, r0
     756:	a0 3b       	cpi	r26, 0xB0	; 176
     758:	b1 07       	cpc	r27, r17
     75a:	d9 f7       	brne	.-10     	; 0x752 <__do_copy_data+0x10>
     75c:	1b be       	out	0x3b, r1	; 59

0000075e <__do_clear_bss>:
     75e:	21 e3       	ldi	r18, 0x31	; 49
     760:	a0 eb       	ldi	r26, 0xB0	; 176
     762:	b0 e2       	ldi	r27, 0x20	; 32
     764:	01 c0       	rjmp	.+2      	; 0x768 <.do_clear_bss_start>

00000766 <.do_clear_bss_loop>:
     766:	1d 92       	st	X+, r1

00000768 <.do_clear_bss_start>:
     768:	aa 35       	cpi	r26, 0x5A	; 90
     76a:	b2 07       	cpc	r27, r18
     76c:	e1 f7       	brne	.-8      	; 0x766 <.do_clear_bss_loop>

0000076e <__do_global_ctors>:
     76e:	13 e0       	ldi	r17, 0x03	; 3
     770:	c5 e9       	ldi	r28, 0x95	; 149
     772:	d3 e0       	ldi	r29, 0x03	; 3
     774:	00 e0       	ldi	r16, 0x00	; 0
     776:	06 c0       	rjmp	.+12     	; 0x784 <__do_global_ctors+0x16>
     778:	21 97       	sbiw	r28, 0x01	; 1
     77a:	01 09       	sbc	r16, r1
     77c:	80 2f       	mov	r24, r16
     77e:	fe 01       	movw	r30, r28
     780:	0e 94 ec 21 	call	0x43d8	; 0x43d8 <__tablejump2__>
     784:	c4 39       	cpi	r28, 0x94	; 148
     786:	d1 07       	cpc	r29, r17
     788:	80 e0       	ldi	r24, 0x00	; 0
     78a:	08 07       	cpc	r16, r24
     78c:	a9 f7       	brne	.-22     	; 0x778 <__do_global_ctors+0xa>
     78e:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <main>
     792:	0c 94 bb 22 	jmp	0x4576	; 0x4576 <_exit>

00000796 <__bad_interrupt>:
     796:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000079a <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     79a:	cf 93       	push	r28
     79c:	df 93       	push	r29
     79e:	00 d0       	rcall	.+0      	; 0x7a0 <_ZN12EncoderMotor3runEv+0x6>
     7a0:	1f 92       	push	r1
     7a2:	cd b7       	in	r28, 0x3d	; 61
     7a4:	de b7       	in	r29, 0x3e	; 62
     7a6:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7a8:	0e 94 ce 12 	call	0x259c	; 0x259c <xTaskGetTickCount>
     7ac:	69 83       	std	Y+1, r22	; 0x01
     7ae:	7a 83       	std	Y+2, r23	; 0x02
     7b0:	8b 83       	std	Y+3, r24	; 0x03
     7b2:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     7b4:	e0 e8       	ldi	r30, 0x80	; 128
     7b6:	f6 e0       	ldi	r31, 0x06	; 6
     7b8:	8c e0       	ldi	r24, 0x0C	; 12
     7ba:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     7bc:	82 89       	ldd	r24, Z+18	; 0x12
     7be:	83 60       	ori	r24, 0x03	; 3
     7c0:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     7c2:	83 89       	ldd	r24, Z+19	; 0x13
     7c4:	83 60       	ori	r24, 0x03	; 3
     7c6:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     7c8:	e0 e8       	ldi	r30, 0x80	; 128
     7ca:	f1 e0       	ldi	r31, 0x01	; 1
     7cc:	82 e7       	ldi	r24, 0x72	; 114
     7ce:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     7d0:	89 e0       	ldi	r24, 0x09	; 9
     7d2:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     7d4:	e0 e0       	ldi	r30, 0x00	; 0
     7d6:	f9 e0       	ldi	r31, 0x09	; 9
     7d8:	88 e6       	ldi	r24, 0x68	; 104
     7da:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     7dc:	8f ef       	ldi	r24, 0xFF	; 255
     7de:	9f ef       	ldi	r25, 0xFF	; 255
     7e0:	86 a3       	std	Z+38, r24	; 0x26
     7e2:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     7e8:	0f 2e       	mov	r0, r31
     7ea:	a1 2c       	mov	r10, r1
     7ec:	f9 e0       	ldi	r31, 0x09	; 9
     7ee:	bf 2e       	mov	r11, r31
     7f0:	f0 2d       	mov	r31, r0
     7f2:	f5 01       	movw	r30, r10
     7f4:	00 a1       	ldd	r16, Z+32	; 0x20
     7f6:	11 a1       	ldd	r17, Z+33	; 0x21
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     7f8:	0f b6       	in	r0, 0x3f	; 63
     7fa:	f8 94       	cli
     7fc:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     7fe:	0f 90       	pop	r0
     800:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     802:	0f b6       	in	r0, 0x3f	; 63
     804:	f8 94       	cli
     806:	0f 92       	push	r0
			the_data = new_data;
     808:	c8 01       	movw	r24, r16
     80a:	01 2e       	mov	r0, r17
     80c:	00 0c       	add	r0, r0
     80e:	aa 0b       	sbc	r26, r26
     810:	bb 0b       	sbc	r27, r27
     812:	ac 01       	movw	r20, r24
     814:	bd 01       	movw	r22, r26
     816:	44 0f       	add	r20, r20
     818:	55 1f       	adc	r21, r21
     81a:	66 1f       	adc	r22, r22
     81c:	77 1f       	adc	r23, r23
     81e:	3a 01       	movw	r6, r20
     820:	4b 01       	movw	r8, r22
     822:	68 0e       	add	r6, r24
     824:	79 1e       	adc	r7, r25
     826:	8a 1e       	adc	r8, r26
     828:	9b 1e       	adc	r9, r27
     82a:	c4 01       	movw	r24, r8
     82c:	b3 01       	movw	r22, r6
     82e:	24 e6       	ldi	r18, 0x64	; 100
     830:	30 e0       	ldi	r19, 0x00	; 0
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	50 e0       	ldi	r21, 0x00	; 0
     836:	0e 94 cd 21 	call	0x439a	; 0x439a <__divmodsi4>
     83a:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <linear_offset>
     83e:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <linear_offset+0x1>
     842:	28 1b       	sub	r18, r24
     844:	39 0b       	sbc	r19, r25
     846:	20 93 46 31 	sts	0x3146, r18	; 0x803146 <linear_position>
     84a:	30 93 47 31 	sts	0x3147, r19	; 0x803147 <linear_position+0x1>
			portEXIT_CRITICAL ();
     84e:	0f 90       	pop	r0
     850:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	0f 92       	push	r0
			the_data = new_data;
     858:	c8 01       	movw	r24, r16
     85a:	8c 19       	sub	r24, r12
     85c:	9d 09       	sbc	r25, r13
     85e:	80 93 44 31 	sts	0x3144, r24	; 0x803144 <thdMotor>
     862:	90 93 45 31 	sts	0x3145, r25	; 0x803145 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     866:	0f 90       	pop	r0
     868:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     86a:	f7 01       	movw	r30, r14
     86c:	86 85       	ldd	r24, Z+14	; 0x0e
     86e:	97 85       	ldd	r25, Z+15	; 0x0f
     870:	a0 89       	ldd	r26, Z+16	; 0x10
     872:	b1 89       	ldd	r27, Z+17	; 0x11
     874:	01 96       	adiw	r24, 0x01	; 1
     876:	a1 1d       	adc	r26, r1
     878:	b1 1d       	adc	r27, r1
     87a:	86 87       	std	Z+14, r24	; 0x0e
     87c:	97 87       	std	Z+15, r25	; 0x0f
     87e:	a0 8b       	std	Z+16, r26	; 0x10
     880:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     882:	41 e0       	ldi	r20, 0x01	; 1
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	ce 01       	movw	r24, r28
     88c:	01 96       	adiw	r24, 0x01	; 1
     88e:	0e 94 6c 14 	call	0x28d8	; 0x28d8 <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     892:	68 01       	movw	r12, r16
     894:	ae cf       	rjmp	.-164    	; 0x7f2 <_ZN12EncoderMotor3runEv+0x58>

00000896 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     896:	0f 93       	push	r16
     898:	1f 93       	push	r17
     89a:	cf 93       	push	r28
     89c:	df 93       	push	r29
     89e:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8a0:	0e 94 09 17 	call	0x2e12	; 0x2e12 <_ZN8frt_taskC1EPKchjP8emstream>
     8a4:	8a e0       	ldi	r24, 0x0A	; 10
     8a6:	90 e2       	ldi	r25, 0x20	; 32
     8a8:	88 83       	st	Y, r24
     8aa:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	08 95       	ret

000008b6 <_ZN15EncoderPendulum3runEv>:
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void)
{
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	00 d0       	rcall	.+0      	; 0x8bc <_ZN15EncoderPendulum3runEv+0x6>
     8bc:	1f 92       	push	r1
     8be:	cd b7       	in	r28, 0x3d	; 61
     8c0:	de b7       	in	r29, 0x3e	; 62
     8c2:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8c4:	0e 94 ce 12 	call	0x259c	; 0x259c <xTaskGetTickCount>
     8c8:	69 83       	std	Y+1, r22	; 0x01
     8ca:	7a 83       	std	Y+2, r23	; 0x02
     8cc:	8b 83       	std	Y+3, r24	; 0x03
     8ce:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     8d0:	e0 e8       	ldi	r30, 0x80	; 128
     8d2:	f6 e0       	ldi	r31, 0x06	; 6
     8d4:	83 e0       	ldi	r24, 0x03	; 3
     8d6:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     8d8:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     8da:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     8dc:	e0 e8       	ldi	r30, 0x80	; 128
     8de:	f1 e0       	ldi	r31, 0x01	; 1
     8e0:	80 e7       	ldi	r24, 0x70	; 112
     8e2:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     8e4:	89 e0       	ldi	r24, 0x09	; 9
     8e6:	82 87       	std	Z+10, r24	; 0x0a
	
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     8e8:	e0 e4       	ldi	r30, 0x40	; 64
     8ea:	f8 e0       	ldi	r31, 0x08	; 8
     8ec:	8a e6       	ldi	r24, 0x6A	; 106
     8ee:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     8f0:	80 ea       	ldi	r24, 0xA0	; 160
     8f2:	95 e0       	ldi	r25, 0x05	; 5
     8f4:	86 a3       	std	Z+38, r24	; 0x26
     8f6:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     8f8:	81 e0       	ldi	r24, 0x01	; 1
     8fa:	80 83       	st	Z, r24
	
	int16_t count; // contains the current encoder value
	
	while(1)
	{
		count = TCC1.CNT; // read value from hardware counter
     8fc:	68 94       	set
     8fe:	ee 24       	eor	r14, r14
     900:	e6 f8       	bld	r14, 6
     902:	ff 24       	eor	r15, r15
     904:	f3 f8       	bld	r15, 3
     906:	f7 01       	movw	r30, r14
     908:	80 a1       	ldd	r24, Z+32	; 0x20
     90a:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	0f 92       	push	r0
			the_data = new_data;
     912:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <thPendulum>
     916:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <thPendulum+0x1>
			portEXIT_CRITICAL ();
     91a:	0f 90       	pop	r0
     91c:	0f be       	out	0x3f, r0	; 63
		//theta_pendulum = ( (int32_t) count*100/4);			// count/(4*360)*360 degrees * 100
		
		thPendulum.put(count); // push angular position [ticks] to pendulum controller task
		
		// Increment counter for debugging
		runs++;
     91e:	f8 01       	movw	r30, r16
     920:	86 85       	ldd	r24, Z+14	; 0x0e
     922:	97 85       	ldd	r25, Z+15	; 0x0f
     924:	a0 89       	ldd	r26, Z+16	; 0x10
     926:	b1 89       	ldd	r27, Z+17	; 0x11
     928:	01 96       	adiw	r24, 0x01	; 1
     92a:	a1 1d       	adc	r26, r1
     92c:	b1 1d       	adc	r27, r1
     92e:	86 87       	std	Z+14, r24	; 0x0e
     930:	97 87       	std	Z+15, r25	; 0x0f
     932:	a0 8b       	std	Z+16, r26	; 0x10
     934:	b1 8b       	std	Z+17, r27	; 0x11
     936:	41 e0       	ldi	r20, 0x01	; 1
     938:	50 e0       	ldi	r21, 0x00	; 0
     93a:	60 e0       	ldi	r22, 0x00	; 0
     93c:	70 e0       	ldi	r23, 0x00	; 0
     93e:	ce 01       	movw	r24, r28
     940:	01 96       	adiw	r24, 0x01	; 1
     942:	0e 94 6c 14 	call	0x28d8	; 0x28d8 <vTaskDelayUntil>
     946:	df cf       	rjmp	.-66     	; 0x906 <_ZN15EncoderPendulum3runEv+0x50>

00000948 <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     948:	0f 93       	push	r16
     94a:	1f 93       	push	r17
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     952:	0e 94 09 17 	call	0x2e12	; 0x2e12 <_ZN8frt_taskC1EPKchjP8emstream>
     956:	82 e1       	ldi	r24, 0x12	; 18
     958:	90 e2       	ldi	r25, 0x20	; 32
     95a:	88 83       	st	Y, r24
     95c:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	1f 91       	pop	r17
     964:	0f 91       	pop	r16
     966:	08 95       	ret

00000968 <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	00 d0       	rcall	.+0      	; 0x96e <_ZN13LimitSwitches3runEv+0x6>
     96e:	1f 92       	push	r1
     970:	cd b7       	in	r28, 0x3d	; 61
     972:	de b7       	in	r29, 0x3e	; 62
     974:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     976:	0e 94 ce 12 	call	0x259c	; 0x259c <xTaskGetTickCount>
     97a:	69 83       	std	Y+1, r22	; 0x01
     97c:	7a 83       	std	Y+2, r23	; 0x02
     97e:	8b 83       	std	Y+3, r24	; 0x03
     980:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     982:	e0 e6       	ldi	r30, 0x60	; 96
     984:	f6 e0       	ldi	r31, 0x06	; 6
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     98a:	84 e0       	ldi	r24, 0x04	; 4
     98c:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     98e:	88 e1       	ldi	r24, 0x18	; 24
     990:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     992:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     994:	08 e6       	ldi	r16, 0x68	; 104
     996:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     998:	dd 24       	eor	r13, r13
     99a:	d3 94       	inc	r13
     99c:	f8 01       	movw	r30, r16
     99e:	80 81       	ld	r24, Z
     9a0:	80 fd       	sbrc	r24, 0
     9a2:	08 c0       	rjmp	.+16     	; 0x9b4 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9a4:	0f b6       	in	r0, 0x3f	; 63
     9a6:	f8 94       	cli
     9a8:	0f 92       	push	r0
			the_data = new_data;
     9aa:	d0 92 41 31 	sts	0x3141, r13	; 0x803141 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9ae:	0f 90       	pop	r0
     9b0:	0f be       	out	0x3f, r0	; 63
     9b2:	07 c0       	rjmp	.+14     	; 0x9c2 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9b4:	0f b6       	in	r0, 0x3f	; 63
     9b6:	f8 94       	cli
     9b8:	0f 92       	push	r0
			the_data = new_data;
     9ba:	10 92 41 31 	sts	0x3141, r1	; 0x803141 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     9be:	0f 90       	pop	r0
     9c0:	0f be       	out	0x3f, r0	; 63
			leftLimitSwitch.put(leftLimit);

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     9c2:	f8 01       	movw	r30, r16
     9c4:	80 81       	ld	r24, Z
     9c6:	82 fd       	sbrc	r24, 2
     9c8:	08 c0       	rjmp	.+16     	; 0x9da <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9ca:	0f b6       	in	r0, 0x3f	; 63
     9cc:	f8 94       	cli
     9ce:	0f 92       	push	r0
			the_data = new_data;
     9d0:	d0 92 40 31 	sts	0x3140, r13	; 0x803140 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9d4:	0f 90       	pop	r0
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	07 c0       	rjmp	.+14     	; 0x9e8 <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     9da:	0f b6       	in	r0, 0x3f	; 63
     9dc:	f8 94       	cli
     9de:	0f 92       	push	r0
			the_data = new_data;
     9e0:	10 92 40 31 	sts	0x3140, r1	; 0x803140 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     9e4:	0f 90       	pop	r0
     9e6:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     9e8:	f7 01       	movw	r30, r14
     9ea:	86 85       	ldd	r24, Z+14	; 0x0e
     9ec:	97 85       	ldd	r25, Z+15	; 0x0f
     9ee:	a0 89       	ldd	r26, Z+16	; 0x10
     9f0:	b1 89       	ldd	r27, Z+17	; 0x11
     9f2:	01 96       	adiw	r24, 0x01	; 1
     9f4:	a1 1d       	adc	r26, r1
     9f6:	b1 1d       	adc	r27, r1
     9f8:	86 87       	std	Z+14, r24	; 0x0e
     9fa:	97 87       	std	Z+15, r25	; 0x0f
     9fc:	a0 8b       	std	Z+16, r26	; 0x10
     9fe:	b1 8b       	std	Z+17, r27	; 0x11
     a00:	41 e0       	ldi	r20, 0x01	; 1
     a02:	50 e0       	ldi	r21, 0x00	; 0
     a04:	60 e0       	ldi	r22, 0x00	; 0
     a06:	70 e0       	ldi	r23, 0x00	; 0
     a08:	ce 01       	movw	r24, r28
     a0a:	01 96       	adiw	r24, 0x01	; 1
     a0c:	0e 94 6c 14 	call	0x28d8	; 0x28d8 <vTaskDelayUntil>
     a10:	c5 cf       	rjmp	.-118    	; 0x99c <_ZN13LimitSwitches3runEv+0x34>

00000a12 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     a12:	0f 93       	push	r16
     a14:	1f 93       	push	r17
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     a1c:	0e 94 09 17 	call	0x2e12	; 0x2e12 <_ZN8frt_taskC1EPKchjP8emstream>
     a20:	8a e1       	ldi	r24, 0x1A	; 26
     a22:	90 e2       	ldi	r25, 0x20	; 32
     a24:	88 83       	st	Y, r24
     a26:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     a28:	df 91       	pop	r29
     a2a:	cf 91       	pop	r28
     a2c:	1f 91       	pop	r17
     a2e:	0f 91       	pop	r16
     a30:	08 95       	ret

00000a32 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	cd b7       	in	r28, 0x3d	; 61
     a38:	de b7       	in	r29, 0x3e	; 62
     a3a:	6a 97       	sbiw	r28, 0x1a	; 26
     a3c:	cd bf       	out	0x3d, r28	; 61
     a3e:	de bf       	out	0x3e, r29	; 62
     a40:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     a42:	0e 94 ce 12 	call	0x259c	; 0x259c <xTaskGetTickCount>
     a46:	69 83       	std	Y+1, r22	; 0x01
     a48:	7a 83       	std	Y+2, r23	; 0x02
     a4a:	8b 83       	std	Y+3, r24	; 0x03
     a4c:	9c 83       	std	Y+4, r25	; 0x04

	dt = 1; // [ms]
     a4e:	f8 01       	movw	r30, r16
     a50:	fe 96       	adiw	r30, 0x3e	; 62
     a52:	81 e0       	ldi	r24, 0x01	; 1
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	a0 e0       	ldi	r26, 0x00	; 0
     a58:	b0 e0       	ldi	r27, 0x00	; 0
     a5a:	80 83       	st	Z, r24
     a5c:	91 83       	std	Z+1, r25	; 0x01
     a5e:	a2 83       	std	Z+2, r26	; 0x02
     a60:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     a62:	d8 01       	movw	r26, r16
     a64:	dc 96       	adiw	r26, 0x3c	; 60
     a66:	8d 93       	st	X+, r24
     a68:	9c 93       	st	X, r25
     a6a:	dd 97       	sbiw	r26, 0x3d	; 61
	
	// Initialize PWM 
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     a6c:	a0 e4       	ldi	r26, 0x40	; 64
     a6e:	b6 e0       	ldi	r27, 0x06	; 6
     a70:	87 e0       	ldi	r24, 0x07	; 7
     a72:	11 96       	adiw	r26, 0x01	; 1
     a74:	8c 93       	st	X, r24
     a76:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     a78:	84 e0       	ldi	r24, 0x04	; 4
     a7a:	15 96       	adiw	r26, 0x05	; 5
     a7c:	8c 93       	st	X, r24
     a7e:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     a80:	e0 e0       	ldi	r30, 0x00	; 0
     a82:	f8 e0       	ldi	r31, 0x08	; 8
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     a88:	83 e0       	ldi	r24, 0x03	; 3
     a8a:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     a8c:	a6 a3       	std	Z+38, r26	; 0x26
     a8e:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     a90:	10 a6       	std	Z+40, r1	; 0x28
     a92:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     a94:	12 a6       	std	Z+42, r1	; 0x2a
     a96:	13 a6       	std	Z+43, r1	; 0x2b
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     a98:	81 81       	ldd	r24, Z+1	; 0x01
     a9a:	80 63       	ori	r24, 0x30	; 48
     a9c:	81 83       	std	Z+1, r24	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     a9e:	0f b6       	in	r0, 0x3f	; 63
     aa0:	f8 94       	cli
     aa2:	0f 92       	push	r0
			the_data = new_data;
     aa4:	10 92 3e 31 	sts	0x313E, r1	; 0x80313e <linear_offset>
     aa8:	10 92 3f 31 	sts	0x313F, r1	; 0x80313f <linear_offset+0x1>
			portEXIT_CRITICAL ();
     aac:	0f 90       	pop	r0
     aae:	0f be       	out	0x3f, r0	; 63
	linear_offset.put(0);								// Initialize motor offset	
	int16_t left_home;									// Initialize left distance to calculate center
	int16_t position_set;								// Setpoint of cart's position
	int16_t KP_pos = 100;								// P gain for cart position				
	int16_t position_error = 0;							// positional error	
	int16_t position_midpoint = 0;						// midpoint calculated from homing sequence
     ab0:	1f 8a       	std	Y+23, r1	; 0x17
     ab2:	18 8e       	std	Y+24, r1	; 0x18
				omegam_set = -10;	// [ticks/ms]
			
				if (leftLimitSwitch.get())
				{
					left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     ab4:	58 01       	movw	r10, r16
     ab6:	b0 e5       	ldi	r27, 0x50	; 80
     ab8:	ab 0e       	add	r10, r27
     aba:	b1 1c       	adc	r11, r1
					output_correct = 0;
     abc:	68 01       	movw	r12, r16
     abe:	ee e5       	ldi	r30, 0x5E	; 94
     ac0:	ce 0e       	add	r12, r30
     ac2:	d1 1c       	adc	r13, r1
			case(0) :
				if (begin.get())											// If user begins Calibration Sequence
				{
					reset.put(0);											// turn off flag
					stop.put(0);
					omegam_set = 10;	// [ticks/ms]
     ac4:	0f 2e       	mov	r0, r31
     ac6:	fa e0       	ldi	r31, 0x0A	; 10
     ac8:	2f 2e       	mov	r2, r31
     aca:	31 2c       	mov	r3, r1
     acc:	f0 2d       	mov	r31, r0
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     ace:	98 01       	movw	r18, r16
     ad0:	28 5b       	subi	r18, 0xB8	; 184
     ad2:	3f 4f       	sbci	r19, 0xFF	; 255
     ad4:	2f 87       	std	Y+15, r18	; 0x0f
     ad6:	38 8b       	std	Y+16, r19	; 0x10
		_Ki = .7*256;
     ad8:	c8 01       	movw	r24, r16
     ada:	84 5b       	subi	r24, 0xB4	; 180
     adc:	9f 4f       	sbci	r25, 0xFF	; 255
     ade:	8d 83       	std	Y+5, r24	; 0x05
     ae0:	9e 83       	std	Y+6, r25	; 0x06
		_Kd = 0;
     ae2:	d8 01       	movw	r26, r16
     ae4:	a6 5b       	subi	r26, 0xB6	; 182
     ae6:	bf 4f       	sbci	r27, 0xFF	; 255
     ae8:	a9 8b       	std	Y+17, r26	; 0x11
     aea:	ba 8b       	std	Y+18, r27	; 0x12
		antiwind_gain = .75*256;
     aec:	f8 01       	movw	r30, r16
     aee:	ec 59       	subi	r30, 0x9C	; 156
     af0:	ff 4f       	sbci	r31, 0xFF	; 255
     af2:	ef 83       	std	Y+7, r30	; 0x07
     af4:	f8 87       	std	Y+8, r31	; 0x08
		
		_max = 1600;
     af6:	24 50       	subi	r18, 0x04	; 4
     af8:	31 09       	sbc	r19, r1
     afa:	29 87       	std	Y+9, r18	; 0x09
     afc:	3a 87       	std	Y+10, r19	; 0x0a
		_min = -1600;
     afe:	06 97       	sbiw	r24, 0x06	; 6
     b00:	8d 87       	std	Y+13, r24	; 0x0d
     b02:	9e 87       	std	Y+14, r25	; 0x0e
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     b04:	52 96       	adiw	r26, 0x12	; 18
     b06:	ab 8b       	std	Y+19, r26	; 0x13
     b08:	bc 8b       	std	Y+20, r27	; 0x14

		// Integral term
		error_int = error - antiwind_correct;
     b0a:	48 01       	movw	r8, r16
     b0c:	b6 e6       	ldi	r27, 0x66	; 102
     b0e:	8b 0e       	add	r8, r27
     b10:	91 1c       	adc	r9, r1
     b12:	34 96       	adiw	r30, 0x04	; 4
     b14:	ed 8b       	std	Y+21, r30	; 0x15
     b16:	fe 8b       	std	Y+22, r31	; 0x16
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     b18:	26 50       	subi	r18, 0x06	; 6
     b1a:	31 09       	sbc	r19, r1
     b1c:	2b 87       	std	Y+11, r18	; 0x0b
     b1e:	3c 87       	std	Y+12, r19	; 0x0c
	int16_t KP_angle = -1000;
	int16_t angle_set = 720;							// vertical setpoint for pendulum
	
	while(1){
		// Increment counter for debugging
		runs++;
     b20:	f8 01       	movw	r30, r16
     b22:	86 85       	ldd	r24, Z+14	; 0x0e
     b24:	97 85       	ldd	r25, Z+15	; 0x0f
     b26:	a0 89       	ldd	r26, Z+16	; 0x10
     b28:	b1 89       	ldd	r27, Z+17	; 0x11
     b2a:	01 96       	adiw	r24, 0x01	; 1
     b2c:	a1 1d       	adc	r26, r1
     b2e:	b1 1d       	adc	r27, r1
     b30:	86 87       	std	Z+14, r24	; 0x0e
     b32:	97 87       	std	Z+15, r25	; 0x0f
     b34:	a0 8b       	std	Z+16, r26	; 0x10
     b36:	b1 8b       	std	Z+17, r27	; 0x11
		
		switch (state)
     b38:	84 85       	ldd	r24, Z+12	; 0x0c
     b3a:	81 30       	cpi	r24, 0x01	; 1
     b3c:	09 f4       	brne	.+2      	; 0xb40 <_ZN5Motor3runEv+0x10e>
     b3e:	4b c0       	rjmp	.+150    	; 0xbd6 <_ZN5Motor3runEv+0x1a4>
     b40:	38 f0       	brcs	.+14     	; 0xb50 <_ZN5Motor3runEv+0x11e>
     b42:	82 30       	cpi	r24, 0x02	; 2
     b44:	09 f4       	brne	.+2      	; 0xb48 <_ZN5Motor3runEv+0x116>
     b46:	83 c0       	rjmp	.+262    	; 0xc4e <_ZN5Motor3runEv+0x21c>
     b48:	83 30       	cpi	r24, 0x03	; 3
     b4a:	09 f4       	brne	.+2      	; 0xb4e <_ZN5Motor3runEv+0x11c>
     b4c:	c7 c0       	rjmp	.+398    	; 0xcdc <_ZN5Motor3runEv+0x2aa>
     b4e:	12 c1       	rjmp	.+548    	; 0xd74 <_ZN5Motor3runEv+0x342>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b50:	0f b6       	in	r0, 0x3f	; 63
     b52:	f8 94       	cli
     b54:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b56:	0f 90       	pop	r0
     b58:	0f be       	out	0x3f, r0	; 63
		{
			// Home right
			case(0) :
				if (begin.get())											// If user begins Calibration Sequence
     b5a:	80 91 3d 31 	lds	r24, 0x313D	; 0x80313d <begin>
     b5e:	88 23       	and	r24, r24
     b60:	09 f4       	brne	.+2      	; 0xb64 <_ZN5Motor3runEv+0x132>
     b62:	08 c1       	rjmp	.+528    	; 0xd74 <_ZN5Motor3runEv+0x342>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b64:	0f b6       	in	r0, 0x3f	; 63
     b66:	f8 94       	cli
     b68:	0f 92       	push	r0
			the_data = new_data;
     b6a:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <reset>
			portEXIT_CRITICAL ();
     b6e:	0f 90       	pop	r0
     b70:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b72:	0f b6       	in	r0, 0x3f	; 63
     b74:	f8 94       	cli
     b76:	0f 92       	push	r0
			the_data = new_data;
     b78:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <stop>
			portEXIT_CRITICAL ();
     b7c:	0f 90       	pop	r0
     b7e:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);											// turn off flag
					stop.put(0);
					omegam_set = 10;	// [ticks/ms]
     b80:	22 8e       	std	Z+26, r2	; 0x1a
     b82:	33 8e       	std	Z+27, r3	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b84:	0f b6       	in	r0, 0x3f	; 63
     b86:	f8 94       	cli
     b88:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b8a:	0f 90       	pop	r0
     b8c:	0f be       	out	0x3f, r0	; 63

					if (rightLimitSwitch.get())
     b8e:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rightLimitSwitch>
     b92:	88 23       	and	r24, r24
     b94:	09 f4       	brne	.+2      	; 0xb98 <_ZN5Motor3runEv+0x166>
     b96:	ee c0       	rjmp	.+476    	; 0xd74 <_ZN5Motor3runEv+0x342>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b98:	0f b6       	in	r0, 0x3f	; 63
     b9a:	f8 94       	cli
     b9c:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b9e:	0f 90       	pop	r0
     ba0:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     ba2:	0f b6       	in	r0, 0x3f	; 63
     ba4:	f8 94       	cli
     ba6:	0f 92       	push	r0
			the_data = new_data;
     ba8:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <linear_position>
     bac:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <linear_position+0x1>
     bb0:	80 93 3e 31 	sts	0x313E, r24	; 0x80313e <linear_offset>
     bb4:	90 93 3f 31 	sts	0x313F, r25	; 0x80313f <linear_offset+0x1>
			portEXIT_CRITICAL ();
     bb8:	0f 90       	pop	r0
     bba:	0f be       	out	0x3f, r0	; 63
					{
						linear_offset.put(linear_position.get());			// set the offset
						_integral = 0;
     bbc:	f5 01       	movw	r30, r10
     bbe:	10 82       	st	Z, r1
     bc0:	11 82       	std	Z+1, r1	; 0x01
     bc2:	12 82       	std	Z+2, r1	; 0x02
     bc4:	13 82       	std	Z+3, r1	; 0x03
						output_correct = 0;
     bc6:	d6 01       	movw	r26, r12
     bc8:	1d 92       	st	X+, r1
     bca:	1c 92       	st	X, r1
						transition_to(1);									// if right Limit Switch is triggered 
     bcc:	61 e0       	ldi	r22, 0x01	; 1
     bce:	c8 01       	movw	r24, r16
     bd0:	0e 94 05 17 	call	0x2e0a	; 0x2e0a <_ZN8frt_task13transition_toEh>
     bd4:	cf c0       	rjmp	.+414    	; 0xd74 <_ZN5Motor3runEv+0x342>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     bd6:	0f b6       	in	r0, 0x3f	; 63
     bd8:	f8 94       	cli
     bda:	0f 92       	push	r0
			the_data = new_data;
     bdc:	10 92 3d 31 	sts	0x313D, r1	; 0x80313d <begin>
			portEXIT_CRITICAL ();
     be0:	0f 90       	pop	r0
     be2:	0f be       	out	0x3f, r0	; 63
				break;
				
			// Home left
			case(1) :
				begin.put(0);		// turn off flag
				omegam_set = -10;	// [ticks/ms]
     be4:	86 ef       	ldi	r24, 0xF6	; 246
     be6:	9f ef       	ldi	r25, 0xFF	; 255
     be8:	f8 01       	movw	r30, r16
     bea:	82 8f       	std	Z+26, r24	; 0x1a
     bec:	93 8f       	std	Z+27, r25	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     bee:	0f b6       	in	r0, 0x3f	; 63
     bf0:	f8 94       	cli
     bf2:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     bf4:	0f 90       	pop	r0
     bf6:	0f be       	out	0x3f, r0	; 63
			
				if (leftLimitSwitch.get())
     bf8:	80 91 41 31 	lds	r24, 0x3141	; 0x803141 <leftLimitSwitch>
     bfc:	88 23       	and	r24, r24
     bfe:	c1 f0       	breq	.+48     	; 0xc30 <_ZN5Motor3runEv+0x1fe>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c00:	0f b6       	in	r0, 0x3f	; 63
     c02:	f8 94       	cli
     c04:	0f 92       	push	r0
			temporary_copy = the_data;
     c06:	20 91 46 31 	lds	r18, 0x3146	; 0x803146 <linear_position>
     c0a:	30 91 47 31 	lds	r19, 0x3147	; 0x803147 <linear_position+0x1>
     c0e:	29 8f       	std	Y+25, r18	; 0x19
     c10:	3a 8f       	std	Y+26, r19	; 0x1a
			portEXIT_CRITICAL ();
     c12:	0f 90       	pop	r0
     c14:	0f be       	out	0x3f, r0	; 63
				{
					left_home = linear_position.get();			// Store end of rail distance
					_integral = 0;
     c16:	d5 01       	movw	r26, r10
     c18:	1d 92       	st	X+, r1
     c1a:	1d 92       	st	X+, r1
     c1c:	1d 92       	st	X+, r1
     c1e:	1c 92       	st	X, r1
     c20:	13 97       	sbiw	r26, 0x03	; 3
					output_correct = 0;
     c22:	f6 01       	movw	r30, r12
     c24:	10 82       	st	Z, r1
     c26:	11 82       	std	Z+1, r1	; 0x01
					transition_to(2);									// if left limit switch is triggered
     c28:	62 e0       	ldi	r22, 0x02	; 2
     c2a:	c8 01       	movw	r24, r16
     c2c:	0e 94 05 17 	call	0x2e0a	; 0x2e0a <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c30:	0f b6       	in	r0, 0x3f	; 63
     c32:	f8 94       	cli
     c34:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c36:	0f 90       	pop	r0
     c38:	0f be       	out	0x3f, r0	; 63
				}
						
				if (reset.get() == 1)
     c3a:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <reset>
     c3e:	88 23       	and	r24, r24
     c40:	09 f4       	brne	.+2      	; 0xc44 <_ZN5Motor3runEv+0x212>
     c42:	98 c0       	rjmp	.+304    	; 0xd74 <_ZN5Motor3runEv+0x342>
				{
					transition_to(0);
     c44:	60 e0       	ldi	r22, 0x00	; 0
     c46:	c8 01       	movw	r24, r16
     c48:	0e 94 05 17 	call	0x2e0a	; 0x2e0a <_ZN8frt_task13transition_toEh>
     c4c:	93 c0       	rjmp	.+294    	; 0xd74 <_ZN5Motor3runEv+0x342>
							
				break;
			
			// Center Cart - Position Loop included
			case(2) :
				position_midpoint = left_home/2;
     c4e:	89 8d       	ldd	r24, Y+25	; 0x19
     c50:	9a 8d       	ldd	r25, Y+26	; 0x1a
     c52:	99 23       	and	r25, r25
     c54:	0c f4       	brge	.+2      	; 0xc58 <_ZN5Motor3runEv+0x226>
     c56:	01 96       	adiw	r24, 0x01	; 1
     c58:	9c 01       	movw	r18, r24
     c5a:	35 95       	asr	r19
     c5c:	27 95       	ror	r18
     c5e:	2f 8b       	std	Y+23, r18	; 0x17
     c60:	38 8f       	std	Y+24, r19	; 0x18
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c62:	0f b6       	in	r0, 0x3f	; 63
     c64:	f8 94       	cli
     c66:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c68:	0f 90       	pop	r0
     c6a:	0f be       	out	0x3f, r0	; 63
				position_set = position_midpoint;
				position_error = position_set - linear_position.get();  // 
				omegam_set = position_error*KP_pos/1000;
     c6c:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <linear_position>
     c70:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <linear_position+0x1>
     c74:	28 1b       	sub	r18, r24
     c76:	39 0b       	sbc	r19, r25
     c78:	44 e6       	ldi	r20, 0x64	; 100
     c7a:	42 9f       	mul	r20, r18
     c7c:	c0 01       	movw	r24, r0
     c7e:	43 9f       	mul	r20, r19
     c80:	90 0d       	add	r25, r0
     c82:	11 24       	eor	r1, r1
     c84:	68 ee       	ldi	r22, 0xE8	; 232
     c86:	73 e0       	ldi	r23, 0x03	; 3
     c88:	0e 94 97 21 	call	0x432e	; 0x432e <__divmodhi4>
     c8c:	d8 01       	movw	r26, r16
     c8e:	5a 96       	adiw	r26, 0x1a	; 26
     c90:	6d 93       	st	X+, r22
     c92:	7c 93       	st	X, r23
     c94:	5b 97       	sbiw	r26, 0x1b	; 27
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     c96:	0f b6       	in	r0, 0x3f	; 63
     c98:	f8 94       	cli
     c9a:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     c9c:	0f 90       	pop	r0
     c9e:	0f be       	out	0x3f, r0	; 63
				
				if (reset.get() == 1)			// if user hits reset
     ca0:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <reset>
     ca4:	88 23       	and	r24, r24
     ca6:	59 f0       	breq	.+22     	; 0xcbe <_ZN5Motor3runEv+0x28c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	f8 94       	cli
     cac:	0f 92       	push	r0
			the_data = new_data;
     cae:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <reset>
			portEXIT_CRITICAL ();
     cb2:	0f 90       	pop	r0
     cb4:	0f be       	out	0x3f, r0	; 63
				{
					reset.put(0);				// turn off flag
					transition_to(0);
     cb6:	60 e0       	ldi	r22, 0x00	; 0
     cb8:	c8 01       	movw	r24, r16
     cba:	0e 94 05 17 	call	0x2e0a	; 0x2e0a <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     cbe:	0f b6       	in	r0, 0x3f	; 63
     cc0:	f8 94       	cli
     cc2:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cc4:	0f 90       	pop	r0
     cc6:	0f be       	out	0x3f, r0	; 63
					
				}
				
				if(go.get() == 1)				// If user says pendulum is upright or angle = 720;
     cc8:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <go>
     ccc:	88 23       	and	r24, r24
     cce:	09 f4       	brne	.+2      	; 0xcd2 <_ZN5Motor3runEv+0x2a0>
     cd0:	51 c0       	rjmp	.+162    	; 0xd74 <_ZN5Motor3runEv+0x342>
				{
					transition_to(3);
     cd2:	63 e0       	ldi	r22, 0x03	; 3
     cd4:	c8 01       	movw	r24, r16
     cd6:	0e 94 05 17 	call	0x2e0a	; 0x2e0a <_ZN8frt_task13transition_toEh>
     cda:	4c c0       	rjmp	.+152    	; 0xd74 <_ZN5Motor3runEv+0x342>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     cdc:	0f b6       	in	r0, 0x3f	; 63
     cde:	f8 94       	cli
     ce0:	0f 92       	push	r0
			the_data = new_data;
     ce2:	10 92 3c 31 	sts	0x313C, r1	; 0x80313c <go>
			portEXIT_CRITICAL ();
     ce6:	0f 90       	pop	r0
     ce8:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     cea:	0f b6       	in	r0, 0x3f	; 63
     cec:	f8 94       	cli
     cee:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cf0:	0f 90       	pop	r0
     cf2:	0f be       	out	0x3f, r0	; 63
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     cf4:	0f b6       	in	r0, 0x3f	; 63
     cf6:	f8 94       	cli
     cf8:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cfa:	0f 90       	pop	r0
     cfc:	0f be       	out	0x3f, r0	; 63
			case(3) :
				go.put(0);										// turn off flag
				angle_error = angle_set - thPendulum.get();
				position_set = position_midpoint + angle_error*KP_angle/1000;
				position_error = position_set - linear_position.get();  // 
				omegam_set = position_error*KP_pos/1000;
     cfe:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <thPendulum>
     d02:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <thPendulum+0x1>
     d06:	20 ed       	ldi	r18, 0xD0	; 208
     d08:	32 e0       	ldi	r19, 0x02	; 2
     d0a:	28 1b       	sub	r18, r24
     d0c:	39 0b       	sbc	r19, r25
     d0e:	48 e1       	ldi	r20, 0x18	; 24
     d10:	5c ef       	ldi	r21, 0xFC	; 252
     d12:	24 9f       	mul	r18, r20
     d14:	c0 01       	movw	r24, r0
     d16:	25 9f       	mul	r18, r21
     d18:	90 0d       	add	r25, r0
     d1a:	34 9f       	mul	r19, r20
     d1c:	90 0d       	add	r25, r0
     d1e:	11 24       	eor	r1, r1
     d20:	28 ee       	ldi	r18, 0xE8	; 232
     d22:	33 e0       	ldi	r19, 0x03	; 3
     d24:	b9 01       	movw	r22, r18
     d26:	0e 94 97 21 	call	0x432e	; 0x432e <__divmodhi4>
     d2a:	ef 89       	ldd	r30, Y+23	; 0x17
     d2c:	f8 8d       	ldd	r31, Y+24	; 0x18
     d2e:	6e 0f       	add	r22, r30
     d30:	7f 1f       	adc	r23, r31
     d32:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <linear_position>
     d36:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <linear_position+0x1>
     d3a:	68 1b       	sub	r22, r24
     d3c:	79 0b       	sbc	r23, r25
     d3e:	44 e6       	ldi	r20, 0x64	; 100
     d40:	46 9f       	mul	r20, r22
     d42:	c0 01       	movw	r24, r0
     d44:	47 9f       	mul	r20, r23
     d46:	90 0d       	add	r25, r0
     d48:	11 24       	eor	r1, r1
     d4a:	b9 01       	movw	r22, r18
     d4c:	0e 94 97 21 	call	0x432e	; 0x432e <__divmodhi4>
     d50:	d8 01       	movw	r26, r16
     d52:	5a 96       	adiw	r26, 0x1a	; 26
     d54:	6d 93       	st	X+, r22
     d56:	7c 93       	st	X, r23
     d58:	5b 97       	sbiw	r26, 0x1b	; 27
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d5a:	0f b6       	in	r0, 0x3f	; 63
     d5c:	f8 94       	cli
     d5e:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d60:	0f 90       	pop	r0
     d62:	0f be       	out	0x3f, r0	; 63
				
				if (reset.get())
     d64:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <reset>
     d68:	88 23       	and	r24, r24
     d6a:	21 f0       	breq	.+8      	; 0xd74 <_ZN5Motor3runEv+0x342>
				{
					transition_to(0);
     d6c:	60 e0       	ldi	r22, 0x00	; 0
     d6e:	c8 01       	movw	r24, r16
     d70:	0e 94 05 17 	call	0x2e0a	; 0x2e0a <_ZN8frt_task13transition_toEh>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d74:	0f b6       	in	r0, 0x3f	; 63
     d76:	f8 94       	cli
     d78:	0f 92       	push	r0
			temporary_copy = the_data;
     d7a:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <thdMotor>
     d7e:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <thdMotor+0x1>
			portEXIT_CRITICAL ();
     d82:	0f 90       	pop	r0
     d84:	0f be       	out	0x3f, r0	; 63
				break;													
		
		};

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     d86:	f8 01       	movw	r30, r16
     d88:	86 8f       	std	Z+30, r24	; 0x1e
     d8a:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 10.1;
     d8c:	af 85       	ldd	r26, Y+15	; 0x0f
     d8e:	b8 89       	ldd	r27, Y+16	; 0x10
     d90:	2d 92       	st	X+, r2
     d92:	3c 92       	st	X, r3
		_Ki = .7*256;
     d94:	23 eb       	ldi	r18, 0xB3	; 179
     d96:	30 e0       	ldi	r19, 0x00	; 0
     d98:	ed 81       	ldd	r30, Y+5	; 0x05
     d9a:	fe 81       	ldd	r31, Y+6	; 0x06
     d9c:	20 83       	st	Z, r18
     d9e:	31 83       	std	Z+1, r19	; 0x01
		_Kd = 0;
     da0:	a9 89       	ldd	r26, Y+17	; 0x11
     da2:	ba 89       	ldd	r27, Y+18	; 0x12
     da4:	1d 92       	st	X+, r1
     da6:	1c 92       	st	X, r1
		antiwind_gain = .75*256;
     da8:	20 ec       	ldi	r18, 0xC0	; 192
     daa:	30 e0       	ldi	r19, 0x00	; 0
     dac:	ef 81       	ldd	r30, Y+7	; 0x07
     dae:	f8 85       	ldd	r31, Y+8	; 0x08
     db0:	20 83       	st	Z, r18
     db2:	31 83       	std	Z+1, r19	; 0x01
		
		_max = 1600;
     db4:	20 e4       	ldi	r18, 0x40	; 64
     db6:	36 e0       	ldi	r19, 0x06	; 6
     db8:	a9 85       	ldd	r26, Y+9	; 0x09
     dba:	ba 85       	ldd	r27, Y+10	; 0x0a
     dbc:	2d 93       	st	X+, r18
     dbe:	3c 93       	st	X, r19
		_min = -1600;
     dc0:	20 ec       	ldi	r18, 0xC0	; 192
     dc2:	39 ef       	ldi	r19, 0xF9	; 249
     dc4:	ed 85       	ldd	r30, Y+13	; 0x0d
     dc6:	fe 85       	ldd	r31, Y+14	; 0x0e
     dc8:	20 83       	st	Z, r18
     dca:	31 83       	std	Z+1, r19	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     dcc:	d8 01       	movw	r26, r16
     dce:	5a 96       	adiw	r26, 0x1a	; 26
     dd0:	ed 90       	ld	r14, X+
     dd2:	fc 90       	ld	r15, X
     dd4:	5b 97       	sbiw	r26, 0x1b	; 27
     dd6:	e8 1a       	sub	r14, r24
     dd8:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     dda:	b7 01       	movw	r22, r14
     ddc:	c1 01       	movw	r24, r2
     dde:	0e 94 a1 08 	call	0x1142	; 0x1142 <_ZN7satmath20signed_saturated_mulEii>
     de2:	2b 01       	movw	r4, r22
     de4:	3c 01       	movw	r6, r24
     de6:	eb 89       	ldd	r30, Y+19	; 0x13
     de8:	fc 89       	ldd	r31, Y+20	; 0x14
     dea:	60 83       	st	Z, r22
     dec:	71 83       	std	Z+1, r23	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     dee:	d4 01       	movw	r26, r8
     df0:	8d 91       	ld	r24, X+
     df2:	9c 91       	ld	r25, X
     df4:	f7 01       	movw	r30, r14
     df6:	e8 1b       	sub	r30, r24
     df8:	f9 0b       	sbc	r31, r25
     dfa:	cf 01       	movw	r24, r30
     dfc:	ad 89       	ldd	r26, Y+21	; 0x15
     dfe:	be 89       	ldd	r27, Y+22	; 0x16
     e00:	ed 93       	st	X+, r30
     e02:	fc 93       	st	X, r31
		error_int_gain = (_Ki * error_int);
     e04:	ed 81       	ldd	r30, Y+5	; 0x05
     e06:	fe 81       	ldd	r31, Y+6	; 0x06
     e08:	20 81       	ld	r18, Z
     e0a:	31 81       	ldd	r19, Z+1	; 0x01
     e0c:	82 9f       	mul	r24, r18
     e0e:	d0 01       	movw	r26, r0
     e10:	83 9f       	mul	r24, r19
     e12:	b0 0d       	add	r27, r0
     e14:	92 9f       	mul	r25, r18
     e16:	b0 0d       	add	r27, r0
     e18:	11 24       	eor	r1, r1
     e1a:	f8 01       	movw	r30, r16
     e1c:	e6 59       	subi	r30, 0x96	; 150
     e1e:	ff 4f       	sbci	r31, 0xFF	; 255
     e20:	a0 83       	st	Z, r26
     e22:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     e24:	eb 85       	ldd	r30, Y+11	; 0x0b
     e26:	fc 85       	ldd	r31, Y+12	; 0x0c
     e28:	20 81       	ld	r18, Z
     e2a:	31 81       	ldd	r19, Z+1	; 0x01
     e2c:	42 81       	ldd	r20, Z+2	; 0x02
     e2e:	53 81       	ldd	r21, Z+3	; 0x03
     e30:	0e 94 1e 22 	call	0x443c	; 0x443c <__mulshisi3>
     e34:	9b 01       	movw	r18, r22
     e36:	ac 01       	movw	r20, r24
     e38:	99 23       	and	r25, r25
     e3a:	24 f4       	brge	.+8      	; 0xe44 <_ZN5Motor3runEv+0x412>
     e3c:	21 50       	subi	r18, 0x01	; 1
     e3e:	3f 4f       	sbci	r19, 0xFF	; 255
     e40:	4f 4f       	sbci	r20, 0xFF	; 255
     e42:	5f 4f       	sbci	r21, 0xFF	; 255
     e44:	bb 27       	eor	r27, r27
     e46:	57 fd       	sbrc	r21, 7
     e48:	ba 95       	dec	r27
     e4a:	a5 2f       	mov	r26, r21
     e4c:	94 2f       	mov	r25, r20
     e4e:	83 2f       	mov	r24, r19
     e50:	f5 01       	movw	r30, r10
     e52:	40 81       	ld	r20, Z
     e54:	51 81       	ldd	r21, Z+1	; 0x01
     e56:	62 81       	ldd	r22, Z+2	; 0x02
     e58:	73 81       	ldd	r23, Z+3	; 0x03
     e5a:	84 0f       	add	r24, r20
     e5c:	95 1f       	adc	r25, r21
     e5e:	a6 1f       	adc	r26, r22
     e60:	b7 1f       	adc	r27, r23
		if(_integral > 1000000000)
     e62:	81 30       	cpi	r24, 0x01	; 1
     e64:	fa ec       	ldi	r31, 0xCA	; 202
     e66:	9f 07       	cpc	r25, r31
     e68:	fa e9       	ldi	r31, 0x9A	; 154
     e6a:	af 07       	cpc	r26, r31
     e6c:	fb e3       	ldi	r31, 0x3B	; 59
     e6e:	bf 07       	cpc	r27, r31
     e70:	54 f0       	brlt	.+20     	; 0xe86 <_ZN5Motor3runEv+0x454>
		{
			_integral = 1000000000;
     e72:	80 e0       	ldi	r24, 0x00	; 0
     e74:	9a ec       	ldi	r25, 0xCA	; 202
     e76:	aa e9       	ldi	r26, 0x9A	; 154
     e78:	bb e3       	ldi	r27, 0x3B	; 59
     e7a:	f5 01       	movw	r30, r10
     e7c:	80 83       	st	Z, r24
     e7e:	91 83       	std	Z+1, r25	; 0x01
     e80:	a2 83       	std	Z+2, r26	; 0x02
     e82:	b3 83       	std	Z+3, r27	; 0x03
     e84:	17 c0       	rjmp	.+46     	; 0xeb4 <_ZN5Motor3runEv+0x482>
		}
		else if(_integral < -1000000000)
     e86:	81 15       	cp	r24, r1
     e88:	f6 e3       	ldi	r31, 0x36	; 54
     e8a:	9f 07       	cpc	r25, r31
     e8c:	f5 e6       	ldi	r31, 0x65	; 101
     e8e:	af 07       	cpc	r26, r31
     e90:	f4 ec       	ldi	r31, 0xC4	; 196
     e92:	bf 07       	cpc	r27, r31
     e94:	34 f0       	brlt	.+12     	; 0xea2 <_ZN5Motor3runEv+0x470>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     e96:	f5 01       	movw	r30, r10
     e98:	80 83       	st	Z, r24
     e9a:	91 83       	std	Z+1, r25	; 0x01
     e9c:	a2 83       	std	Z+2, r26	; 0x02
     e9e:	b3 83       	std	Z+3, r27	; 0x03
     ea0:	09 c0       	rjmp	.+18     	; 0xeb4 <_ZN5Motor3runEv+0x482>
		{
			_integral = 1000000000;
		}
		else if(_integral < -1000000000)
		{
			_integral = -1000000000;
     ea2:	80 e0       	ldi	r24, 0x00	; 0
     ea4:	96 e3       	ldi	r25, 0x36	; 54
     ea6:	a5 e6       	ldi	r26, 0x65	; 101
     ea8:	b4 ec       	ldi	r27, 0xC4	; 196
     eaa:	f5 01       	movw	r30, r10
     eac:	80 83       	st	Z, r24
     eae:	91 83       	std	Z+1, r25	; 0x01
     eb0:	a2 83       	std	Z+2, r26	; 0x02
     eb2:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
     eb4:	d5 01       	movw	r26, r10
     eb6:	6d 91       	ld	r22, X+
     eb8:	7c 91       	ld	r23, X
     eba:	c2 01       	movw	r24, r4
     ebc:	0e 94 85 08 	call	0x110a	; 0x110a <_ZN7satmath20signed_saturated_addEii>
     ec0:	f8 01       	movw	r30, r16
     ec2:	e0 5a       	subi	r30, 0xA0	; 160
     ec4:	ff 4f       	sbci	r31, 0xFF	; 255
     ec6:	80 83       	st	Z, r24
     ec8:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
     eca:	f6 01       	movw	r30, r12
     ecc:	80 83       	st	Z, r24
     ece:	91 83       	std	Z+1, r25	; 0x01
		// Restrict to max/min
		if( output_correct > _max )
     ed0:	a9 85       	ldd	r26, Y+9	; 0x09
     ed2:	ba 85       	ldd	r27, Y+10	; 0x0a
     ed4:	2d 91       	ld	r18, X+
     ed6:	3c 91       	ld	r19, X
     ed8:	28 17       	cp	r18, r24
     eda:	39 07       	cpc	r19, r25
     edc:	1c f4       	brge	.+6      	; 0xee4 <_ZN5Motor3runEv+0x4b2>
		output_correct = _max;
     ede:	20 83       	st	Z, r18
     ee0:	31 83       	std	Z+1, r19	; 0x01
     ee2:	0a c0       	rjmp	.+20     	; 0xef8 <_ZN5Motor3runEv+0x4c6>
		else if( output_correct < _min )
     ee4:	ed 85       	ldd	r30, Y+13	; 0x0d
     ee6:	fe 85       	ldd	r31, Y+14	; 0x0e
     ee8:	20 81       	ld	r18, Z
     eea:	31 81       	ldd	r19, Z+1	; 0x01
     eec:	82 17       	cp	r24, r18
     eee:	93 07       	cpc	r25, r19
     ef0:	1c f4       	brge	.+6      	; 0xef8 <_ZN5Motor3runEv+0x4c6>
		output_correct = _min;
     ef2:	d6 01       	movw	r26, r12
     ef4:	2d 93       	st	X+, r18
     ef6:	3c 93       	st	X, r19

		// Save error to previous error
		_pre_error = error;
     ef8:	f8 01       	movw	r30, r16
     efa:	e2 5b       	subi	r30, 0xB2	; 178
     efc:	ff 4f       	sbci	r31, 0xFF	; 255
     efe:	e0 82       	st	Z, r14
     f00:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
     f02:	f6 01       	movw	r30, r12
     f04:	20 81       	ld	r18, Z
     f06:	31 81       	ldd	r19, Z+1	; 0x01
     f08:	82 1b       	sub	r24, r18
     f0a:	93 0b       	sbc	r25, r19
     f0c:	f8 01       	movw	r30, r16
     f0e:	ee 59       	subi	r30, 0x9E	; 158
     f10:	ff 4f       	sbci	r31, 0xFF	; 255
     f12:	80 83       	st	Z, r24
     f14:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
     f16:	af 81       	ldd	r26, Y+7	; 0x07
     f18:	b8 85       	ldd	r27, Y+8	; 0x08
     f1a:	4d 91       	ld	r20, X+
     f1c:	5c 91       	ld	r21, X
     f1e:	84 9f       	mul	r24, r20
     f20:	90 01       	movw	r18, r0
     f22:	85 9f       	mul	r24, r21
     f24:	30 0d       	add	r19, r0
     f26:	94 9f       	mul	r25, r20
     f28:	30 0d       	add	r19, r0
     f2a:	11 24       	eor	r1, r1
     f2c:	33 23       	and	r19, r19
     f2e:	14 f4       	brge	.+4      	; 0xf34 <_ZN5Motor3runEv+0x502>
     f30:	21 50       	subi	r18, 0x01	; 1
     f32:	3f 4f       	sbci	r19, 0xFF	; 255
     f34:	83 2f       	mov	r24, r19
     f36:	88 0f       	add	r24, r24
     f38:	88 0b       	sbc	r24, r24
     f3a:	f4 01       	movw	r30, r8
     f3c:	30 83       	st	Z, r19
     f3e:	81 83       	std	Z+1, r24	; 0x01
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     f40:	0f b6       	in	r0, 0x3f	; 63
     f42:	f8 94       	cli
     f44:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     f46:	0f 90       	pop	r0
     f48:	0f be       	out	0x3f, r0	; 63
				//*p_serial << "stop flag" << stop.get() << endl;
				//*p_serial << "reset flag " << reset.get() << endl;
			}
		
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get() || stop.get())		// If limit switch or If emergency stop button was hit
     f4a:	80 91 41 31 	lds	r24, 0x3141	; 0x803141 <leftLimitSwitch>
     f4e:	81 11       	cpse	r24, r1
     f50:	12 c0       	rjmp	.+36     	; 0xf76 <_ZN5Motor3runEv+0x544>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     f52:	0f b6       	in	r0, 0x3f	; 63
     f54:	f8 94       	cli
     f56:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     f58:	0f 90       	pop	r0
     f5a:	0f be       	out	0x3f, r0	; 63
     f5c:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rightLimitSwitch>
     f60:	81 11       	cpse	r24, r1
     f62:	09 c0       	rjmp	.+18     	; 0xf76 <_ZN5Motor3runEv+0x544>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     f64:	0f b6       	in	r0, 0x3f	; 63
     f66:	f8 94       	cli
     f68:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     f6a:	0f 90       	pop	r0
     f6c:	0f be       	out	0x3f, r0	; 63
     f6e:	80 91 3b 31 	lds	r24, 0x313B	; 0x80313b <stop>
     f72:	88 23       	and	r24, r24
     f74:	e9 f0       	breq	.+58     	; 0xfb0 <_ZN5Motor3runEv+0x57e>
		{
			//omegam_set = 0; // [ticks/ms]
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
     f76:	d5 01       	movw	r26, r10
     f78:	1d 92       	st	X+, r1
     f7a:	1d 92       	st	X+, r1
     f7c:	1d 92       	st	X+, r1
     f7e:	1c 92       	st	X, r1
     f80:	13 97       	sbiw	r26, 0x03	; 3
			output_correct = 0;
     f82:	f6 01       	movw	r30, r12
     f84:	10 82       	st	Z, r1
     f86:	11 82       	std	Z+1, r1	; 0x01
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     f88:	0f b6       	in	r0, 0x3f	; 63
     f8a:	f8 94       	cli
     f8c:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     f8e:	0f 90       	pop	r0
     f90:	0f be       	out	0x3f, r0	; 63
			
			if (reset.get())										// if user hits reset
     f92:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <reset>
     f96:	88 23       	and	r24, r24
     f98:	59 f0       	breq	.+22     	; 0xfb0 <_ZN5Motor3runEv+0x57e>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     f9a:	0f b6       	in	r0, 0x3f	; 63
     f9c:	f8 94       	cli
     f9e:	0f 92       	push	r0
			the_data = new_data;
     fa0:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <reset>
			portEXIT_CRITICAL ();
     fa4:	0f 90       	pop	r0
     fa6:	0f be       	out	0x3f, r0	; 63
			{
				reset.put(0);
				transition_to(0);
     fa8:	60 e0       	ldi	r22, 0x00	; 0
     faa:	c8 01       	movw	r24, r16
     fac:	0e 94 05 17 	call	0x2e0a	; 0x2e0a <_ZN8frt_task13transition_toEh>
		
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     fb0:	d8 01       	movw	r26, r16
     fb2:	98 96       	adiw	r26, 0x28	; 40
     fb4:	1d 92       	st	X+, r1
     fb6:	1c 92       	st	X, r1
     fb8:	99 97       	sbiw	r26, 0x29	; 41
		Im_set = Tset/K_T;
     fba:	92 96       	adiw	r26, 0x22	; 34
     fbc:	8d 91       	ld	r24, X+
     fbe:	9c 91       	ld	r25, X
     fc0:	93 97       	sbiw	r26, 0x23	; 35
     fc2:	60 e0       	ldi	r22, 0x00	; 0
     fc4:	70 e0       	ldi	r23, 0x00	; 0
     fc6:	0e 94 97 21 	call	0x432e	; 0x432e <__divmodhi4>
     fca:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
     fcc:	07 2e       	mov	r0, r23
     fce:	00 0c       	add	r0, r0
     fd0:	88 0b       	sbc	r24, r24
     fd2:	99 0b       	sbc	r25, r25
     fd4:	0e 94 23 21 	call	0x4246	; 0x4246 <__floatsisf>
     fd8:	2b 01       	movw	r4, r22
     fda:	3c 01       	movw	r6, r24
     fdc:	23 e3       	ldi	r18, 0x33	; 51
     fde:	33 e3       	ldi	r19, 0x33	; 51
     fe0:	4b e8       	ldi	r20, 0x8B	; 139
     fe2:	51 e4       	ldi	r21, 0x41	; 65
     fe4:	0e 94 82 21 	call	0x4304	; 0x4304 <__gesf2>
     fe8:	18 16       	cp	r1, r24
     fea:	34 f4       	brge	.+12     	; 0xff8 <_ZN5Motor3runEv+0x5c6>
			Im_set = 17.4;
     fec:	81 e1       	ldi	r24, 0x11	; 17
     fee:	90 e0       	ldi	r25, 0x00	; 0
     ff0:	f8 01       	movw	r30, r16
     ff2:	84 a3       	std	Z+36, r24	; 0x24
     ff4:	95 a3       	std	Z+37, r25	; 0x25
     ff6:	15 c0       	rjmp	.+42     	; 0x1022 <_ZN5Motor3runEv+0x5f0>
		} else if(Im_set < -17.4) {
     ff8:	23 e3       	ldi	r18, 0x33	; 51
     ffa:	33 e3       	ldi	r19, 0x33	; 51
     ffc:	4b e8       	ldi	r20, 0x8B	; 139
     ffe:	51 ec       	ldi	r21, 0xC1	; 193
    1000:	c3 01       	movw	r24, r6
    1002:	b2 01       	movw	r22, r4
    1004:	0e 94 1c 21 	call	0x4238	; 0x4238 <__cmpsf2>
    1008:	88 23       	and	r24, r24
    100a:	34 f0       	brlt	.+12     	; 0x1018 <_ZN5Motor3runEv+0x5e6>
		// int16_t Tset = (pidTorque.calculate(omegam_set, omegam_measured));
		//PWMvalue.put(output_correct);
		
					
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
    100c:	d8 01       	movw	r26, r16
    100e:	94 96       	adiw	r26, 0x24	; 36
    1010:	ed 92       	st	X+, r14
    1012:	fc 92       	st	X, r15
    1014:	95 97       	sbiw	r26, 0x25	; 37
    1016:	05 c0       	rjmp	.+10     	; 0x1022 <_ZN5Motor3runEv+0x5f0>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
    1018:	8f ee       	ldi	r24, 0xEF	; 239
    101a:	9f ef       	ldi	r25, 0xFF	; 255
    101c:	f8 01       	movw	r30, r16
    101e:	84 a3       	std	Z+36, r24	; 0x24
    1020:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
    1022:	d8 01       	movw	r26, r16
    1024:	d6 96       	adiw	r26, 0x36	; 54
    1026:	1d 92       	st	X+, r1
    1028:	1c 92       	st	X, r1
    102a:	d7 97       	sbiw	r26, 0x37	; 55
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
    102c:	d2 96       	adiw	r26, 0x32	; 50
    102e:	1d 92       	st	X+, r1
    1030:	1c 92       	st	X, r1
    1032:	d3 97       	sbiw	r26, 0x33	; 51
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
    1034:	d4 96       	adiw	r26, 0x34	; 52
    1036:	1d 92       	st	X+, r1
    1038:	1c 92       	st	X, r1
    103a:	d5 97       	sbiw	r26, 0x35	; 53

		V_m = V_R + V_E;
    103c:	d0 96       	adiw	r26, 0x30	; 48
    103e:	8d 91       	ld	r24, X+
    1040:	9c 91       	ld	r25, X
    1042:	d1 97       	sbiw	r26, 0x31	; 49

		// Saturater for voltage
		if (V_m > 24) {
    1044:	89 31       	cpi	r24, 0x19	; 25
    1046:	91 05       	cpc	r25, r1
    1048:	3c f0       	brlt	.+14     	; 0x1058 <_ZN5Motor3runEv+0x626>
			V_m = 24;
    104a:	88 e1       	ldi	r24, 0x18	; 24
    104c:	90 e0       	ldi	r25, 0x00	; 0
    104e:	d8 96       	adiw	r26, 0x38	; 56
    1050:	8d 93       	st	X+, r24
    1052:	9c 93       	st	X, r25
    1054:	d9 97       	sbiw	r26, 0x39	; 57
    1056:	0f c0       	rjmp	.+30     	; 0x1076 <_ZN5Motor3runEv+0x644>
		} else if(V_m < -24) {
    1058:	88 3e       	cpi	r24, 0xE8	; 232
    105a:	bf ef       	ldi	r27, 0xFF	; 255
    105c:	9b 07       	cpc	r25, r27
    105e:	24 f0       	brlt	.+8      	; 0x1068 <_ZN5Motor3runEv+0x636>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
    1060:	f8 01       	movw	r30, r16
    1062:	80 af       	std	Z+56, r24	; 0x38
    1064:	91 af       	std	Z+57, r25	; 0x39
    1066:	07 c0       	rjmp	.+14     	; 0x1076 <_ZN5Motor3runEv+0x644>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
    1068:	88 ee       	ldi	r24, 0xE8	; 232
    106a:	9f ef       	ldi	r25, 0xFF	; 255
    106c:	d8 01       	movw	r26, r16
    106e:	d8 96       	adiw	r26, 0x38	; 56
    1070:	8d 93       	st	X+, r24
    1072:	9c 93       	st	X, r25
    1074:	d9 97       	sbiw	r26, 0x39	; 57
		}

		
		// PWM function to command motor
		if (output_correct >= 0)
    1076:	f6 01       	movw	r30, r12
    1078:	80 81       	ld	r24, Z
    107a:	91 81       	ldd	r25, Z+1	; 0x01
    107c:	99 23       	and	r25, r25
    107e:	3c f0       	brlt	.+14     	; 0x108e <_ZN5Motor3runEv+0x65c>
		{
			TCC0.CCA = output_correct;
    1080:	e0 e0       	ldi	r30, 0x00	; 0
    1082:	f8 e0       	ldi	r31, 0x08	; 8
    1084:	80 a7       	std	Z+40, r24	; 0x28
    1086:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
    1088:	12 a6       	std	Z+42, r1	; 0x2a
    108a:	13 a6       	std	Z+43, r1	; 0x2b
    108c:	0c c0       	rjmp	.+24     	; 0x10a6 <_ZN5Motor3runEv+0x674>
		}
		else if (output_correct < 0)
		{
			TCC0.CCA = 0;
    108e:	e0 e0       	ldi	r30, 0x00	; 0
    1090:	f8 e0       	ldi	r31, 0x08	; 8
    1092:	10 a6       	std	Z+40, r1	; 0x28
    1094:	11 a6       	std	Z+41, r1	; 0x29
			TCC0.CCB = -output_correct;
    1096:	d6 01       	movw	r26, r12
    1098:	8d 91       	ld	r24, X+
    109a:	9c 91       	ld	r25, X
    109c:	91 95       	neg	r25
    109e:	81 95       	neg	r24
    10a0:	91 09       	sbc	r25, r1
    10a2:	82 a7       	std	Z+42, r24	; 0x2a
    10a4:	93 a7       	std	Z+43, r25	; 0x2b

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
    10a6:	eb 85       	ldd	r30, Y+11	; 0x0b
    10a8:	fc 85       	ldd	r31, Y+12	; 0x0c
    10aa:	20 81       	ld	r18, Z
    10ac:	31 81       	ldd	r19, Z+1	; 0x01
    10ae:	42 81       	ldd	r20, Z+2	; 0x02
    10b0:	53 81       	ldd	r21, Z+3	; 0x03
    10b2:	a8 ee       	ldi	r26, 0xE8	; 232
    10b4:	b3 e0       	ldi	r27, 0x03	; 3
    10b6:	0e 94 13 22 	call	0x4426	; 0x4426 <__muluhisi3>
    10ba:	68 3e       	cpi	r22, 0xE8	; 232
    10bc:	f3 e0       	ldi	r31, 0x03	; 3
    10be:	7f 07       	cpc	r23, r31
    10c0:	81 05       	cpc	r24, r1
    10c2:	91 05       	cpc	r25, r1
    10c4:	48 f0       	brcs	.+18     	; 0x10d8 <_ZN5Motor3runEv+0x6a6>
    10c6:	28 ee       	ldi	r18, 0xE8	; 232
    10c8:	33 e0       	ldi	r19, 0x03	; 3
    10ca:	40 e0       	ldi	r20, 0x00	; 0
    10cc:	50 e0       	ldi	r21, 0x00	; 0
    10ce:	0e 94 ab 21 	call	0x4356	; 0x4356 <__udivmodsi4>
    10d2:	ba 01       	movw	r22, r20
    10d4:	a9 01       	movw	r20, r18
    10d6:	04 c0       	rjmp	.+8      	; 0x10e0 <_ZN5Motor3runEv+0x6ae>
    10d8:	41 e0       	ldi	r20, 0x01	; 1
    10da:	50 e0       	ldi	r21, 0x00	; 0
    10dc:	60 e0       	ldi	r22, 0x00	; 0
    10de:	70 e0       	ldi	r23, 0x00	; 0
    10e0:	ce 01       	movw	r24, r28
    10e2:	01 96       	adiw	r24, 0x01	; 1
    10e4:	0e 94 6c 14 	call	0x28d8	; 0x28d8 <vTaskDelayUntil>
    10e8:	1b cd       	rjmp	.-1482   	; 0xb20 <_ZN5Motor3runEv+0xee>

000010ea <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
    10ea:	0f 93       	push	r16
    10ec:	1f 93       	push	r17
    10ee:	cf 93       	push	r28
    10f0:	df 93       	push	r29
    10f2:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    10f4:	0e 94 09 17 	call	0x2e12	; 0x2e12 <_ZN8frt_taskC1EPKchjP8emstream>
    10f8:	82 e2       	ldi	r24, 0x22	; 34
    10fa:	90 e2       	ldi	r25, 0x20	; 32
    10fc:	88 83       	st	Y, r24
    10fe:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
    1100:	df 91       	pop	r29
    1102:	cf 91       	pop	r28
    1104:	1f 91       	pop	r17
    1106:	0f 91       	pop	r16
    1108:	08 95       	ret

0000110a <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
    110a:	9c 01       	movw	r18, r24
    110c:	93 2f       	mov	r25, r19
    110e:	99 1f       	adc	r25, r25
    1110:	99 27       	eor	r25, r25
    1112:	99 1f       	adc	r25, r25
    1114:	89 2f       	mov	r24, r25
    1116:	90 e0       	ldi	r25, 0x00	; 0
    1118:	81 50       	subi	r24, 0x01	; 1
    111a:	90 48       	sbci	r25, 0x80	; 128
    111c:	43 2f       	mov	r20, r19
    111e:	40 95       	com	r20
    1120:	44 1f       	adc	r20, r20
    1122:	44 27       	eor	r20, r20
    1124:	44 1f       	adc	r20, r20
    1126:	fc 01       	movw	r30, r24
    1128:	e2 1b       	sub	r30, r18
    112a:	f3 0b       	sbc	r31, r19
    112c:	51 e0       	ldi	r21, 0x01	; 1
    112e:	e6 17       	cp	r30, r22
    1130:	f7 07       	cpc	r31, r23
    1132:	0c f0       	brlt	.+2      	; 0x1136 <_ZN7satmath20signed_saturated_addEii+0x2c>
    1134:	50 e0       	ldi	r21, 0x00	; 0
    1136:	45 17       	cp	r20, r21
    1138:	19 f0       	breq	.+6      	; 0x1140 <_ZN7satmath20signed_saturated_addEii+0x36>
    113a:	c9 01       	movw	r24, r18
    113c:	86 0f       	add	r24, r22
    113e:	97 1f       	adc	r25, r23
    1140:	08 95       	ret

00001142 <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    1142:	81 15       	cp	r24, r1
    1144:	20 e8       	ldi	r18, 0x80	; 128
    1146:	92 07       	cpc	r25, r18
    1148:	21 f4       	brne	.+8      	; 0x1152 <_ZN7satmath20signed_saturated_mulEii+0x10>
    114a:	61 15       	cp	r22, r1
    114c:	20 e8       	ldi	r18, 0x80	; 128
    114e:	72 07       	cpc	r23, r18
    1150:	29 f0       	breq	.+10     	; 0x115c <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
    1152:	9c 01       	movw	r18, r24
    1154:	db 01       	movw	r26, r22
    1156:	0e 94 f5 21 	call	0x43ea	; 0x43ea <__mulhisi3>
    115a:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
    115c:	6f ef       	ldi	r22, 0xFF	; 255
    115e:	7f ef       	ldi	r23, 0xFF	; 255
    1160:	8f ef       	ldi	r24, 0xFF	; 255
    1162:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
    1164:	08 95       	ret

00001166 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    1166:	0f 93       	push	r16
    1168:	1f 93       	push	r17
    116a:	cf 93       	push	r28
    116c:	df 93       	push	r29
    116e:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    1170:	0e 94 09 17 	call	0x2e12	; 0x2e12 <_ZN8frt_taskC1EPKchjP8emstream>
    1174:	8a e2       	ldi	r24, 0x2A	; 42
    1176:	90 e2       	ldi	r25, 0x20	; 32
    1178:	88 83       	st	Y, r24
    117a:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    117c:	df 91       	pop	r29
    117e:	cf 91       	pop	r28
    1180:	1f 91       	pop	r17
    1182:	0f 91       	pop	r16
    1184:	08 95       	ret

00001186 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    1186:	0f 93       	push	r16
    1188:	1f 93       	push	r17
    118a:	cf 93       	push	r28
    118c:	df 93       	push	r29
    118e:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    1190:	6a e0       	ldi	r22, 0x0A	; 10
    1192:	8e 81       	ldd	r24, Y+6	; 0x06
    1194:	9f 81       	ldd	r25, Y+7	; 0x07
    1196:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    119a:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    119c:	63 e5       	ldi	r22, 0x53	; 83
    119e:	75 e0       	ldi	r23, 0x05	; 5
    11a0:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    11a4:	6a e0       	ldi	r22, 0x0A	; 10
    11a6:	c8 01       	movw	r24, r16
    11a8:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    11ac:	8c 01       	movw	r16, r24
    11ae:	6d e4       	ldi	r22, 0x4D	; 77
    11b0:	75 e0       	ldi	r23, 0x05	; 5
    11b2:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    11b6:	67 e0       	ldi	r22, 0x07	; 7
    11b8:	c8 01       	movw	r24, r16
    11ba:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    11be:	6a e0       	ldi	r22, 0x0A	; 10
    11c0:	8e 81       	ldd	r24, Y+6	; 0x06
    11c2:	9f 81       	ldd	r25, Y+7	; 0x07
    11c4:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    11c8:	8c 01       	movw	r16, r24
    11ca:	6e e2       	ldi	r22, 0x2E	; 46
    11cc:	75 e0       	ldi	r23, 0x05	; 5
    11ce:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    11d2:	6a e0       	ldi	r22, 0x0A	; 10
    11d4:	c8 01       	movw	r24, r16
    11d6:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    11da:	8c 01       	movw	r16, r24
    11dc:	68 e2       	ldi	r22, 0x28	; 40
    11de:	75 e0       	ldi	r23, 0x05	; 5
    11e0:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    11e4:	66 e0       	ldi	r22, 0x06	; 6
    11e6:	c8 01       	movw	r24, r16
    11e8:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    11ec:	6a e0       	ldi	r22, 0x0A	; 10
    11ee:	8e 81       	ldd	r24, Y+6	; 0x06
    11f0:	9f 81       	ldd	r25, Y+7	; 0x07
    11f2:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    11f6:	8c 01       	movw	r16, r24
    11f8:	61 e1       	ldi	r22, 0x11	; 17
    11fa:	75 e0       	ldi	r23, 0x05	; 5
    11fc:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    1200:	66 e0       	ldi	r22, 0x06	; 6
    1202:	c8 01       	movw	r24, r16
    1204:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    1208:	6a e0       	ldi	r22, 0x0A	; 10
    120a:	8e 81       	ldd	r24, Y+6	; 0x06
    120c:	9f 81       	ldd	r25, Y+7	; 0x07
    120e:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    1212:	8c 01       	movw	r16, r24
    1214:	65 ef       	ldi	r22, 0xF5	; 245
    1216:	74 e0       	ldi	r23, 0x04	; 4
    1218:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    121c:	66 e0       	ldi	r22, 0x06	; 6
    121e:	c8 01       	movw	r24, r16
    1220:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    1224:	6a e0       	ldi	r22, 0x0A	; 10
    1226:	8e 81       	ldd	r24, Y+6	; 0x06
    1228:	9f 81       	ldd	r25, Y+7	; 0x07
    122a:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    122e:	8c 01       	movw	r16, r24
    1230:	6d ed       	ldi	r22, 0xDD	; 221
    1232:	74 e0       	ldi	r23, 0x04	; 4
    1234:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    1238:	66 e0       	ldi	r22, 0x06	; 6
    123a:	c8 01       	movw	r24, r16
    123c:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    1240:	6a e0       	ldi	r22, 0x0A	; 10
    1242:	8e 81       	ldd	r24, Y+6	; 0x06
    1244:	9f 81       	ldd	r25, Y+7	; 0x07
    1246:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    124a:	8c 01       	movw	r16, r24
    124c:	6c eb       	ldi	r22, 0xBC	; 188
    124e:	74 e0       	ldi	r23, 0x04	; 4
    1250:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    1254:	66 e0       	ldi	r22, 0x06	; 6
    1256:	c8 01       	movw	r24, r16
    1258:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    125c:	6a e0       	ldi	r22, 0x0A	; 10
    125e:	8e 81       	ldd	r24, Y+6	; 0x06
    1260:	9f 81       	ldd	r25, Y+7	; 0x07
    1262:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    1266:	8c 01       	movw	r16, r24
    1268:	65 e9       	ldi	r22, 0x95	; 149
    126a:	74 e0       	ldi	r23, 0x04	; 4
    126c:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    1270:	66 e0       	ldi	r22, 0x06	; 6
    1272:	c8 01       	movw	r24, r16
    1274:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    1278:	6a e0       	ldi	r22, 0x0A	; 10
    127a:	8e 81       	ldd	r24, Y+6	; 0x06
    127c:	9f 81       	ldd	r25, Y+7	; 0x07
    127e:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    1282:	8c 01       	movw	r16, r24
    1284:	67 e7       	ldi	r22, 0x77	; 119
    1286:	74 e0       	ldi	r23, 0x04	; 4
    1288:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    128c:	66 e0       	ldi	r22, 0x06	; 6
    128e:	c8 01       	movw	r24, r16
    1290:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    1294:	6a e0       	ldi	r22, 0x0A	; 10
    1296:	8e 81       	ldd	r24, Y+6	; 0x06
    1298:	9f 81       	ldd	r25, Y+7	; 0x07
    129a:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    129e:	8c 01       	movw	r16, r24
    12a0:	6c e5       	ldi	r22, 0x5C	; 92
    12a2:	74 e0       	ldi	r23, 0x04	; 4
    12a4:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    12a8:	66 e0       	ldi	r22, 0x06	; 6
    12aa:	c8 01       	movw	r24, r16
    12ac:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    12b0:	6a e0       	ldi	r22, 0x0A	; 10
    12b2:	8e 81       	ldd	r24, Y+6	; 0x06
    12b4:	9f 81       	ldd	r25, Y+7	; 0x07
    12b6:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    12ba:	8c 01       	movw	r16, r24
    12bc:	6d e4       	ldi	r22, 0x4D	; 77
    12be:	74 e0       	ldi	r23, 0x04	; 4
    12c0:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    12c4:	66 e0       	ldi	r22, 0x06	; 6
    12c6:	c8 01       	movw	r24, r16
    12c8:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    b:   Begin Calibration of Inverted Pendulum?") << endl;
    12cc:	6a e0       	ldi	r22, 0x0A	; 10
    12ce:	8e 81       	ldd	r24, Y+6	; 0x06
    12d0:	9f 81       	ldd	r25, Y+7	; 0x07
    12d2:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    12d6:	8c 01       	movw	r16, r24
    12d8:	6c e1       	ldi	r22, 0x1C	; 28
    12da:	74 e0       	ldi	r23, 0x04	; 4
    12dc:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    12e0:	66 e0       	ldi	r22, 0x06	; 6
    12e2:	c8 01       	movw	r24, r16
    12e4:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    g:   Swing Pendulum Upright, then Go.") << endl;
    12e8:	6a e0       	ldi	r22, 0x0A	; 10
    12ea:	8e 81       	ldd	r24, Y+6	; 0x06
    12ec:	9f 81       	ldd	r25, Y+7	; 0x07
    12ee:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    12f2:	8c 01       	movw	r16, r24
    12f4:	62 ef       	ldi	r22, 0xF2	; 242
    12f6:	73 e0       	ldi	r23, 0x03	; 3
    12f8:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    12fc:	66 e0       	ldi	r22, 0x06	; 6
    12fe:	c8 01       	movw	r24, r16
    1300:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    d:   Emergency Stop") << endl;
    1304:	6a e0       	ldi	r22, 0x0A	; 10
    1306:	8e 81       	ldd	r24, Y+6	; 0x06
    1308:	9f 81       	ldd	r25, Y+7	; 0x07
    130a:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    130e:	8c 01       	movw	r16, r24
    1310:	6a ed       	ldi	r22, 0xDA	; 218
    1312:	73 e0       	ldi	r23, 0x03	; 3
    1314:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    1318:	66 e0       	ldi	r22, 0x06	; 6
    131a:	c8 01       	movw	r24, r16
    131c:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    r:   Reset to Idle") << endl;
    1320:	6a e0       	ldi	r22, 0x0A	; 10
    1322:	8e 81       	ldd	r24, Y+6	; 0x06
    1324:	9f 81       	ldd	r25, Y+7	; 0x07
    1326:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    132a:	ec 01       	movw	r28, r24
    132c:	63 ec       	ldi	r22, 0xC3	; 195
    132e:	73 e0       	ldi	r23, 0x03	; 3
    1330:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    1334:	66 e0       	ldi	r22, 0x06	; 6
    1336:	ce 01       	movw	r24, r28
    1338:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
}
    133c:	df 91       	pop	r29
    133e:	cf 91       	pop	r28
    1340:	1f 91       	pop	r17
    1342:	0f 91       	pop	r16
    1344:	08 95       	ret

00001346 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    1346:	af 92       	push	r10
    1348:	bf 92       	push	r11
    134a:	cf 92       	push	r12
    134c:	df 92       	push	r13
    134e:	ef 92       	push	r14
    1350:	ff 92       	push	r15
    1352:	0f 93       	push	r16
    1354:	1f 93       	push	r17
    1356:	cf 93       	push	r28
    1358:	df 93       	push	r29
    135a:	00 d0       	rcall	.+0      	; 0x135c <_ZN9task_user11show_statusEv+0x16>
    135c:	00 d0       	rcall	.+0      	; 0x135e <_ZN9task_user11show_statusEv+0x18>
    135e:	cd b7       	in	r28, 0x3d	; 61
    1360:	de b7       	in	r29, 0x3e	; 62
    1362:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1364:	19 82       	std	Y+1, r1	; 0x01
    1366:	1a 82       	std	Y+2, r1	; 0x02
    1368:	1b 82       	std	Y+3, r1	; 0x03
    136a:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    136c:	1d 82       	std	Y+5, r1	; 0x05
    136e:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    1370:	0e 94 81 0c 	call	0x1902	; 0x1902 <xPortGetFreeHeapSize>
    1374:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    1376:	ce 01       	movw	r24, r28
    1378:	01 96       	adiw	r24, 0x01	; 1
    137a:	0e 94 ba 1a 	call	0x3574	; 0x3574 <_ZN10time_stamp10set_to_nowEv>
    137e:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program version, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1380:	66 e0       	ldi	r22, 0x06	; 6
    1382:	f8 01       	movw	r30, r16
    1384:	86 81       	ldd	r24, Z+6	; 0x06
    1386:	97 81       	ldd	r25, Z+7	; 0x07
    1388:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    138c:	6a e0       	ldi	r22, 0x0A	; 10
    138e:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    1392:	7c 01       	movw	r14, r24
    1394:	64 ea       	ldi	r22, 0xA4	; 164
    1396:	73 e0       	ldi	r23, 0x03	; 3
    1398:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    139c:	6a e0       	ldi	r22, 0x0A	; 10
    139e:	c7 01       	movw	r24, r14
    13a0:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    13a4:	7c 01       	movw	r14, r24
    13a6:	68 e9       	ldi	r22, 0x98	; 152
    13a8:	73 e0       	ldi	r23, 0x03	; 3
    13aa:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    13ae:	66 e0       	ldi	r22, 0x06	; 6
    13b0:	c7 01       	movw	r24, r14
    13b2:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    13b6:	6a e0       	ldi	r22, 0x0A	; 10
    13b8:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    13bc:	7c 01       	movw	r14, r24
    13be:	61 e9       	ldi	r22, 0x91	; 145
    13c0:	73 e0       	ldi	r23, 0x03	; 3
    13c2:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    13c6:	b5 01       	movw	r22, r10
    13c8:	c7 01       	movw	r24, r14
    13ca:	0e 94 5e 1a 	call	0x34bc	; 0x34bc <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    13ce:	6a e0       	ldi	r22, 0x0A	; 10
    13d0:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    13d4:	7c 01       	movw	r14, r24
    13d6:	63 e8       	ldi	r22, 0x83	; 131
    13d8:	73 e0       	ldi	r23, 0x03	; 3
    13da:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    13de:	b6 01       	movw	r22, r12
    13e0:	c7 01       	movw	r24, r14
    13e2:	0e 94 b5 1c 	call	0x396a	; 0x396a <_ZN8emstreamlsEj>
    13e6:	6a e0       	ldi	r22, 0x0A	; 10
    13e8:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    13ec:	7c 01       	movw	r14, r24
    13ee:	61 e8       	ldi	r22, 0x81	; 129
    13f0:	73 e0       	ldi	r23, 0x03	; 3
    13f2:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    13f6:	4f ef       	ldi	r20, 0xFF	; 255
    13f8:	5f e0       	ldi	r21, 0x0F	; 15
    13fa:	60 e0       	ldi	r22, 0x00	; 0
    13fc:	70 e0       	ldi	r23, 0x00	; 0
    13fe:	c7 01       	movw	r24, r14
    1400:	0e 94 e9 1c 	call	0x39d2	; 0x39d2 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1404:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1408:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    140c:	6a e0       	ldi	r22, 0x0A	; 10
    140e:	f8 01       	movw	r30, r16
    1410:	86 81       	ldd	r24, Z+6	; 0x06
    1412:	97 81       	ldd	r25, Z+7	; 0x07
    1414:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    1418:	7c 01       	movw	r14, r24
    141a:	66 e7       	ldi	r22, 0x76	; 118
    141c:	73 e0       	ldi	r23, 0x03	; 3
    141e:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    1422:	b6 01       	movw	r22, r12
    1424:	c7 01       	movw	r24, r14
    1426:	0e 94 b5 1c 	call	0x396a	; 0x396a <_ZN8emstreamlsEj>
    142a:	66 e0       	ldi	r22, 0x06	; 6
    142c:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    1430:	66 e0       	ldi	r22, 0x06	; 6
    1432:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1436:	f8 01       	movw	r30, r16
    1438:	86 81       	ldd	r24, Z+6	; 0x06
    143a:	97 81       	ldd	r25, Z+7	; 0x07
    143c:	0e 94 17 19 	call	0x322e	; 0x322e <_Z15print_task_listP8emstream>
}
    1440:	26 96       	adiw	r28, 0x06	; 6
    1442:	cd bf       	out	0x3d, r28	; 61
    1444:	de bf       	out	0x3e, r29	; 62
    1446:	df 91       	pop	r29
    1448:	cf 91       	pop	r28
    144a:	1f 91       	pop	r17
    144c:	0f 91       	pop	r16
    144e:	ff 90       	pop	r15
    1450:	ef 90       	pop	r14
    1452:	df 90       	pop	r13
    1454:	cf 90       	pop	r12
    1456:	bf 90       	pop	r11
    1458:	af 90       	pop	r10
    145a:	08 95       	ret

0000145c <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    145c:	cf 93       	push	r28
    145e:	df 93       	push	r29
    1460:	00 d0       	rcall	.+0      	; 0x1462 <_ZN9task_user3runEv+0x6>
    1462:	00 d0       	rcall	.+0      	; 0x1464 <_ZN9task_user3runEv+0x8>
    1464:	cd b7       	in	r28, 0x3d	; 61
    1466:	de b7       	in	r29, 0x3e	; 62
    1468:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    146a:	19 82       	std	Y+1, r1	; 0x01
    146c:	1a 82       	std	Y+2, r1	; 0x02
    146e:	1b 82       	std	Y+3, r1	; 0x03
    1470:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1472:	1d 82       	std	Y+5, r1	; 0x05
    1474:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;
    1476:	6a e0       	ldi	r22, 0x0A	; 10
    1478:	dc 01       	movw	r26, r24
    147a:	16 96       	adiw	r26, 0x06	; 6
    147c:	8d 91       	ld	r24, X+
    147e:	9c 91       	ld	r25, X
    1480:	17 97       	sbiw	r26, 0x07	; 7
    1482:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    1486:	7c 01       	movw	r14, r24
    1488:	61 ef       	ldi	r22, 0xF1	; 241
    148a:	75 e0       	ldi	r23, 0x05	; 5
    148c:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    1490:	66 e0       	ldi	r22, 0x06	; 6
    1492:	c7 01       	movw	r24, r14
    1494:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1498:	f8 01       	movw	r30, r16
    149a:	84 85       	ldd	r24, Z+12	; 0x0c
    149c:	88 23       	and	r24, r24
    149e:	21 f0       	breq	.+8      	; 0x14a8 <_ZN9task_user3runEv+0x4c>
    14a0:	81 30       	cpi	r24, 0x01	; 1
    14a2:	09 f4       	brne	.+2      	; 0x14a6 <_ZN9task_user3runEv+0x4a>
    14a4:	5d c0       	rjmp	.+186    	; 0x1560 <_ZN9task_user3runEv+0x104>
    14a6:	32 c1       	rjmp	.+612    	; 0x170c <_ZN9task_user3runEv+0x2b0>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    14a8:	86 81       	ldd	r24, Z+6	; 0x06
    14aa:	97 81       	ldd	r25, Z+7	; 0x07
    14ac:	dc 01       	movw	r26, r24
    14ae:	ed 91       	ld	r30, X+
    14b0:	fc 91       	ld	r31, X
    14b2:	04 80       	ldd	r0, Z+4	; 0x04
    14b4:	f5 81       	ldd	r31, Z+5	; 0x05
    14b6:	e0 2d       	mov	r30, r0
    14b8:	19 95       	eicall
    14ba:	88 23       	and	r24, r24
    14bc:	a9 f1       	breq	.+106    	; 0x1528 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    14be:	f8 01       	movw	r30, r16
    14c0:	86 81       	ldd	r24, Z+6	; 0x06
    14c2:	97 81       	ldd	r25, Z+7	; 0x07
    14c4:	dc 01       	movw	r26, r24
    14c6:	ed 91       	ld	r30, X+
    14c8:	fc 91       	ld	r31, X
    14ca:	06 80       	ldd	r0, Z+6	; 0x06
    14cc:	f7 81       	ldd	r31, Z+7	; 0x07
    14ce:	e0 2d       	mov	r30, r0
    14d0:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    14d2:	99 27       	eor	r25, r25
    14d4:	81 30       	cpi	r24, 0x01	; 1
    14d6:	91 05       	cpc	r25, r1
    14d8:	f9 f0       	breq	.+62     	; 0x1518 <_ZN9task_user3runEv+0xbc>
    14da:	03 97       	sbiw	r24, 0x03	; 3
    14dc:	09 f0       	breq	.+2      	; 0x14e0 <_ZN9task_user3runEv+0x84>
    14de:	31 c1       	rjmp	.+610    	; 0x1742 <_ZN9task_user3runEv+0x2e6>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    14e0:	6a e0       	ldi	r22, 0x0A	; 10
    14e2:	f8 01       	movw	r30, r16
    14e4:	86 81       	ldd	r24, Z+6	; 0x06
    14e6:	97 81       	ldd	r25, Z+7	; 0x07
    14e8:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    14ec:	8c 01       	movw	r16, r24
    14ee:	63 ee       	ldi	r22, 0xE3	; 227
    14f0:	75 e0       	ldi	r23, 0x05	; 5
    14f2:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    14f6:	66 e0       	ldi	r22, 0x06	; 6
    14f8:	c8 01       	movw	r24, r16
    14fa:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    14fe:	93 e0       	ldi	r25, 0x03	; 3
    1500:	88 ed       	ldi	r24, 0xD8	; 216
    1502:	08 b6       	in	r0, 0x38	; 56
    1504:	18 be       	out	0x38, r1	; 56
    1506:	84 bf       	out	0x34, r24	; 52
    1508:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    150c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1510:	81 fd       	sbrc	r24, 1
    1512:	fc cf       	rjmp	.-8      	; 0x150c <_ZN9task_user3runEv+0xb0>
    1514:	08 be       	out	0x38, r0	; 56
    1516:	ff cf       	rjmp	.-2      	; 0x1516 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1518:	c8 01       	movw	r24, r16
    151a:	0e 94 c3 08 	call	0x1186	; 0x1186 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    151e:	61 e0       	ldi	r22, 0x01	; 1
    1520:	c8 01       	movw	r24, r16
    1522:	0e 94 05 17 	call	0x2e0a	; 0x2e0a <_ZN8frt_task13transition_toEh>
							break;
    1526:	0d c1       	rjmp	.+538    	; 0x1742 <_ZN9task_user3runEv+0x2e6>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1528:	88 e4       	ldi	r24, 0x48	; 72
    152a:	91 e3       	ldi	r25, 0x31	; 49
    152c:	0e 94 c6 19 	call	0x338c	; 0x338c <_ZN14frt_text_queue14check_for_charEv>
    1530:	88 23       	and	r24, r24
    1532:	09 f4       	brne	.+2      	; 0x1536 <_ZN9task_user3runEv+0xda>
    1534:	06 c1       	rjmp	.+524    	; 0x1742 <_ZN9task_user3runEv+0x2e6>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1536:	d8 01       	movw	r26, r16
    1538:	16 96       	adiw	r26, 0x06	; 6
    153a:	ed 91       	ld	r30, X+
    153c:	fc 91       	ld	r31, X
    153e:	17 97       	sbiw	r26, 0x07	; 7
    1540:	01 90       	ld	r0, Z+
    1542:	f0 81       	ld	r31, Z
    1544:	e0 2d       	mov	r30, r0
    1546:	e2 80       	ldd	r14, Z+2	; 0x02
    1548:	f3 80       	ldd	r15, Z+3	; 0x03
    154a:	88 e4       	ldi	r24, 0x48	; 72
    154c:	91 e3       	ldi	r25, 0x31	; 49
    154e:	0e 94 a8 19 	call	0x3350	; 0x3350 <_ZN14frt_text_queue7getcharEv>
    1552:	68 2f       	mov	r22, r24
    1554:	f8 01       	movw	r30, r16
    1556:	86 81       	ldd	r24, Z+6	; 0x06
    1558:	97 81       	ldd	r25, Z+7	; 0x07
    155a:	f7 01       	movw	r30, r14
    155c:	19 95       	eicall
    155e:	f1 c0       	rjmp	.+482    	; 0x1742 <_ZN9task_user3runEv+0x2e6>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1560:	86 81       	ldd	r24, Z+6	; 0x06
    1562:	97 81       	ldd	r25, Z+7	; 0x07
    1564:	dc 01       	movw	r26, r24
    1566:	ed 91       	ld	r30, X+
    1568:	fc 91       	ld	r31, X
    156a:	04 80       	ldd	r0, Z+4	; 0x04
    156c:	f5 81       	ldd	r31, Z+5	; 0x05
    156e:	e0 2d       	mov	r30, r0
    1570:	19 95       	eicall
    1572:	88 23       	and	r24, r24
    1574:	09 f4       	brne	.+2      	; 0x1578 <_ZN9task_user3runEv+0x11c>
    1576:	e5 c0       	rjmp	.+458    	; 0x1742 <_ZN9task_user3runEv+0x2e6>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1578:	f8 01       	movw	r30, r16
    157a:	86 81       	ldd	r24, Z+6	; 0x06
    157c:	97 81       	ldd	r25, Z+7	; 0x07
    157e:	dc 01       	movw	r26, r24
    1580:	ed 91       	ld	r30, X+
    1582:	fc 91       	ld	r31, X
    1584:	06 80       	ldd	r0, Z+6	; 0x06
    1586:	f7 81       	ldd	r31, Z+7	; 0x07
    1588:	e0 2d       	mov	r30, r0
    158a:	19 95       	eicall
    158c:	bc 01       	movw	r22, r24

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    158e:	fc 01       	movw	r30, r24
    1590:	ff 27       	eor	r31, r31
    1592:	7b 97       	sbiw	r30, 0x1b	; 27
    1594:	ec 35       	cpi	r30, 0x5C	; 92
    1596:	f1 05       	cpc	r31, r1
    1598:	08 f0       	brcs	.+2      	; 0x159c <_ZN9task_user3runEv+0x140>
    159a:	9c c0       	rjmp	.+312    	; 0x16d4 <_ZN9task_user3runEv+0x278>
    159c:	88 27       	eor	r24, r24
    159e:	e2 50       	subi	r30, 0x02	; 2
    15a0:	ff 4f       	sbci	r31, 0xFF	; 255
    15a2:	8f 4f       	sbci	r24, 0xFF	; 255
    15a4:	0c 94 ec 21 	jmp	0x43d8	; 0x43d8 <__tablejump2__>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    15a8:	ce 01       	movw	r24, r28
    15aa:	01 96       	adiw	r24, 0x01	; 1
    15ac:	0e 94 ba 1a 	call	0x3574	; 0x3574 <_ZN10time_stamp10set_to_nowEv>
    15b0:	bc 01       	movw	r22, r24
    15b2:	f8 01       	movw	r30, r16
    15b4:	86 81       	ldd	r24, Z+6	; 0x06
    15b6:	97 81       	ldd	r25, Z+7	; 0x07
    15b8:	0e 94 5e 1a 	call	0x34bc	; 0x34bc <_ZlsR8emstreamR10time_stamp>
    15bc:	66 e0       	ldi	r22, 0x06	; 6
    15be:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
							break;
    15c2:	bf c0       	rjmp	.+382    	; 0x1742 <_ZN9task_user3runEv+0x2e6>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    15c4:	c8 01       	movw	r24, r16
    15c6:	0e 94 a3 09 	call	0x1346	; 0x1346 <_ZN9task_user11show_statusEv>
							break;
    15ca:	bb c0       	rjmp	.+374    	; 0x1742 <_ZN9task_user3runEv+0x2e6>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    15cc:	d8 01       	movw	r26, r16
    15ce:	16 96       	adiw	r26, 0x06	; 6
    15d0:	8d 91       	ld	r24, X+
    15d2:	9c 91       	ld	r25, X
    15d4:	17 97       	sbiw	r26, 0x07	; 7
    15d6:	0e 94 1e 18 	call	0x303c	; 0x303c <_Z17print_task_stacksP8emstream>
							break;
    15da:	b3 c0       	rjmp	.+358    	; 0x1742 <_ZN9task_user3runEv+0x2e6>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    15dc:	c8 01       	movw	r24, r16
    15de:	0e 94 c3 08 	call	0x1186	; 0x1186 <_ZN9task_user18print_help_messageEv>
							break;
    15e2:	af c0       	rjmp	.+350    	; 0x1742 <_ZN9task_user3runEv+0x2e6>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    15e4:	6a e0       	ldi	r22, 0x0A	; 10
    15e6:	f8 01       	movw	r30, r16
    15e8:	86 81       	ldd	r24, Z+6	; 0x06
    15ea:	97 81       	ldd	r25, Z+7	; 0x07
    15ec:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    15f0:	7c 01       	movw	r14, r24
    15f2:	61 ed       	ldi	r22, 0xD1	; 209
    15f4:	75 e0       	ldi	r23, 0x05	; 5
    15f6:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    15fa:	66 e0       	ldi	r22, 0x06	; 6
    15fc:	c7 01       	movw	r24, r14
    15fe:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0); 
    1602:	60 e0       	ldi	r22, 0x00	; 0
    1604:	c8 01       	movw	r24, r16
    1606:	0e 94 05 17 	call	0x2e0a	; 0x2e0a <_ZN8frt_task13transition_toEh>
							break;
    160a:	9b c0       	rjmp	.+310    	; 0x1742 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    160c:	0f b6       	in	r0, 0x3f	; 63
    160e:	f8 94       	cli
    1610:	0f 92       	push	r0
			the_data = new_data;
    1612:	81 e0       	ldi	r24, 0x01	; 1
    1614:	80 93 3d 31 	sts	0x313D, r24	; 0x80313d <begin>
			portEXIT_CRITICAL ();
    1618:	0f 90       	pop	r0
    161a:	0f be       	out	0x3f, r0	; 63
							
						case ('b'):
							begin.put(true);
							*p_serial << PMS ("Begin Homing") << endl;
    161c:	6a e0       	ldi	r22, 0x0A	; 10
    161e:	d8 01       	movw	r26, r16
    1620:	16 96       	adiw	r26, 0x06	; 6
    1622:	8d 91       	ld	r24, X+
    1624:	9c 91       	ld	r25, X
    1626:	17 97       	sbiw	r26, 0x07	; 7
    1628:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    162c:	7c 01       	movw	r14, r24
    162e:	64 ec       	ldi	r22, 0xC4	; 196
    1630:	75 e0       	ldi	r23, 0x05	; 5
    1632:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    1636:	66 e0       	ldi	r22, 0x06	; 6
    1638:	c7 01       	movw	r24, r14
    163a:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
							break;
    163e:	81 c0       	rjmp	.+258    	; 0x1742 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    1640:	0f b6       	in	r0, 0x3f	; 63
    1642:	f8 94       	cli
    1644:	0f 92       	push	r0
			the_data = new_data;
    1646:	81 e0       	ldi	r24, 0x01	; 1
    1648:	80 93 3c 31 	sts	0x313C, r24	; 0x80313c <go>
			portEXIT_CRITICAL ();
    164c:	0f 90       	pop	r0
    164e:	0f be       	out	0x3f, r0	; 63
						
						case ('g'):
							go.put(true);
							*p_serial << PMS ("Commence Balance") << endl;
    1650:	6a e0       	ldi	r22, 0x0A	; 10
    1652:	f8 01       	movw	r30, r16
    1654:	86 81       	ldd	r24, Z+6	; 0x06
    1656:	97 81       	ldd	r25, Z+7	; 0x07
    1658:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    165c:	7c 01       	movw	r14, r24
    165e:	63 eb       	ldi	r22, 0xB3	; 179
    1660:	75 e0       	ldi	r23, 0x05	; 5
    1662:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    1666:	66 e0       	ldi	r22, 0x06	; 6
    1668:	c7 01       	movw	r24, r14
    166a:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
							break;
    166e:	69 c0       	rjmp	.+210    	; 0x1742 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    1670:	0f b6       	in	r0, 0x3f	; 63
    1672:	f8 94       	cli
    1674:	0f 92       	push	r0
			the_data = new_data;
    1676:	81 e0       	ldi	r24, 0x01	; 1
    1678:	80 93 3b 31 	sts	0x313B, r24	; 0x80313b <stop>
			portEXIT_CRITICAL ();
    167c:	0f 90       	pop	r0
    167e:	0f be       	out	0x3f, r0	; 63
						
						case('d'):
							stop.put(true);
							*p_serial << PMS ("EMERGENCY STOP") << endl;
    1680:	6a e0       	ldi	r22, 0x0A	; 10
    1682:	d8 01       	movw	r26, r16
    1684:	16 96       	adiw	r26, 0x06	; 6
    1686:	8d 91       	ld	r24, X+
    1688:	9c 91       	ld	r25, X
    168a:	17 97       	sbiw	r26, 0x07	; 7
    168c:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    1690:	7c 01       	movw	r14, r24
    1692:	64 ea       	ldi	r22, 0xA4	; 164
    1694:	75 e0       	ldi	r23, 0x05	; 5
    1696:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    169a:	66 e0       	ldi	r22, 0x06	; 6
    169c:	c7 01       	movw	r24, r14
    169e:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
							break;
    16a2:	4f c0       	rjmp	.+158    	; 0x1742 <_ZN9task_user3runEv+0x2e6>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
    16a4:	0f b6       	in	r0, 0x3f	; 63
    16a6:	f8 94       	cli
    16a8:	0f 92       	push	r0
			the_data = new_data;
    16aa:	81 e0       	ldi	r24, 0x01	; 1
    16ac:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <reset>
			portEXIT_CRITICAL ();
    16b0:	0f 90       	pop	r0
    16b2:	0f be       	out	0x3f, r0	; 63
						
						case('r'):
							reset.put(true);
							*p_serial << PMS ("Reset, try Homing again by pressing 'b'") << endl;
    16b4:	6a e0       	ldi	r22, 0x0A	; 10
    16b6:	f8 01       	movw	r30, r16
    16b8:	86 81       	ldd	r24, Z+6	; 0x06
    16ba:	97 81       	ldd	r25, Z+7	; 0x07
    16bc:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    16c0:	7c 01       	movw	r14, r24
    16c2:	6c e7       	ldi	r22, 0x7C	; 124
    16c4:	75 e0       	ldi	r23, 0x05	; 5
    16c6:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    16ca:	66 e0       	ldi	r22, 0x06	; 6
    16cc:	c7 01       	movw	r24, r14
    16ce:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
							break;
    16d2:	37 c0       	rjmp	.+110    	; 0x1742 <_ZN9task_user3runEv+0x2e6>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    16d4:	d8 01       	movw	r26, r16
    16d6:	16 96       	adiw	r26, 0x06	; 6
    16d8:	8d 91       	ld	r24, X+
    16da:	9c 91       	ld	r25, X
    16dc:	17 97       	sbiw	r26, 0x07	; 7
    16de:	dc 01       	movw	r26, r24
    16e0:	ed 91       	ld	r30, X+
    16e2:	fc 91       	ld	r31, X
    16e4:	02 80       	ldd	r0, Z+2	; 0x02
    16e6:	f3 81       	ldd	r31, Z+3	; 0x03
    16e8:	e0 2d       	mov	r30, r0
    16ea:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    16ec:	6a e0       	ldi	r22, 0x0A	; 10
    16ee:	f8 01       	movw	r30, r16
    16f0:	86 81       	ldd	r24, Z+6	; 0x06
    16f2:	97 81       	ldd	r25, Z+7	; 0x07
    16f4:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    16f8:	7c 01       	movw	r14, r24
    16fa:	66 e7       	ldi	r22, 0x76	; 118
    16fc:	75 e0       	ldi	r23, 0x05	; 5
    16fe:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    1702:	66 e0       	ldi	r22, 0x06	; 6
    1704:	c7 01       	movw	r24, r14
    1706:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
							break;
    170a:	1b c0       	rjmp	.+54     	; 0x1742 <_ZN9task_user3runEv+0x2e6>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    170c:	6a e0       	ldi	r22, 0x0A	; 10
    170e:	86 81       	ldd	r24, Z+6	; 0x06
    1710:	97 81       	ldd	r25, Z+7	; 0x07
    1712:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    1716:	8c 01       	movw	r16, r24
    1718:	69 e5       	ldi	r22, 0x59	; 89
    171a:	75 e0       	ldi	r23, 0x05	; 5
    171c:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    1720:	66 e0       	ldi	r22, 0x06	; 6
    1722:	c8 01       	movw	r24, r16
    1724:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1728:	93 e0       	ldi	r25, 0x03	; 3
    172a:	88 ed       	ldi	r24, 0xD8	; 216
    172c:	08 b6       	in	r0, 0x38	; 56
    172e:	18 be       	out	0x38, r1	; 56
    1730:	84 bf       	out	0x34, r24	; 52
    1732:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1736:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    173a:	81 fd       	sbrc	r24, 1
    173c:	fc cf       	rjmp	.-8      	; 0x1736 <_ZN9task_user3runEv+0x2da>
    173e:	08 be       	out	0x38, r0	; 56
    1740:	ff cf       	rjmp	.-2      	; 0x1740 <_ZN9task_user3runEv+0x2e4>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1742:	f8 01       	movw	r30, r16
    1744:	86 85       	ldd	r24, Z+14	; 0x0e
    1746:	97 85       	ldd	r25, Z+15	; 0x0f
    1748:	a0 89       	ldd	r26, Z+16	; 0x10
    174a:	b1 89       	ldd	r27, Z+17	; 0x11
    174c:	01 96       	adiw	r24, 0x01	; 1
    174e:	a1 1d       	adc	r26, r1
    1750:	b1 1d       	adc	r27, r1
    1752:	86 87       	std	Z+14, r24	; 0x0e
    1754:	97 87       	std	Z+15, r25	; 0x0f
    1756:	a0 8b       	std	Z+16, r26	; 0x10
    1758:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    175a:	61 e0       	ldi	r22, 0x01	; 1
    175c:	70 e0       	ldi	r23, 0x00	; 0
    175e:	80 e0       	ldi	r24, 0x00	; 0
    1760:	90 e0       	ldi	r25, 0x00	; 0
    1762:	0e 94 d9 14 	call	0x29b2	; 0x29b2 <vTaskDelay>
	*p_serial << PMS ("Press Ctrl-A to get to command mode for Inverted Pendulum") << endl;

	
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1766:	98 ce       	rjmp	.-720    	; 0x1498 <_ZN9task_user3runEv+0x3c>

00001768 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1768:	0f 93       	push	r16
    176a:	1f 93       	push	r17
    176c:	cf 93       	push	r28
    176e:	df 93       	push	r29
    1770:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1772:	0e 94 c8 12 	call	0x2590	; 0x2590 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1776:	80 91 b0 20 	lds	r24, 0x20B0	; 0x8020b0 <__data_end>
    177a:	81 11       	cpse	r24, r1
    177c:	1d c0       	rjmp	.+58     	; 0x17b8 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    177e:	a5 eb       	ldi	r26, 0xB5	; 181
    1780:	b0 e2       	ldi	r27, 0x20	; 32
    1782:	e9 eb       	ldi	r30, 0xB9	; 185
    1784:	f0 e2       	ldi	r31, 0x20	; 32
    1786:	ed 93       	st	X+, r30
    1788:	fc 93       	st	X, r31
    178a:	11 97       	sbiw	r26, 0x01	; 1
    178c:	12 96       	adiw	r26, 0x02	; 2
    178e:	1d 92       	st	X+, r1
    1790:	1c 92       	st	X, r1
    1792:	13 97       	sbiw	r26, 0x03	; 3
    1794:	a1 eb       	ldi	r26, 0xB1	; 177
    1796:	b0 e2       	ldi	r27, 0x20	; 32
    1798:	8f ef       	ldi	r24, 0xFF	; 255
    179a:	9f e0       	ldi	r25, 0x0F	; 15
    179c:	12 96       	adiw	r26, 0x02	; 2
    179e:	8d 93       	st	X+, r24
    17a0:	9c 93       	st	X, r25
    17a2:	13 97       	sbiw	r26, 0x03	; 3
    17a4:	1d 92       	st	X+, r1
    17a6:	1c 92       	st	X, r1
    17a8:	11 97       	sbiw	r26, 0x01	; 1
    17aa:	82 83       	std	Z+2, r24	; 0x02
    17ac:	93 83       	std	Z+3, r25	; 0x03
    17ae:	a0 83       	st	Z, r26
    17b0:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    17b2:	81 e0       	ldi	r24, 0x01	; 1
    17b4:	80 93 b0 20 	sts	0x20B0, r24	; 0x8020b0 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    17b8:	20 97       	sbiw	r28, 0x00	; 0
    17ba:	09 f4       	brne	.+2      	; 0x17be <pvPortMalloc+0x56>
    17bc:	5f c0       	rjmp	.+190    	; 0x187c <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    17be:	9e 01       	movw	r18, r28
    17c0:	2b 5f       	subi	r18, 0xFB	; 251
    17c2:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    17c4:	24 96       	adiw	r28, 0x04	; 4
    17c6:	ce 3f       	cpi	r28, 0xFE	; 254
    17c8:	df 40       	sbci	r29, 0x0F	; 15
    17ca:	08 f0       	brcs	.+2      	; 0x17ce <pvPortMalloc+0x66>
    17cc:	5a c0       	rjmp	.+180    	; 0x1882 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    17ce:	e0 91 b5 20 	lds	r30, 0x20B5	; 0x8020b5 <xStart>
    17d2:	f0 91 b6 20 	lds	r31, 0x20B6	; 0x8020b6 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    17d6:	a5 eb       	ldi	r26, 0xB5	; 181
    17d8:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    17da:	02 c0       	rjmp	.+4      	; 0x17e0 <pvPortMalloc+0x78>
    17dc:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    17de:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    17e0:	82 81       	ldd	r24, Z+2	; 0x02
    17e2:	93 81       	ldd	r25, Z+3	; 0x03
    17e4:	82 17       	cp	r24, r18
    17e6:	93 07       	cpc	r25, r19
    17e8:	20 f4       	brcc	.+8      	; 0x17f2 <pvPortMalloc+0x8a>
    17ea:	80 81       	ld	r24, Z
    17ec:	91 81       	ldd	r25, Z+1	; 0x01
    17ee:	00 97       	sbiw	r24, 0x00	; 0
    17f0:	a9 f7       	brne	.-22     	; 0x17dc <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    17f2:	c0 e2       	ldi	r28, 0x20	; 32
    17f4:	e1 3b       	cpi	r30, 0xB1	; 177
    17f6:	fc 07       	cpc	r31, r28
    17f8:	09 f4       	brne	.+2      	; 0x17fc <pvPortMalloc+0x94>
    17fa:	46 c0       	rjmp	.+140    	; 0x1888 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    17fc:	cd 91       	ld	r28, X+
    17fe:	dc 91       	ld	r29, X
    1800:	11 97       	sbiw	r26, 0x01	; 1
    1802:	8e 01       	movw	r16, r28
    1804:	0b 5f       	subi	r16, 0xFB	; 251
    1806:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1808:	80 81       	ld	r24, Z
    180a:	91 81       	ldd	r25, Z+1	; 0x01
    180c:	8d 93       	st	X+, r24
    180e:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1810:	82 81       	ldd	r24, Z+2	; 0x02
    1812:	93 81       	ldd	r25, Z+3	; 0x03
    1814:	82 1b       	sub	r24, r18
    1816:	93 0b       	sbc	r25, r19
    1818:	8b 30       	cpi	r24, 0x0B	; 11
    181a:	91 05       	cpc	r25, r1
    181c:	10 f1       	brcs	.+68     	; 0x1862 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    181e:	bf 01       	movw	r22, r30
    1820:	62 0f       	add	r22, r18
    1822:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1824:	db 01       	movw	r26, r22
    1826:	12 96       	adiw	r26, 0x02	; 2
    1828:	8d 93       	st	X+, r24
    182a:	9c 93       	st	X, r25
    182c:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    182e:	22 83       	std	Z+2, r18	; 0x02
    1830:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1832:	12 96       	adiw	r26, 0x02	; 2
    1834:	4d 91       	ld	r20, X+
    1836:	5c 91       	ld	r21, X
    1838:	13 97       	sbiw	r26, 0x03	; 3
    183a:	85 eb       	ldi	r24, 0xB5	; 181
    183c:	90 e2       	ldi	r25, 0x20	; 32
    183e:	01 c0       	rjmp	.+2      	; 0x1842 <pvPortMalloc+0xda>
    1840:	cd 01       	movw	r24, r26
    1842:	ec 01       	movw	r28, r24
    1844:	a8 81       	ld	r26, Y
    1846:	b9 81       	ldd	r27, Y+1	; 0x01
    1848:	12 96       	adiw	r26, 0x02	; 2
    184a:	2d 91       	ld	r18, X+
    184c:	3c 91       	ld	r19, X
    184e:	13 97       	sbiw	r26, 0x03	; 3
    1850:	24 17       	cp	r18, r20
    1852:	35 07       	cpc	r19, r21
    1854:	a8 f3       	brcs	.-22     	; 0x1840 <pvPortMalloc+0xd8>
    1856:	eb 01       	movw	r28, r22
    1858:	a8 83       	st	Y, r26
    185a:	b9 83       	std	Y+1, r27	; 0x01
    185c:	dc 01       	movw	r26, r24
    185e:	6d 93       	st	X+, r22
    1860:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1862:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1866:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    186a:	22 81       	ldd	r18, Z+2	; 0x02
    186c:	33 81       	ldd	r19, Z+3	; 0x03
    186e:	82 1b       	sub	r24, r18
    1870:	93 0b       	sbc	r25, r19
    1872:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1876:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    187a:	08 c0       	rjmp	.+16     	; 0x188c <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    187c:	00 e0       	ldi	r16, 0x00	; 0
    187e:	10 e0       	ldi	r17, 0x00	; 0
    1880:	05 c0       	rjmp	.+10     	; 0x188c <pvPortMalloc+0x124>
    1882:	00 e0       	ldi	r16, 0x00	; 0
    1884:	10 e0       	ldi	r17, 0x00	; 0
    1886:	02 c0       	rjmp	.+4      	; 0x188c <pvPortMalloc+0x124>
    1888:	00 e0       	ldi	r16, 0x00	; 0
    188a:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    188c:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1890:	c8 01       	movw	r24, r16
    1892:	df 91       	pop	r29
    1894:	cf 91       	pop	r28
    1896:	1f 91       	pop	r17
    1898:	0f 91       	pop	r16
    189a:	08 95       	ret

0000189c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    189c:	0f 93       	push	r16
    189e:	1f 93       	push	r17
    18a0:	cf 93       	push	r28
    18a2:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    18a4:	00 97       	sbiw	r24, 0x00	; 0
    18a6:	41 f1       	breq	.+80     	; 0x18f8 <vPortFree+0x5c>
    18a8:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    18aa:	8c 01       	movw	r16, r24
    18ac:	05 50       	subi	r16, 0x05	; 5
    18ae:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    18b0:	0e 94 c8 12 	call	0x2590	; 0x2590 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    18b4:	f8 01       	movw	r30, r16
    18b6:	42 81       	ldd	r20, Z+2	; 0x02
    18b8:	53 81       	ldd	r21, Z+3	; 0x03
    18ba:	a5 eb       	ldi	r26, 0xB5	; 181
    18bc:	b0 e2       	ldi	r27, 0x20	; 32
    18be:	01 c0       	rjmp	.+2      	; 0x18c2 <vPortFree+0x26>
    18c0:	df 01       	movw	r26, r30
    18c2:	ed 91       	ld	r30, X+
    18c4:	fc 91       	ld	r31, X
    18c6:	11 97       	sbiw	r26, 0x01	; 1
    18c8:	22 81       	ldd	r18, Z+2	; 0x02
    18ca:	33 81       	ldd	r19, Z+3	; 0x03
    18cc:	24 17       	cp	r18, r20
    18ce:	35 07       	cpc	r19, r21
    18d0:	b8 f3       	brcs	.-18     	; 0x18c0 <vPortFree+0x24>
    18d2:	25 97       	sbiw	r28, 0x05	; 5
    18d4:	e8 83       	st	Y, r30
    18d6:	f9 83       	std	Y+1, r31	; 0x01
    18d8:	0d 93       	st	X+, r16
    18da:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    18dc:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    18e0:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    18e4:	8a 81       	ldd	r24, Y+2	; 0x02
    18e6:	9b 81       	ldd	r25, Y+3	; 0x03
    18e8:	82 0f       	add	r24, r18
    18ea:	93 1f       	adc	r25, r19
    18ec:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    18f0:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    18f4:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <xTaskResumeAll>
	}
}
    18f8:	df 91       	pop	r29
    18fa:	cf 91       	pop	r28
    18fc:	1f 91       	pop	r17
    18fe:	0f 91       	pop	r16
    1900:	08 95       	ret

00001902 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1902:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1906:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    190a:	08 95       	ret

0000190c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    190c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    190e:	03 96       	adiw	r24, 0x03	; 3
    1910:	81 83       	std	Z+1, r24	; 0x01
    1912:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1914:	4f ef       	ldi	r20, 0xFF	; 255
    1916:	5f ef       	ldi	r21, 0xFF	; 255
    1918:	ba 01       	movw	r22, r20
    191a:	43 83       	std	Z+3, r20	; 0x03
    191c:	54 83       	std	Z+4, r21	; 0x04
    191e:	65 83       	std	Z+5, r22	; 0x05
    1920:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1922:	87 83       	std	Z+7, r24	; 0x07
    1924:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1926:	81 87       	std	Z+9, r24	; 0x09
    1928:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    192a:	10 82       	st	Z, r1
    192c:	08 95       	ret

0000192e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    192e:	fc 01       	movw	r30, r24
    1930:	12 86       	std	Z+10, r1	; 0x0a
    1932:	13 86       	std	Z+11, r1	; 0x0b
    1934:	08 95       	ret

00001936 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1936:	cf 93       	push	r28
    1938:	df 93       	push	r29
    193a:	fc 01       	movw	r30, r24
    193c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    193e:	21 81       	ldd	r18, Z+1	; 0x01
    1940:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1942:	e9 01       	movw	r28, r18
    1944:	8c 81       	ldd	r24, Y+4	; 0x04
    1946:	9d 81       	ldd	r25, Y+5	; 0x05
    1948:	14 96       	adiw	r26, 0x04	; 4
    194a:	8d 93       	st	X+, r24
    194c:	9c 93       	st	X, r25
    194e:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1950:	81 81       	ldd	r24, Z+1	; 0x01
    1952:	92 81       	ldd	r25, Z+2	; 0x02
    1954:	16 96       	adiw	r26, 0x06	; 6
    1956:	8d 93       	st	X+, r24
    1958:	9c 93       	st	X, r25
    195a:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    195c:	8c 81       	ldd	r24, Y+4	; 0x04
    195e:	9d 81       	ldd	r25, Y+5	; 0x05
    1960:	ec 01       	movw	r28, r24
    1962:	6e 83       	std	Y+6, r22	; 0x06
    1964:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1966:	e9 01       	movw	r28, r18
    1968:	6c 83       	std	Y+4, r22	; 0x04
    196a:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    196c:	61 83       	std	Z+1, r22	; 0x01
    196e:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1970:	1a 96       	adiw	r26, 0x0a	; 10
    1972:	ed 93       	st	X+, r30
    1974:	fc 93       	st	X, r31
    1976:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1978:	80 81       	ld	r24, Z
    197a:	8f 5f       	subi	r24, 0xFF	; 255
    197c:	80 83       	st	Z, r24
}
    197e:	df 91       	pop	r29
    1980:	cf 91       	pop	r28
    1982:	08 95       	ret

00001984 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1984:	0f 93       	push	r16
    1986:	1f 93       	push	r17
    1988:	cf 93       	push	r28
    198a:	df 93       	push	r29
    198c:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    198e:	08 81       	ld	r16, Y
    1990:	19 81       	ldd	r17, Y+1	; 0x01
    1992:	2a 81       	ldd	r18, Y+2	; 0x02
    1994:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1996:	0f 3f       	cpi	r16, 0xFF	; 255
    1998:	4f ef       	ldi	r20, 0xFF	; 255
    199a:	14 07       	cpc	r17, r20
    199c:	24 07       	cpc	r18, r20
    199e:	34 07       	cpc	r19, r20
    19a0:	31 f4       	brne	.+12     	; 0x19ae <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    19a2:	dc 01       	movw	r26, r24
    19a4:	19 96       	adiw	r26, 0x09	; 9
    19a6:	ed 91       	ld	r30, X+
    19a8:	fc 91       	ld	r31, X
    19aa:	1a 97       	sbiw	r26, 0x0a	; 10
    19ac:	1f c0       	rjmp	.+62     	; 0x19ec <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    19ae:	fc 01       	movw	r30, r24
    19b0:	33 96       	adiw	r30, 0x03	; 3
    19b2:	dc 01       	movw	r26, r24
    19b4:	17 96       	adiw	r26, 0x07	; 7
    19b6:	4d 91       	ld	r20, X+
    19b8:	5c 91       	ld	r21, X
    19ba:	18 97       	sbiw	r26, 0x08	; 8
    19bc:	da 01       	movw	r26, r20
    19be:	4d 91       	ld	r20, X+
    19c0:	5d 91       	ld	r21, X+
    19c2:	6d 91       	ld	r22, X+
    19c4:	7c 91       	ld	r23, X
    19c6:	04 17       	cp	r16, r20
    19c8:	15 07       	cpc	r17, r21
    19ca:	26 07       	cpc	r18, r22
    19cc:	37 07       	cpc	r19, r23
    19ce:	70 f0       	brcs	.+28     	; 0x19ec <vListInsert+0x68>
    19d0:	04 80       	ldd	r0, Z+4	; 0x04
    19d2:	f5 81       	ldd	r31, Z+5	; 0x05
    19d4:	e0 2d       	mov	r30, r0
    19d6:	a4 81       	ldd	r26, Z+4	; 0x04
    19d8:	b5 81       	ldd	r27, Z+5	; 0x05
    19da:	4d 91       	ld	r20, X+
    19dc:	5d 91       	ld	r21, X+
    19de:	6d 91       	ld	r22, X+
    19e0:	7c 91       	ld	r23, X
    19e2:	04 17       	cp	r16, r20
    19e4:	15 07       	cpc	r17, r21
    19e6:	26 07       	cpc	r18, r22
    19e8:	37 07       	cpc	r19, r23
    19ea:	90 f7       	brcc	.-28     	; 0x19d0 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    19ec:	a4 81       	ldd	r26, Z+4	; 0x04
    19ee:	b5 81       	ldd	r27, Z+5	; 0x05
    19f0:	ac 83       	std	Y+4, r26	; 0x04
    19f2:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    19f4:	16 96       	adiw	r26, 0x06	; 6
    19f6:	cd 93       	st	X+, r28
    19f8:	dc 93       	st	X, r29
    19fa:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    19fc:	ee 83       	std	Y+6, r30	; 0x06
    19fe:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1a00:	c4 83       	std	Z+4, r28	; 0x04
    1a02:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1a04:	8a 87       	std	Y+10, r24	; 0x0a
    1a06:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1a08:	fc 01       	movw	r30, r24
    1a0a:	20 81       	ld	r18, Z
    1a0c:	2f 5f       	subi	r18, 0xFF	; 255
    1a0e:	20 83       	st	Z, r18
}
    1a10:	df 91       	pop	r29
    1a12:	cf 91       	pop	r28
    1a14:	1f 91       	pop	r17
    1a16:	0f 91       	pop	r16
    1a18:	08 95       	ret

00001a1a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1a1a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1a1c:	a4 81       	ldd	r26, Z+4	; 0x04
    1a1e:	b5 81       	ldd	r27, Z+5	; 0x05
    1a20:	86 81       	ldd	r24, Z+6	; 0x06
    1a22:	97 81       	ldd	r25, Z+7	; 0x07
    1a24:	16 96       	adiw	r26, 0x06	; 6
    1a26:	8d 93       	st	X+, r24
    1a28:	9c 93       	st	X, r25
    1a2a:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1a2c:	a6 81       	ldd	r26, Z+6	; 0x06
    1a2e:	b7 81       	ldd	r27, Z+7	; 0x07
    1a30:	84 81       	ldd	r24, Z+4	; 0x04
    1a32:	95 81       	ldd	r25, Z+5	; 0x05
    1a34:	14 96       	adiw	r26, 0x04	; 4
    1a36:	8d 93       	st	X+, r24
    1a38:	9c 93       	st	X, r25
    1a3a:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1a3c:	a2 85       	ldd	r26, Z+10	; 0x0a
    1a3e:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1a40:	11 96       	adiw	r26, 0x01	; 1
    1a42:	8d 91       	ld	r24, X+
    1a44:	9c 91       	ld	r25, X
    1a46:	12 97       	sbiw	r26, 0x02	; 2
    1a48:	e8 17       	cp	r30, r24
    1a4a:	f9 07       	cpc	r31, r25
    1a4c:	31 f4       	brne	.+12     	; 0x1a5a <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1a4e:	86 81       	ldd	r24, Z+6	; 0x06
    1a50:	97 81       	ldd	r25, Z+7	; 0x07
    1a52:	11 96       	adiw	r26, 0x01	; 1
    1a54:	8d 93       	st	X+, r24
    1a56:	9c 93       	st	X, r25
    1a58:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1a5a:	12 86       	std	Z+10, r1	; 0x0a
    1a5c:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1a5e:	8c 91       	ld	r24, X
    1a60:	81 50       	subi	r24, 0x01	; 1
    1a62:	8c 93       	st	X, r24
    1a64:	08 95       	ret

00001a66 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a66:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <portStackTopForTask>
    1a6a:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <portStackTopForTask+0x1>
    1a6e:	31 e1       	ldi	r19, 0x11	; 17
    1a70:	fc 01       	movw	r30, r24
    1a72:	30 83       	st	Z, r19
    1a74:	31 97       	sbiw	r30, 0x01	; 1
    1a76:	22 e2       	ldi	r18, 0x22	; 34
    1a78:	20 83       	st	Z, r18
    1a7a:	31 97       	sbiw	r30, 0x01	; 1
    1a7c:	a3 e3       	ldi	r26, 0x33	; 51
    1a7e:	a0 83       	st	Z, r26
    1a80:	31 97       	sbiw	r30, 0x01	; 1
    1a82:	60 83       	st	Z, r22
    1a84:	31 97       	sbiw	r30, 0x01	; 1
    1a86:	70 83       	st	Z, r23
    1a88:	31 97       	sbiw	r30, 0x01	; 1
    1a8a:	10 82       	st	Z, r1
    1a8c:	31 97       	sbiw	r30, 0x01	; 1
    1a8e:	10 82       	st	Z, r1
    1a90:	31 97       	sbiw	r30, 0x01	; 1
    1a92:	60 e8       	ldi	r22, 0x80	; 128
    1a94:	60 83       	st	Z, r22
    1a96:	31 97       	sbiw	r30, 0x01	; 1
    1a98:	10 82       	st	Z, r1
    1a9a:	31 97       	sbiw	r30, 0x01	; 1
    1a9c:	10 82       	st	Z, r1
    1a9e:	31 97       	sbiw	r30, 0x01	; 1
    1aa0:	10 82       	st	Z, r1
    1aa2:	31 97       	sbiw	r30, 0x01	; 1
    1aa4:	62 e0       	ldi	r22, 0x02	; 2
    1aa6:	60 83       	st	Z, r22
    1aa8:	31 97       	sbiw	r30, 0x01	; 1
    1aaa:	63 e0       	ldi	r22, 0x03	; 3
    1aac:	60 83       	st	Z, r22
    1aae:	31 97       	sbiw	r30, 0x01	; 1
    1ab0:	64 e0       	ldi	r22, 0x04	; 4
    1ab2:	60 83       	st	Z, r22
    1ab4:	31 97       	sbiw	r30, 0x01	; 1
    1ab6:	65 e0       	ldi	r22, 0x05	; 5
    1ab8:	60 83       	st	Z, r22
    1aba:	31 97       	sbiw	r30, 0x01	; 1
    1abc:	66 e0       	ldi	r22, 0x06	; 6
    1abe:	60 83       	st	Z, r22
    1ac0:	31 97       	sbiw	r30, 0x01	; 1
    1ac2:	67 e0       	ldi	r22, 0x07	; 7
    1ac4:	60 83       	st	Z, r22
    1ac6:	31 97       	sbiw	r30, 0x01	; 1
    1ac8:	68 e0       	ldi	r22, 0x08	; 8
    1aca:	60 83       	st	Z, r22
    1acc:	31 97       	sbiw	r30, 0x01	; 1
    1ace:	69 e0       	ldi	r22, 0x09	; 9
    1ad0:	60 83       	st	Z, r22
    1ad2:	31 97       	sbiw	r30, 0x01	; 1
    1ad4:	60 e1       	ldi	r22, 0x10	; 16
    1ad6:	60 83       	st	Z, r22
    1ad8:	31 97       	sbiw	r30, 0x01	; 1
    1ada:	30 83       	st	Z, r19
    1adc:	31 97       	sbiw	r30, 0x01	; 1
    1ade:	32 e1       	ldi	r19, 0x12	; 18
    1ae0:	30 83       	st	Z, r19
    1ae2:	31 97       	sbiw	r30, 0x01	; 1
    1ae4:	33 e1       	ldi	r19, 0x13	; 19
    1ae6:	30 83       	st	Z, r19
    1ae8:	31 97       	sbiw	r30, 0x01	; 1
    1aea:	34 e1       	ldi	r19, 0x14	; 20
    1aec:	30 83       	st	Z, r19
    1aee:	31 97       	sbiw	r30, 0x01	; 1
    1af0:	35 e1       	ldi	r19, 0x15	; 21
    1af2:	30 83       	st	Z, r19
    1af4:	31 97       	sbiw	r30, 0x01	; 1
    1af6:	36 e1       	ldi	r19, 0x16	; 22
    1af8:	30 83       	st	Z, r19
    1afa:	31 97       	sbiw	r30, 0x01	; 1
    1afc:	37 e1       	ldi	r19, 0x17	; 23
    1afe:	30 83       	st	Z, r19
    1b00:	31 97       	sbiw	r30, 0x01	; 1
    1b02:	38 e1       	ldi	r19, 0x18	; 24
    1b04:	30 83       	st	Z, r19
    1b06:	31 97       	sbiw	r30, 0x01	; 1
    1b08:	39 e1       	ldi	r19, 0x19	; 25
    1b0a:	30 83       	st	Z, r19
    1b0c:	31 97       	sbiw	r30, 0x01	; 1
    1b0e:	30 e2       	ldi	r19, 0x20	; 32
    1b10:	30 83       	st	Z, r19
    1b12:	31 97       	sbiw	r30, 0x01	; 1
    1b14:	31 e2       	ldi	r19, 0x21	; 33
    1b16:	30 83       	st	Z, r19
    1b18:	31 97       	sbiw	r30, 0x01	; 1
    1b1a:	20 83       	st	Z, r18
    1b1c:	31 97       	sbiw	r30, 0x01	; 1
    1b1e:	23 e2       	ldi	r18, 0x23	; 35
    1b20:	20 83       	st	Z, r18
    1b22:	31 97       	sbiw	r30, 0x01	; 1
    1b24:	40 83       	st	Z, r20
    1b26:	31 97       	sbiw	r30, 0x01	; 1
    1b28:	50 83       	st	Z, r21
    1b2a:	31 97       	sbiw	r30, 0x01	; 1
    1b2c:	26 e2       	ldi	r18, 0x26	; 38
    1b2e:	20 83       	st	Z, r18
    1b30:	31 97       	sbiw	r30, 0x01	; 1
    1b32:	27 e2       	ldi	r18, 0x27	; 39
    1b34:	20 83       	st	Z, r18
    1b36:	31 97       	sbiw	r30, 0x01	; 1
    1b38:	28 e2       	ldi	r18, 0x28	; 40
    1b3a:	20 83       	st	Z, r18
    1b3c:	31 97       	sbiw	r30, 0x01	; 1
    1b3e:	29 e2       	ldi	r18, 0x29	; 41
    1b40:	20 83       	st	Z, r18
    1b42:	31 97       	sbiw	r30, 0x01	; 1
    1b44:	20 e3       	ldi	r18, 0x30	; 48
    1b46:	20 83       	st	Z, r18
    1b48:	31 97       	sbiw	r30, 0x01	; 1
    1b4a:	21 e3       	ldi	r18, 0x31	; 49
    1b4c:	20 83       	st	Z, r18
    1b4e:	89 97       	sbiw	r24, 0x29	; 41
    1b50:	08 95       	ret

00001b52 <xPortStartScheduler>:
    1b52:	8c e7       	ldi	r24, 0x7C	; 124
    1b54:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1b58:	8f ef       	ldi	r24, 0xFF	; 255
    1b5a:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1b5e:	81 e0       	ldi	r24, 0x01	; 1
    1b60:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    1b64:	91 e1       	ldi	r25, 0x11	; 17
    1b66:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    1b6a:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    1b6e:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1b72:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1b76:	cd 91       	ld	r28, X+
    1b78:	cd bf       	out	0x3d, r28	; 61
    1b7a:	dd 91       	ld	r29, X+
    1b7c:	de bf       	out	0x3e, r29	; 62
    1b7e:	ff 91       	pop	r31
    1b80:	ef 91       	pop	r30
    1b82:	df 91       	pop	r29
    1b84:	cf 91       	pop	r28
    1b86:	bf 91       	pop	r27
    1b88:	af 91       	pop	r26
    1b8a:	9f 91       	pop	r25
    1b8c:	8f 91       	pop	r24
    1b8e:	7f 91       	pop	r23
    1b90:	6f 91       	pop	r22
    1b92:	5f 91       	pop	r21
    1b94:	4f 91       	pop	r20
    1b96:	3f 91       	pop	r19
    1b98:	2f 91       	pop	r18
    1b9a:	1f 91       	pop	r17
    1b9c:	0f 91       	pop	r16
    1b9e:	ff 90       	pop	r15
    1ba0:	ef 90       	pop	r14
    1ba2:	df 90       	pop	r13
    1ba4:	cf 90       	pop	r12
    1ba6:	bf 90       	pop	r11
    1ba8:	af 90       	pop	r10
    1baa:	9f 90       	pop	r9
    1bac:	8f 90       	pop	r8
    1bae:	7f 90       	pop	r7
    1bb0:	6f 90       	pop	r6
    1bb2:	5f 90       	pop	r5
    1bb4:	4f 90       	pop	r4
    1bb6:	3f 90       	pop	r3
    1bb8:	2f 90       	pop	r2
    1bba:	1f 90       	pop	r1
    1bbc:	0f 90       	pop	r0
    1bbe:	0c be       	out	0x3c, r0	; 60
    1bc0:	0f 90       	pop	r0
    1bc2:	0b be       	out	0x3b, r0	; 59
    1bc4:	0f 90       	pop	r0
    1bc6:	0f be       	out	0x3f, r0	; 63
    1bc8:	0f 90       	pop	r0
    1bca:	08 95       	ret
    1bcc:	08 95       	ret

00001bce <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1bce:	0f 92       	push	r0
    1bd0:	0f b6       	in	r0, 0x3f	; 63
    1bd2:	f8 94       	cli
    1bd4:	0f 92       	push	r0
    1bd6:	0b b6       	in	r0, 0x3b	; 59
    1bd8:	0f 92       	push	r0
    1bda:	0c b6       	in	r0, 0x3c	; 60
    1bdc:	0f 92       	push	r0
    1bde:	1f 92       	push	r1
    1be0:	11 24       	eor	r1, r1
    1be2:	2f 92       	push	r2
    1be4:	3f 92       	push	r3
    1be6:	4f 92       	push	r4
    1be8:	5f 92       	push	r5
    1bea:	6f 92       	push	r6
    1bec:	7f 92       	push	r7
    1bee:	8f 92       	push	r8
    1bf0:	9f 92       	push	r9
    1bf2:	af 92       	push	r10
    1bf4:	bf 92       	push	r11
    1bf6:	cf 92       	push	r12
    1bf8:	df 92       	push	r13
    1bfa:	ef 92       	push	r14
    1bfc:	ff 92       	push	r15
    1bfe:	0f 93       	push	r16
    1c00:	1f 93       	push	r17
    1c02:	2f 93       	push	r18
    1c04:	3f 93       	push	r19
    1c06:	4f 93       	push	r20
    1c08:	5f 93       	push	r21
    1c0a:	6f 93       	push	r22
    1c0c:	7f 93       	push	r23
    1c0e:	8f 93       	push	r24
    1c10:	9f 93       	push	r25
    1c12:	af 93       	push	r26
    1c14:	bf 93       	push	r27
    1c16:	cf 93       	push	r28
    1c18:	df 93       	push	r29
    1c1a:	ef 93       	push	r30
    1c1c:	ff 93       	push	r31
    1c1e:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1c22:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1c26:	0d b6       	in	r0, 0x3d	; 61
    1c28:	0d 92       	st	X+, r0
    1c2a:	0e b6       	in	r0, 0x3e	; 62
    1c2c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1c2e:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1c32:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1c36:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1c3a:	cd 91       	ld	r28, X+
    1c3c:	cd bf       	out	0x3d, r28	; 61
    1c3e:	dd 91       	ld	r29, X+
    1c40:	de bf       	out	0x3e, r29	; 62
    1c42:	ff 91       	pop	r31
    1c44:	ef 91       	pop	r30
    1c46:	df 91       	pop	r29
    1c48:	cf 91       	pop	r28
    1c4a:	bf 91       	pop	r27
    1c4c:	af 91       	pop	r26
    1c4e:	9f 91       	pop	r25
    1c50:	8f 91       	pop	r24
    1c52:	7f 91       	pop	r23
    1c54:	6f 91       	pop	r22
    1c56:	5f 91       	pop	r21
    1c58:	4f 91       	pop	r20
    1c5a:	3f 91       	pop	r19
    1c5c:	2f 91       	pop	r18
    1c5e:	1f 91       	pop	r17
    1c60:	0f 91       	pop	r16
    1c62:	ff 90       	pop	r15
    1c64:	ef 90       	pop	r14
    1c66:	df 90       	pop	r13
    1c68:	cf 90       	pop	r12
    1c6a:	bf 90       	pop	r11
    1c6c:	af 90       	pop	r10
    1c6e:	9f 90       	pop	r9
    1c70:	8f 90       	pop	r8
    1c72:	7f 90       	pop	r7
    1c74:	6f 90       	pop	r6
    1c76:	5f 90       	pop	r5
    1c78:	4f 90       	pop	r4
    1c7a:	3f 90       	pop	r3
    1c7c:	2f 90       	pop	r2
    1c7e:	1f 90       	pop	r1
    1c80:	0f 90       	pop	r0
    1c82:	0c be       	out	0x3c, r0	; 60
    1c84:	0f 90       	pop	r0
    1c86:	0b be       	out	0x3b, r0	; 59
    1c88:	0f 90       	pop	r0
    1c8a:	0f be       	out	0x3f, r0	; 63
    1c8c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c8e:	08 95       	ret

00001c90 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1c90:	0f 92       	push	r0
    1c92:	0f b6       	in	r0, 0x3f	; 63
    1c94:	f8 94       	cli
    1c96:	0f 92       	push	r0
    1c98:	0b b6       	in	r0, 0x3b	; 59
    1c9a:	0f 92       	push	r0
    1c9c:	0c b6       	in	r0, 0x3c	; 60
    1c9e:	0f 92       	push	r0
    1ca0:	1f 92       	push	r1
    1ca2:	11 24       	eor	r1, r1
    1ca4:	2f 92       	push	r2
    1ca6:	3f 92       	push	r3
    1ca8:	4f 92       	push	r4
    1caa:	5f 92       	push	r5
    1cac:	6f 92       	push	r6
    1cae:	7f 92       	push	r7
    1cb0:	8f 92       	push	r8
    1cb2:	9f 92       	push	r9
    1cb4:	af 92       	push	r10
    1cb6:	bf 92       	push	r11
    1cb8:	cf 92       	push	r12
    1cba:	df 92       	push	r13
    1cbc:	ef 92       	push	r14
    1cbe:	ff 92       	push	r15
    1cc0:	0f 93       	push	r16
    1cc2:	1f 93       	push	r17
    1cc4:	2f 93       	push	r18
    1cc6:	3f 93       	push	r19
    1cc8:	4f 93       	push	r20
    1cca:	5f 93       	push	r21
    1ccc:	6f 93       	push	r22
    1cce:	7f 93       	push	r23
    1cd0:	8f 93       	push	r24
    1cd2:	9f 93       	push	r25
    1cd4:	af 93       	push	r26
    1cd6:	bf 93       	push	r27
    1cd8:	cf 93       	push	r28
    1cda:	df 93       	push	r29
    1cdc:	ef 93       	push	r30
    1cde:	ff 93       	push	r31
    1ce0:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1ce4:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1ce8:	0d b6       	in	r0, 0x3d	; 61
    1cea:	0d 92       	st	X+, r0
    1cec:	0e b6       	in	r0, 0x3e	; 62
    1cee:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1cf0:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vTaskIncrementTick>
	vTaskSwitchContext();
    1cf4:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1cf8:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1cfc:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1d00:	cd 91       	ld	r28, X+
    1d02:	cd bf       	out	0x3d, r28	; 61
    1d04:	dd 91       	ld	r29, X+
    1d06:	de bf       	out	0x3e, r29	; 62
    1d08:	ff 91       	pop	r31
    1d0a:	ef 91       	pop	r30
    1d0c:	df 91       	pop	r29
    1d0e:	cf 91       	pop	r28
    1d10:	bf 91       	pop	r27
    1d12:	af 91       	pop	r26
    1d14:	9f 91       	pop	r25
    1d16:	8f 91       	pop	r24
    1d18:	7f 91       	pop	r23
    1d1a:	6f 91       	pop	r22
    1d1c:	5f 91       	pop	r21
    1d1e:	4f 91       	pop	r20
    1d20:	3f 91       	pop	r19
    1d22:	2f 91       	pop	r18
    1d24:	1f 91       	pop	r17
    1d26:	0f 91       	pop	r16
    1d28:	ff 90       	pop	r15
    1d2a:	ef 90       	pop	r14
    1d2c:	df 90       	pop	r13
    1d2e:	cf 90       	pop	r12
    1d30:	bf 90       	pop	r11
    1d32:	af 90       	pop	r10
    1d34:	9f 90       	pop	r9
    1d36:	8f 90       	pop	r8
    1d38:	7f 90       	pop	r7
    1d3a:	6f 90       	pop	r6
    1d3c:	5f 90       	pop	r5
    1d3e:	4f 90       	pop	r4
    1d40:	3f 90       	pop	r3
    1d42:	2f 90       	pop	r2
    1d44:	1f 90       	pop	r1
    1d46:	0f 90       	pop	r0
    1d48:	0c be       	out	0x3c, r0	; 60
    1d4a:	0f 90       	pop	r0
    1d4c:	0b be       	out	0x3b, r0	; 59
    1d4e:	0f 90       	pop	r0
    1d50:	0f be       	out	0x3f, r0	; 63
    1d52:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1d54:	08 95       	ret

00001d56 <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1d56:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1d5a:	18 95       	reti

00001d5c <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1d5c:	cf 93       	push	r28
    1d5e:	df 93       	push	r29
    1d60:	ec 01       	movw	r28, r24
    1d62:	88 a1       	ldd	r24, Y+32	; 0x20
    1d64:	81 11       	cpse	r24, r1
    1d66:	0b c0       	rjmp	.+22     	; 0x1d7e <prvCopyDataToQueue+0x22>
    1d68:	88 81       	ld	r24, Y
    1d6a:	99 81       	ldd	r25, Y+1	; 0x01
    1d6c:	89 2b       	or	r24, r25
    1d6e:	e1 f5       	brne	.+120    	; 0x1de8 <prvCopyDataToQueue+0x8c>
    1d70:	8a 81       	ldd	r24, Y+2	; 0x02
    1d72:	9b 81       	ldd	r25, Y+3	; 0x03
    1d74:	0e 94 c2 16 	call	0x2d84	; 0x2d84 <vTaskPriorityDisinherit>
    1d78:	1a 82       	std	Y+2, r1	; 0x02
    1d7a:	1b 82       	std	Y+3, r1	; 0x03
    1d7c:	35 c0       	rjmp	.+106    	; 0x1de8 <prvCopyDataToQueue+0x8c>
    1d7e:	41 11       	cpse	r20, r1
    1d80:	17 c0       	rjmp	.+46     	; 0x1db0 <prvCopyDataToQueue+0x54>
    1d82:	48 2f       	mov	r20, r24
    1d84:	50 e0       	ldi	r21, 0x00	; 0
    1d86:	8c 81       	ldd	r24, Y+4	; 0x04
    1d88:	9d 81       	ldd	r25, Y+5	; 0x05
    1d8a:	0e 94 3a 22 	call	0x4474	; 0x4474 <memcpy>
    1d8e:	28 a1       	ldd	r18, Y+32	; 0x20
    1d90:	8c 81       	ldd	r24, Y+4	; 0x04
    1d92:	9d 81       	ldd	r25, Y+5	; 0x05
    1d94:	82 0f       	add	r24, r18
    1d96:	91 1d       	adc	r25, r1
    1d98:	8c 83       	std	Y+4, r24	; 0x04
    1d9a:	9d 83       	std	Y+5, r25	; 0x05
    1d9c:	2a 81       	ldd	r18, Y+2	; 0x02
    1d9e:	3b 81       	ldd	r19, Y+3	; 0x03
    1da0:	82 17       	cp	r24, r18
    1da2:	93 07       	cpc	r25, r19
    1da4:	08 f1       	brcs	.+66     	; 0x1de8 <prvCopyDataToQueue+0x8c>
    1da6:	88 81       	ld	r24, Y
    1da8:	99 81       	ldd	r25, Y+1	; 0x01
    1daa:	8c 83       	std	Y+4, r24	; 0x04
    1dac:	9d 83       	std	Y+5, r25	; 0x05
    1dae:	1c c0       	rjmp	.+56     	; 0x1de8 <prvCopyDataToQueue+0x8c>
    1db0:	48 2f       	mov	r20, r24
    1db2:	50 e0       	ldi	r21, 0x00	; 0
    1db4:	8e 81       	ldd	r24, Y+6	; 0x06
    1db6:	9f 81       	ldd	r25, Y+7	; 0x07
    1db8:	0e 94 3a 22 	call	0x4474	; 0x4474 <memcpy>
    1dbc:	88 a1       	ldd	r24, Y+32	; 0x20
    1dbe:	90 e0       	ldi	r25, 0x00	; 0
    1dc0:	91 95       	neg	r25
    1dc2:	81 95       	neg	r24
    1dc4:	91 09       	sbc	r25, r1
    1dc6:	2e 81       	ldd	r18, Y+6	; 0x06
    1dc8:	3f 81       	ldd	r19, Y+7	; 0x07
    1dca:	28 0f       	add	r18, r24
    1dcc:	39 1f       	adc	r19, r25
    1dce:	2e 83       	std	Y+6, r18	; 0x06
    1dd0:	3f 83       	std	Y+7, r19	; 0x07
    1dd2:	48 81       	ld	r20, Y
    1dd4:	59 81       	ldd	r21, Y+1	; 0x01
    1dd6:	24 17       	cp	r18, r20
    1dd8:	35 07       	cpc	r19, r21
    1dda:	30 f4       	brcc	.+12     	; 0x1de8 <prvCopyDataToQueue+0x8c>
    1ddc:	2a 81       	ldd	r18, Y+2	; 0x02
    1dde:	3b 81       	ldd	r19, Y+3	; 0x03
    1de0:	82 0f       	add	r24, r18
    1de2:	93 1f       	adc	r25, r19
    1de4:	8e 83       	std	Y+6, r24	; 0x06
    1de6:	9f 83       	std	Y+7, r25	; 0x07
    1de8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1dea:	8f 5f       	subi	r24, 0xFF	; 255
    1dec:	8e 8f       	std	Y+30, r24	; 0x1e
    1dee:	df 91       	pop	r29
    1df0:	cf 91       	pop	r28
    1df2:	08 95       	ret

00001df4 <prvCopyDataFromQueue>:
    1df4:	fc 01       	movw	r30, r24
    1df6:	80 81       	ld	r24, Z
    1df8:	91 81       	ldd	r25, Z+1	; 0x01
    1dfa:	00 97       	sbiw	r24, 0x00	; 0
    1dfc:	a1 f0       	breq	.+40     	; 0x1e26 <prvCopyDataFromQueue+0x32>
    1dfe:	40 a1       	ldd	r20, Z+32	; 0x20
    1e00:	50 e0       	ldi	r21, 0x00	; 0
    1e02:	26 81       	ldd	r18, Z+6	; 0x06
    1e04:	37 81       	ldd	r19, Z+7	; 0x07
    1e06:	24 0f       	add	r18, r20
    1e08:	35 1f       	adc	r19, r21
    1e0a:	26 83       	std	Z+6, r18	; 0x06
    1e0c:	37 83       	std	Z+7, r19	; 0x07
    1e0e:	a2 81       	ldd	r26, Z+2	; 0x02
    1e10:	b3 81       	ldd	r27, Z+3	; 0x03
    1e12:	2a 17       	cp	r18, r26
    1e14:	3b 07       	cpc	r19, r27
    1e16:	10 f0       	brcs	.+4      	; 0x1e1c <prvCopyDataFromQueue+0x28>
    1e18:	86 83       	std	Z+6, r24	; 0x06
    1e1a:	97 83       	std	Z+7, r25	; 0x07
    1e1c:	cb 01       	movw	r24, r22
    1e1e:	66 81       	ldd	r22, Z+6	; 0x06
    1e20:	77 81       	ldd	r23, Z+7	; 0x07
    1e22:	0e 94 3a 22 	call	0x4474	; 0x4474 <memcpy>
    1e26:	08 95       	ret

00001e28 <prvUnlockQueue>:
    1e28:	0f 93       	push	r16
    1e2a:	1f 93       	push	r17
    1e2c:	cf 93       	push	r28
    1e2e:	df 93       	push	r29
    1e30:	ec 01       	movw	r28, r24
    1e32:	0f b6       	in	r0, 0x3f	; 63
    1e34:	f8 94       	cli
    1e36:	0f 92       	push	r0
    1e38:	8a a1       	ldd	r24, Y+34	; 0x22
    1e3a:	18 16       	cp	r1, r24
    1e3c:	b4 f4       	brge	.+44     	; 0x1e6a <prvUnlockQueue+0x42>
    1e3e:	8b 89       	ldd	r24, Y+19	; 0x13
    1e40:	81 11       	cpse	r24, r1
    1e42:	05 c0       	rjmp	.+10     	; 0x1e4e <prvUnlockQueue+0x26>
    1e44:	12 c0       	rjmp	.+36     	; 0x1e6a <prvUnlockQueue+0x42>
    1e46:	8b 89       	ldd	r24, Y+19	; 0x13
    1e48:	81 11       	cpse	r24, r1
    1e4a:	04 c0       	rjmp	.+8      	; 0x1e54 <prvUnlockQueue+0x2c>
    1e4c:	0e c0       	rjmp	.+28     	; 0x1e6a <prvUnlockQueue+0x42>
    1e4e:	8e 01       	movw	r16, r28
    1e50:	0d 5e       	subi	r16, 0xED	; 237
    1e52:	1f 4f       	sbci	r17, 0xFF	; 255
    1e54:	c8 01       	movw	r24, r16
    1e56:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <xTaskRemoveFromEventList>
    1e5a:	81 11       	cpse	r24, r1
    1e5c:	0e 94 4b 16 	call	0x2c96	; 0x2c96 <vTaskMissedYield>
    1e60:	8a a1       	ldd	r24, Y+34	; 0x22
    1e62:	81 50       	subi	r24, 0x01	; 1
    1e64:	8a a3       	std	Y+34, r24	; 0x22
    1e66:	18 16       	cp	r1, r24
    1e68:	74 f3       	brlt	.-36     	; 0x1e46 <prvUnlockQueue+0x1e>
    1e6a:	8f ef       	ldi	r24, 0xFF	; 255
    1e6c:	8a a3       	std	Y+34, r24	; 0x22
    1e6e:	0f 90       	pop	r0
    1e70:	0f be       	out	0x3f, r0	; 63
    1e72:	0f b6       	in	r0, 0x3f	; 63
    1e74:	f8 94       	cli
    1e76:	0f 92       	push	r0
    1e78:	89 a1       	ldd	r24, Y+33	; 0x21
    1e7a:	18 16       	cp	r1, r24
    1e7c:	b4 f4       	brge	.+44     	; 0x1eaa <prvUnlockQueue+0x82>
    1e7e:	88 85       	ldd	r24, Y+8	; 0x08
    1e80:	81 11       	cpse	r24, r1
    1e82:	05 c0       	rjmp	.+10     	; 0x1e8e <prvUnlockQueue+0x66>
    1e84:	12 c0       	rjmp	.+36     	; 0x1eaa <prvUnlockQueue+0x82>
    1e86:	88 85       	ldd	r24, Y+8	; 0x08
    1e88:	81 11       	cpse	r24, r1
    1e8a:	04 c0       	rjmp	.+8      	; 0x1e94 <prvUnlockQueue+0x6c>
    1e8c:	0e c0       	rjmp	.+28     	; 0x1eaa <prvUnlockQueue+0x82>
    1e8e:	8e 01       	movw	r16, r28
    1e90:	08 5f       	subi	r16, 0xF8	; 248
    1e92:	1f 4f       	sbci	r17, 0xFF	; 255
    1e94:	c8 01       	movw	r24, r16
    1e96:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <xTaskRemoveFromEventList>
    1e9a:	81 11       	cpse	r24, r1
    1e9c:	0e 94 4b 16 	call	0x2c96	; 0x2c96 <vTaskMissedYield>
    1ea0:	89 a1       	ldd	r24, Y+33	; 0x21
    1ea2:	81 50       	subi	r24, 0x01	; 1
    1ea4:	89 a3       	std	Y+33, r24	; 0x21
    1ea6:	18 16       	cp	r1, r24
    1ea8:	74 f3       	brlt	.-36     	; 0x1e86 <prvUnlockQueue+0x5e>
    1eaa:	8f ef       	ldi	r24, 0xFF	; 255
    1eac:	89 a3       	std	Y+33, r24	; 0x21
    1eae:	0f 90       	pop	r0
    1eb0:	0f be       	out	0x3f, r0	; 63
    1eb2:	df 91       	pop	r29
    1eb4:	cf 91       	pop	r28
    1eb6:	1f 91       	pop	r17
    1eb8:	0f 91       	pop	r16
    1eba:	08 95       	ret

00001ebc <xQueueGenericReset>:
    1ebc:	1f 93       	push	r17
    1ebe:	cf 93       	push	r28
    1ec0:	df 93       	push	r29
    1ec2:	61 30       	cpi	r22, 0x01	; 1
    1ec4:	59 f0       	breq	.+22     	; 0x1edc <xQueueGenericReset+0x20>
    1ec6:	fc 01       	movw	r30, r24
    1ec8:	23 89       	ldd	r18, Z+19	; 0x13
    1eca:	30 85       	ldd	r19, Z+8	; 0x08
    1ecc:	31 11       	cpse	r19, r1
    1ece:	2c c0       	rjmp	.+88     	; 0x1f28 <xQueueGenericReset+0x6c>
    1ed0:	11 e0       	ldi	r17, 0x01	; 1
    1ed2:	21 11       	cpse	r18, r1
    1ed4:	10 e0       	ldi	r17, 0x00	; 0
    1ed6:	21 11       	cpse	r18, r1
    1ed8:	28 c0       	rjmp	.+80     	; 0x1f2a <xQueueGenericReset+0x6e>
    1eda:	01 c0       	rjmp	.+2      	; 0x1ede <xQueueGenericReset+0x22>
    1edc:	11 e0       	ldi	r17, 0x01	; 1
    1ede:	ec 01       	movw	r28, r24
    1ee0:	48 81       	ld	r20, Y
    1ee2:	59 81       	ldd	r21, Y+1	; 0x01
    1ee4:	28 a1       	ldd	r18, Y+32	; 0x20
    1ee6:	30 e0       	ldi	r19, 0x00	; 0
    1ee8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1eea:	62 9f       	mul	r22, r18
    1eec:	c0 01       	movw	r24, r0
    1eee:	63 9f       	mul	r22, r19
    1ef0:	90 0d       	add	r25, r0
    1ef2:	11 24       	eor	r1, r1
    1ef4:	ba 01       	movw	r22, r20
    1ef6:	68 0f       	add	r22, r24
    1ef8:	79 1f       	adc	r23, r25
    1efa:	6a 83       	std	Y+2, r22	; 0x02
    1efc:	7b 83       	std	Y+3, r23	; 0x03
    1efe:	1e 8e       	std	Y+30, r1	; 0x1e
    1f00:	4c 83       	std	Y+4, r20	; 0x04
    1f02:	5d 83       	std	Y+5, r21	; 0x05
    1f04:	82 1b       	sub	r24, r18
    1f06:	93 0b       	sbc	r25, r19
    1f08:	84 0f       	add	r24, r20
    1f0a:	95 1f       	adc	r25, r21
    1f0c:	8e 83       	std	Y+6, r24	; 0x06
    1f0e:	9f 83       	std	Y+7, r25	; 0x07
    1f10:	8f ef       	ldi	r24, 0xFF	; 255
    1f12:	89 a3       	std	Y+33, r24	; 0x21
    1f14:	8a a3       	std	Y+34, r24	; 0x22
    1f16:	ce 01       	movw	r24, r28
    1f18:	08 96       	adiw	r24, 0x08	; 8
    1f1a:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInitialise>
    1f1e:	ce 01       	movw	r24, r28
    1f20:	43 96       	adiw	r24, 0x13	; 19
    1f22:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInitialise>
    1f26:	01 c0       	rjmp	.+2      	; 0x1f2a <xQueueGenericReset+0x6e>
    1f28:	10 e0       	ldi	r17, 0x00	; 0
    1f2a:	81 2f       	mov	r24, r17
    1f2c:	df 91       	pop	r29
    1f2e:	cf 91       	pop	r28
    1f30:	1f 91       	pop	r17
    1f32:	08 95       	ret

00001f34 <xQueueGenericCreate>:
    1f34:	0f 93       	push	r16
    1f36:	1f 93       	push	r17
    1f38:	cf 93       	push	r28
    1f3a:	df 93       	push	r29
    1f3c:	88 23       	and	r24, r24
    1f3e:	01 f1       	breq	.+64     	; 0x1f80 <xQueueGenericCreate+0x4c>
    1f40:	06 2f       	mov	r16, r22
    1f42:	18 2f       	mov	r17, r24
    1f44:	83 e2       	ldi	r24, 0x23	; 35
    1f46:	90 e0       	ldi	r25, 0x00	; 0
    1f48:	0e 94 b4 0b 	call	0x1768	; 0x1768 <pvPortMalloc>
    1f4c:	ec 01       	movw	r28, r24
    1f4e:	89 2b       	or	r24, r25
    1f50:	c9 f0       	breq	.+50     	; 0x1f84 <xQueueGenericCreate+0x50>
    1f52:	10 9f       	mul	r17, r16
    1f54:	c0 01       	movw	r24, r0
    1f56:	11 24       	eor	r1, r1
    1f58:	01 96       	adiw	r24, 0x01	; 1
    1f5a:	0e 94 b4 0b 	call	0x1768	; 0x1768 <pvPortMalloc>
    1f5e:	88 83       	st	Y, r24
    1f60:	99 83       	std	Y+1, r25	; 0x01
    1f62:	89 2b       	or	r24, r25
    1f64:	39 f0       	breq	.+14     	; 0x1f74 <xQueueGenericCreate+0x40>
    1f66:	1f 8f       	std	Y+31, r17	; 0x1f
    1f68:	08 a3       	std	Y+32, r16	; 0x20
    1f6a:	61 e0       	ldi	r22, 0x01	; 1
    1f6c:	ce 01       	movw	r24, r28
    1f6e:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <xQueueGenericReset>
    1f72:	08 c0       	rjmp	.+16     	; 0x1f84 <xQueueGenericCreate+0x50>
    1f74:	ce 01       	movw	r24, r28
    1f76:	0e 94 4e 0c 	call	0x189c	; 0x189c <vPortFree>
    1f7a:	c0 e0       	ldi	r28, 0x00	; 0
    1f7c:	d0 e0       	ldi	r29, 0x00	; 0
    1f7e:	02 c0       	rjmp	.+4      	; 0x1f84 <xQueueGenericCreate+0x50>
    1f80:	c0 e0       	ldi	r28, 0x00	; 0
    1f82:	d0 e0       	ldi	r29, 0x00	; 0
    1f84:	ce 01       	movw	r24, r28
    1f86:	df 91       	pop	r29
    1f88:	cf 91       	pop	r28
    1f8a:	1f 91       	pop	r17
    1f8c:	0f 91       	pop	r16
    1f8e:	08 95       	ret

00001f90 <xQueueGenericSend>:
    1f90:	af 92       	push	r10
    1f92:	bf 92       	push	r11
    1f94:	cf 92       	push	r12
    1f96:	df 92       	push	r13
    1f98:	ef 92       	push	r14
    1f9a:	ff 92       	push	r15
    1f9c:	0f 93       	push	r16
    1f9e:	1f 93       	push	r17
    1fa0:	cf 93       	push	r28
    1fa2:	df 93       	push	r29
    1fa4:	cd b7       	in	r28, 0x3d	; 61
    1fa6:	de b7       	in	r29, 0x3e	; 62
    1fa8:	29 97       	sbiw	r28, 0x09	; 9
    1faa:	cd bf       	out	0x3d, r28	; 61
    1fac:	de bf       	out	0x3e, r29	; 62
    1fae:	7c 01       	movw	r14, r24
    1fb0:	5b 01       	movw	r10, r22
    1fb2:	2e 83       	std	Y+6, r18	; 0x06
    1fb4:	3f 83       	std	Y+7, r19	; 0x07
    1fb6:	48 87       	std	Y+8, r20	; 0x08
    1fb8:	59 87       	std	Y+9, r21	; 0x09
    1fba:	10 e0       	ldi	r17, 0x00	; 0
    1fbc:	6c 01       	movw	r12, r24
    1fbe:	88 e0       	ldi	r24, 0x08	; 8
    1fc0:	c8 0e       	add	r12, r24
    1fc2:	d1 1c       	adc	r13, r1
    1fc4:	0f b6       	in	r0, 0x3f	; 63
    1fc6:	f8 94       	cli
    1fc8:	0f 92       	push	r0
    1fca:	f7 01       	movw	r30, r14
    1fcc:	96 8d       	ldd	r25, Z+30	; 0x1e
    1fce:	87 8d       	ldd	r24, Z+31	; 0x1f
    1fd0:	98 17       	cp	r25, r24
    1fd2:	a8 f4       	brcc	.+42     	; 0x1ffe <xQueueGenericSend+0x6e>
    1fd4:	40 2f       	mov	r20, r16
    1fd6:	b5 01       	movw	r22, r10
    1fd8:	c7 01       	movw	r24, r14
    1fda:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <prvCopyDataToQueue>
    1fde:	f7 01       	movw	r30, r14
    1fe0:	83 89       	ldd	r24, Z+19	; 0x13
    1fe2:	88 23       	and	r24, r24
    1fe4:	41 f0       	breq	.+16     	; 0x1ff6 <xQueueGenericSend+0x66>
    1fe6:	c7 01       	movw	r24, r14
    1fe8:	43 96       	adiw	r24, 0x13	; 19
    1fea:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <xTaskRemoveFromEventList>
    1fee:	81 30       	cpi	r24, 0x01	; 1
    1ff0:	11 f4       	brne	.+4      	; 0x1ff6 <xQueueGenericSend+0x66>
    1ff2:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <vPortYield>
    1ff6:	0f 90       	pop	r0
    1ff8:	0f be       	out	0x3f, r0	; 63
    1ffa:	81 e0       	ldi	r24, 0x01	; 1
    1ffc:	56 c0       	rjmp	.+172    	; 0x20aa <xQueueGenericSend+0x11a>
    1ffe:	8e 81       	ldd	r24, Y+6	; 0x06
    2000:	9f 81       	ldd	r25, Y+7	; 0x07
    2002:	a8 85       	ldd	r26, Y+8	; 0x08
    2004:	b9 85       	ldd	r27, Y+9	; 0x09
    2006:	89 2b       	or	r24, r25
    2008:	8a 2b       	or	r24, r26
    200a:	8b 2b       	or	r24, r27
    200c:	21 f4       	brne	.+8      	; 0x2016 <xQueueGenericSend+0x86>
    200e:	0f 90       	pop	r0
    2010:	0f be       	out	0x3f, r0	; 63
    2012:	80 e0       	ldi	r24, 0x00	; 0
    2014:	4a c0       	rjmp	.+148    	; 0x20aa <xQueueGenericSend+0x11a>
    2016:	11 11       	cpse	r17, r1
    2018:	05 c0       	rjmp	.+10     	; 0x2024 <xQueueGenericSend+0x94>
    201a:	ce 01       	movw	r24, r28
    201c:	01 96       	adiw	r24, 0x01	; 1
    201e:	0e 94 cd 15 	call	0x2b9a	; 0x2b9a <vTaskSetTimeOutState>
    2022:	11 e0       	ldi	r17, 0x01	; 1
    2024:	0f 90       	pop	r0
    2026:	0f be       	out	0x3f, r0	; 63
    2028:	0e 94 c8 12 	call	0x2590	; 0x2590 <vTaskSuspendAll>
    202c:	0f b6       	in	r0, 0x3f	; 63
    202e:	f8 94       	cli
    2030:	0f 92       	push	r0
    2032:	f7 01       	movw	r30, r14
    2034:	81 a1       	ldd	r24, Z+33	; 0x21
    2036:	8f 3f       	cpi	r24, 0xFF	; 255
    2038:	09 f4       	brne	.+2      	; 0x203c <xQueueGenericSend+0xac>
    203a:	11 a2       	std	Z+33, r1	; 0x21
    203c:	f7 01       	movw	r30, r14
    203e:	82 a1       	ldd	r24, Z+34	; 0x22
    2040:	8f 3f       	cpi	r24, 0xFF	; 255
    2042:	09 f4       	brne	.+2      	; 0x2046 <xQueueGenericSend+0xb6>
    2044:	12 a2       	std	Z+34, r1	; 0x22
    2046:	0f 90       	pop	r0
    2048:	0f be       	out	0x3f, r0	; 63
    204a:	be 01       	movw	r22, r28
    204c:	6a 5f       	subi	r22, 0xFA	; 250
    204e:	7f 4f       	sbci	r23, 0xFF	; 255
    2050:	ce 01       	movw	r24, r28
    2052:	01 96       	adiw	r24, 0x01	; 1
    2054:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <xTaskCheckForTimeOut>
    2058:	81 11       	cpse	r24, r1
    205a:	21 c0       	rjmp	.+66     	; 0x209e <xQueueGenericSend+0x10e>
    205c:	0f b6       	in	r0, 0x3f	; 63
    205e:	f8 94       	cli
    2060:	0f 92       	push	r0
    2062:	f7 01       	movw	r30, r14
    2064:	96 8d       	ldd	r25, Z+30	; 0x1e
    2066:	0f 90       	pop	r0
    2068:	0f be       	out	0x3f, r0	; 63
    206a:	87 8d       	ldd	r24, Z+31	; 0x1f
    206c:	98 13       	cpse	r25, r24
    206e:	11 c0       	rjmp	.+34     	; 0x2092 <xQueueGenericSend+0x102>
    2070:	4e 81       	ldd	r20, Y+6	; 0x06
    2072:	5f 81       	ldd	r21, Y+7	; 0x07
    2074:	68 85       	ldd	r22, Y+8	; 0x08
    2076:	79 85       	ldd	r23, Y+9	; 0x09
    2078:	c6 01       	movw	r24, r12
    207a:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vTaskPlaceOnEventList>
    207e:	c7 01       	movw	r24, r14
    2080:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <prvUnlockQueue>
    2084:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <xTaskResumeAll>
    2088:	81 11       	cpse	r24, r1
    208a:	9c cf       	rjmp	.-200    	; 0x1fc4 <xQueueGenericSend+0x34>
    208c:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <vPortYield>
    2090:	99 cf       	rjmp	.-206    	; 0x1fc4 <xQueueGenericSend+0x34>
    2092:	c7 01       	movw	r24, r14
    2094:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <prvUnlockQueue>
    2098:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <xTaskResumeAll>
    209c:	93 cf       	rjmp	.-218    	; 0x1fc4 <xQueueGenericSend+0x34>
    209e:	c7 01       	movw	r24, r14
    20a0:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <prvUnlockQueue>
    20a4:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <xTaskResumeAll>
    20a8:	80 e0       	ldi	r24, 0x00	; 0
    20aa:	29 96       	adiw	r28, 0x09	; 9
    20ac:	cd bf       	out	0x3d, r28	; 61
    20ae:	de bf       	out	0x3e, r29	; 62
    20b0:	df 91       	pop	r29
    20b2:	cf 91       	pop	r28
    20b4:	1f 91       	pop	r17
    20b6:	0f 91       	pop	r16
    20b8:	ff 90       	pop	r15
    20ba:	ef 90       	pop	r14
    20bc:	df 90       	pop	r13
    20be:	cf 90       	pop	r12
    20c0:	bf 90       	pop	r11
    20c2:	af 90       	pop	r10
    20c4:	08 95       	ret

000020c6 <xQueueGenericReceive>:
    20c6:	af 92       	push	r10
    20c8:	bf 92       	push	r11
    20ca:	cf 92       	push	r12
    20cc:	df 92       	push	r13
    20ce:	ef 92       	push	r14
    20d0:	ff 92       	push	r15
    20d2:	0f 93       	push	r16
    20d4:	1f 93       	push	r17
    20d6:	cf 93       	push	r28
    20d8:	df 93       	push	r29
    20da:	cd b7       	in	r28, 0x3d	; 61
    20dc:	de b7       	in	r29, 0x3e	; 62
    20de:	29 97       	sbiw	r28, 0x09	; 9
    20e0:	cd bf       	out	0x3d, r28	; 61
    20e2:	de bf       	out	0x3e, r29	; 62
    20e4:	7c 01       	movw	r14, r24
    20e6:	5b 01       	movw	r10, r22
    20e8:	2e 83       	std	Y+6, r18	; 0x06
    20ea:	3f 83       	std	Y+7, r19	; 0x07
    20ec:	48 87       	std	Y+8, r20	; 0x08
    20ee:	59 87       	std	Y+9, r21	; 0x09
    20f0:	10 e0       	ldi	r17, 0x00	; 0
    20f2:	6c 01       	movw	r12, r24
    20f4:	83 e1       	ldi	r24, 0x13	; 19
    20f6:	c8 0e       	add	r12, r24
    20f8:	d1 1c       	adc	r13, r1
    20fa:	0f b6       	in	r0, 0x3f	; 63
    20fc:	f8 94       	cli
    20fe:	0f 92       	push	r0
    2100:	f7 01       	movw	r30, r14
    2102:	86 8d       	ldd	r24, Z+30	; 0x1e
    2104:	88 23       	and	r24, r24
    2106:	99 f1       	breq	.+102    	; 0x216e <xQueueGenericReceive+0xa8>
    2108:	c6 80       	ldd	r12, Z+6	; 0x06
    210a:	d7 80       	ldd	r13, Z+7	; 0x07
    210c:	b5 01       	movw	r22, r10
    210e:	c7 01       	movw	r24, r14
    2110:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <prvCopyDataFromQueue>
    2114:	01 11       	cpse	r16, r1
    2116:	1a c0       	rjmp	.+52     	; 0x214c <xQueueGenericReceive+0x86>
    2118:	f7 01       	movw	r30, r14
    211a:	86 8d       	ldd	r24, Z+30	; 0x1e
    211c:	81 50       	subi	r24, 0x01	; 1
    211e:	86 8f       	std	Z+30, r24	; 0x1e
    2120:	80 81       	ld	r24, Z
    2122:	91 81       	ldd	r25, Z+1	; 0x01
    2124:	89 2b       	or	r24, r25
    2126:	29 f4       	brne	.+10     	; 0x2132 <xQueueGenericReceive+0x6c>
    2128:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xTaskGetCurrentTaskHandle>
    212c:	f7 01       	movw	r30, r14
    212e:	82 83       	std	Z+2, r24	; 0x02
    2130:	93 83       	std	Z+3, r25	; 0x03
    2132:	f7 01       	movw	r30, r14
    2134:	80 85       	ldd	r24, Z+8	; 0x08
    2136:	88 23       	and	r24, r24
    2138:	b1 f0       	breq	.+44     	; 0x2166 <xQueueGenericReceive+0xa0>
    213a:	c7 01       	movw	r24, r14
    213c:	08 96       	adiw	r24, 0x08	; 8
    213e:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <xTaskRemoveFromEventList>
    2142:	81 30       	cpi	r24, 0x01	; 1
    2144:	81 f4       	brne	.+32     	; 0x2166 <xQueueGenericReceive+0xa0>
    2146:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <vPortYield>
    214a:	0d c0       	rjmp	.+26     	; 0x2166 <xQueueGenericReceive+0xa0>
    214c:	f7 01       	movw	r30, r14
    214e:	c6 82       	std	Z+6, r12	; 0x06
    2150:	d7 82       	std	Z+7, r13	; 0x07
    2152:	83 89       	ldd	r24, Z+19	; 0x13
    2154:	88 23       	and	r24, r24
    2156:	39 f0       	breq	.+14     	; 0x2166 <xQueueGenericReceive+0xa0>
    2158:	c7 01       	movw	r24, r14
    215a:	43 96       	adiw	r24, 0x13	; 19
    215c:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <xTaskRemoveFromEventList>
    2160:	81 11       	cpse	r24, r1
    2162:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <vPortYield>
    2166:	0f 90       	pop	r0
    2168:	0f be       	out	0x3f, r0	; 63
    216a:	81 e0       	ldi	r24, 0x01	; 1
    216c:	62 c0       	rjmp	.+196    	; 0x2232 <xQueueGenericReceive+0x16c>
    216e:	8e 81       	ldd	r24, Y+6	; 0x06
    2170:	9f 81       	ldd	r25, Y+7	; 0x07
    2172:	a8 85       	ldd	r26, Y+8	; 0x08
    2174:	b9 85       	ldd	r27, Y+9	; 0x09
    2176:	89 2b       	or	r24, r25
    2178:	8a 2b       	or	r24, r26
    217a:	8b 2b       	or	r24, r27
    217c:	21 f4       	brne	.+8      	; 0x2186 <xQueueGenericReceive+0xc0>
    217e:	0f 90       	pop	r0
    2180:	0f be       	out	0x3f, r0	; 63
    2182:	80 e0       	ldi	r24, 0x00	; 0
    2184:	56 c0       	rjmp	.+172    	; 0x2232 <xQueueGenericReceive+0x16c>
    2186:	11 11       	cpse	r17, r1
    2188:	05 c0       	rjmp	.+10     	; 0x2194 <xQueueGenericReceive+0xce>
    218a:	ce 01       	movw	r24, r28
    218c:	01 96       	adiw	r24, 0x01	; 1
    218e:	0e 94 cd 15 	call	0x2b9a	; 0x2b9a <vTaskSetTimeOutState>
    2192:	11 e0       	ldi	r17, 0x01	; 1
    2194:	0f 90       	pop	r0
    2196:	0f be       	out	0x3f, r0	; 63
    2198:	0e 94 c8 12 	call	0x2590	; 0x2590 <vTaskSuspendAll>
    219c:	0f b6       	in	r0, 0x3f	; 63
    219e:	f8 94       	cli
    21a0:	0f 92       	push	r0
    21a2:	f7 01       	movw	r30, r14
    21a4:	81 a1       	ldd	r24, Z+33	; 0x21
    21a6:	8f 3f       	cpi	r24, 0xFF	; 255
    21a8:	09 f4       	brne	.+2      	; 0x21ac <xQueueGenericReceive+0xe6>
    21aa:	11 a2       	std	Z+33, r1	; 0x21
    21ac:	f7 01       	movw	r30, r14
    21ae:	82 a1       	ldd	r24, Z+34	; 0x22
    21b0:	8f 3f       	cpi	r24, 0xFF	; 255
    21b2:	09 f4       	brne	.+2      	; 0x21b6 <xQueueGenericReceive+0xf0>
    21b4:	12 a2       	std	Z+34, r1	; 0x22
    21b6:	0f 90       	pop	r0
    21b8:	0f be       	out	0x3f, r0	; 63
    21ba:	be 01       	movw	r22, r28
    21bc:	6a 5f       	subi	r22, 0xFA	; 250
    21be:	7f 4f       	sbci	r23, 0xFF	; 255
    21c0:	ce 01       	movw	r24, r28
    21c2:	01 96       	adiw	r24, 0x01	; 1
    21c4:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <xTaskCheckForTimeOut>
    21c8:	81 11       	cpse	r24, r1
    21ca:	2d c0       	rjmp	.+90     	; 0x2226 <xQueueGenericReceive+0x160>
    21cc:	0f b6       	in	r0, 0x3f	; 63
    21ce:	f8 94       	cli
    21d0:	0f 92       	push	r0
    21d2:	f7 01       	movw	r30, r14
    21d4:	86 8d       	ldd	r24, Z+30	; 0x1e
    21d6:	0f 90       	pop	r0
    21d8:	0f be       	out	0x3f, r0	; 63
    21da:	81 11       	cpse	r24, r1
    21dc:	1e c0       	rjmp	.+60     	; 0x221a <xQueueGenericReceive+0x154>
    21de:	80 81       	ld	r24, Z
    21e0:	91 81       	ldd	r25, Z+1	; 0x01
    21e2:	89 2b       	or	r24, r25
    21e4:	49 f4       	brne	.+18     	; 0x21f8 <xQueueGenericReceive+0x132>
    21e6:	0f b6       	in	r0, 0x3f	; 63
    21e8:	f8 94       	cli
    21ea:	0f 92       	push	r0
    21ec:	82 81       	ldd	r24, Z+2	; 0x02
    21ee:	93 81       	ldd	r25, Z+3	; 0x03
    21f0:	0e 94 6d 16 	call	0x2cda	; 0x2cda <vTaskPriorityInherit>
    21f4:	0f 90       	pop	r0
    21f6:	0f be       	out	0x3f, r0	; 63
    21f8:	4e 81       	ldd	r20, Y+6	; 0x06
    21fa:	5f 81       	ldd	r21, Y+7	; 0x07
    21fc:	68 85       	ldd	r22, Y+8	; 0x08
    21fe:	79 85       	ldd	r23, Y+9	; 0x09
    2200:	c6 01       	movw	r24, r12
    2202:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <vTaskPlaceOnEventList>
    2206:	c7 01       	movw	r24, r14
    2208:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <prvUnlockQueue>
    220c:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <xTaskResumeAll>
    2210:	81 11       	cpse	r24, r1
    2212:	73 cf       	rjmp	.-282    	; 0x20fa <xQueueGenericReceive+0x34>
    2214:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <vPortYield>
    2218:	70 cf       	rjmp	.-288    	; 0x20fa <xQueueGenericReceive+0x34>
    221a:	c7 01       	movw	r24, r14
    221c:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <prvUnlockQueue>
    2220:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <xTaskResumeAll>
    2224:	6a cf       	rjmp	.-300    	; 0x20fa <xQueueGenericReceive+0x34>
    2226:	c7 01       	movw	r24, r14
    2228:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <prvUnlockQueue>
    222c:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <xTaskResumeAll>
    2230:	80 e0       	ldi	r24, 0x00	; 0
    2232:	29 96       	adiw	r28, 0x09	; 9
    2234:	cd bf       	out	0x3d, r28	; 61
    2236:	de bf       	out	0x3e, r29	; 62
    2238:	df 91       	pop	r29
    223a:	cf 91       	pop	r28
    223c:	1f 91       	pop	r17
    223e:	0f 91       	pop	r16
    2240:	ff 90       	pop	r15
    2242:	ef 90       	pop	r14
    2244:	df 90       	pop	r13
    2246:	cf 90       	pop	r12
    2248:	bf 90       	pop	r11
    224a:	af 90       	pop	r10
    224c:	08 95       	ret

0000224e <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    224e:	0f b6       	in	r0, 0x3f	; 63
    2250:	f8 94       	cli
    2252:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2254:	fc 01       	movw	r30, r24
    2256:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2258:	0f 90       	pop	r0
    225a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    225c:	08 95       	ret

0000225e <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    225e:	cc ee       	ldi	r28, 0xEC	; 236
    2260:	d0 e3       	ldi	r29, 0x30	; 48
    2262:	88 81       	ld	r24, Y
    2264:	82 30       	cpi	r24, 0x02	; 2
    2266:	e8 f3       	brcs	.-6      	; 0x2262 <prvIdleTask+0x4>
    2268:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <vPortYield>
    226c:	fa cf       	rjmp	.-12     	; 0x2262 <prvIdleTask+0x4>

0000226e <prvAddCurrentTaskToDelayedList>:
    226e:	cf 92       	push	r12
    2270:	df 92       	push	r13
    2272:	ef 92       	push	r14
    2274:	ff 92       	push	r15
    2276:	6b 01       	movw	r12, r22
    2278:	7c 01       	movw	r14, r24
    227a:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    227e:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2282:	62 83       	std	Z+2, r22	; 0x02
    2284:	73 83       	std	Z+3, r23	; 0x03
    2286:	84 83       	std	Z+4, r24	; 0x04
    2288:	95 83       	std	Z+5, r25	; 0x05
    228a:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    228e:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2292:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2296:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    229a:	c8 16       	cp	r12, r24
    229c:	d9 06       	cpc	r13, r25
    229e:	ea 06       	cpc	r14, r26
    22a0:	fb 06       	cpc	r15, r27
    22a2:	68 f4       	brcc	.+26     	; 0x22be <prvAddCurrentTaskToDelayedList+0x50>
    22a4:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    22a8:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    22ac:	80 91 d2 30 	lds	r24, 0x30D2	; 0x8030d2 <pxOverflowDelayedTaskList>
    22b0:	90 91 d3 30 	lds	r25, 0x30D3	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    22b4:	6e 5f       	subi	r22, 0xFE	; 254
    22b6:	7f 4f       	sbci	r23, 0xFF	; 255
    22b8:	0e 94 c2 0c 	call	0x1984	; 0x1984 <vListInsert>
    22bc:	21 c0       	rjmp	.+66     	; 0x2300 <prvAddCurrentTaskToDelayedList+0x92>
    22be:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    22c2:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    22c6:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    22ca:	90 91 d5 30 	lds	r25, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    22ce:	6e 5f       	subi	r22, 0xFE	; 254
    22d0:	7f 4f       	sbci	r23, 0xFF	; 255
    22d2:	0e 94 c2 0c 	call	0x1984	; 0x1984 <vListInsert>
    22d6:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    22da:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    22de:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    22e2:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    22e6:	c8 16       	cp	r12, r24
    22e8:	d9 06       	cpc	r13, r25
    22ea:	ea 06       	cpc	r14, r26
    22ec:	fb 06       	cpc	r15, r27
    22ee:	40 f4       	brcc	.+16     	; 0x2300 <prvAddCurrentTaskToDelayedList+0x92>
    22f0:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    22f4:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    22f8:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    22fc:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    2300:	ff 90       	pop	r15
    2302:	ef 90       	pop	r14
    2304:	df 90       	pop	r13
    2306:	cf 90       	pop	r12
    2308:	08 95       	ret

0000230a <xTaskGenericCreate>:
    230a:	4f 92       	push	r4
    230c:	5f 92       	push	r5
    230e:	6f 92       	push	r6
    2310:	7f 92       	push	r7
    2312:	8f 92       	push	r8
    2314:	9f 92       	push	r9
    2316:	af 92       	push	r10
    2318:	bf 92       	push	r11
    231a:	cf 92       	push	r12
    231c:	df 92       	push	r13
    231e:	ef 92       	push	r14
    2320:	ff 92       	push	r15
    2322:	0f 93       	push	r16
    2324:	1f 93       	push	r17
    2326:	cf 93       	push	r28
    2328:	df 93       	push	r29
    232a:	5c 01       	movw	r10, r24
    232c:	4b 01       	movw	r8, r22
    232e:	3a 01       	movw	r6, r20
    2330:	29 01       	movw	r4, r18
    2332:	88 e2       	ldi	r24, 0x28	; 40
    2334:	90 e0       	ldi	r25, 0x00	; 0
    2336:	0e 94 b4 0b 	call	0x1768	; 0x1768 <pvPortMalloc>
    233a:	ec 01       	movw	r28, r24
    233c:	89 2b       	or	r24, r25
    233e:	09 f4       	brne	.+2      	; 0x2342 <xTaskGenericCreate+0x38>
    2340:	d4 c0       	rjmp	.+424    	; 0x24ea <xTaskGenericCreate+0x1e0>
    2342:	c1 14       	cp	r12, r1
    2344:	d1 04       	cpc	r13, r1
    2346:	09 f0       	breq	.+2      	; 0x234a <xTaskGenericCreate+0x40>
    2348:	cc c0       	rjmp	.+408    	; 0x24e2 <xTaskGenericCreate+0x1d8>
    234a:	c3 01       	movw	r24, r6
    234c:	0e 94 b4 0b 	call	0x1768	; 0x1768 <pvPortMalloc>
    2350:	8b 8f       	std	Y+27, r24	; 0x1b
    2352:	9c 8f       	std	Y+28, r25	; 0x1c
    2354:	00 97       	sbiw	r24, 0x00	; 0
    2356:	21 f4       	brne	.+8      	; 0x2360 <xTaskGenericCreate+0x56>
    2358:	ce 01       	movw	r24, r28
    235a:	0e 94 4e 0c 	call	0x189c	; 0x189c <vPortFree>
    235e:	c5 c0       	rjmp	.+394    	; 0x24ea <xTaskGenericCreate+0x1e0>
    2360:	a3 01       	movw	r20, r6
    2362:	61 e1       	ldi	r22, 0x11	; 17
    2364:	70 e0       	ldi	r23, 0x00	; 0
    2366:	0e 94 43 22 	call	0x4486	; 0x4486 <memset>
    236a:	93 01       	movw	r18, r6
    236c:	21 50       	subi	r18, 0x01	; 1
    236e:	31 09       	sbc	r19, r1
    2370:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2372:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2374:	3c 01       	movw	r6, r24
    2376:	62 0e       	add	r6, r18
    2378:	73 1e       	adc	r7, r19
    237a:	4a e0       	ldi	r20, 0x0A	; 10
    237c:	50 e0       	ldi	r21, 0x00	; 0
    237e:	b4 01       	movw	r22, r8
    2380:	ce 01       	movw	r24, r28
    2382:	4d 96       	adiw	r24, 0x1d	; 29
    2384:	0e 94 4a 22 	call	0x4494	; 0x4494 <strncpy>
    2388:	1e a2       	std	Y+38, r1	; 0x26
    238a:	10 2f       	mov	r17, r16
    238c:	04 30       	cpi	r16, 0x04	; 4
    238e:	08 f0       	brcs	.+2      	; 0x2392 <xTaskGenericCreate+0x88>
    2390:	13 e0       	ldi	r17, 0x03	; 3
    2392:	1a 8f       	std	Y+26, r17	; 0x1a
    2394:	1f a3       	std	Y+39, r17	; 0x27
    2396:	6e 01       	movw	r12, r28
    2398:	22 e0       	ldi	r18, 0x02	; 2
    239a:	c2 0e       	add	r12, r18
    239c:	d1 1c       	adc	r13, r1
    239e:	c6 01       	movw	r24, r12
    23a0:	0e 94 97 0c 	call	0x192e	; 0x192e <vListInitialiseItem>
    23a4:	ce 01       	movw	r24, r28
    23a6:	0e 96       	adiw	r24, 0x0e	; 14
    23a8:	0e 94 97 0c 	call	0x192e	; 0x192e <vListInitialiseItem>
    23ac:	ca 87       	std	Y+10, r28	; 0x0a
    23ae:	db 87       	std	Y+11, r29	; 0x0b
    23b0:	84 e0       	ldi	r24, 0x04	; 4
    23b2:	90 e0       	ldi	r25, 0x00	; 0
    23b4:	a0 e0       	ldi	r26, 0x00	; 0
    23b6:	b0 e0       	ldi	r27, 0x00	; 0
    23b8:	81 1b       	sub	r24, r17
    23ba:	91 09       	sbc	r25, r1
    23bc:	a1 09       	sbc	r26, r1
    23be:	b1 09       	sbc	r27, r1
    23c0:	8e 87       	std	Y+14, r24	; 0x0e
    23c2:	9f 87       	std	Y+15, r25	; 0x0f
    23c4:	a8 8b       	std	Y+16, r26	; 0x10
    23c6:	b9 8b       	std	Y+17, r27	; 0x11
    23c8:	ce 8b       	std	Y+22, r28	; 0x16
    23ca:	df 8b       	std	Y+23, r29	; 0x17
    23cc:	a2 01       	movw	r20, r4
    23ce:	b5 01       	movw	r22, r10
    23d0:	c3 01       	movw	r24, r6
    23d2:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <pxPortInitialiseStack>
    23d6:	88 83       	st	Y, r24
    23d8:	99 83       	std	Y+1, r25	; 0x01
    23da:	e1 14       	cp	r14, r1
    23dc:	f1 04       	cpc	r15, r1
    23de:	19 f0       	breq	.+6      	; 0x23e6 <xTaskGenericCreate+0xdc>
    23e0:	f7 01       	movw	r30, r14
    23e2:	c0 83       	st	Z, r28
    23e4:	d1 83       	std	Z+1, r29	; 0x01
    23e6:	0f b6       	in	r0, 0x3f	; 63
    23e8:	f8 94       	cli
    23ea:	0f 92       	push	r0
    23ec:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    23f0:	8f 5f       	subi	r24, 0xFF	; 255
    23f2:	80 93 c4 30 	sts	0x30C4, r24	; 0x8030c4 <uxCurrentNumberOfTasks>
    23f6:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    23fa:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    23fe:	89 2b       	or	r24, r25
    2400:	89 f5       	brne	.+98     	; 0x2464 <xTaskGenericCreate+0x15a>
    2402:	c0 93 18 31 	sts	0x3118, r28	; 0x803118 <pxCurrentTCB>
    2406:	d0 93 19 31 	sts	0x3119, r29	; 0x803119 <pxCurrentTCB+0x1>
    240a:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    240e:	81 30       	cpi	r24, 0x01	; 1
    2410:	c1 f5       	brne	.+112    	; 0x2482 <xTaskGenericCreate+0x178>
    2412:	8c ee       	ldi	r24, 0xEC	; 236
    2414:	90 e3       	ldi	r25, 0x30	; 48
    2416:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInitialise>
    241a:	87 ef       	ldi	r24, 0xF7	; 247
    241c:	90 e3       	ldi	r25, 0x30	; 48
    241e:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInitialise>
    2422:	82 e0       	ldi	r24, 0x02	; 2
    2424:	91 e3       	ldi	r25, 0x31	; 49
    2426:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInitialise>
    242a:	8d e0       	ldi	r24, 0x0D	; 13
    242c:	91 e3       	ldi	r25, 0x31	; 49
    242e:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInitialise>
    2432:	81 ee       	ldi	r24, 0xE1	; 225
    2434:	90 e3       	ldi	r25, 0x30	; 48
    2436:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInitialise>
    243a:	86 ed       	ldi	r24, 0xD6	; 214
    243c:	90 e3       	ldi	r25, 0x30	; 48
    243e:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInitialise>
    2442:	87 ec       	ldi	r24, 0xC7	; 199
    2444:	90 e3       	ldi	r25, 0x30	; 48
    2446:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInitialise>
    244a:	81 ee       	ldi	r24, 0xE1	; 225
    244c:	90 e3       	ldi	r25, 0x30	; 48
    244e:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <pxDelayedTaskList>
    2452:	90 93 d5 30 	sts	0x30D5, r25	; 0x8030d5 <pxDelayedTaskList+0x1>
    2456:	86 ed       	ldi	r24, 0xD6	; 214
    2458:	90 e3       	ldi	r25, 0x30	; 48
    245a:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <pxOverflowDelayedTaskList>
    245e:	90 93 d3 30 	sts	0x30D3, r25	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    2462:	0f c0       	rjmp	.+30     	; 0x2482 <xTaskGenericCreate+0x178>
    2464:	80 91 bd 30 	lds	r24, 0x30BD	; 0x8030bd <xSchedulerRunning>
    2468:	81 11       	cpse	r24, r1
    246a:	0b c0       	rjmp	.+22     	; 0x2482 <xTaskGenericCreate+0x178>
    246c:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    2470:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2474:	82 8d       	ldd	r24, Z+26	; 0x1a
    2476:	08 17       	cp	r16, r24
    2478:	20 f0       	brcs	.+8      	; 0x2482 <xTaskGenericCreate+0x178>
    247a:	c0 93 18 31 	sts	0x3118, r28	; 0x803118 <pxCurrentTCB>
    247e:	d0 93 19 31 	sts	0x3119, r29	; 0x803119 <pxCurrentTCB+0x1>
    2482:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2484:	90 91 bf 30 	lds	r25, 0x30BF	; 0x8030bf <uxTopUsedPriority>
    2488:	98 17       	cp	r25, r24
    248a:	10 f4       	brcc	.+4      	; 0x2490 <xTaskGenericCreate+0x186>
    248c:	80 93 bf 30 	sts	0x30BF, r24	; 0x8030bf <uxTopUsedPriority>
    2490:	90 91 b8 30 	lds	r25, 0x30B8	; 0x8030b8 <uxTaskNumber>
    2494:	9f 5f       	subi	r25, 0xFF	; 255
    2496:	90 93 b8 30 	sts	0x30B8, r25	; 0x8030b8 <uxTaskNumber>
    249a:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    249e:	98 17       	cp	r25, r24
    24a0:	10 f4       	brcc	.+4      	; 0x24a6 <xTaskGenericCreate+0x19c>
    24a2:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    24a6:	fb e0       	ldi	r31, 0x0B	; 11
    24a8:	8f 9f       	mul	r24, r31
    24aa:	c0 01       	movw	r24, r0
    24ac:	11 24       	eor	r1, r1
    24ae:	b6 01       	movw	r22, r12
    24b0:	84 51       	subi	r24, 0x14	; 20
    24b2:	9f 4c       	sbci	r25, 0xCF	; 207
    24b4:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vListInsertEnd>
    24b8:	0f 90       	pop	r0
    24ba:	0f be       	out	0x3f, r0	; 63
    24bc:	80 91 bd 30 	lds	r24, 0x30BD	; 0x8030bd <xSchedulerRunning>
    24c0:	88 23       	and	r24, r24
    24c2:	59 f0       	breq	.+22     	; 0x24da <xTaskGenericCreate+0x1d0>
    24c4:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    24c8:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    24cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    24ce:	80 17       	cp	r24, r16
    24d0:	30 f4       	brcc	.+12     	; 0x24de <xTaskGenericCreate+0x1d4>
    24d2:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <vPortYield>
    24d6:	81 e0       	ldi	r24, 0x01	; 1
    24d8:	09 c0       	rjmp	.+18     	; 0x24ec <xTaskGenericCreate+0x1e2>
    24da:	81 e0       	ldi	r24, 0x01	; 1
    24dc:	07 c0       	rjmp	.+14     	; 0x24ec <xTaskGenericCreate+0x1e2>
    24de:	81 e0       	ldi	r24, 0x01	; 1
    24e0:	05 c0       	rjmp	.+10     	; 0x24ec <xTaskGenericCreate+0x1e2>
    24e2:	cb 8e       	std	Y+27, r12	; 0x1b
    24e4:	dc 8e       	std	Y+28, r13	; 0x1c
    24e6:	c6 01       	movw	r24, r12
    24e8:	3b cf       	rjmp	.-394    	; 0x2360 <xTaskGenericCreate+0x56>
    24ea:	8f ef       	ldi	r24, 0xFF	; 255
    24ec:	df 91       	pop	r29
    24ee:	cf 91       	pop	r28
    24f0:	1f 91       	pop	r17
    24f2:	0f 91       	pop	r16
    24f4:	ff 90       	pop	r15
    24f6:	ef 90       	pop	r14
    24f8:	df 90       	pop	r13
    24fa:	cf 90       	pop	r12
    24fc:	bf 90       	pop	r11
    24fe:	af 90       	pop	r10
    2500:	9f 90       	pop	r9
    2502:	8f 90       	pop	r8
    2504:	7f 90       	pop	r7
    2506:	6f 90       	pop	r6
    2508:	5f 90       	pop	r5
    250a:	4f 90       	pop	r4
    250c:	08 95       	ret

0000250e <uxTaskPriorityGet>:
    250e:	0f b6       	in	r0, 0x3f	; 63
    2510:	f8 94       	cli
    2512:	0f 92       	push	r0
    2514:	00 97       	sbiw	r24, 0x00	; 0
    2516:	21 f4       	brne	.+8      	; 0x2520 <uxTaskPriorityGet+0x12>
    2518:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    251c:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2520:	0f 90       	pop	r0
    2522:	0f be       	out	0x3f, r0	; 63
    2524:	fc 01       	movw	r30, r24
    2526:	82 8d       	ldd	r24, Z+26	; 0x1a
    2528:	08 95       	ret

0000252a <vTaskStartScheduler>:
    252a:	af 92       	push	r10
    252c:	bf 92       	push	r11
    252e:	cf 92       	push	r12
    2530:	df 92       	push	r13
    2532:	ef 92       	push	r14
    2534:	ff 92       	push	r15
    2536:	0f 93       	push	r16
    2538:	a1 2c       	mov	r10, r1
    253a:	b1 2c       	mov	r11, r1
    253c:	c1 2c       	mov	r12, r1
    253e:	d1 2c       	mov	r13, r1
    2540:	0f 2e       	mov	r0, r31
    2542:	f5 ec       	ldi	r31, 0xC5	; 197
    2544:	ef 2e       	mov	r14, r31
    2546:	f0 e3       	ldi	r31, 0x30	; 48
    2548:	ff 2e       	mov	r15, r31
    254a:	f0 2d       	mov	r31, r0
    254c:	00 e0       	ldi	r16, 0x00	; 0
    254e:	20 e0       	ldi	r18, 0x00	; 0
    2550:	30 e0       	ldi	r19, 0x00	; 0
    2552:	44 e6       	ldi	r20, 0x64	; 100
    2554:	50 e0       	ldi	r21, 0x00	; 0
    2556:	6e e2       	ldi	r22, 0x2E	; 46
    2558:	70 e2       	ldi	r23, 0x20	; 32
    255a:	8f e2       	ldi	r24, 0x2F	; 47
    255c:	91 e1       	ldi	r25, 0x11	; 17
    255e:	0e 94 85 11 	call	0x230a	; 0x230a <xTaskGenericCreate>
    2562:	81 30       	cpi	r24, 0x01	; 1
    2564:	69 f4       	brne	.+26     	; 0x2580 <vTaskStartScheduler+0x56>
    2566:	f8 94       	cli
    2568:	80 93 bd 30 	sts	0x30BD, r24	; 0x8030bd <xSchedulerRunning>
    256c:	10 92 c0 30 	sts	0x30C0, r1	; 0x8030c0 <xTickCount>
    2570:	10 92 c1 30 	sts	0x30C1, r1	; 0x8030c1 <xTickCount+0x1>
    2574:	10 92 c2 30 	sts	0x30C2, r1	; 0x8030c2 <xTickCount+0x2>
    2578:	10 92 c3 30 	sts	0x30C3, r1	; 0x8030c3 <xTickCount+0x3>
    257c:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <xPortStartScheduler>
    2580:	0f 91       	pop	r16
    2582:	ff 90       	pop	r15
    2584:	ef 90       	pop	r14
    2586:	df 90       	pop	r13
    2588:	cf 90       	pop	r12
    258a:	bf 90       	pop	r11
    258c:	af 90       	pop	r10
    258e:	08 95       	ret

00002590 <vTaskSuspendAll>:
    2590:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2594:	8f 5f       	subi	r24, 0xFF	; 255
    2596:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <uxSchedulerSuspended>
    259a:	08 95       	ret

0000259c <xTaskGetTickCount>:
    259c:	0f b6       	in	r0, 0x3f	; 63
    259e:	f8 94       	cli
    25a0:	0f 92       	push	r0
    25a2:	60 91 c0 30 	lds	r22, 0x30C0	; 0x8030c0 <xTickCount>
    25a6:	70 91 c1 30 	lds	r23, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    25aa:	80 91 c2 30 	lds	r24, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    25ae:	90 91 c3 30 	lds	r25, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    25b2:	0f 90       	pop	r0
    25b4:	0f be       	out	0x3f, r0	; 63
    25b6:	08 95       	ret

000025b8 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    25b8:	00 97       	sbiw	r24, 0x00	; 0
    25ba:	21 f4       	brne	.+8      	; 0x25c4 <pcTaskGetTaskName+0xc>
    25bc:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    25c0:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    25c4:	4d 96       	adiw	r24, 0x1d	; 29
    25c6:	08 95       	ret

000025c8 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    25c8:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xIdleTaskHandle>
    25cc:	90 91 c6 30 	lds	r25, 0x30C6	; 0x8030c6 <xIdleTaskHandle+0x1>
    25d0:	08 95       	ret

000025d2 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    25d2:	ff 92       	push	r15
    25d4:	0f 93       	push	r16
    25d6:	1f 93       	push	r17
    25d8:	cf 93       	push	r28
    25da:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    25dc:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    25e0:	81 11       	cpse	r24, r1
    25e2:	ed c0       	rjmp	.+474    	; 0x27be <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    25e4:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    25e8:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    25ec:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    25f0:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    25f4:	01 96       	adiw	r24, 0x01	; 1
    25f6:	a1 1d       	adc	r26, r1
    25f8:	b1 1d       	adc	r27, r1
    25fa:	80 93 c0 30 	sts	0x30C0, r24	; 0x8030c0 <xTickCount>
    25fe:	90 93 c1 30 	sts	0x30C1, r25	; 0x8030c1 <xTickCount+0x1>
    2602:	a0 93 c2 30 	sts	0x30C2, r26	; 0x8030c2 <xTickCount+0x2>
    2606:	b0 93 c3 30 	sts	0x30C3, r27	; 0x8030c3 <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    260a:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    260e:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2612:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2616:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    261a:	89 2b       	or	r24, r25
    261c:	8a 2b       	or	r24, r26
    261e:	8b 2b       	or	r24, r27
    2620:	f1 f5       	brne	.+124    	; 0x269e <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2622:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2626:	90 91 d5 30 	lds	r25, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    262a:	20 91 d2 30 	lds	r18, 0x30D2	; 0x8030d2 <pxOverflowDelayedTaskList>
    262e:	30 91 d3 30 	lds	r19, 0x30D3	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    2632:	20 93 d4 30 	sts	0x30D4, r18	; 0x8030d4 <pxDelayedTaskList>
    2636:	30 93 d5 30 	sts	0x30D5, r19	; 0x8030d5 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    263a:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <pxOverflowDelayedTaskList>
    263e:	90 93 d3 30 	sts	0x30D3, r25	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    2642:	80 91 b9 30 	lds	r24, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    2646:	8f 5f       	subi	r24, 0xFF	; 255
    2648:	80 93 b9 30 	sts	0x30B9, r24	; 0x8030b9 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    264c:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2650:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    2654:	80 81       	ld	r24, Z
    2656:	81 11       	cpse	r24, r1
    2658:	0c c0       	rjmp	.+24     	; 0x2672 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    265a:	8f ef       	ldi	r24, 0xFF	; 255
    265c:	9f ef       	ldi	r25, 0xFF	; 255
    265e:	dc 01       	movw	r26, r24
    2660:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2664:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2668:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    266c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2670:	16 c0       	rjmp	.+44     	; 0x269e <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2672:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2676:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    267a:	07 80       	ldd	r0, Z+7	; 0x07
    267c:	f0 85       	ldd	r31, Z+8	; 0x08
    267e:	e0 2d       	mov	r30, r0
    2680:	00 84       	ldd	r0, Z+8	; 0x08
    2682:	f1 85       	ldd	r31, Z+9	; 0x09
    2684:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2686:	82 81       	ldd	r24, Z+2	; 0x02
    2688:	93 81       	ldd	r25, Z+3	; 0x03
    268a:	a4 81       	ldd	r26, Z+4	; 0x04
    268c:	b5 81       	ldd	r27, Z+5	; 0x05
    268e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2692:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2696:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    269a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    269e:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    26a2:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    26a6:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    26aa:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    26ae:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    26b2:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    26b6:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    26ba:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    26be:	48 17       	cp	r20, r24
    26c0:	59 07       	cpc	r21, r25
    26c2:	6a 07       	cpc	r22, r26
    26c4:	7b 07       	cpc	r23, r27
    26c6:	08 f4       	brcc	.+2      	; 0x26ca <vTaskIncrementTick+0xf8>
    26c8:	7f c0       	rjmp	.+254    	; 0x27c8 <vTaskIncrementTick+0x1f6>
    26ca:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    26ce:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    26d2:	80 81       	ld	r24, Z
    26d4:	88 23       	and	r24, r24
    26d6:	f9 f0       	breq	.+62     	; 0x2716 <vTaskIncrementTick+0x144>
    26d8:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    26dc:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    26e0:	07 80       	ldd	r0, Z+7	; 0x07
    26e2:	f0 85       	ldd	r31, Z+8	; 0x08
    26e4:	e0 2d       	mov	r30, r0
    26e6:	c0 85       	ldd	r28, Z+8	; 0x08
    26e8:	d1 85       	ldd	r29, Z+9	; 0x09
    26ea:	8a 81       	ldd	r24, Y+2	; 0x02
    26ec:	9b 81       	ldd	r25, Y+3	; 0x03
    26ee:	ac 81       	ldd	r26, Y+4	; 0x04
    26f0:	bd 81       	ldd	r27, Y+5	; 0x05
    26f2:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    26f6:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    26fa:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    26fe:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2702:	48 17       	cp	r20, r24
    2704:	59 07       	cpc	r21, r25
    2706:	6a 07       	cpc	r22, r26
    2708:	7b 07       	cpc	r23, r27
    270a:	58 f1       	brcs	.+86     	; 0x2762 <vTaskIncrementTick+0x190>
    270c:	0f 2e       	mov	r0, r31
    270e:	fb e0       	ldi	r31, 0x0B	; 11
    2710:	ff 2e       	mov	r15, r31
    2712:	f0 2d       	mov	r31, r0
    2714:	2f c0       	rjmp	.+94     	; 0x2774 <vTaskIncrementTick+0x1a2>
    2716:	8f ef       	ldi	r24, 0xFF	; 255
    2718:	9f ef       	ldi	r25, 0xFF	; 255
    271a:	dc 01       	movw	r26, r24
    271c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2720:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2724:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2728:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    272c:	4d c0       	rjmp	.+154    	; 0x27c8 <vTaskIncrementTick+0x1f6>
    272e:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2732:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    2736:	07 80       	ldd	r0, Z+7	; 0x07
    2738:	f0 85       	ldd	r31, Z+8	; 0x08
    273a:	e0 2d       	mov	r30, r0
    273c:	c0 85       	ldd	r28, Z+8	; 0x08
    273e:	d1 85       	ldd	r29, Z+9	; 0x09
    2740:	8a 81       	ldd	r24, Y+2	; 0x02
    2742:	9b 81       	ldd	r25, Y+3	; 0x03
    2744:	ac 81       	ldd	r26, Y+4	; 0x04
    2746:	bd 81       	ldd	r27, Y+5	; 0x05
    2748:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    274c:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2750:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2754:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2758:	48 17       	cp	r20, r24
    275a:	59 07       	cpc	r21, r25
    275c:	6a 07       	cpc	r22, r26
    275e:	7b 07       	cpc	r23, r27
    2760:	48 f4       	brcc	.+18     	; 0x2774 <vTaskIncrementTick+0x1a2>
    2762:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2766:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    276a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    276e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2772:	2a c0       	rjmp	.+84     	; 0x27c8 <vTaskIncrementTick+0x1f6>
    2774:	8e 01       	movw	r16, r28
    2776:	0e 5f       	subi	r16, 0xFE	; 254
    2778:	1f 4f       	sbci	r17, 0xFF	; 255
    277a:	c8 01       	movw	r24, r16
    277c:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <vListRemove>
    2780:	88 8d       	ldd	r24, Y+24	; 0x18
    2782:	99 8d       	ldd	r25, Y+25	; 0x19
    2784:	89 2b       	or	r24, r25
    2786:	21 f0       	breq	.+8      	; 0x2790 <vTaskIncrementTick+0x1be>
    2788:	ce 01       	movw	r24, r28
    278a:	0e 96       	adiw	r24, 0x0e	; 14
    278c:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <vListRemove>
    2790:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2792:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2796:	98 17       	cp	r25, r24
    2798:	10 f4       	brcc	.+4      	; 0x279e <vTaskIncrementTick+0x1cc>
    279a:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    279e:	f8 9e       	mul	r15, r24
    27a0:	c0 01       	movw	r24, r0
    27a2:	11 24       	eor	r1, r1
    27a4:	b8 01       	movw	r22, r16
    27a6:	84 51       	subi	r24, 0x14	; 20
    27a8:	9f 4c       	sbci	r25, 0xCF	; 207
    27aa:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vListInsertEnd>
    27ae:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    27b2:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    27b6:	80 81       	ld	r24, Z
    27b8:	81 11       	cpse	r24, r1
    27ba:	b9 cf       	rjmp	.-142    	; 0x272e <vTaskIncrementTick+0x15c>
    27bc:	ac cf       	rjmp	.-168    	; 0x2716 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    27be:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    27c2:	8f 5f       	subi	r24, 0xFF	; 255
    27c4:	80 93 bb 30 	sts	0x30BB, r24	; 0x8030bb <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    27c8:	df 91       	pop	r29
    27ca:	cf 91       	pop	r28
    27cc:	1f 91       	pop	r17
    27ce:	0f 91       	pop	r16
    27d0:	ff 90       	pop	r15
    27d2:	08 95       	ret

000027d4 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    27d4:	cf 92       	push	r12
    27d6:	df 92       	push	r13
    27d8:	ef 92       	push	r14
    27da:	ff 92       	push	r15
    27dc:	0f 93       	push	r16
    27de:	1f 93       	push	r17
    27e0:	cf 93       	push	r28
    27e2:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    27e4:	0f b6       	in	r0, 0x3f	; 63
    27e6:	f8 94       	cli
    27e8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    27ea:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    27ee:	81 50       	subi	r24, 0x01	; 1
    27f0:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    27f4:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    27f8:	81 11       	cpse	r24, r1
    27fa:	60 c0       	rjmp	.+192    	; 0x28bc <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    27fc:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    2800:	81 11       	cpse	r24, r1
    2802:	2c c0       	rjmp	.+88     	; 0x285c <xTaskResumeAll+0x88>
    2804:	5e c0       	rjmp	.+188    	; 0x28c2 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2806:	d7 01       	movw	r26, r14
    2808:	17 96       	adiw	r26, 0x07	; 7
    280a:	ed 91       	ld	r30, X+
    280c:	fc 91       	ld	r31, X
    280e:	18 97       	sbiw	r26, 0x08	; 8
    2810:	c0 85       	ldd	r28, Z+8	; 0x08
    2812:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2814:	ce 01       	movw	r24, r28
    2816:	0e 96       	adiw	r24, 0x0e	; 14
    2818:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    281c:	8e 01       	movw	r16, r28
    281e:	0e 5f       	subi	r16, 0xFE	; 254
    2820:	1f 4f       	sbci	r17, 0xFF	; 255
    2822:	c8 01       	movw	r24, r16
    2824:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2828:	8a 8d       	ldd	r24, Y+26	; 0x1a
    282a:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    282e:	98 17       	cp	r25, r24
    2830:	10 f4       	brcc	.+4      	; 0x2836 <xTaskResumeAll+0x62>
    2832:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2836:	d8 9e       	mul	r13, r24
    2838:	c0 01       	movw	r24, r0
    283a:	11 24       	eor	r1, r1
    283c:	b8 01       	movw	r22, r16
    283e:	84 51       	subi	r24, 0x14	; 20
    2840:	9f 4c       	sbci	r25, 0xCF	; 207
    2842:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2846:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    284a:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    284e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2850:	82 8d       	ldd	r24, Z+26	; 0x1a
    2852:	98 17       	cp	r25, r24
    2854:	70 f0       	brcs	.+28     	; 0x2872 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    2856:	cc 24       	eor	r12, r12
    2858:	c3 94       	inc	r12
    285a:	0b c0       	rjmp	.+22     	; 0x2872 <xTaskResumeAll+0x9e>
    285c:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    285e:	0f 2e       	mov	r0, r31
    2860:	f7 ec       	ldi	r31, 0xC7	; 199
    2862:	ef 2e       	mov	r14, r31
    2864:	f0 e3       	ldi	r31, 0x30	; 48
    2866:	ff 2e       	mov	r15, r31
    2868:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    286a:	0f 2e       	mov	r0, r31
    286c:	fb e0       	ldi	r31, 0x0B	; 11
    286e:	df 2e       	mov	r13, r31
    2870:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2872:	f7 01       	movw	r30, r14
    2874:	80 81       	ld	r24, Z
    2876:	81 11       	cpse	r24, r1
    2878:	c6 cf       	rjmp	.-116    	; 0x2806 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    287a:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    287e:	88 23       	and	r24, r24
    2880:	81 f0       	breq	.+32     	; 0x28a2 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2882:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2886:	88 23       	and	r24, r24
    2888:	99 f0       	breq	.+38     	; 0x28b0 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    288a:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <vTaskIncrementTick>
						--uxMissedTicks;
    288e:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2892:	81 50       	subi	r24, 0x01	; 1
    2894:	80 93 bb 30 	sts	0x30BB, r24	; 0x8030bb <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2898:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    289c:	81 11       	cpse	r24, r1
    289e:	f5 cf       	rjmp	.-22     	; 0x288a <xTaskResumeAll+0xb6>
    28a0:	07 c0       	rjmp	.+14     	; 0x28b0 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    28a2:	f1 e0       	ldi	r31, 0x01	; 1
    28a4:	cf 16       	cp	r12, r31
    28a6:	21 f0       	breq	.+8      	; 0x28b0 <xTaskResumeAll+0xdc>
    28a8:	80 91 ba 30 	lds	r24, 0x30BA	; 0x8030ba <xMissedYield>
    28ac:	81 30       	cpi	r24, 0x01	; 1
    28ae:	41 f4       	brne	.+16     	; 0x28c0 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    28b0:	10 92 ba 30 	sts	0x30BA, r1	; 0x8030ba <xMissedYield>
					portYIELD_WITHIN_API();
    28b4:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    28b8:	81 e0       	ldi	r24, 0x01	; 1
    28ba:	03 c0       	rjmp	.+6      	; 0x28c2 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    28bc:	80 e0       	ldi	r24, 0x00	; 0
    28be:	01 c0       	rjmp	.+2      	; 0x28c2 <xTaskResumeAll+0xee>
    28c0:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    28c2:	0f 90       	pop	r0
    28c4:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    28c6:	df 91       	pop	r29
    28c8:	cf 91       	pop	r28
    28ca:	1f 91       	pop	r17
    28cc:	0f 91       	pop	r16
    28ce:	ff 90       	pop	r15
    28d0:	ef 90       	pop	r14
    28d2:	df 90       	pop	r13
    28d4:	cf 90       	pop	r12
    28d6:	08 95       	ret

000028d8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    28d8:	cf 92       	push	r12
    28da:	df 92       	push	r13
    28dc:	ef 92       	push	r14
    28de:	ff 92       	push	r15
    28e0:	cf 93       	push	r28
    28e2:	df 93       	push	r29
    28e4:	ec 01       	movw	r28, r24
    28e6:	6a 01       	movw	r12, r20
    28e8:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    28ea:	0e 94 c8 12 	call	0x2590	; 0x2590 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    28ee:	88 81       	ld	r24, Y
    28f0:	99 81       	ldd	r25, Y+1	; 0x01
    28f2:	aa 81       	ldd	r26, Y+2	; 0x02
    28f4:	bb 81       	ldd	r27, Y+3	; 0x03
    28f6:	c8 0e       	add	r12, r24
    28f8:	d9 1e       	adc	r13, r25
    28fa:	ea 1e       	adc	r14, r26
    28fc:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    28fe:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    2902:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2906:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    290a:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    290e:	48 17       	cp	r20, r24
    2910:	59 07       	cpc	r21, r25
    2912:	6a 07       	cpc	r22, r26
    2914:	7b 07       	cpc	r23, r27
    2916:	b8 f4       	brcc	.+46     	; 0x2946 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2918:	c8 16       	cp	r12, r24
    291a:	d9 06       	cpc	r13, r25
    291c:	ea 06       	cpc	r14, r26
    291e:	fb 06       	cpc	r15, r27
    2920:	e0 f5       	brcc	.+120    	; 0x299a <vTaskDelayUntil+0xc2>
    2922:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2926:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    292a:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    292e:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2932:	c8 82       	st	Y, r12
    2934:	d9 82       	std	Y+1, r13	; 0x01
    2936:	ea 82       	std	Y+2, r14	; 0x02
    2938:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    293a:	8c 15       	cp	r24, r12
    293c:	9d 05       	cpc	r25, r13
    293e:	ae 05       	cpc	r26, r14
    2940:	bf 05       	cpc	r27, r15
    2942:	f8 f4       	brcc	.+62     	; 0x2982 <vTaskDelayUntil+0xaa>
    2944:	13 c0       	rjmp	.+38     	; 0x296c <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2946:	c8 16       	cp	r12, r24
    2948:	d9 06       	cpc	r13, r25
    294a:	ea 06       	cpc	r14, r26
    294c:	fb 06       	cpc	r15, r27
    294e:	00 f1       	brcs	.+64     	; 0x2990 <vTaskDelayUntil+0xb8>
    2950:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2954:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2958:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    295c:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2960:	8c 15       	cp	r24, r12
    2962:	9d 05       	cpc	r25, r13
    2964:	ae 05       	cpc	r26, r14
    2966:	bf 05       	cpc	r27, r15
    2968:	98 f0       	brcs	.+38     	; 0x2990 <vTaskDelayUntil+0xb8>
    296a:	17 c0       	rjmp	.+46     	; 0x299a <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    296c:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2970:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2974:	02 96       	adiw	r24, 0x02	; 2
    2976:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    297a:	c7 01       	movw	r24, r14
    297c:	b6 01       	movw	r22, r12
    297e:	0e 94 37 11 	call	0x226e	; 0x226e <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2982:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2986:	81 11       	cpse	r24, r1
    2988:	0d c0       	rjmp	.+26     	; 0x29a4 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    298a:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <vPortYield>
		}
	}
    298e:	0a c0       	rjmp	.+20     	; 0x29a4 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2990:	c8 82       	st	Y, r12
    2992:	d9 82       	std	Y+1, r13	; 0x01
    2994:	ea 82       	std	Y+2, r14	; 0x02
    2996:	fb 82       	std	Y+3, r15	; 0x03
    2998:	e9 cf       	rjmp	.-46     	; 0x296c <vTaskDelayUntil+0x94>
    299a:	c8 82       	st	Y, r12
    299c:	d9 82       	std	Y+1, r13	; 0x01
    299e:	ea 82       	std	Y+2, r14	; 0x02
    29a0:	fb 82       	std	Y+3, r15	; 0x03
    29a2:	ef cf       	rjmp	.-34     	; 0x2982 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    29a4:	df 91       	pop	r29
    29a6:	cf 91       	pop	r28
    29a8:	ff 90       	pop	r15
    29aa:	ef 90       	pop	r14
    29ac:	df 90       	pop	r13
    29ae:	cf 90       	pop	r12
    29b0:	08 95       	ret

000029b2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    29b2:	cf 92       	push	r12
    29b4:	df 92       	push	r13
    29b6:	ef 92       	push	r14
    29b8:	ff 92       	push	r15
    29ba:	6b 01       	movw	r12, r22
    29bc:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    29be:	67 2b       	or	r22, r23
    29c0:	68 2b       	or	r22, r24
    29c2:	69 2b       	or	r22, r25
    29c4:	e9 f0       	breq	.+58     	; 0x2a00 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    29c6:	0e 94 c8 12 	call	0x2590	; 0x2590 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    29ca:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    29ce:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    29d2:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    29d6:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    29da:	c8 0e       	add	r12, r24
    29dc:	d9 1e       	adc	r13, r25
    29de:	ea 1e       	adc	r14, r26
    29e0:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    29e2:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    29e6:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    29ea:	02 96       	adiw	r24, 0x02	; 2
    29ec:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    29f0:	c7 01       	movw	r24, r14
    29f2:	b6 01       	movw	r22, r12
    29f4:	0e 94 37 11 	call	0x226e	; 0x226e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    29f8:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    29fc:	81 11       	cpse	r24, r1
    29fe:	02 c0       	rjmp	.+4      	; 0x2a04 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2a00:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <vPortYield>
		}
	}
    2a04:	ff 90       	pop	r15
    2a06:	ef 90       	pop	r14
    2a08:	df 90       	pop	r13
    2a0a:	cf 90       	pop	r12
    2a0c:	08 95       	ret

00002a0e <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2a0e:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2a12:	81 11       	cpse	r24, r1
    2a14:	0c c0       	rjmp	.+24     	; 0x2a2e <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2a16:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2a1a:	4b e0       	ldi	r20, 0x0B	; 11
    2a1c:	e4 9f       	mul	r30, r20
    2a1e:	f0 01       	movw	r30, r0
    2a20:	11 24       	eor	r1, r1
    2a22:	e4 51       	subi	r30, 0x14	; 20
    2a24:	ff 4c       	sbci	r31, 0xCF	; 207
    2a26:	80 81       	ld	r24, Z
    2a28:	88 23       	and	r24, r24
    2a2a:	29 f0       	breq	.+10     	; 0x2a36 <vTaskSwitchContext+0x28>
    2a2c:	14 c0       	rjmp	.+40     	; 0x2a56 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2a2e:	81 e0       	ldi	r24, 0x01	; 1
    2a30:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <xMissedYield>
    2a34:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2a36:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2a38:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2a3c:	81 50       	subi	r24, 0x01	; 1
    2a3e:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2a42:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2a46:	9e 9f       	mul	r25, r30
    2a48:	f0 01       	movw	r30, r0
    2a4a:	11 24       	eor	r1, r1
    2a4c:	e4 51       	subi	r30, 0x14	; 20
    2a4e:	ff 4c       	sbci	r31, 0xCF	; 207
    2a50:	80 81       	ld	r24, Z
    2a52:	88 23       	and	r24, r24
    2a54:	89 f3       	breq	.-30     	; 0x2a38 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2a56:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2a5a:	28 2f       	mov	r18, r24
    2a5c:	30 e0       	ldi	r19, 0x00	; 0
    2a5e:	4b e0       	ldi	r20, 0x0B	; 11
    2a60:	84 9f       	mul	r24, r20
    2a62:	c0 01       	movw	r24, r0
    2a64:	11 24       	eor	r1, r1
    2a66:	dc 01       	movw	r26, r24
    2a68:	a4 51       	subi	r26, 0x14	; 20
    2a6a:	bf 4c       	sbci	r27, 0xCF	; 207
    2a6c:	11 96       	adiw	r26, 0x01	; 1
    2a6e:	ed 91       	ld	r30, X+
    2a70:	fc 91       	ld	r31, X
    2a72:	12 97       	sbiw	r26, 0x02	; 2
    2a74:	04 80       	ldd	r0, Z+4	; 0x04
    2a76:	f5 81       	ldd	r31, Z+5	; 0x05
    2a78:	e0 2d       	mov	r30, r0
    2a7a:	11 96       	adiw	r26, 0x01	; 1
    2a7c:	ed 93       	st	X+, r30
    2a7e:	fc 93       	st	X, r31
    2a80:	12 97       	sbiw	r26, 0x02	; 2
    2a82:	81 51       	subi	r24, 0x11	; 17
    2a84:	9f 4c       	sbci	r25, 0xCF	; 207
    2a86:	e8 17       	cp	r30, r24
    2a88:	f9 07       	cpc	r31, r25
    2a8a:	61 f4       	brne	.+24     	; 0x2aa4 <vTaskSwitchContext+0x96>
    2a8c:	84 81       	ldd	r24, Z+4	; 0x04
    2a8e:	95 81       	ldd	r25, Z+5	; 0x05
    2a90:	4b e0       	ldi	r20, 0x0B	; 11
    2a92:	42 9f       	mul	r20, r18
    2a94:	f0 01       	movw	r30, r0
    2a96:	43 9f       	mul	r20, r19
    2a98:	f0 0d       	add	r31, r0
    2a9a:	11 24       	eor	r1, r1
    2a9c:	e4 51       	subi	r30, 0x14	; 20
    2a9e:	ff 4c       	sbci	r31, 0xCF	; 207
    2aa0:	81 83       	std	Z+1, r24	; 0x01
    2aa2:	92 83       	std	Z+2, r25	; 0x02
    2aa4:	8b e0       	ldi	r24, 0x0B	; 11
    2aa6:	82 9f       	mul	r24, r18
    2aa8:	f0 01       	movw	r30, r0
    2aaa:	83 9f       	mul	r24, r19
    2aac:	f0 0d       	add	r31, r0
    2aae:	11 24       	eor	r1, r1
    2ab0:	e4 51       	subi	r30, 0x14	; 20
    2ab2:	ff 4c       	sbci	r31, 0xCF	; 207
    2ab4:	01 80       	ldd	r0, Z+1	; 0x01
    2ab6:	f2 81       	ldd	r31, Z+2	; 0x02
    2ab8:	e0 2d       	mov	r30, r0
    2aba:	80 85       	ldd	r24, Z+8	; 0x08
    2abc:	91 85       	ldd	r25, Z+9	; 0x09
    2abe:	80 93 18 31 	sts	0x3118, r24	; 0x803118 <pxCurrentTCB>
    2ac2:	90 93 19 31 	sts	0x3119, r25	; 0x803119 <pxCurrentTCB+0x1>
    2ac6:	08 95       	ret

00002ac8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2ac8:	cf 92       	push	r12
    2aca:	df 92       	push	r13
    2acc:	ef 92       	push	r14
    2ace:	ff 92       	push	r15
    2ad0:	6a 01       	movw	r12, r20
    2ad2:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2ad4:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    2ad8:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2adc:	62 5f       	subi	r22, 0xF2	; 242
    2ade:	7f 4f       	sbci	r23, 0xFF	; 255
    2ae0:	0e 94 c2 0c 	call	0x1984	; 0x1984 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2ae4:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2ae8:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2aec:	02 96       	adiw	r24, 0x02	; 2
    2aee:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2af2:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2af6:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2afa:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2afe:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2b02:	bc 01       	movw	r22, r24
    2b04:	cd 01       	movw	r24, r26
    2b06:	6c 0d       	add	r22, r12
    2b08:	7d 1d       	adc	r23, r13
    2b0a:	8e 1d       	adc	r24, r14
    2b0c:	9f 1d       	adc	r25, r15
    2b0e:	0e 94 37 11 	call	0x226e	; 0x226e <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2b12:	ff 90       	pop	r15
    2b14:	ef 90       	pop	r14
    2b16:	df 90       	pop	r13
    2b18:	cf 90       	pop	r12
    2b1a:	08 95       	ret

00002b1c <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2b1c:	0f 93       	push	r16
    2b1e:	1f 93       	push	r17
    2b20:	cf 93       	push	r28
    2b22:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2b24:	dc 01       	movw	r26, r24
    2b26:	17 96       	adiw	r26, 0x07	; 7
    2b28:	ed 91       	ld	r30, X+
    2b2a:	fc 91       	ld	r31, X
    2b2c:	18 97       	sbiw	r26, 0x08	; 8
    2b2e:	c0 85       	ldd	r28, Z+8	; 0x08
    2b30:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2b32:	8e 01       	movw	r16, r28
    2b34:	02 5f       	subi	r16, 0xF2	; 242
    2b36:	1f 4f       	sbci	r17, 0xFF	; 255
    2b38:	c8 01       	movw	r24, r16
    2b3a:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2b3e:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2b42:	81 11       	cpse	r24, r1
    2b44:	16 c0       	rjmp	.+44     	; 0x2b72 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2b46:	0c 50       	subi	r16, 0x0C	; 12
    2b48:	11 09       	sbc	r17, r1
    2b4a:	c8 01       	movw	r24, r16
    2b4c:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2b50:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b52:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2b56:	98 17       	cp	r25, r24
    2b58:	10 f4       	brcc	.+4      	; 0x2b5e <xTaskRemoveFromEventList+0x42>
    2b5a:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2b5e:	bb e0       	ldi	r27, 0x0B	; 11
    2b60:	8b 9f       	mul	r24, r27
    2b62:	c0 01       	movw	r24, r0
    2b64:	11 24       	eor	r1, r1
    2b66:	b8 01       	movw	r22, r16
    2b68:	84 51       	subi	r24, 0x14	; 20
    2b6a:	9f 4c       	sbci	r25, 0xCF	; 207
    2b6c:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vListInsertEnd>
    2b70:	05 c0       	rjmp	.+10     	; 0x2b7c <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2b72:	b8 01       	movw	r22, r16
    2b74:	87 ec       	ldi	r24, 0xC7	; 199
    2b76:	90 e3       	ldi	r25, 0x30	; 48
    2b78:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2b7c:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    2b80:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2b84:	81 e0       	ldi	r24, 0x01	; 1
    2b86:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2b88:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b8a:	29 17       	cp	r18, r25
    2b8c:	08 f4       	brcc	.+2      	; 0x2b90 <xTaskRemoveFromEventList+0x74>
    2b8e:	80 e0       	ldi	r24, 0x00	; 0
}
    2b90:	df 91       	pop	r29
    2b92:	cf 91       	pop	r28
    2b94:	1f 91       	pop	r17
    2b96:	0f 91       	pop	r16
    2b98:	08 95       	ret

00002b9a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2b9a:	20 91 b9 30 	lds	r18, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    2b9e:	fc 01       	movw	r30, r24
    2ba0:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2ba2:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    2ba6:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2baa:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2bae:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2bb2:	41 83       	std	Z+1, r20	; 0x01
    2bb4:	52 83       	std	Z+2, r21	; 0x02
    2bb6:	63 83       	std	Z+3, r22	; 0x03
    2bb8:	74 83       	std	Z+4, r23	; 0x04
    2bba:	08 95       	ret

00002bbc <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2bbc:	8f 92       	push	r8
    2bbe:	9f 92       	push	r9
    2bc0:	af 92       	push	r10
    2bc2:	bf 92       	push	r11
    2bc4:	cf 92       	push	r12
    2bc6:	df 92       	push	r13
    2bc8:	ef 92       	push	r14
    2bca:	ff 92       	push	r15
    2bcc:	0f 93       	push	r16
    2bce:	1f 93       	push	r17
    2bd0:	cf 93       	push	r28
    2bd2:	df 93       	push	r29
    2bd4:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2bd6:	0f b6       	in	r0, 0x3f	; 63
    2bd8:	f8 94       	cli
    2bda:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2bdc:	80 91 b9 30 	lds	r24, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    2be0:	90 81       	ld	r25, Z
    2be2:	98 17       	cp	r25, r24
    2be4:	89 f0       	breq	.+34     	; 0x2c08 <xTaskCheckForTimeOut+0x4c>
    2be6:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2bea:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2bee:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2bf2:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2bf6:	01 81       	ldd	r16, Z+1	; 0x01
    2bf8:	12 81       	ldd	r17, Z+2	; 0x02
    2bfa:	23 81       	ldd	r18, Z+3	; 0x03
    2bfc:	34 81       	ldd	r19, Z+4	; 0x04
    2bfe:	80 17       	cp	r24, r16
    2c00:	91 07       	cpc	r25, r17
    2c02:	a2 07       	cpc	r26, r18
    2c04:	b3 07       	cpc	r27, r19
    2c06:	a8 f5       	brcc	.+106    	; 0x2c72 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2c08:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2c0c:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2c10:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2c14:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2c18:	c1 80       	ldd	r12, Z+1	; 0x01
    2c1a:	d2 80       	ldd	r13, Z+2	; 0x02
    2c1c:	e3 80       	ldd	r14, Z+3	; 0x03
    2c1e:	f4 80       	ldd	r15, Z+4	; 0x04
    2c20:	eb 01       	movw	r28, r22
    2c22:	08 81       	ld	r16, Y
    2c24:	19 81       	ldd	r17, Y+1	; 0x01
    2c26:	2a 81       	ldd	r18, Y+2	; 0x02
    2c28:	3b 81       	ldd	r19, Y+3	; 0x03
    2c2a:	8c 19       	sub	r24, r12
    2c2c:	9d 09       	sbc	r25, r13
    2c2e:	ae 09       	sbc	r26, r14
    2c30:	bf 09       	sbc	r27, r15
    2c32:	80 17       	cp	r24, r16
    2c34:	91 07       	cpc	r25, r17
    2c36:	a2 07       	cpc	r26, r18
    2c38:	b3 07       	cpc	r27, r19
    2c3a:	e8 f4       	brcc	.+58     	; 0x2c76 <xTaskCheckForTimeOut+0xba>
    2c3c:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2c3e:	80 90 c0 30 	lds	r8, 0x30C0	; 0x8030c0 <xTickCount>
    2c42:	90 90 c1 30 	lds	r9, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2c46:	a0 90 c2 30 	lds	r10, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2c4a:	b0 90 c3 30 	lds	r11, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2c4e:	b5 01       	movw	r22, r10
    2c50:	a4 01       	movw	r20, r8
    2c52:	4c 19       	sub	r20, r12
    2c54:	5d 09       	sbc	r21, r13
    2c56:	6e 09       	sbc	r22, r14
    2c58:	7f 09       	sbc	r23, r15
    2c5a:	04 1b       	sub	r16, r20
    2c5c:	15 0b       	sbc	r17, r21
    2c5e:	26 0b       	sbc	r18, r22
    2c60:	37 0b       	sbc	r19, r23
    2c62:	08 83       	st	Y, r16
    2c64:	19 83       	std	Y+1, r17	; 0x01
    2c66:	2a 83       	std	Y+2, r18	; 0x02
    2c68:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2c6a:	0e 94 cd 15 	call	0x2b9a	; 0x2b9a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2c6e:	80 e0       	ldi	r24, 0x00	; 0
    2c70:	03 c0       	rjmp	.+6      	; 0x2c78 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2c72:	81 e0       	ldi	r24, 0x01	; 1
    2c74:	01 c0       	rjmp	.+2      	; 0x2c78 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2c76:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2c78:	0f 90       	pop	r0
    2c7a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2c7c:	df 91       	pop	r29
    2c7e:	cf 91       	pop	r28
    2c80:	1f 91       	pop	r17
    2c82:	0f 91       	pop	r16
    2c84:	ff 90       	pop	r15
    2c86:	ef 90       	pop	r14
    2c88:	df 90       	pop	r13
    2c8a:	cf 90       	pop	r12
    2c8c:	bf 90       	pop	r11
    2c8e:	af 90       	pop	r10
    2c90:	9f 90       	pop	r9
    2c92:	8f 90       	pop	r8
    2c94:	08 95       	ret

00002c96 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2c96:	81 e0       	ldi	r24, 0x01	; 1
    2c98:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <xMissedYield>
    2c9c:	08 95       	ret

00002c9e <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2c9e:	00 97       	sbiw	r24, 0x00	; 0
    2ca0:	21 f4       	brne	.+8      	; 0x2caa <uxTaskGetStackHighWaterMark+0xc>
    2ca2:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2ca6:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2caa:	dc 01       	movw	r26, r24
    2cac:	5b 96       	adiw	r26, 0x1b	; 27
    2cae:	ed 91       	ld	r30, X+
    2cb0:	fc 91       	ld	r31, X
    2cb2:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2cb4:	80 81       	ld	r24, Z
    2cb6:	81 31       	cpi	r24, 0x11	; 17
    2cb8:	41 f4       	brne	.+16     	; 0x2cca <uxTaskGetStackHighWaterMark+0x2c>
    2cba:	31 96       	adiw	r30, 0x01	; 1
    2cbc:	80 e0       	ldi	r24, 0x00	; 0
    2cbe:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2cc0:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2cc2:	21 91       	ld	r18, Z+
    2cc4:	21 31       	cpi	r18, 0x11	; 17
    2cc6:	e1 f3       	breq	.-8      	; 0x2cc0 <uxTaskGetStackHighWaterMark+0x22>
    2cc8:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2cca:	80 e0       	ldi	r24, 0x00	; 0
    2ccc:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2cce:	08 95       	ret

00002cd0 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2cd0:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2cd4:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2cd8:	08 95       	ret

00002cda <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2cda:	0f 93       	push	r16
    2cdc:	1f 93       	push	r17
    2cde:	cf 93       	push	r28
    2ce0:	df 93       	push	r29
    2ce2:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2ce4:	22 8d       	ldd	r18, Z+26	; 0x1a
    2ce6:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    2cea:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2cee:	5a 96       	adiw	r26, 0x1a	; 26
    2cf0:	8c 91       	ld	r24, X
    2cf2:	28 17       	cp	r18, r24
    2cf4:	08 f0       	brcs	.+2      	; 0x2cf8 <vTaskPriorityInherit+0x1e>
    2cf6:	41 c0       	rjmp	.+130    	; 0x2d7a <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2cf8:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    2cfc:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2d00:	5a 96       	adiw	r26, 0x1a	; 26
    2d02:	3c 91       	ld	r19, X
    2d04:	84 e0       	ldi	r24, 0x04	; 4
    2d06:	90 e0       	ldi	r25, 0x00	; 0
    2d08:	a0 e0       	ldi	r26, 0x00	; 0
    2d0a:	b0 e0       	ldi	r27, 0x00	; 0
    2d0c:	83 1b       	sub	r24, r19
    2d0e:	91 09       	sbc	r25, r1
    2d10:	a1 09       	sbc	r26, r1
    2d12:	b1 09       	sbc	r27, r1
    2d14:	86 87       	std	Z+14, r24	; 0x0e
    2d16:	97 87       	std	Z+15, r25	; 0x0f
    2d18:	a0 8b       	std	Z+16, r26	; 0x10
    2d1a:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2d1c:	8b e0       	ldi	r24, 0x0B	; 11
    2d1e:	28 9f       	mul	r18, r24
    2d20:	90 01       	movw	r18, r0
    2d22:	11 24       	eor	r1, r1
    2d24:	24 51       	subi	r18, 0x14	; 20
    2d26:	3f 4c       	sbci	r19, 0xCF	; 207
    2d28:	84 85       	ldd	r24, Z+12	; 0x0c
    2d2a:	95 85       	ldd	r25, Z+13	; 0x0d
    2d2c:	82 17       	cp	r24, r18
    2d2e:	93 07       	cpc	r25, r19
    2d30:	e9 f4       	brne	.+58     	; 0x2d6c <vTaskPriorityInherit+0x92>
    2d32:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2d34:	ef 01       	movw	r28, r30
    2d36:	22 96       	adiw	r28, 0x02	; 2
    2d38:	ce 01       	movw	r24, r28
    2d3a:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2d3e:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    2d42:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2d46:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d48:	f8 01       	movw	r30, r16
    2d4a:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2d4c:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2d50:	98 17       	cp	r25, r24
    2d52:	10 f4       	brcc	.+4      	; 0x2d58 <vTaskPriorityInherit+0x7e>
    2d54:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2d58:	fb e0       	ldi	r31, 0x0B	; 11
    2d5a:	8f 9f       	mul	r24, r31
    2d5c:	c0 01       	movw	r24, r0
    2d5e:	11 24       	eor	r1, r1
    2d60:	be 01       	movw	r22, r28
    2d62:	84 51       	subi	r24, 0x14	; 20
    2d64:	9f 4c       	sbci	r25, 0xCF	; 207
    2d66:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vListInsertEnd>
    2d6a:	07 c0       	rjmp	.+14     	; 0x2d7a <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2d6c:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    2d70:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2d74:	5a 96       	adiw	r26, 0x1a	; 26
    2d76:	8c 91       	ld	r24, X
    2d78:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2d7a:	df 91       	pop	r29
    2d7c:	cf 91       	pop	r28
    2d7e:	1f 91       	pop	r17
    2d80:	0f 91       	pop	r16
    2d82:	08 95       	ret

00002d84 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2d84:	0f 93       	push	r16
    2d86:	1f 93       	push	r17
    2d88:	cf 93       	push	r28
    2d8a:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2d8c:	00 97       	sbiw	r24, 0x00	; 0
    2d8e:	49 f1       	breq	.+82     	; 0x2de2 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2d90:	fc 01       	movw	r30, r24
    2d92:	32 8d       	ldd	r19, Z+26	; 0x1a
    2d94:	27 a1       	ldd	r18, Z+39	; 0x27
    2d96:	32 17       	cp	r19, r18
    2d98:	21 f1       	breq	.+72     	; 0x2de2 <vTaskPriorityDisinherit+0x5e>
    2d9a:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2d9c:	8c 01       	movw	r16, r24
    2d9e:	0e 5f       	subi	r16, 0xFE	; 254
    2da0:	1f 4f       	sbci	r17, 0xFF	; 255
    2da2:	c8 01       	movw	r24, r16
    2da4:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2da8:	8f a1       	ldd	r24, Y+39	; 0x27
    2daa:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2dac:	44 e0       	ldi	r20, 0x04	; 4
    2dae:	50 e0       	ldi	r21, 0x00	; 0
    2db0:	60 e0       	ldi	r22, 0x00	; 0
    2db2:	70 e0       	ldi	r23, 0x00	; 0
    2db4:	48 1b       	sub	r20, r24
    2db6:	51 09       	sbc	r21, r1
    2db8:	61 09       	sbc	r22, r1
    2dba:	71 09       	sbc	r23, r1
    2dbc:	4e 87       	std	Y+14, r20	; 0x0e
    2dbe:	5f 87       	std	Y+15, r21	; 0x0f
    2dc0:	68 8b       	std	Y+16, r22	; 0x10
    2dc2:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2dc4:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2dc8:	98 17       	cp	r25, r24
    2dca:	10 f4       	brcc	.+4      	; 0x2dd0 <vTaskPriorityDisinherit+0x4c>
    2dcc:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2dd0:	fb e0       	ldi	r31, 0x0B	; 11
    2dd2:	8f 9f       	mul	r24, r31
    2dd4:	c0 01       	movw	r24, r0
    2dd6:	11 24       	eor	r1, r1
    2dd8:	b8 01       	movw	r22, r16
    2dda:	84 51       	subi	r24, 0x14	; 20
    2ddc:	9f 4c       	sbci	r25, 0xCF	; 207
    2dde:	0e 94 9b 0c 	call	0x1936	; 0x1936 <vListInsertEnd>
			}
		}
	}
    2de2:	df 91       	pop	r29
    2de4:	cf 91       	pop	r28
    2de6:	1f 91       	pop	r17
    2de8:	0f 91       	pop	r16
    2dea:	08 95       	ret

00002dec <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2dec:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2dee:	e8 81       	ld	r30, Y
    2df0:	f9 81       	ldd	r31, Y+1	; 0x01
    2df2:	01 90       	ld	r0, Z+
    2df4:	f0 81       	ld	r31, Z
    2df6:	e0 2d       	mov	r30, r0
    2df8:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2dfa:	1a 82       	std	Y+2, r1	; 0x02
    2dfc:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2dfe:	6f ef       	ldi	r22, 0xFF	; 255
    2e00:	7f ef       	ldi	r23, 0xFF	; 255
    2e02:	cb 01       	movw	r24, r22
    2e04:	0e 94 d9 14 	call	0x29b2	; 0x29b2 <vTaskDelay>
    2e08:	fa cf       	rjmp	.-12     	; 0x2dfe <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002e0a <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2e0a:	fc 01       	movw	r30, r24
    2e0c:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2e0e:	65 87       	std	Z+13, r22	; 0x0d
    2e10:	08 95       	ret

00002e12 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2e12:	4f 92       	push	r4
    2e14:	5f 92       	push	r5
    2e16:	6f 92       	push	r6
    2e18:	7f 92       	push	r7
    2e1a:	8f 92       	push	r8
    2e1c:	9f 92       	push	r9
    2e1e:	af 92       	push	r10
    2e20:	bf 92       	push	r11
    2e22:	cf 92       	push	r12
    2e24:	df 92       	push	r13
    2e26:	ef 92       	push	r14
    2e28:	ff 92       	push	r15
    2e2a:	0f 93       	push	r16
    2e2c:	1f 93       	push	r17
    2e2e:	cf 93       	push	r28
    2e30:	df 93       	push	r29
    2e32:	cd b7       	in	r28, 0x3d	; 61
    2e34:	de b7       	in	r29, 0x3e	; 62
    2e36:	2a 97       	sbiw	r28, 0x0a	; 10
    2e38:	cd bf       	out	0x3d, r28	; 61
    2e3a:	de bf       	out	0x3e, r29	; 62
    2e3c:	4c 01       	movw	r8, r24
    2e3e:	29 01       	movw	r4, r18
    2e40:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2e42:	87 e3       	ldi	r24, 0x37	; 55
    2e44:	90 e2       	ldi	r25, 0x20	; 32
    2e46:	f4 01       	movw	r30, r8
    2e48:	80 83       	st	Z, r24
    2e4a:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2e4c:	fb 01       	movw	r30, r22
    2e4e:	80 81       	ld	r24, Z
    2e50:	88 23       	and	r24, r24
    2e52:	69 f0       	breq	.+26     	; 0x2e6e <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2e54:	de 01       	movw	r26, r28
    2e56:	11 96       	adiw	r26, 0x01	; 1
    2e58:	31 96       	adiw	r30, 0x01	; 1
    2e5a:	90 e0       	ldi	r25, 0x00	; 0
    2e5c:	02 c0       	rjmp	.+4      	; 0x2e62 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2e5e:	99 30       	cpi	r25, 0x09	; 9
    2e60:	39 f0       	breq	.+14     	; 0x2e70 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2e62:	9f 5f       	subi	r25, 0xFF	; 255
    2e64:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2e66:	81 91       	ld	r24, Z+
    2e68:	81 11       	cpse	r24, r1
    2e6a:	f9 cf       	rjmp	.-14     	; 0x2e5e <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2e6c:	01 c0       	rjmp	.+2      	; 0x2e70 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2e6e:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2e70:	e1 e0       	ldi	r30, 0x01	; 1
    2e72:	f0 e0       	ldi	r31, 0x00	; 0
    2e74:	ec 0f       	add	r30, r28
    2e76:	fd 1f       	adc	r31, r29
    2e78:	e9 0f       	add	r30, r25
    2e7a:	f1 1d       	adc	r31, r1
    2e7c:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2e7e:	74 01       	movw	r14, r8
    2e80:	f2 e0       	ldi	r31, 0x02	; 2
    2e82:	ef 0e       	add	r14, r31
    2e84:	f1 1c       	adc	r15, r1
    2e86:	a1 2c       	mov	r10, r1
    2e88:	b1 2c       	mov	r11, r1
    2e8a:	c1 2c       	mov	r12, r1
    2e8c:	d1 2c       	mov	r13, r1
    2e8e:	04 2f       	mov	r16, r20
    2e90:	94 01       	movw	r18, r8
    2e92:	a2 01       	movw	r20, r4
    2e94:	be 01       	movw	r22, r28
    2e96:	6f 5f       	subi	r22, 0xFF	; 255
    2e98:	7f 4f       	sbci	r23, 0xFF	; 255
    2e9a:	82 e9       	ldi	r24, 0x92	; 146
    2e9c:	93 e0       	ldi	r25, 0x03	; 3
    2e9e:	0e 94 85 11 	call	0x230a	; 0x230a <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2ea2:	f4 01       	movw	r30, r8
    2ea4:	66 82       	std	Z+6, r6	; 0x06
    2ea6:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2ea8:	40 86       	std	Z+8, r4	; 0x08
    2eaa:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2eac:	20 91 1a 31 	lds	r18, 0x311A	; 0x80311a <last_created_task_pointer>
    2eb0:	30 91 1b 31 	lds	r19, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    2eb4:	24 83       	std	Z+4, r18	; 0x04
    2eb6:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2eb8:	80 92 1a 31 	sts	0x311A, r8	; 0x80311a <last_created_task_pointer>
    2ebc:	90 92 1b 31 	sts	0x311B, r9	; 0x80311b <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2ec0:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2ec2:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2ec4:	40 90 58 31 	lds	r4, 0x3158	; 0x803158 <portStackTopForTask>
    2ec8:	50 90 59 31 	lds	r5, 0x3159	; 0x803159 <portStackTopForTask+0x1>
    2ecc:	ff ef       	ldi	r31, 0xFF	; 255
    2ece:	4f 1a       	sub	r4, r31
    2ed0:	5f 0a       	sbc	r5, r31
    2ed2:	40 92 58 31 	sts	0x3158, r4	; 0x803158 <portStackTopForTask>
    2ed6:	50 92 59 31 	sts	0x3159, r5	; 0x803159 <portStackTopForTask+0x1>
    2eda:	f4 01       	movw	r30, r8
    2edc:	42 86       	std	Z+10, r4	; 0x0a
    2ede:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2ee0:	16 86       	std	Z+14, r1	; 0x0e
    2ee2:	17 86       	std	Z+15, r1	; 0x0f
    2ee4:	10 8a       	std	Z+16, r1	; 0x10
    2ee6:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2ee8:	61 14       	cp	r6, r1
    2eea:	71 04       	cpc	r7, r1
    2eec:	09 f4       	brne	.+2      	; 0x2ef0 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2eee:	44 c0       	rjmp	.+136    	; 0x2f78 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2ef0:	81 30       	cpi	r24, 0x01	; 1
    2ef2:	79 f5       	brne	.+94     	; 0x2f52 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2ef4:	6a e0       	ldi	r22, 0x0A	; 10
    2ef6:	c3 01       	movw	r24, r6
    2ef8:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    2efc:	7c 01       	movw	r14, r24
    2efe:	60 e7       	ldi	r22, 0x70	; 112
    2f00:	76 e0       	ldi	r23, 0x06	; 6
    2f02:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    2f06:	be 01       	movw	r22, r28
    2f08:	6f 5f       	subi	r22, 0xFF	; 255
    2f0a:	7f 4f       	sbci	r23, 0xFF	; 255
    2f0c:	c7 01       	movw	r24, r14
    2f0e:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    2f12:	6a e0       	ldi	r22, 0x0A	; 10
    2f14:	c7 01       	movw	r24, r14
    2f16:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    2f1a:	7c 01       	movw	r14, r24
    2f1c:	67 e6       	ldi	r22, 0x67	; 103
    2f1e:	76 e0       	ldi	r23, 0x06	; 6
    2f20:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2f24:	6a e0       	ldi	r22, 0x0A	; 10
    2f26:	c7 01       	movw	r24, r14
    2f28:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    2f2c:	7c 01       	movw	r14, r24
    2f2e:	69 e5       	ldi	r22, 0x59	; 89
    2f30:	76 e0       	ldi	r23, 0x06	; 6
    2f32:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    2f36:	63 e0       	ldi	r22, 0x03	; 3
    2f38:	c7 01       	movw	r24, r14
    2f3a:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    2f3e:	b2 01       	movw	r22, r4
    2f40:	0e 94 b5 1c 	call	0x396a	; 0x396a <_ZN8emstreamlsEj>
    2f44:	62 e0       	ldi	r22, 0x02	; 2
    2f46:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    2f4a:	66 e0       	ldi	r22, 0x06	; 6
    2f4c:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    2f50:	13 c0       	rjmp	.+38     	; 0x2f78 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2f52:	6a e0       	ldi	r22, 0x0A	; 10
    2f54:	c3 01       	movw	r24, r6
    2f56:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    2f5a:	4c 01       	movw	r8, r24
    2f5c:	64 e4       	ldi	r22, 0x44	; 68
    2f5e:	76 e0       	ldi	r23, 0x06	; 6
    2f60:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    2f64:	be 01       	movw	r22, r28
    2f66:	6f 5f       	subi	r22, 0xFF	; 255
    2f68:	7f 4f       	sbci	r23, 0xFF	; 255
    2f6a:	c4 01       	movw	r24, r8
    2f6c:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    2f70:	66 e0       	ldi	r22, 0x06	; 6
    2f72:	c4 01       	movw	r24, r8
    2f74:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2f78:	2a 96       	adiw	r28, 0x0a	; 10
    2f7a:	cd bf       	out	0x3d, r28	; 61
    2f7c:	de bf       	out	0x3e, r29	; 62
    2f7e:	df 91       	pop	r29
    2f80:	cf 91       	pop	r28
    2f82:	1f 91       	pop	r17
    2f84:	0f 91       	pop	r16
    2f86:	ff 90       	pop	r15
    2f88:	ef 90       	pop	r14
    2f8a:	df 90       	pop	r13
    2f8c:	cf 90       	pop	r12
    2f8e:	bf 90       	pop	r11
    2f90:	af 90       	pop	r10
    2f92:	9f 90       	pop	r9
    2f94:	8f 90       	pop	r8
    2f96:	7f 90       	pop	r7
    2f98:	6f 90       	pop	r6
    2f9a:	5f 90       	pop	r5
    2f9c:	4f 90       	pop	r4
    2f9e:	08 95       	ret

00002fa0 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2fa0:	cf 92       	push	r12
    2fa2:	df 92       	push	r13
    2fa4:	ef 92       	push	r14
    2fa6:	ff 92       	push	r15
    2fa8:	0f 93       	push	r16
    2faa:	1f 93       	push	r17
    2fac:	cf 93       	push	r28
    2fae:	df 93       	push	r29
    2fb0:	ec 01       	movw	r28, r24
    2fb2:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2fb4:	8a 81       	ldd	r24, Y+2	; 0x02
    2fb6:	9b 81       	ldd	r25, Y+3	; 0x03
    2fb8:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <pcTaskGetTaskName>
    2fbc:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2fbe:	6a e0       	ldi	r22, 0x0A	; 10
    2fc0:	c7 01       	movw	r24, r14
    2fc2:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    2fc6:	8c 01       	movw	r16, r24
    2fc8:	63 e8       	ldi	r22, 0x83	; 131
    2fca:	76 e0       	ldi	r23, 0x06	; 6
    2fcc:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    2fd0:	6a e0       	ldi	r22, 0x0A	; 10
    2fd2:	c8 01       	movw	r24, r16
    2fd4:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    2fd8:	8c 01       	movw	r16, r24
    2fda:	6c e7       	ldi	r22, 0x7C	; 124
    2fdc:	76 e0       	ldi	r23, 0x06	; 6
    2fde:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    2fe2:	b6 01       	movw	r22, r12
    2fe4:	c8 01       	movw	r24, r16
    2fe6:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2fea:	6a e0       	ldi	r22, 0x0A	; 10
    2fec:	c8 01       	movw	r24, r16
    2fee:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    2ff2:	8c 01       	movw	r16, r24
    2ff4:	66 e7       	ldi	r22, 0x76	; 118
    2ff6:	76 e0       	ldi	r23, 0x06	; 6
    2ff8:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    2ffc:	66 e0       	ldi	r22, 0x06	; 6
    2ffe:	c8 01       	movw	r24, r16
    3000:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    3004:	8a 85       	ldd	r24, Y+10	; 0x0a
    3006:	9b 85       	ldd	r25, Y+11	; 0x0b
    3008:	e8 85       	ldd	r30, Y+8	; 0x08
    300a:	f9 85       	ldd	r31, Y+9	; 0x09
    300c:	01 e1       	ldi	r16, 0x11	; 17
    300e:	21 e0       	ldi	r18, 0x01	; 1
    3010:	a7 01       	movw	r20, r14
    3012:	bc 01       	movw	r22, r24
    3014:	8e 1b       	sub	r24, r30
    3016:	9f 0b       	sbc	r25, r31
    3018:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    301c:	8c 81       	ldd	r24, Y+4	; 0x04
    301e:	9d 81       	ldd	r25, Y+5	; 0x05
    3020:	00 97       	sbiw	r24, 0x00	; 0
    3022:	19 f0       	breq	.+6      	; 0x302a <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    3024:	b7 01       	movw	r22, r14
    3026:	0e 94 d0 17 	call	0x2fa0	; 0x2fa0 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    302a:	df 91       	pop	r29
    302c:	cf 91       	pop	r28
    302e:	1f 91       	pop	r17
    3030:	0f 91       	pop	r16
    3032:	ff 90       	pop	r15
    3034:	ef 90       	pop	r14
    3036:	df 90       	pop	r13
    3038:	cf 90       	pop	r12
    303a:	08 95       	ret

0000303c <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    303c:	0f 93       	push	r16
    303e:	1f 93       	push	r17
    3040:	cf 93       	push	r28
    3042:	df 93       	push	r29
    3044:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    3046:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <last_created_task_pointer>
    304a:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    304e:	00 97       	sbiw	r24, 0x00	; 0
    3050:	19 f0       	breq	.+6      	; 0x3058 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    3052:	be 01       	movw	r22, r28
    3054:	0e 94 d0 17 	call	0x2fa0	; 0x2fa0 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    3058:	6a e0       	ldi	r22, 0x0A	; 10
    305a:	ce 01       	movw	r24, r28
    305c:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    3060:	8c 01       	movw	r16, r24
    3062:	69 e9       	ldi	r22, 0x99	; 153
    3064:	76 e0       	ldi	r23, 0x06	; 6
    3066:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    306a:	6a e0       	ldi	r22, 0x0A	; 10
    306c:	c8 01       	movw	r24, r16
    306e:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    3072:	8c 01       	movw	r16, r24
    3074:	6e e8       	ldi	r22, 0x8E	; 142
    3076:	76 e0       	ldi	r23, 0x06	; 6
    3078:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    307c:	6a e0       	ldi	r22, 0x0A	; 10
    307e:	c8 01       	movw	r24, r16
    3080:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    3084:	8c 01       	movw	r16, r24
    3086:	68 e8       	ldi	r22, 0x88	; 136
    3088:	76 e0       	ldi	r23, 0x06	; 6
    308a:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    308e:	66 e0       	ldi	r22, 0x06	; 6
    3090:	c8 01       	movw	r24, r16
    3092:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    3096:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <portStackTopForTask>
    309a:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <portStackTopForTask+0x1>
    309e:	bc 01       	movw	r22, r24
    30a0:	6f 5f       	subi	r22, 0xFF	; 255
    30a2:	7f 4f       	sbci	r23, 0xFF	; 255
    30a4:	01 e1       	ldi	r16, 0x11	; 17
    30a6:	21 e0       	ldi	r18, 0x01	; 1
    30a8:	ae 01       	movw	r20, r28
    30aa:	83 56       	subi	r24, 0x63	; 99
    30ac:	91 09       	sbc	r25, r1
    30ae:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    30b2:	df 91       	pop	r29
    30b4:	cf 91       	pop	r28
    30b6:	1f 91       	pop	r17
    30b8:	0f 91       	pop	r16
    30ba:	08 95       	ret

000030bc <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    30bc:	8f 92       	push	r8
    30be:	9f 92       	push	r9
    30c0:	af 92       	push	r10
    30c2:	bf 92       	push	r11
    30c4:	cf 92       	push	r12
    30c6:	df 92       	push	r13
    30c8:	ef 92       	push	r14
    30ca:	ff 92       	push	r15
    30cc:	0f 93       	push	r16
    30ce:	1f 93       	push	r17
    30d0:	cf 93       	push	r28
    30d2:	df 93       	push	r29
    30d4:	ec 01       	movw	r28, r24
    30d6:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    30d8:	8a 81       	ldd	r24, Y+2	; 0x02
    30da:	9b 81       	ldd	r25, Y+3	; 0x03
    30dc:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <pcTaskGetTaskName>
    30e0:	bc 01       	movw	r22, r24
    30e2:	c8 01       	movw	r24, r16
    30e4:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    30e8:	d8 01       	movw	r26, r16
    30ea:	ed 91       	ld	r30, X+
    30ec:	fc 91       	ld	r31, X
    30ee:	02 80       	ldd	r0, Z+2	; 0x02
    30f0:	f3 81       	ldd	r31, Z+3	; 0x03
    30f2:	e0 2d       	mov	r30, r0
    30f4:	69 e0       	ldi	r22, 0x09	; 9
    30f6:	c8 01       	movw	r24, r16
    30f8:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    30fa:	8a 81       	ldd	r24, Y+2	; 0x02
    30fc:	9b 81       	ldd	r25, Y+3	; 0x03
    30fe:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <pcTaskGetTaskName>
    3102:	fc 01       	movw	r30, r24
    3104:	01 90       	ld	r0, Z+
    3106:	00 20       	and	r0, r0
    3108:	e9 f7       	brne	.-6      	; 0x3104 <_ZN8frt_task12print_statusER8emstream+0x48>
    310a:	31 97       	sbiw	r30, 0x01	; 1
    310c:	e8 1b       	sub	r30, r24
    310e:	f9 0b       	sbc	r31, r25
    3110:	38 97       	sbiw	r30, 0x08	; 8
    3112:	48 f4       	brcc	.+18     	; 0x3126 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    3114:	d8 01       	movw	r26, r16
    3116:	ed 91       	ld	r30, X+
    3118:	fc 91       	ld	r31, X
    311a:	02 80       	ldd	r0, Z+2	; 0x02
    311c:	f3 81       	ldd	r31, Z+3	; 0x03
    311e:	e0 2d       	mov	r30, r0
    3120:	69 e0       	ldi	r22, 0x09	; 9
    3122:	c8 01       	movw	r24, r16
    3124:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    3126:	ce 84       	ldd	r12, Y+14	; 0x0e
    3128:	df 84       	ldd	r13, Y+15	; 0x0f
    312a:	e8 88       	ldd	r14, Y+16	; 0x10
    312c:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    312e:	a8 84       	ldd	r10, Y+8	; 0x08
    3130:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3132:	8a 81       	ldd	r24, Y+2	; 0x02
    3134:	9b 81       	ldd	r25, Y+3	; 0x03
    3136:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <uxTaskGetStackHighWaterMark>
    313a:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    313c:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    313e:	8a 81       	ldd	r24, Y+2	; 0x02
    3140:	9b 81       	ldd	r25, Y+3	; 0x03
    3142:	0e 94 87 12 	call	0x250e	; 0x250e <uxTaskPriorityGet>
    3146:	68 2f       	mov	r22, r24
    3148:	c8 01       	movw	r24, r16
    314a:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <_ZN8emstreamlsEh>
    314e:	6a e0       	ldi	r22, 0x0A	; 10
    3150:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    3154:	ec 01       	movw	r28, r24
    3156:	6e e0       	ldi	r22, 0x0E	; 14
    3158:	77 e0       	ldi	r23, 0x07	; 7
    315a:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
			<< get_state ()
    315e:	68 2d       	mov	r22, r8
    3160:	ce 01       	movw	r24, r28
    3162:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3166:	6a e0       	ldi	r22, 0x0A	; 10
    3168:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    316c:	ec 01       	movw	r28, r24
    316e:	6c e0       	ldi	r22, 0x0C	; 12
    3170:	77 e0       	ldi	r23, 0x07	; 7
    3172:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    3176:	69 2d       	mov	r22, r9
    3178:	ce 01       	movw	r24, r28
    317a:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <_ZN8emstreamlsEh>
    317e:	6a e0       	ldi	r22, 0x0A	; 10
    3180:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    3184:	ec 01       	movw	r28, r24
    3186:	6a e0       	ldi	r22, 0x0A	; 10
    3188:	77 e0       	ldi	r23, 0x07	; 7
    318a:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    318e:	b5 01       	movw	r22, r10
    3190:	ce 01       	movw	r24, r28
    3192:	0e 94 b5 1c 	call	0x396a	; 0x396a <_ZN8emstreamlsEj>
    3196:	6a e0       	ldi	r22, 0x0A	; 10
    3198:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    319c:	ec 01       	movw	r28, r24
    319e:	68 e0       	ldi	r22, 0x08	; 8
    31a0:	77 e0       	ldi	r23, 0x07	; 7
    31a2:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    31a6:	6a e0       	ldi	r22, 0x0A	; 10
    31a8:	ce 01       	movw	r24, r28
    31aa:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    31ae:	ec 01       	movw	r28, r24
    31b0:	66 e0       	ldi	r22, 0x06	; 6
    31b2:	77 e0       	ldi	r23, 0x07	; 7
    31b4:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    31b8:	b7 01       	movw	r22, r14
    31ba:	a6 01       	movw	r20, r12
    31bc:	ce 01       	movw	r24, r28
    31be:	0e 94 e9 1c 	call	0x39d2	; 0x39d2 <_ZN8emstreamlsEm>
}
    31c2:	df 91       	pop	r29
    31c4:	cf 91       	pop	r28
    31c6:	1f 91       	pop	r17
    31c8:	0f 91       	pop	r16
    31ca:	ff 90       	pop	r15
    31cc:	ef 90       	pop	r14
    31ce:	df 90       	pop	r13
    31d0:	cf 90       	pop	r12
    31d2:	bf 90       	pop	r11
    31d4:	af 90       	pop	r10
    31d6:	9f 90       	pop	r9
    31d8:	8f 90       	pop	r8
    31da:	08 95       	ret

000031dc <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    31dc:	cf 93       	push	r28
    31de:	df 93       	push	r29
    31e0:	ec 01       	movw	r28, r24
    31e2:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    31e4:	db 01       	movw	r26, r22
    31e6:	ed 91       	ld	r30, X+
    31e8:	fc 91       	ld	r31, X
    31ea:	02 80       	ldd	r0, Z+2	; 0x02
    31ec:	f3 81       	ldd	r31, Z+3	; 0x03
    31ee:	e0 2d       	mov	r30, r0
    31f0:	be 01       	movw	r22, r28
    31f2:	19 95       	eicall
	return (ser_dev);
}
    31f4:	ce 01       	movw	r24, r28
    31f6:	df 91       	pop	r29
    31f8:	cf 91       	pop	r28
    31fa:	08 95       	ret

000031fc <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    31fc:	0f 93       	push	r16
    31fe:	1f 93       	push	r17
    3200:	cf 93       	push	r28
    3202:	df 93       	push	r29
    3204:	ec 01       	movw	r28, r24
    3206:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    3208:	bc 01       	movw	r22, r24
    320a:	c8 01       	movw	r24, r16
    320c:	0e 94 ee 18 	call	0x31dc	; 0x31dc <_ZlsR8emstreamR8frt_task>
    3210:	66 e0       	ldi	r22, 0x06	; 6
    3212:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    3216:	8c 81       	ldd	r24, Y+4	; 0x04
    3218:	9d 81       	ldd	r25, Y+5	; 0x05
    321a:	00 97       	sbiw	r24, 0x00	; 0
    321c:	19 f0       	breq	.+6      	; 0x3224 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    321e:	b8 01       	movw	r22, r16
    3220:	0e 94 fe 18 	call	0x31fc	; 0x31fc <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    3224:	df 91       	pop	r29
    3226:	cf 91       	pop	r28
    3228:	1f 91       	pop	r17
    322a:	0f 91       	pop	r16
    322c:	08 95       	ret

0000322e <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    322e:	0f 93       	push	r16
    3230:	1f 93       	push	r17
    3232:	cf 93       	push	r28
    3234:	df 93       	push	r29
    3236:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    3238:	6a e0       	ldi	r22, 0x0A	; 10
    323a:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    323e:	8c 01       	movw	r16, r24
    3240:	6b ef       	ldi	r22, 0xFB	; 251
    3242:	76 e0       	ldi	r23, 0x06	; 6
    3244:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    3248:	6a e0       	ldi	r22, 0x0A	; 10
    324a:	c8 01       	movw	r24, r16
    324c:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    3250:	8c 01       	movw	r16, r24
    3252:	64 ef       	ldi	r22, 0xF4	; 244
    3254:	76 e0       	ldi	r23, 0x06	; 6
    3256:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    325a:	66 e0       	ldi	r22, 0x06	; 6
    325c:	c8 01       	movw	r24, r16
    325e:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    3262:	6a e0       	ldi	r22, 0x0A	; 10
    3264:	ce 01       	movw	r24, r28
    3266:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    326a:	8c 01       	movw	r16, r24
    326c:	63 ee       	ldi	r22, 0xE3	; 227
    326e:	76 e0       	ldi	r23, 0x06	; 6
    3270:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    3274:	6a e0       	ldi	r22, 0x0A	; 10
    3276:	c8 01       	movw	r24, r16
    3278:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    327c:	8c 01       	movw	r16, r24
    327e:	67 ed       	ldi	r22, 0xD7	; 215
    3280:	76 e0       	ldi	r23, 0x06	; 6
    3282:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    3286:	6a e0       	ldi	r22, 0x0A	; 10
    3288:	c8 01       	movw	r24, r16
    328a:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    328e:	8c 01       	movw	r16, r24
    3290:	61 ed       	ldi	r22, 0xD1	; 209
    3292:	76 e0       	ldi	r23, 0x06	; 6
    3294:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    3298:	66 e0       	ldi	r22, 0x06	; 6
    329a:	c8 01       	movw	r24, r16
    329c:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    32a0:	6a e0       	ldi	r22, 0x0A	; 10
    32a2:	ce 01       	movw	r24, r28
    32a4:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    32a8:	8c 01       	movw	r16, r24
    32aa:	60 ec       	ldi	r22, 0xC0	; 192
    32ac:	76 e0       	ldi	r23, 0x06	; 6
    32ae:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    32b2:	6a e0       	ldi	r22, 0x0A	; 10
    32b4:	c8 01       	movw	r24, r16
    32b6:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    32ba:	8c 01       	movw	r16, r24
    32bc:	64 eb       	ldi	r22, 0xB4	; 180
    32be:	76 e0       	ldi	r23, 0x06	; 6
    32c0:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    32c4:	6a e0       	ldi	r22, 0x0A	; 10
    32c6:	c8 01       	movw	r24, r16
    32c8:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    32cc:	8c 01       	movw	r16, r24
    32ce:	6e ea       	ldi	r22, 0xAE	; 174
    32d0:	76 e0       	ldi	r23, 0x06	; 6
    32d2:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    32d6:	66 e0       	ldi	r22, 0x06	; 6
    32d8:	c8 01       	movw	r24, r16
    32da:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    32de:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <last_created_task_pointer>
    32e2:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    32e6:	00 97       	sbiw	r24, 0x00	; 0
    32e8:	19 f0       	breq	.+6      	; 0x32f0 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    32ea:	be 01       	movw	r22, r28
    32ec:	0e 94 fe 18 	call	0x31fc	; 0x31fc <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    32f0:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <xTaskGetIdleTaskHandle>
    32f4:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <uxTaskGetStackHighWaterMark>
    32f8:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    32fa:	6a e0       	ldi	r22, 0x0A	; 10
    32fc:	ce 01       	movw	r24, r28
    32fe:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    3302:	ec 01       	movw	r28, r24
    3304:	63 ea       	ldi	r22, 0xA3	; 163
    3306:	76 e0       	ldi	r23, 0x06	; 6
    3308:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    330c:	61 2f       	mov	r22, r17
    330e:	ce 01       	movw	r24, r28
    3310:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    3314:	6a e0       	ldi	r22, 0x0A	; 10
    3316:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    331a:	ec 01       	movw	r28, r24
    331c:	61 ea       	ldi	r22, 0xA1	; 161
    331e:	76 e0       	ldi	r23, 0x06	; 6
    3320:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    3324:	64 e6       	ldi	r22, 0x64	; 100
    3326:	70 e0       	ldi	r23, 0x00	; 0
    3328:	ce 01       	movw	r24, r28
    332a:	0e 94 b5 1c 	call	0x396a	; 0x396a <_ZN8emstreamlsEj>
    332e:	6a e0       	ldi	r22, 0x0A	; 10
    3330:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    3334:	ec 01       	movw	r28, r24
    3336:	6e e9       	ldi	r22, 0x9E	; 158
    3338:	76 e0       	ldi	r23, 0x06	; 6
    333a:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    333e:	66 e0       	ldi	r22, 0x06	; 6
    3340:	ce 01       	movw	r24, r28
    3342:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
}
    3346:	df 91       	pop	r29
    3348:	cf 91       	pop	r28
    334a:	1f 91       	pop	r17
    334c:	0f 91       	pop	r16
    334e:	08 95       	ret

00003350 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    3350:	0f 93       	push	r16
    3352:	cf 93       	push	r28
    3354:	df 93       	push	r29
    3356:	1f 92       	push	r1
    3358:	cd b7       	in	r28, 0x3d	; 61
    335a:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    335c:	00 e0       	ldi	r16, 0x00	; 0
    335e:	2f ef       	ldi	r18, 0xFF	; 255
    3360:	3f ef       	ldi	r19, 0xFF	; 255
    3362:	a9 01       	movw	r20, r18
    3364:	be 01       	movw	r22, r28
    3366:	6f 5f       	subi	r22, 0xFF	; 255
    3368:	7f 4f       	sbci	r23, 0xFF	; 255
    336a:	fc 01       	movw	r30, r24
    336c:	80 85       	ldd	r24, Z+8	; 0x08
    336e:	91 85       	ldd	r25, Z+9	; 0x09
    3370:	0e 94 63 10 	call	0x20c6	; 0x20c6 <xQueueGenericReceive>
    3374:	81 30       	cpi	r24, 0x01	; 1
    3376:	19 f4       	brne	.+6      	; 0x337e <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    3378:	89 81       	ldd	r24, Y+1	; 0x01
    337a:	90 e0       	ldi	r25, 0x00	; 0
    337c:	02 c0       	rjmp	.+4      	; 0x3382 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    337e:	8f ef       	ldi	r24, 0xFF	; 255
    3380:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    3382:	0f 90       	pop	r0
    3384:	df 91       	pop	r29
    3386:	cf 91       	pop	r28
    3388:	0f 91       	pop	r16
    338a:	08 95       	ret

0000338c <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    338c:	fc 01       	movw	r30, r24
    338e:	80 85       	ldd	r24, Z+8	; 0x08
    3390:	91 85       	ldd	r25, Z+9	; 0x09
    3392:	0e 94 27 11 	call	0x224e	; 0x224e <uxQueueMessagesWaiting>
    3396:	91 e0       	ldi	r25, 0x01	; 1
    3398:	81 11       	cpse	r24, r1
    339a:	01 c0       	rjmp	.+2      	; 0x339e <_ZN14frt_text_queue14check_for_charEv+0x12>
    339c:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    339e:	89 2f       	mov	r24, r25
    33a0:	08 95       	ret

000033a2 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    33a2:	0f 93       	push	r16
    33a4:	cf 93       	push	r28
    33a6:	df 93       	push	r29
    33a8:	1f 92       	push	r1
    33aa:	cd b7       	in	r28, 0x3d	; 61
    33ac:	de b7       	in	r29, 0x3e	; 62
    33ae:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    33b0:	fc 01       	movw	r30, r24
    33b2:	22 85       	ldd	r18, Z+10	; 0x0a
    33b4:	33 85       	ldd	r19, Z+11	; 0x0b
    33b6:	44 85       	ldd	r20, Z+12	; 0x0c
    33b8:	55 85       	ldd	r21, Z+13	; 0x0d
    33ba:	00 e0       	ldi	r16, 0x00	; 0
    33bc:	be 01       	movw	r22, r28
    33be:	6f 5f       	subi	r22, 0xFF	; 255
    33c0:	7f 4f       	sbci	r23, 0xFF	; 255
    33c2:	80 85       	ldd	r24, Z+8	; 0x08
    33c4:	91 85       	ldd	r25, Z+9	; 0x09
    33c6:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueGenericSend>
    33ca:	91 e0       	ldi	r25, 0x01	; 1
    33cc:	81 11       	cpse	r24, r1
    33ce:	01 c0       	rjmp	.+2      	; 0x33d2 <_ZN14frt_text_queue7putcharEc+0x30>
    33d0:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    33d2:	89 2f       	mov	r24, r25
    33d4:	0f 90       	pop	r0
    33d6:	df 91       	pop	r29
    33d8:	cf 91       	pop	r28
    33da:	0f 91       	pop	r16
    33dc:	08 95       	ret

000033de <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    33de:	8f 92       	push	r8
    33e0:	9f 92       	push	r9
    33e2:	bf 92       	push	r11
    33e4:	cf 92       	push	r12
    33e6:	df 92       	push	r13
    33e8:	ef 92       	push	r14
    33ea:	ff 92       	push	r15
    33ec:	0f 93       	push	r16
    33ee:	1f 93       	push	r17
    33f0:	cf 93       	push	r28
    33f2:	df 93       	push	r29
    33f4:	ec 01       	movw	r28, r24
    33f6:	b6 2e       	mov	r11, r22
    33f8:	4a 01       	movw	r8, r20
    33fa:	68 01       	movw	r12, r16
    33fc:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    33fe:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstreamC1Ev>
    3402:	8f e3       	ldi	r24, 0x3F	; 63
    3404:	90 e2       	ldi	r25, 0x20	; 32
    3406:	88 83       	st	Y, r24
    3408:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    340a:	8e 86       	std	Y+14, r8	; 0x0e
    340c:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    340e:	40 e0       	ldi	r20, 0x00	; 0
    3410:	61 e0       	ldi	r22, 0x01	; 1
    3412:	8b 2d       	mov	r24, r11
    3414:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <xQueueGenericCreate>
    3418:	88 87       	std	Y+8, r24	; 0x08
    341a:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    341c:	ca 86       	std	Y+10, r12	; 0x0a
    341e:	db 86       	std	Y+11, r13	; 0x0b
    3420:	ec 86       	std	Y+12, r14	; 0x0c
    3422:	fd 86       	std	Y+13, r15	; 0x0d
}
    3424:	df 91       	pop	r29
    3426:	cf 91       	pop	r28
    3428:	1f 91       	pop	r17
    342a:	0f 91       	pop	r16
    342c:	ff 90       	pop	r15
    342e:	ef 90       	pop	r14
    3430:	df 90       	pop	r13
    3432:	cf 90       	pop	r12
    3434:	bf 90       	pop	r11
    3436:	9f 90       	pop	r9
    3438:	8f 90       	pop	r8
    343a:	08 95       	ret

0000343c <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    343c:	cf 92       	push	r12
    343e:	df 92       	push	r13
    3440:	ef 92       	push	r14
    3442:	ff 92       	push	r15
    3444:	cf 93       	push	r28
    3446:	df 93       	push	r29
    3448:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    344a:	68 81       	ld	r22, Y
    344c:	79 81       	ldd	r23, Y+1	; 0x01
    344e:	8a 81       	ldd	r24, Y+2	; 0x02
    3450:	9b 81       	ldd	r25, Y+3	; 0x03
    3452:	0f 2e       	mov	r0, r31
    3454:	f8 ee       	ldi	r31, 0xE8	; 232
    3456:	cf 2e       	mov	r12, r31
    3458:	f3 e0       	ldi	r31, 0x03	; 3
    345a:	df 2e       	mov	r13, r31
    345c:	e1 2c       	mov	r14, r1
    345e:	f1 2c       	mov	r15, r1
    3460:	f0 2d       	mov	r31, r0
    3462:	a7 01       	movw	r20, r14
    3464:	96 01       	movw	r18, r12
    3466:	0e 94 ab 21 	call	0x4356	; 0x4356 <__udivmodsi4>
    346a:	9b 01       	movw	r18, r22
    346c:	ac 01       	movw	r20, r24
    346e:	60 e4       	ldi	r22, 0x40	; 64
    3470:	72 e4       	ldi	r23, 0x42	; 66
    3472:	8f e0       	ldi	r24, 0x0F	; 15
    3474:	90 e0       	ldi	r25, 0x00	; 0
    3476:	0e 94 87 21 	call	0x430e	; 0x430e <__mulsi3>
    347a:	a7 01       	movw	r20, r14
    347c:	96 01       	movw	r18, r12
    347e:	0e 94 ab 21 	call	0x4356	; 0x4356 <__udivmodsi4>
    3482:	69 01       	movw	r12, r18
    3484:	7a 01       	movw	r14, r20
    3486:	ac 81       	ldd	r26, Y+4	; 0x04
    3488:	bd 81       	ldd	r27, Y+5	; 0x05
    348a:	20 e4       	ldi	r18, 0x40	; 64
    348c:	32 e4       	ldi	r19, 0x42	; 66
    348e:	4f e0       	ldi	r20, 0x0F	; 15
    3490:	50 e0       	ldi	r21, 0x00	; 0
    3492:	0e 94 13 22 	call	0x4426	; 0x4426 <__muluhisi3>
    3496:	20 e0       	ldi	r18, 0x00	; 0
    3498:	38 e4       	ldi	r19, 0x48	; 72
    349a:	48 ee       	ldi	r20, 0xE8	; 232
    349c:	51 e0       	ldi	r21, 0x01	; 1
    349e:	0e 94 ab 21 	call	0x4356	; 0x4356 <__udivmodsi4>
    34a2:	c7 01       	movw	r24, r14
    34a4:	b6 01       	movw	r22, r12
    34a6:	62 0f       	add	r22, r18
    34a8:	73 1f       	adc	r23, r19
    34aa:	84 1f       	adc	r24, r20
    34ac:	95 1f       	adc	r25, r21
}
    34ae:	df 91       	pop	r29
    34b0:	cf 91       	pop	r28
    34b2:	ff 90       	pop	r15
    34b4:	ef 90       	pop	r14
    34b6:	df 90       	pop	r13
    34b8:	cf 90       	pop	r12
    34ba:	08 95       	ret

000034bc <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    34bc:	cf 92       	push	r12
    34be:	df 92       	push	r13
    34c0:	ef 92       	push	r14
    34c2:	ff 92       	push	r15
    34c4:	0f 93       	push	r16
    34c6:	1f 93       	push	r17
    34c8:	cf 93       	push	r28
    34ca:	df 93       	push	r29
    34cc:	cd b7       	in	r28, 0x3d	; 61
    34ce:	de b7       	in	r29, 0x3e	; 62
    34d0:	2f 97       	sbiw	r28, 0x0f	; 15
    34d2:	cd bf       	out	0x3d, r28	; 61
    34d4:	de bf       	out	0x3e, r29	; 62
    34d6:	6c 01       	movw	r12, r24
    34d8:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    34da:	db 01       	movw	r26, r22
    34dc:	6d 91       	ld	r22, X+
    34de:	7d 91       	ld	r23, X+
    34e0:	8d 91       	ld	r24, X+
    34e2:	9c 91       	ld	r25, X
    34e4:	28 ee       	ldi	r18, 0xE8	; 232
    34e6:	33 e0       	ldi	r19, 0x03	; 3
    34e8:	40 e0       	ldi	r20, 0x00	; 0
    34ea:	50 e0       	ldi	r21, 0x00	; 0
    34ec:	0e 94 ab 21 	call	0x4356	; 0x4356 <__udivmodsi4>
    34f0:	ba 01       	movw	r22, r20
    34f2:	a9 01       	movw	r20, r18
    34f4:	c6 01       	movw	r24, r12
    34f6:	0e 94 e9 1c 	call	0x39d2	; 0x39d2 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    34fa:	d6 01       	movw	r26, r12
    34fc:	ed 91       	ld	r30, X+
    34fe:	fc 91       	ld	r31, X
    3500:	02 80       	ldd	r0, Z+2	; 0x02
    3502:	f3 81       	ldd	r31, Z+3	; 0x03
    3504:	e0 2d       	mov	r30, r0
    3506:	6e e2       	ldi	r22, 0x2E	; 46
    3508:	c6 01       	movw	r24, r12
    350a:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    350c:	c8 01       	movw	r24, r16
    350e:	0e 94 1e 1a 	call	0x343c	; 0x343c <_ZN10time_stamp12get_microsecEv>
    3512:	8e 01       	movw	r16, r28
    3514:	09 5f       	subi	r16, 0xF9	; 249
    3516:	1f 4f       	sbci	r17, 0xFF	; 255
    3518:	fe 01       	movw	r30, r28
    351a:	31 96       	adiw	r30, 0x01	; 1
    351c:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    351e:	2a e0       	ldi	r18, 0x0A	; 10
    3520:	30 e0       	ldi	r19, 0x00	; 0
    3522:	40 e0       	ldi	r20, 0x00	; 0
    3524:	50 e0       	ldi	r21, 0x00	; 0
    3526:	0e 94 cd 21 	call	0x439a	; 0x439a <__divmodsi4>
    352a:	e6 2f       	mov	r30, r22
    352c:	28 87       	std	Y+8, r18	; 0x08
    352e:	39 87       	std	Y+9, r19	; 0x09
    3530:	4a 87       	std	Y+10, r20	; 0x0a
    3532:	5b 87       	std	Y+11, r21	; 0x0b
    3534:	68 85       	ldd	r22, Y+8	; 0x08
    3536:	79 85       	ldd	r23, Y+9	; 0x09
    3538:	8a 85       	ldd	r24, Y+10	; 0x0a
    353a:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    353c:	20 e3       	ldi	r18, 0x30	; 48
    353e:	2e 0f       	add	r18, r30
    3540:	d8 01       	movw	r26, r16
    3542:	2e 93       	st	-X, r18
    3544:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3546:	ae 15       	cp	r26, r14
    3548:	bf 05       	cpc	r27, r15
    354a:	49 f7       	brne	.-46     	; 0x351e <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    354c:	1f 82       	std	Y+7, r1	; 0x07
    354e:	be 01       	movw	r22, r28
    3550:	6f 5f       	subi	r22, 0xFF	; 255
    3552:	7f 4f       	sbci	r23, 0xFF	; 255
    3554:	c6 01       	movw	r24, r12
    3556:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    355a:	c6 01       	movw	r24, r12
    355c:	2f 96       	adiw	r28, 0x0f	; 15
    355e:	cd bf       	out	0x3d, r28	; 61
    3560:	de bf       	out	0x3e, r29	; 62
    3562:	df 91       	pop	r29
    3564:	cf 91       	pop	r28
    3566:	1f 91       	pop	r17
    3568:	0f 91       	pop	r16
    356a:	ff 90       	pop	r15
    356c:	ef 90       	pop	r14
    356e:	df 90       	pop	r13
    3570:	cf 90       	pop	r12
    3572:	08 95       	ret

00003574 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3574:	cf 93       	push	r28
    3576:	df 93       	push	r29
    3578:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    357a:	0f b6       	in	r0, 0x3f	; 63
    357c:	f8 94       	cli
    357e:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3580:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3584:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3588:	8c 83       	std	Y+4, r24	; 0x04
    358a:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    358c:	0e 94 ce 12 	call	0x259c	; 0x259c <xTaskGetTickCount>
    3590:	68 83       	st	Y, r22
    3592:	79 83       	std	Y+1, r23	; 0x01
    3594:	8a 83       	std	Y+2, r24	; 0x02
    3596:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3598:	0f 90       	pop	r0
    359a:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    359c:	ce 01       	movw	r24, r28
    359e:	df 91       	pop	r29
    35a0:	cf 91       	pop	r28
    35a2:	08 95       	ret

000035a4 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    35a4:	5f 92       	push	r5
    35a6:	6f 92       	push	r6
    35a8:	7f 92       	push	r7
    35aa:	8f 92       	push	r8
    35ac:	9f 92       	push	r9
    35ae:	af 92       	push	r10
    35b0:	bf 92       	push	r11
    35b2:	cf 92       	push	r12
    35b4:	df 92       	push	r13
    35b6:	ef 92       	push	r14
    35b8:	ff 92       	push	r15
    35ba:	0f 93       	push	r16
    35bc:	1f 93       	push	r17
    35be:	cf 93       	push	r28
    35c0:	df 93       	push	r29
    35c2:	5c 01       	movw	r10, r24
    35c4:	4b 01       	movw	r8, r22
    35c6:	7a 01       	movw	r14, r20
    35c8:	12 2f       	mov	r17, r18
    35ca:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    35cc:	63 e0       	ldi	r22, 0x03	; 3
    35ce:	ca 01       	movw	r24, r20
    35d0:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    35d4:	a8 14       	cp	r10, r8
    35d6:	b9 04       	cpc	r11, r9
    35d8:	08 f0       	brcs	.+2      	; 0x35dc <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    35da:	7d c0       	rjmp	.+250    	; 0x36d6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    35dc:	65 01       	movw	r12, r10
    35de:	84 e1       	ldi	r24, 0x14	; 20
    35e0:	c8 0e       	add	r12, r24
    35e2:	d1 1c       	adc	r13, r1
    35e4:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    35e6:	6a 2c       	mov	r6, r10
    35e8:	5b 2c       	mov	r5, r11
    35ea:	b5 01       	movw	r22, r10
    35ec:	c7 01       	movw	r24, r14
    35ee:	0e 94 b5 1c 	call	0x396a	; 0x396a <_ZN8emstreamlsEj>
    35f2:	6a e0       	ldi	r22, 0x0A	; 10
    35f4:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    35f8:	60 e2       	ldi	r22, 0x20	; 32
    35fa:	77 e0       	ldi	r23, 0x07	; 7
    35fc:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3600:	11 23       	and	r17, r17
    3602:	09 f4       	brne	.+2      	; 0x3606 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3604:	6d c0       	rjmp	.+218    	; 0x36e0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3606:	00 23       	and	r16, r16
    3608:	09 f4       	brne	.+2      	; 0x360c <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    360a:	6a c0       	rjmp	.+212    	; 0x36e0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    360c:	6a e0       	ldi	r22, 0x0A	; 10
    360e:	c7 01       	movw	r24, r14
    3610:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    3614:	6b e1       	ldi	r22, 0x1B	; 27
    3616:	77 e0       	ldi	r23, 0x07	; 7
    3618:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    361c:	61 c0       	rjmp	.+194    	; 0x36e0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    361e:	11 23       	and	r17, r17
    3620:	71 f0       	breq	.+28     	; 0x363e <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3622:	01 11       	cpse	r16, r1
    3624:	0c c0       	rjmp	.+24     	; 0x363e <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3626:	88 81       	ld	r24, Y
    3628:	87 15       	cp	r24, r7
    362a:	49 f0       	breq	.+18     	; 0x363e <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    362c:	6a e0       	ldi	r22, 0x0A	; 10
    362e:	c7 01       	movw	r24, r14
    3630:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    3634:	66 e1       	ldi	r22, 0x16	; 22
    3636:	77 e0       	ldi	r23, 0x07	; 7
    3638:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    363c:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    363e:	69 91       	ld	r22, Y+
    3640:	c7 01       	movw	r24, r14
    3642:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3646:	dc 01       	movw	r26, r24
    3648:	ed 91       	ld	r30, X+
    364a:	fc 91       	ld	r31, X
    364c:	02 80       	ldd	r0, Z+2	; 0x02
    364e:	f3 81       	ldd	r31, Z+3	; 0x03
    3650:	e0 2d       	mov	r30, r0
    3652:	60 e2       	ldi	r22, 0x20	; 32
    3654:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3656:	cc 16       	cp	r12, r28
    3658:	dd 06       	cpc	r13, r29
    365a:	09 f7       	brne	.-62     	; 0x361e <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    365c:	11 23       	and	r17, r17
    365e:	89 f0       	breq	.+34     	; 0x3682 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3660:	6a e0       	ldi	r22, 0x0A	; 10
    3662:	c7 01       	movw	r24, r14
    3664:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    3668:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    366a:	60 e1       	ldi	r22, 0x10	; 16
    366c:	77 e0       	ldi	r23, 0x07	; 7
    366e:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3672:	e8 81       	ld	r30, Y
    3674:	f9 81       	ldd	r31, Y+1	; 0x01
    3676:	02 80       	ldd	r0, Z+2	; 0x02
    3678:	f3 81       	ldd	r31, Z+3	; 0x03
    367a:	e0 2d       	mov	r30, r0
    367c:	60 e2       	ldi	r22, 0x20	; 32
    367e:	ce 01       	movw	r24, r28
    3680:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3682:	c6 2d       	mov	r28, r6
    3684:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3686:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3688:	80 ee       	ldi	r24, 0xE0	; 224
    368a:	86 0f       	add	r24, r22
    368c:	8f 35       	cpi	r24, 0x5F	; 95
    368e:	48 f4       	brcc	.+18     	; 0x36a2 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3690:	d7 01       	movw	r26, r14
    3692:	ed 91       	ld	r30, X+
    3694:	fc 91       	ld	r31, X
    3696:	02 80       	ldd	r0, Z+2	; 0x02
    3698:	f3 81       	ldd	r31, Z+3	; 0x03
    369a:	e0 2d       	mov	r30, r0
    369c:	c7 01       	movw	r24, r14
    369e:	19 95       	eicall
    36a0:	09 c0       	rjmp	.+18     	; 0x36b4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    36a2:	d7 01       	movw	r26, r14
    36a4:	ed 91       	ld	r30, X+
    36a6:	fc 91       	ld	r31, X
    36a8:	02 80       	ldd	r0, Z+2	; 0x02
    36aa:	f3 81       	ldd	r31, Z+3	; 0x03
    36ac:	e0 2d       	mov	r30, r0
    36ae:	6e e2       	ldi	r22, 0x2E	; 46
    36b0:	c7 01       	movw	r24, r14
    36b2:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    36b4:	cc 16       	cp	r12, r28
    36b6:	dd 06       	cpc	r13, r29
    36b8:	31 f7       	brne	.-52     	; 0x3686 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    36ba:	b4 e1       	ldi	r27, 0x14	; 20
    36bc:	ab 0e       	add	r10, r27
    36be:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    36c0:	66 e0       	ldi	r22, 0x06	; 6
    36c2:	c7 01       	movw	r24, r14
    36c4:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    36c8:	84 e1       	ldi	r24, 0x14	; 20
    36ca:	c8 0e       	add	r12, r24
    36cc:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    36ce:	a8 14       	cp	r10, r8
    36d0:	b9 04       	cpc	r11, r9
    36d2:	08 f4       	brcc	.+2      	; 0x36d6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    36d4:	88 cf       	rjmp	.-240    	; 0x35e6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    36d6:	62 e0       	ldi	r22, 0x02	; 2
    36d8:	c7 01       	movw	r24, r14
    36da:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
}
    36de:	03 c0       	rjmp	.+6      	; 0x36e6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    36e0:	c6 2d       	mov	r28, r6
    36e2:	d5 2d       	mov	r29, r5
    36e4:	9c cf       	rjmp	.-200    	; 0x361e <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    36e6:	df 91       	pop	r29
    36e8:	cf 91       	pop	r28
    36ea:	1f 91       	pop	r17
    36ec:	0f 91       	pop	r16
    36ee:	ff 90       	pop	r15
    36f0:	ef 90       	pop	r14
    36f2:	df 90       	pop	r13
    36f4:	cf 90       	pop	r12
    36f6:	bf 90       	pop	r11
    36f8:	af 90       	pop	r10
    36fa:	9f 90       	pop	r9
    36fc:	8f 90       	pop	r8
    36fe:	7f 90       	pop	r7
    3700:	6f 90       	pop	r6
    3702:	5f 90       	pop	r5
    3704:	08 95       	ret

00003706 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3706:	0e 94 b4 0b 	call	0x1768	; 0x1768 <pvPortMalloc>
    370a:	08 95       	ret

0000370c <_Znaj>:
    370c:	0e 94 b4 0b 	call	0x1768	; 0x1768 <pvPortMalloc>
    3710:	08 95       	ret

00003712 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3712:	08 95       	ret

00003714 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3714:	cf 93       	push	r28
    3716:	df 93       	push	r29
    3718:	fc 01       	movw	r30, r24
    371a:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    371c:	40 3a       	cpi	r20, 0xA0	; 160
    371e:	68 e0       	ldi	r22, 0x08	; 8
    3720:	56 07       	cpc	r21, r22
    3722:	49 f4       	brne	.+18     	; 0x3736 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3724:	80 e4       	ldi	r24, 0x40	; 64
    3726:	96 e0       	ldi	r25, 0x06	; 6
    3728:	82 83       	std	Z+2, r24	; 0x02
    372a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    372c:	82 e0       	ldi	r24, 0x02	; 2
    372e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3730:	83 e0       	ldi	r24, 0x03	; 3
    3732:	85 83       	std	Z+5, r24	; 0x05
    3734:	32 c0       	rjmp	.+100    	; 0x379a <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3736:	40 3b       	cpi	r20, 0xB0	; 176
    3738:	78 e0       	ldi	r23, 0x08	; 8
    373a:	57 07       	cpc	r21, r23
    373c:	49 f4       	brne	.+18     	; 0x3750 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    373e:	80 e4       	ldi	r24, 0x40	; 64
    3740:	96 e0       	ldi	r25, 0x06	; 6
    3742:	82 83       	std	Z+2, r24	; 0x02
    3744:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3746:	86 e0       	ldi	r24, 0x06	; 6
    3748:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    374a:	87 e0       	ldi	r24, 0x07	; 7
    374c:	85 83       	std	Z+5, r24	; 0x05
    374e:	25 c0       	rjmp	.+74     	; 0x379a <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3750:	40 3a       	cpi	r20, 0xA0	; 160
    3752:	89 e0       	ldi	r24, 0x09	; 9
    3754:	58 07       	cpc	r21, r24
    3756:	49 f4       	brne	.+18     	; 0x376a <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3758:	80 e6       	ldi	r24, 0x60	; 96
    375a:	96 e0       	ldi	r25, 0x06	; 6
    375c:	82 83       	std	Z+2, r24	; 0x02
    375e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3760:	82 e0       	ldi	r24, 0x02	; 2
    3762:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3764:	83 e0       	ldi	r24, 0x03	; 3
    3766:	85 83       	std	Z+5, r24	; 0x05
    3768:	18 c0       	rjmp	.+48     	; 0x379a <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    376a:	40 3b       	cpi	r20, 0xB0	; 176
    376c:	69 e0       	ldi	r22, 0x09	; 9
    376e:	56 07       	cpc	r21, r22
    3770:	49 f4       	brne	.+18     	; 0x3784 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3772:	80 e6       	ldi	r24, 0x60	; 96
    3774:	96 e0       	ldi	r25, 0x06	; 6
    3776:	82 83       	std	Z+2, r24	; 0x02
    3778:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    377a:	86 e0       	ldi	r24, 0x06	; 6
    377c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    377e:	87 e0       	ldi	r24, 0x07	; 7
    3780:	85 83       	std	Z+5, r24	; 0x05
    3782:	0b c0       	rjmp	.+22     	; 0x379a <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3784:	40 3a       	cpi	r20, 0xA0	; 160
    3786:	5a 40       	sbci	r21, 0x0A	; 10
    3788:	41 f4       	brne	.+16     	; 0x379a <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    378a:	80 e8       	ldi	r24, 0x80	; 128
    378c:	96 e0       	ldi	r25, 0x06	; 6
    378e:	82 83       	std	Z+2, r24	; 0x02
    3790:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3792:	82 e0       	ldi	r24, 0x02	; 2
    3794:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3796:	83 e0       	ldi	r24, 0x03	; 3
    3798:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    379a:	a6 83       	std	Z+6, r26	; 0x06
    379c:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    379e:	cd 01       	movw	r24, r26
    37a0:	01 96       	adiw	r24, 0x01	; 1
    37a2:	80 87       	std	Z+8, r24	; 0x08
    37a4:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    37a6:	03 96       	adiw	r24, 0x03	; 3
    37a8:	82 87       	std	Z+10, r24	; 0x0a
    37aa:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    37ac:	25 81       	ldd	r18, Z+5	; 0x05
    37ae:	c2 81       	ldd	r28, Z+2	; 0x02
    37b0:	d3 81       	ldd	r29, Z+3	; 0x03
    37b2:	4c 81       	ldd	r20, Y+4	; 0x04
    37b4:	81 e0       	ldi	r24, 0x01	; 1
    37b6:	90 e0       	ldi	r25, 0x00	; 0
    37b8:	bc 01       	movw	r22, r24
    37ba:	02 c0       	rjmp	.+4      	; 0x37c0 <_ZN7base232C1EjP12USART_struct+0xac>
    37bc:	66 0f       	add	r22, r22
    37be:	77 1f       	adc	r23, r23
    37c0:	2a 95       	dec	r18
    37c2:	e2 f7       	brpl	.-8      	; 0x37bc <_ZN7base232C1EjP12USART_struct+0xa8>
    37c4:	9b 01       	movw	r18, r22
    37c6:	24 2b       	or	r18, r20
    37c8:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    37ca:	25 81       	ldd	r18, Z+5	; 0x05
    37cc:	c2 81       	ldd	r28, Z+2	; 0x02
    37ce:	d3 81       	ldd	r29, Z+3	; 0x03
    37d0:	48 81       	ld	r20, Y
    37d2:	bc 01       	movw	r22, r24
    37d4:	02 c0       	rjmp	.+4      	; 0x37da <_ZN7base232C1EjP12USART_struct+0xc6>
    37d6:	66 0f       	add	r22, r22
    37d8:	77 1f       	adc	r23, r23
    37da:	2a 95       	dec	r18
    37dc:	e2 f7       	brpl	.-8      	; 0x37d6 <_ZN7base232C1EjP12USART_struct+0xc2>
    37de:	9b 01       	movw	r18, r22
    37e0:	24 2b       	or	r18, r20
    37e2:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    37e4:	34 81       	ldd	r19, Z+4	; 0x04
    37e6:	c2 81       	ldd	r28, Z+2	; 0x02
    37e8:	d3 81       	ldd	r29, Z+3	; 0x03
    37ea:	28 81       	ld	r18, Y
    37ec:	02 c0       	rjmp	.+4      	; 0x37f2 <_ZN7base232C1EjP12USART_struct+0xde>
    37ee:	88 0f       	add	r24, r24
    37f0:	99 1f       	adc	r25, r25
    37f2:	3a 95       	dec	r19
    37f4:	e2 f7       	brpl	.-8      	; 0x37ee <_ZN7base232C1EjP12USART_struct+0xda>
    37f6:	80 95       	com	r24
    37f8:	90 95       	com	r25
    37fa:	82 23       	and	r24, r18
    37fc:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    37fe:	80 e1       	ldi	r24, 0x10	; 16
    3800:	13 96       	adiw	r26, 0x03	; 3
    3802:	8c 93       	st	X, r24
    3804:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3806:	83 e0       	ldi	r24, 0x03	; 3
    3808:	15 96       	adiw	r26, 0x05	; 5
    380a:	8c 93       	st	X, r24
    380c:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    380e:	80 ef       	ldi	r24, 0xF0	; 240
    3810:	17 96       	adiw	r26, 0x07	; 7
    3812:	8c 93       	st	X, r24
    3814:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3816:	81 e2       	ldi	r24, 0x21	; 33
    3818:	16 96       	adiw	r26, 0x06	; 6
    381a:	8c 93       	st	X, r24
    381c:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    381e:	88 e1       	ldi	r24, 0x18	; 24
    3820:	14 96       	adiw	r26, 0x04	; 4
    3822:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3824:	80 e8       	ldi	r24, 0x80	; 128
    3826:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3828:	80 e4       	ldi	r24, 0x40	; 64
    382a:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    382c:	80 e2       	ldi	r24, 0x20	; 32
    382e:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3830:	06 80       	ldd	r0, Z+6	; 0x06
    3832:	f7 81       	ldd	r31, Z+7	; 0x07
    3834:	e0 2d       	mov	r30, r0
    3836:	80 81       	ld	r24, Z
    3838:	80 81       	ld	r24, Z
}
    383a:	df 91       	pop	r29
    383c:	cf 91       	pop	r28
    383e:	08 95       	ret

00003840 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3840:	81 e0       	ldi	r24, 0x01	; 1
    3842:	08 95       	ret

00003844 <_ZN8emstream7getcharEv>:
    3844:	80 e0       	ldi	r24, 0x00	; 0
    3846:	90 e0       	ldi	r25, 0x00	; 0
    3848:	08 95       	ret

0000384a <_ZN8emstream14check_for_charEv>:
    384a:	80 e0       	ldi	r24, 0x00	; 0
    384c:	08 95       	ret

0000384e <_ZN8emstream12transmit_nowEv>:
    384e:	08 95       	ret

00003850 <_ZN8emstream12clear_screenEv>:
    3850:	08 95       	ret

00003852 <_ZN8emstreamC1Ev>:
    3852:	fc 01       	movw	r30, r24
    3854:	8f e4       	ldi	r24, 0x4F	; 79
    3856:	90 e2       	ldi	r25, 0x20	; 32
    3858:	80 83       	st	Z, r24
    385a:	91 83       	std	Z+1, r25	; 0x01
    385c:	8a e0       	ldi	r24, 0x0A	; 10
    385e:	82 83       	std	Z+2, r24	; 0x02
    3860:	13 82       	std	Z+3, r1	; 0x03
    3862:	83 e0       	ldi	r24, 0x03	; 3
    3864:	85 83       	std	Z+5, r24	; 0x05
    3866:	14 82       	std	Z+4, r1	; 0x04
    3868:	16 82       	std	Z+6, r1	; 0x06
    386a:	17 82       	std	Z+7, r1	; 0x07
    386c:	08 95       	ret

0000386e <_ZN8emstream4putsEPKc>:
    386e:	0f 93       	push	r16
    3870:	1f 93       	push	r17
    3872:	cf 93       	push	r28
    3874:	df 93       	push	r29
    3876:	8c 01       	movw	r16, r24
    3878:	fb 01       	movw	r30, r22
    387a:	dc 01       	movw	r26, r24
    387c:	14 96       	adiw	r26, 0x04	; 4
    387e:	8c 91       	ld	r24, X
    3880:	81 11       	cpse	r24, r1
    3882:	04 c0       	rjmp	.+8      	; 0x388c <_ZN8emstream4putsEPKc+0x1e>
    3884:	60 81       	ld	r22, Z
    3886:	61 11       	cpse	r22, r1
    3888:	17 c0       	rjmp	.+46     	; 0x38b8 <_ZN8emstream4putsEPKc+0x4a>
    388a:	23 c0       	rjmp	.+70     	; 0x38d2 <_ZN8emstream4putsEPKc+0x64>
    388c:	d8 01       	movw	r26, r16
    388e:	14 96       	adiw	r26, 0x04	; 4
    3890:	1c 92       	st	X, r1
    3892:	eb 01       	movw	r28, r22
    3894:	21 96       	adiw	r28, 0x01	; 1
    3896:	64 91       	lpm	r22, Z
    3898:	66 23       	and	r22, r22
    389a:	d9 f0       	breq	.+54     	; 0x38d2 <_ZN8emstream4putsEPKc+0x64>
    389c:	d8 01       	movw	r26, r16
    389e:	ed 91       	ld	r30, X+
    38a0:	fc 91       	ld	r31, X
    38a2:	02 80       	ldd	r0, Z+2	; 0x02
    38a4:	f3 81       	ldd	r31, Z+3	; 0x03
    38a6:	e0 2d       	mov	r30, r0
    38a8:	c8 01       	movw	r24, r16
    38aa:	19 95       	eicall
    38ac:	fe 01       	movw	r30, r28
    38ae:	64 91       	lpm	r22, Z
    38b0:	21 96       	adiw	r28, 0x01	; 1
    38b2:	61 11       	cpse	r22, r1
    38b4:	f3 cf       	rjmp	.-26     	; 0x389c <_ZN8emstream4putsEPKc+0x2e>
    38b6:	0d c0       	rjmp	.+26     	; 0x38d2 <_ZN8emstream4putsEPKc+0x64>
    38b8:	ef 01       	movw	r28, r30
    38ba:	21 96       	adiw	r28, 0x01	; 1
    38bc:	d8 01       	movw	r26, r16
    38be:	ed 91       	ld	r30, X+
    38c0:	fc 91       	ld	r31, X
    38c2:	02 80       	ldd	r0, Z+2	; 0x02
    38c4:	f3 81       	ldd	r31, Z+3	; 0x03
    38c6:	e0 2d       	mov	r30, r0
    38c8:	c8 01       	movw	r24, r16
    38ca:	19 95       	eicall
    38cc:	69 91       	ld	r22, Y+
    38ce:	61 11       	cpse	r22, r1
    38d0:	f5 cf       	rjmp	.-22     	; 0x38bc <_ZN8emstream4putsEPKc+0x4e>
    38d2:	df 91       	pop	r29
    38d4:	cf 91       	pop	r28
    38d6:	1f 91       	pop	r17
    38d8:	0f 91       	pop	r16
    38da:	08 95       	ret

000038dc <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    38dc:	cf 93       	push	r28
    38de:	df 93       	push	r29
    38e0:	ec 01       	movw	r28, r24
	switch (new_manip)
    38e2:	86 2f       	mov	r24, r22
    38e4:	90 e0       	ldi	r25, 0x00	; 0
    38e6:	8b 30       	cpi	r24, 0x0B	; 11
    38e8:	91 05       	cpc	r25, r1
    38ea:	d8 f5       	brcc	.+118    	; 0x3962 <_ZN8emstreamlsE15ser_manipulator+0x86>
    38ec:	fc 01       	movw	r30, r24
    38ee:	88 27       	eor	r24, r24
    38f0:	e6 5a       	subi	r30, 0xA6	; 166
    38f2:	fe 4f       	sbci	r31, 0xFE	; 254
    38f4:	8f 4f       	sbci	r24, 0xFF	; 255
    38f6:	0c 94 ec 21 	jmp	0x43d8	; 0x43d8 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    38fa:	82 e0       	ldi	r24, 0x02	; 2
    38fc:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38fe:	31 c0       	rjmp	.+98     	; 0x3962 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3900:	88 e0       	ldi	r24, 0x08	; 8
    3902:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3904:	2e c0       	rjmp	.+92     	; 0x3962 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3906:	8a e0       	ldi	r24, 0x0A	; 10
    3908:	8a 83       	std	Y+2, r24	; 0x02
			break;
    390a:	2b c0       	rjmp	.+86     	; 0x3962 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    390c:	80 e1       	ldi	r24, 0x10	; 16
    390e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3910:	28 c0       	rjmp	.+80     	; 0x3962 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3912:	81 e0       	ldi	r24, 0x01	; 1
    3914:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3916:	25 c0       	rjmp	.+74     	; 0x3962 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3918:	1b 82       	std	Y+3, r1	; 0x03
			break;
    391a:	23 c0       	rjmp	.+70     	; 0x3962 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    391c:	e8 81       	ld	r30, Y
    391e:	f9 81       	ldd	r31, Y+1	; 0x01
    3920:	02 80       	ldd	r0, Z+2	; 0x02
    3922:	f3 81       	ldd	r31, Z+3	; 0x03
    3924:	e0 2d       	mov	r30, r0
    3926:	6d e0       	ldi	r22, 0x0D	; 13
    3928:	ce 01       	movw	r24, r28
    392a:	19 95       	eicall
    392c:	e8 81       	ld	r30, Y
    392e:	f9 81       	ldd	r31, Y+1	; 0x01
    3930:	02 80       	ldd	r0, Z+2	; 0x02
    3932:	f3 81       	ldd	r31, Z+3	; 0x03
    3934:	e0 2d       	mov	r30, r0
    3936:	6a e0       	ldi	r22, 0x0A	; 10
    3938:	ce 01       	movw	r24, r28
    393a:	19 95       	eicall
			break;
    393c:	12 c0       	rjmp	.+36     	; 0x3962 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    393e:	e8 81       	ld	r30, Y
    3940:	f9 81       	ldd	r31, Y+1	; 0x01
    3942:	02 84       	ldd	r0, Z+10	; 0x0a
    3944:	f3 85       	ldd	r31, Z+11	; 0x0b
    3946:	e0 2d       	mov	r30, r0
    3948:	ce 01       	movw	r24, r28
    394a:	19 95       	eicall
			break;
    394c:	0a c0       	rjmp	.+20     	; 0x3962 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    394e:	e8 81       	ld	r30, Y
    3950:	f9 81       	ldd	r31, Y+1	; 0x01
    3952:	00 84       	ldd	r0, Z+8	; 0x08
    3954:	f1 85       	ldd	r31, Z+9	; 0x09
    3956:	e0 2d       	mov	r30, r0
    3958:	ce 01       	movw	r24, r28
    395a:	19 95       	eicall
			break;
    395c:	02 c0       	rjmp	.+4      	; 0x3962 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    395e:	81 e0       	ldi	r24, 0x01	; 1
    3960:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3962:	ce 01       	movw	r24, r28
    3964:	df 91       	pop	r29
    3966:	cf 91       	pop	r28
    3968:	08 95       	ret

0000396a <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    396a:	ff 92       	push	r15
    396c:	0f 93       	push	r16
    396e:	1f 93       	push	r17
    3970:	cf 93       	push	r28
    3972:	df 93       	push	r29
    3974:	cd b7       	in	r28, 0x3d	; 61
    3976:	de b7       	in	r29, 0x3e	; 62
    3978:	61 97       	sbiw	r28, 0x11	; 17
    397a:	cd bf       	out	0x3d, r28	; 61
    397c:	de bf       	out	0x3e, r29	; 62
    397e:	8c 01       	movw	r16, r24
    3980:	f6 2e       	mov	r15, r22
    3982:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3984:	f8 01       	movw	r30, r16
    3986:	42 81       	ldd	r20, Z+2	; 0x02
    3988:	40 31       	cpi	r20, 0x10	; 16
    398a:	21 f0       	breq	.+8      	; 0x3994 <_ZN8emstreamlsEj+0x2a>
    398c:	48 30       	cpi	r20, 0x08	; 8
    398e:	11 f0       	breq	.+4      	; 0x3994 <_ZN8emstreamlsEj+0x2a>
    3990:	42 30       	cpi	r20, 0x02	; 2
    3992:	41 f4       	brne	.+16     	; 0x39a4 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3994:	69 2f       	mov	r22, r25
    3996:	c8 01       	movw	r24, r16
    3998:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <_ZN8emstreamlsEh>
    399c:	6f 2d       	mov	r22, r15
    399e:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <_ZN8emstreamlsEh>
    39a2:	0d c0       	rjmp	.+26     	; 0x39be <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    39a4:	50 e0       	ldi	r21, 0x00	; 0
    39a6:	be 01       	movw	r22, r28
    39a8:	6f 5f       	subi	r22, 0xFF	; 255
    39aa:	7f 4f       	sbci	r23, 0xFF	; 255
    39ac:	8f 2d       	mov	r24, r15
    39ae:	0e 94 86 22 	call	0x450c	; 0x450c <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    39b2:	be 01       	movw	r22, r28
    39b4:	6f 5f       	subi	r22, 0xFF	; 255
    39b6:	7f 4f       	sbci	r23, 0xFF	; 255
    39b8:	c8 01       	movw	r24, r16
    39ba:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    39be:	c8 01       	movw	r24, r16
    39c0:	61 96       	adiw	r28, 0x11	; 17
    39c2:	cd bf       	out	0x3d, r28	; 61
    39c4:	de bf       	out	0x3e, r29	; 62
    39c6:	df 91       	pop	r29
    39c8:	cf 91       	pop	r28
    39ca:	1f 91       	pop	r17
    39cc:	0f 91       	pop	r16
    39ce:	ff 90       	pop	r15
    39d0:	08 95       	ret

000039d2 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    39d2:	df 92       	push	r13
    39d4:	ef 92       	push	r14
    39d6:	ff 92       	push	r15
    39d8:	0f 93       	push	r16
    39da:	1f 93       	push	r17
    39dc:	cf 93       	push	r28
    39de:	df 93       	push	r29
    39e0:	cd b7       	in	r28, 0x3d	; 61
    39e2:	de b7       	in	r29, 0x3e	; 62
    39e4:	a1 97       	sbiw	r28, 0x21	; 33
    39e6:	cd bf       	out	0x3d, r28	; 61
    39e8:	de bf       	out	0x3e, r29	; 62
    39ea:	8c 01       	movw	r16, r24
    39ec:	d4 2e       	mov	r13, r20
    39ee:	e5 2e       	mov	r14, r21
    39f0:	f6 2e       	mov	r15, r22
    39f2:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    39f4:	f8 01       	movw	r30, r16
    39f6:	22 81       	ldd	r18, Z+2	; 0x02
    39f8:	20 31       	cpi	r18, 0x10	; 16
    39fa:	21 f0       	breq	.+8      	; 0x3a04 <_ZN8emstreamlsEm+0x32>
    39fc:	28 30       	cpi	r18, 0x08	; 8
    39fe:	11 f0       	breq	.+4      	; 0x3a04 <_ZN8emstreamlsEm+0x32>
    3a00:	22 30       	cpi	r18, 0x02	; 2
    3a02:	71 f4       	brne	.+28     	; 0x3a20 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3a04:	69 2f       	mov	r22, r25
    3a06:	c8 01       	movw	r24, r16
    3a08:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <_ZN8emstreamlsEh>
    3a0c:	6f 2d       	mov	r22, r15
    3a0e:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <_ZN8emstreamlsEh>
    3a12:	6e 2d       	mov	r22, r14
    3a14:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <_ZN8emstreamlsEh>
    3a18:	6d 2d       	mov	r22, r13
    3a1a:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <_ZN8emstreamlsEh>
    3a1e:	0f c0       	rjmp	.+30     	; 0x3a3e <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3a20:	30 e0       	ldi	r19, 0x00	; 0
    3a22:	ae 01       	movw	r20, r28
    3a24:	4f 5f       	subi	r20, 0xFF	; 255
    3a26:	5f 4f       	sbci	r21, 0xFF	; 255
    3a28:	6d 2d       	mov	r22, r13
    3a2a:	7e 2d       	mov	r23, r14
    3a2c:	8f 2d       	mov	r24, r15
    3a2e:	0e 94 59 22 	call	0x44b2	; 0x44b2 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3a32:	be 01       	movw	r22, r28
    3a34:	6f 5f       	subi	r22, 0xFF	; 255
    3a36:	7f 4f       	sbci	r23, 0xFF	; 255
    3a38:	c8 01       	movw	r24, r16
    3a3a:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3a3e:	c8 01       	movw	r24, r16
    3a40:	a1 96       	adiw	r28, 0x21	; 33
    3a42:	cd bf       	out	0x3d, r28	; 61
    3a44:	de bf       	out	0x3e, r29	; 62
    3a46:	df 91       	pop	r29
    3a48:	cf 91       	pop	r28
    3a4a:	1f 91       	pop	r17
    3a4c:	0f 91       	pop	r16
    3a4e:	ff 90       	pop	r15
    3a50:	ef 90       	pop	r14
    3a52:	df 90       	pop	r13
    3a54:	08 95       	ret

00003a56 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3a56:	cf 92       	push	r12
    3a58:	df 92       	push	r13
    3a5a:	ef 92       	push	r14
    3a5c:	ff 92       	push	r15
    3a5e:	0f 93       	push	r16
    3a60:	1f 93       	push	r17
    3a62:	cf 93       	push	r28
    3a64:	df 93       	push	r29
    3a66:	cd b7       	in	r28, 0x3d	; 61
    3a68:	de b7       	in	r29, 0x3e	; 62
    3a6a:	29 97       	sbiw	r28, 0x09	; 9
    3a6c:	cd bf       	out	0x3d, r28	; 61
    3a6e:	de bf       	out	0x3e, r29	; 62
    3a70:	8c 01       	movw	r16, r24
    3a72:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3a74:	dc 01       	movw	r26, r24
    3a76:	13 96       	adiw	r26, 0x03	; 3
    3a78:	8c 91       	ld	r24, X
    3a7a:	13 97       	sbiw	r26, 0x03	; 3
    3a7c:	88 23       	and	r24, r24
    3a7e:	41 f0       	breq	.+16     	; 0x3a90 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3a80:	ed 91       	ld	r30, X+
    3a82:	fc 91       	ld	r31, X
    3a84:	02 80       	ldd	r0, Z+2	; 0x02
    3a86:	f3 81       	ldd	r31, Z+3	; 0x03
    3a88:	e0 2d       	mov	r30, r0
    3a8a:	c8 01       	movw	r24, r16
    3a8c:	19 95       	eicall
    3a8e:	56 c0       	rjmp	.+172    	; 0x3b3c <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3a90:	f8 01       	movw	r30, r16
    3a92:	42 81       	ldd	r20, Z+2	; 0x02
    3a94:	42 30       	cpi	r20, 0x02	; 2
    3a96:	19 f5       	brne	.+70     	; 0x3ade <_ZN8emstreamlsEh+0x88>
    3a98:	68 94       	set
    3a9a:	cc 24       	eor	r12, r12
    3a9c:	c3 f8       	bld	r12, 3
    3a9e:	d1 2c       	mov	r13, r1
    3aa0:	68 94       	set
    3aa2:	ff 24       	eor	r15, r15
    3aa4:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3aa6:	8e 2d       	mov	r24, r14
    3aa8:	8f 21       	and	r24, r15
    3aaa:	51 f0       	breq	.+20     	; 0x3ac0 <_ZN8emstreamlsEh+0x6a>
    3aac:	d8 01       	movw	r26, r16
    3aae:	ed 91       	ld	r30, X+
    3ab0:	fc 91       	ld	r31, X
    3ab2:	02 80       	ldd	r0, Z+2	; 0x02
    3ab4:	f3 81       	ldd	r31, Z+3	; 0x03
    3ab6:	e0 2d       	mov	r30, r0
    3ab8:	61 e3       	ldi	r22, 0x31	; 49
    3aba:	c8 01       	movw	r24, r16
    3abc:	19 95       	eicall
    3abe:	09 c0       	rjmp	.+18     	; 0x3ad2 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3ac0:	d8 01       	movw	r26, r16
    3ac2:	ed 91       	ld	r30, X+
    3ac4:	fc 91       	ld	r31, X
    3ac6:	02 80       	ldd	r0, Z+2	; 0x02
    3ac8:	f3 81       	ldd	r31, Z+3	; 0x03
    3aca:	e0 2d       	mov	r30, r0
    3acc:	60 e3       	ldi	r22, 0x30	; 48
    3ace:	c8 01       	movw	r24, r16
    3ad0:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3ad2:	f6 94       	lsr	r15
    3ad4:	b1 e0       	ldi	r27, 0x01	; 1
    3ad6:	cb 1a       	sub	r12, r27
    3ad8:	d1 08       	sbc	r13, r1
    3ada:	29 f7       	brne	.-54     	; 0x3aa6 <_ZN8emstreamlsEh+0x50>
    3adc:	2f c0       	rjmp	.+94     	; 0x3b3c <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3ade:	40 31       	cpi	r20, 0x10	; 16
    3ae0:	f9 f4       	brne	.+62     	; 0x3b20 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3ae2:	62 95       	swap	r22
    3ae4:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3ae6:	01 90       	ld	r0, Z+
    3ae8:	f0 81       	ld	r31, Z
    3aea:	e0 2d       	mov	r30, r0
    3aec:	02 80       	ldd	r0, Z+2	; 0x02
    3aee:	f3 81       	ldd	r31, Z+3	; 0x03
    3af0:	e0 2d       	mov	r30, r0
    3af2:	6a 30       	cpi	r22, 0x0A	; 10
    3af4:	10 f0       	brcs	.+4      	; 0x3afa <_ZN8emstreamlsEh+0xa4>
    3af6:	69 5c       	subi	r22, 0xC9	; 201
    3af8:	01 c0       	rjmp	.+2      	; 0x3afc <_ZN8emstreamlsEh+0xa6>
    3afa:	60 5d       	subi	r22, 0xD0	; 208
    3afc:	c8 01       	movw	r24, r16
    3afe:	19 95       	eicall
		temp_char = num & 0x0F;
    3b00:	6e 2d       	mov	r22, r14
    3b02:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3b04:	d8 01       	movw	r26, r16
    3b06:	ed 91       	ld	r30, X+
    3b08:	fc 91       	ld	r31, X
    3b0a:	02 80       	ldd	r0, Z+2	; 0x02
    3b0c:	f3 81       	ldd	r31, Z+3	; 0x03
    3b0e:	e0 2d       	mov	r30, r0
    3b10:	6a 30       	cpi	r22, 0x0A	; 10
    3b12:	10 f0       	brcs	.+4      	; 0x3b18 <_ZN8emstreamlsEh+0xc2>
    3b14:	69 5c       	subi	r22, 0xC9	; 201
    3b16:	01 c0       	rjmp	.+2      	; 0x3b1a <_ZN8emstreamlsEh+0xc4>
    3b18:	60 5d       	subi	r22, 0xD0	; 208
    3b1a:	c8 01       	movw	r24, r16
    3b1c:	19 95       	eicall
    3b1e:	0e c0       	rjmp	.+28     	; 0x3b3c <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3b20:	50 e0       	ldi	r21, 0x00	; 0
    3b22:	be 01       	movw	r22, r28
    3b24:	6f 5f       	subi	r22, 0xFF	; 255
    3b26:	7f 4f       	sbci	r23, 0xFF	; 255
    3b28:	8e 2d       	mov	r24, r14
    3b2a:	90 e0       	ldi	r25, 0x00	; 0
    3b2c:	0e 94 86 22 	call	0x450c	; 0x450c <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3b30:	be 01       	movw	r22, r28
    3b32:	6f 5f       	subi	r22, 0xFF	; 255
    3b34:	7f 4f       	sbci	r23, 0xFF	; 255
    3b36:	c8 01       	movw	r24, r16
    3b38:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3b3c:	c8 01       	movw	r24, r16
    3b3e:	29 96       	adiw	r28, 0x09	; 9
    3b40:	cd bf       	out	0x3d, r28	; 61
    3b42:	de bf       	out	0x3e, r29	; 62
    3b44:	df 91       	pop	r29
    3b46:	cf 91       	pop	r28
    3b48:	1f 91       	pop	r17
    3b4a:	0f 91       	pop	r16
    3b4c:	ff 90       	pop	r15
    3b4e:	ef 90       	pop	r14
    3b50:	df 90       	pop	r13
    3b52:	cf 90       	pop	r12
    3b54:	08 95       	ret

00003b56 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3b56:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3b58:	50 96       	adiw	r26, 0x10	; 16
    3b5a:	ed 91       	ld	r30, X+
    3b5c:	fc 91       	ld	r31, X
    3b5e:	51 97       	sbiw	r26, 0x11	; 17
    3b60:	80 81       	ld	r24, Z
    3b62:	54 96       	adiw	r26, 0x14	; 20
    3b64:	4c 91       	ld	r20, X
    3b66:	54 97       	sbiw	r26, 0x14	; 20
    3b68:	84 23       	and	r24, r20
    3b6a:	29 f0       	breq	.+10     	; 0x3b76 <_ZN5rs2327putcharEc+0x20>
    3b6c:	09 c0       	rjmp	.+18     	; 0x3b80 <_ZN5rs2327putcharEc+0x2a>
    3b6e:	21 50       	subi	r18, 0x01	; 1
    3b70:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3b72:	19 f4       	brne	.+6      	; 0x3b7a <_ZN5rs2327putcharEc+0x24>
    3b74:	12 c0       	rjmp	.+36     	; 0x3b9a <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3b76:	21 e2       	ldi	r18, 0x21	; 33
    3b78:	3e e4       	ldi	r19, 0x4E	; 78
    3b7a:	90 81       	ld	r25, Z
    3b7c:	94 23       	and	r25, r20
    3b7e:	b9 f3       	breq	.-18     	; 0x3b6e <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3b80:	90 81       	ld	r25, Z
    3b82:	56 96       	adiw	r26, 0x16	; 22
    3b84:	8c 91       	ld	r24, X
    3b86:	56 97       	sbiw	r26, 0x16	; 22
    3b88:	89 2b       	or	r24, r25
    3b8a:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3b8c:	1e 96       	adiw	r26, 0x0e	; 14
    3b8e:	ed 91       	ld	r30, X+
    3b90:	fc 91       	ld	r31, X
    3b92:	1f 97       	sbiw	r26, 0x0f	; 15
    3b94:	60 83       	st	Z, r22
	return (true);
    3b96:	81 e0       	ldi	r24, 0x01	; 1
    3b98:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3b9a:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3b9c:	08 95       	ret

00003b9e <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3b9e:	cf 93       	push	r28
    3ba0:	df 93       	push	r29
    3ba2:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3ba4:	c1 8d       	ldd	r28, Z+25	; 0x19
    3ba6:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3ba8:	28 81       	ld	r18, Y
    3baa:	39 81       	ldd	r19, Y+1	; 0x01
    3bac:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3bae:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3bb0:	4d 91       	ld	r20, X+
    3bb2:	5c 91       	ld	r21, X
    3bb4:	24 17       	cp	r18, r20
    3bb6:	35 07       	cpc	r19, r21
    3bb8:	e9 f3       	breq	.-6      	; 0x3bb4 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3bba:	a7 89       	ldd	r26, Z+23	; 0x17
    3bbc:	b0 8d       	ldd	r27, Z+24	; 0x18
    3bbe:	0d 90       	ld	r0, X+
    3bc0:	bc 91       	ld	r27, X
    3bc2:	a0 2d       	mov	r26, r0
    3bc4:	a2 0f       	add	r26, r18
    3bc6:	b3 1f       	adc	r27, r19
    3bc8:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3bca:	2f 5f       	subi	r18, 0xFF	; 255
    3bcc:	3f 4f       	sbci	r19, 0xFF	; 255
    3bce:	28 83       	st	Y, r18
    3bd0:	39 83       	std	Y+1, r19	; 0x01
    3bd2:	24 36       	cpi	r18, 0x64	; 100
    3bd4:	31 05       	cpc	r19, r1
    3bd6:	28 f0       	brcs	.+10     	; 0x3be2 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3bd8:	01 8c       	ldd	r0, Z+25	; 0x19
    3bda:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3bdc:	e0 2d       	mov	r30, r0
    3bde:	10 82       	st	Z, r1
    3be0:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3be2:	90 e0       	ldi	r25, 0x00	; 0
    3be4:	df 91       	pop	r29
    3be6:	cf 91       	pop	r28
    3be8:	08 95       	ret

00003bea <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3bea:	cf 93       	push	r28
    3bec:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3bee:	ec 01       	movw	r28, r24
    3bf0:	a9 8d       	ldd	r26, Y+25	; 0x19
    3bf2:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3bf4:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3bf6:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3bf8:	81 e0       	ldi	r24, 0x01	; 1
    3bfa:	4d 91       	ld	r20, X+
    3bfc:	5c 91       	ld	r21, X
    3bfe:	20 81       	ld	r18, Z
    3c00:	31 81       	ldd	r19, Z+1	; 0x01
    3c02:	42 17       	cp	r20, r18
    3c04:	53 07       	cpc	r21, r19
    3c06:	09 f4       	brne	.+2      	; 0x3c0a <_ZN5rs23214check_for_charEv+0x20>
    3c08:	80 e0       	ldi	r24, 0x00	; 0
}
    3c0a:	df 91       	pop	r29
    3c0c:	cf 91       	pop	r28
    3c0e:	08 95       	ret

00003c10 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3c10:	dc 01       	movw	r26, r24
    3c12:	ed 91       	ld	r30, X+
    3c14:	fc 91       	ld	r31, X
    3c16:	02 80       	ldd	r0, Z+2	; 0x02
    3c18:	f3 81       	ldd	r31, Z+3	; 0x03
    3c1a:	e0 2d       	mov	r30, r0
    3c1c:	6c e0       	ldi	r22, 0x0C	; 12
    3c1e:	19 95       	eicall
    3c20:	08 95       	ret

00003c22 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3c22:	ef 92       	push	r14
    3c24:	ff 92       	push	r15
    3c26:	0f 93       	push	r16
    3c28:	1f 93       	push	r17
    3c2a:	cf 93       	push	r28
    3c2c:	df 93       	push	r29
    3c2e:	ec 01       	movw	r28, r24
    3c30:	7b 01       	movw	r14, r22
    3c32:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3c34:	0e 94 29 1c 	call	0x3852	; 0x3852 <_ZN8emstreamC1Ev>
    3c38:	a8 01       	movw	r20, r16
    3c3a:	b7 01       	movw	r22, r14
    3c3c:	ce 01       	movw	r24, r28
    3c3e:	08 96       	adiw	r24, 0x08	; 8
    3c40:	0e 94 8a 1b 	call	0x3714	; 0x3714 <_ZN7base232C1EjP12USART_struct>
    3c44:	8f e5       	ldi	r24, 0x5F	; 95
    3c46:	90 e2       	ldi	r25, 0x20	; 32
    3c48:	88 83       	st	Y, r24
    3c4a:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3c4c:	00 3a       	cpi	r16, 0xA0	; 160
    3c4e:	88 e0       	ldi	r24, 0x08	; 8
    3c50:	18 07       	cpc	r17, r24
    3c52:	69 f4       	brne	.+26     	; 0x3c6e <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3c54:	88 e3       	ldi	r24, 0x38	; 56
    3c56:	91 e3       	ldi	r25, 0x31	; 49
    3c58:	8f 8b       	std	Y+23, r24	; 0x17
    3c5a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3c5c:	8e e2       	ldi	r24, 0x2E	; 46
    3c5e:	91 e3       	ldi	r25, 0x31	; 49
    3c60:	89 8f       	std	Y+25, r24	; 0x19
    3c62:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3c64:	84 e2       	ldi	r24, 0x24	; 36
    3c66:	91 e3       	ldi	r25, 0x31	; 49
    3c68:	8b 8f       	std	Y+27, r24	; 0x1b
    3c6a:	9c 8f       	std	Y+28, r25	; 0x1c
    3c6c:	42 c0       	rjmp	.+132    	; 0x3cf2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3c6e:	00 3b       	cpi	r16, 0xB0	; 176
    3c70:	e8 e0       	ldi	r30, 0x08	; 8
    3c72:	1e 07       	cpc	r17, r30
    3c74:	69 f4       	brne	.+26     	; 0x3c90 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3c76:	86 e3       	ldi	r24, 0x36	; 54
    3c78:	91 e3       	ldi	r25, 0x31	; 49
    3c7a:	8f 8b       	std	Y+23, r24	; 0x17
    3c7c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3c7e:	8c e2       	ldi	r24, 0x2C	; 44
    3c80:	91 e3       	ldi	r25, 0x31	; 49
    3c82:	89 8f       	std	Y+25, r24	; 0x19
    3c84:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3c86:	82 e2       	ldi	r24, 0x22	; 34
    3c88:	91 e3       	ldi	r25, 0x31	; 49
    3c8a:	8b 8f       	std	Y+27, r24	; 0x1b
    3c8c:	9c 8f       	std	Y+28, r25	; 0x1c
    3c8e:	31 c0       	rjmp	.+98     	; 0x3cf2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3c90:	00 3a       	cpi	r16, 0xA0	; 160
    3c92:	f9 e0       	ldi	r31, 0x09	; 9
    3c94:	1f 07       	cpc	r17, r31
    3c96:	69 f4       	brne	.+26     	; 0x3cb2 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3c98:	84 e3       	ldi	r24, 0x34	; 52
    3c9a:	91 e3       	ldi	r25, 0x31	; 49
    3c9c:	8f 8b       	std	Y+23, r24	; 0x17
    3c9e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3ca0:	8a e2       	ldi	r24, 0x2A	; 42
    3ca2:	91 e3       	ldi	r25, 0x31	; 49
    3ca4:	89 8f       	std	Y+25, r24	; 0x19
    3ca6:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3ca8:	80 e2       	ldi	r24, 0x20	; 32
    3caa:	91 e3       	ldi	r25, 0x31	; 49
    3cac:	8b 8f       	std	Y+27, r24	; 0x1b
    3cae:	9c 8f       	std	Y+28, r25	; 0x1c
    3cb0:	20 c0       	rjmp	.+64     	; 0x3cf2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3cb2:	00 3b       	cpi	r16, 0xB0	; 176
    3cb4:	89 e0       	ldi	r24, 0x09	; 9
    3cb6:	18 07       	cpc	r17, r24
    3cb8:	69 f4       	brne	.+26     	; 0x3cd4 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3cba:	82 e3       	ldi	r24, 0x32	; 50
    3cbc:	91 e3       	ldi	r25, 0x31	; 49
    3cbe:	8f 8b       	std	Y+23, r24	; 0x17
    3cc0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3cc2:	88 e2       	ldi	r24, 0x28	; 40
    3cc4:	91 e3       	ldi	r25, 0x31	; 49
    3cc6:	89 8f       	std	Y+25, r24	; 0x19
    3cc8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3cca:	8e e1       	ldi	r24, 0x1E	; 30
    3ccc:	91 e3       	ldi	r25, 0x31	; 49
    3cce:	8b 8f       	std	Y+27, r24	; 0x1b
    3cd0:	9c 8f       	std	Y+28, r25	; 0x1c
    3cd2:	0f c0       	rjmp	.+30     	; 0x3cf2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3cd4:	00 3a       	cpi	r16, 0xA0	; 160
    3cd6:	1a 40       	sbci	r17, 0x0A	; 10
    3cd8:	61 f4       	brne	.+24     	; 0x3cf2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3cda:	80 e3       	ldi	r24, 0x30	; 48
    3cdc:	91 e3       	ldi	r25, 0x31	; 49
    3cde:	8f 8b       	std	Y+23, r24	; 0x17
    3ce0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3ce2:	86 e2       	ldi	r24, 0x26	; 38
    3ce4:	91 e3       	ldi	r25, 0x31	; 49
    3ce6:	89 8f       	std	Y+25, r24	; 0x19
    3ce8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3cea:	8c e1       	ldi	r24, 0x1C	; 28
    3cec:	91 e3       	ldi	r25, 0x31	; 49
    3cee:	8b 8f       	std	Y+27, r24	; 0x1b
    3cf0:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3cf2:	0f 89       	ldd	r16, Y+23	; 0x17
    3cf4:	18 8d       	ldd	r17, Y+24	; 0x18
    3cf6:	84 e6       	ldi	r24, 0x64	; 100
    3cf8:	90 e0       	ldi	r25, 0x00	; 0
    3cfa:	0e 94 86 1b 	call	0x370c	; 0x370c <_Znaj>
    3cfe:	f8 01       	movw	r30, r16
    3d00:	80 83       	st	Z, r24
    3d02:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3d04:	e9 8d       	ldd	r30, Y+25	; 0x19
    3d06:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3d08:	10 82       	st	Z, r1
    3d0a:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3d0c:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3d0e:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3d10:	10 82       	st	Z, r1
    3d12:	11 82       	std	Z+1, r1	; 0x01
}
    3d14:	df 91       	pop	r29
    3d16:	cf 91       	pop	r28
    3d18:	1f 91       	pop	r17
    3d1a:	0f 91       	pop	r16
    3d1c:	ff 90       	pop	r15
    3d1e:	ef 90       	pop	r14
    3d20:	08 95       	ret

00003d22 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3d22:	1f 92       	push	r1
    3d24:	0f 92       	push	r0
    3d26:	0f b6       	in	r0, 0x3f	; 63
    3d28:	0f 92       	push	r0
    3d2a:	11 24       	eor	r1, r1
    3d2c:	08 b6       	in	r0, 0x38	; 56
    3d2e:	0f 92       	push	r0
    3d30:	18 be       	out	0x38, r1	; 56
    3d32:	0b b6       	in	r0, 0x3b	; 59
    3d34:	0f 92       	push	r0
    3d36:	1b be       	out	0x3b, r1	; 59
    3d38:	2f 93       	push	r18
    3d3a:	3f 93       	push	r19
    3d3c:	8f 93       	push	r24
    3d3e:	9f 93       	push	r25
    3d40:	ef 93       	push	r30
    3d42:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3d44:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3d48:	e0 91 38 31 	lds	r30, 0x3138	; 0x803138 <rcvC0_buffer>
    3d4c:	f0 91 39 31 	lds	r31, 0x3139	; 0x803139 <rcvC0_buffer+0x1>
    3d50:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvC0_write_index>
    3d54:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvC0_write_index+0x1>
    3d58:	e8 0f       	add	r30, r24
    3d5a:	f9 1f       	adc	r31, r25
    3d5c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3d5e:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvC0_write_index>
    3d62:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvC0_write_index+0x1>
    3d66:	01 96       	adiw	r24, 0x01	; 1
    3d68:	84 36       	cpi	r24, 0x64	; 100
    3d6a:	91 05       	cpc	r25, r1
    3d6c:	60 f4       	brcc	.+24     	; 0x3d86 <__vector_25+0x64>
    3d6e:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <rcvC0_write_index>
    3d72:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3d76:	20 91 2e 31 	lds	r18, 0x312E	; 0x80312e <rcvC0_read_index>
    3d7a:	30 91 2f 31 	lds	r19, 0x312F	; 0x80312f <rcvC0_read_index+0x1>
    3d7e:	82 17       	cp	r24, r18
    3d80:	93 07       	cpc	r25, r19
    3d82:	f1 f4       	brne	.+60     	; 0x3dc0 <__vector_25+0x9e>
    3d84:	0c c0       	rjmp	.+24     	; 0x3d9e <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3d86:	10 92 24 31 	sts	0x3124, r1	; 0x803124 <rcvC0_write_index>
    3d8a:	10 92 25 31 	sts	0x3125, r1	; 0x803125 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3d8e:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC0_read_index>
    3d92:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC0_read_index+0x1>
    3d96:	18 16       	cp	r1, r24
    3d98:	19 06       	cpc	r1, r25
    3d9a:	91 f4       	brne	.+36     	; 0x3dc0 <__vector_25+0x9e>
    3d9c:	0e c0       	rjmp	.+28     	; 0x3dba <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3d9e:	01 96       	adiw	r24, 0x01	; 1
    3da0:	84 36       	cpi	r24, 0x64	; 100
    3da2:	91 05       	cpc	r25, r1
    3da4:	28 f4       	brcc	.+10     	; 0x3db0 <__vector_25+0x8e>
    3da6:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC0_read_index>
    3daa:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC0_read_index+0x1>
    3dae:	08 c0       	rjmp	.+16     	; 0x3dc0 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3db0:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC0_read_index>
    3db4:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC0_read_index+0x1>
}
    3db8:	03 c0       	rjmp	.+6      	; 0x3dc0 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3dba:	81 e0       	ldi	r24, 0x01	; 1
    3dbc:	90 e0       	ldi	r25, 0x00	; 0
    3dbe:	f3 cf       	rjmp	.-26     	; 0x3da6 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3dc0:	ff 91       	pop	r31
    3dc2:	ef 91       	pop	r30
    3dc4:	9f 91       	pop	r25
    3dc6:	8f 91       	pop	r24
    3dc8:	3f 91       	pop	r19
    3dca:	2f 91       	pop	r18
    3dcc:	0f 90       	pop	r0
    3dce:	0b be       	out	0x3b, r0	; 59
    3dd0:	0f 90       	pop	r0
    3dd2:	08 be       	out	0x38, r0	; 56
    3dd4:	0f 90       	pop	r0
    3dd6:	0f be       	out	0x3f, r0	; 63
    3dd8:	0f 90       	pop	r0
    3dda:	1f 90       	pop	r1
    3ddc:	18 95       	reti

00003dde <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3dde:	1f 92       	push	r1
    3de0:	0f 92       	push	r0
    3de2:	0f b6       	in	r0, 0x3f	; 63
    3de4:	0f 92       	push	r0
    3de6:	11 24       	eor	r1, r1
    3de8:	08 b6       	in	r0, 0x38	; 56
    3dea:	0f 92       	push	r0
    3dec:	18 be       	out	0x38, r1	; 56
    3dee:	0b b6       	in	r0, 0x3b	; 59
    3df0:	0f 92       	push	r0
    3df2:	1b be       	out	0x3b, r1	; 59
    3df4:	2f 93       	push	r18
    3df6:	3f 93       	push	r19
    3df8:	8f 93       	push	r24
    3dfa:	9f 93       	push	r25
    3dfc:	ef 93       	push	r30
    3dfe:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3e00:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3e04:	e0 91 36 31 	lds	r30, 0x3136	; 0x803136 <rcvC1_buffer>
    3e08:	f0 91 37 31 	lds	r31, 0x3137	; 0x803137 <rcvC1_buffer+0x1>
    3e0c:	80 91 22 31 	lds	r24, 0x3122	; 0x803122 <rcvC1_write_index>
    3e10:	90 91 23 31 	lds	r25, 0x3123	; 0x803123 <rcvC1_write_index+0x1>
    3e14:	e8 0f       	add	r30, r24
    3e16:	f9 1f       	adc	r31, r25
    3e18:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3e1a:	80 91 22 31 	lds	r24, 0x3122	; 0x803122 <rcvC1_write_index>
    3e1e:	90 91 23 31 	lds	r25, 0x3123	; 0x803123 <rcvC1_write_index+0x1>
    3e22:	01 96       	adiw	r24, 0x01	; 1
    3e24:	84 36       	cpi	r24, 0x64	; 100
    3e26:	91 05       	cpc	r25, r1
    3e28:	60 f4       	brcc	.+24     	; 0x3e42 <__vector_28+0x64>
    3e2a:	80 93 22 31 	sts	0x3122, r24	; 0x803122 <rcvC1_write_index>
    3e2e:	90 93 23 31 	sts	0x3123, r25	; 0x803123 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3e32:	20 91 2c 31 	lds	r18, 0x312C	; 0x80312c <rcvC1_read_index>
    3e36:	30 91 2d 31 	lds	r19, 0x312D	; 0x80312d <rcvC1_read_index+0x1>
    3e3a:	82 17       	cp	r24, r18
    3e3c:	93 07       	cpc	r25, r19
    3e3e:	f1 f4       	brne	.+60     	; 0x3e7c <__vector_28+0x9e>
    3e40:	0c c0       	rjmp	.+24     	; 0x3e5a <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3e42:	10 92 22 31 	sts	0x3122, r1	; 0x803122 <rcvC1_write_index>
    3e46:	10 92 23 31 	sts	0x3123, r1	; 0x803123 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3e4a:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvC1_read_index>
    3e4e:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvC1_read_index+0x1>
    3e52:	18 16       	cp	r1, r24
    3e54:	19 06       	cpc	r1, r25
    3e56:	91 f4       	brne	.+36     	; 0x3e7c <__vector_28+0x9e>
    3e58:	0e c0       	rjmp	.+28     	; 0x3e76 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3e5a:	01 96       	adiw	r24, 0x01	; 1
    3e5c:	84 36       	cpi	r24, 0x64	; 100
    3e5e:	91 05       	cpc	r25, r1
    3e60:	28 f4       	brcc	.+10     	; 0x3e6c <__vector_28+0x8e>
    3e62:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvC1_read_index>
    3e66:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvC1_read_index+0x1>
    3e6a:	08 c0       	rjmp	.+16     	; 0x3e7c <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3e6c:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvC1_read_index>
    3e70:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvC1_read_index+0x1>
}
    3e74:	03 c0       	rjmp	.+6      	; 0x3e7c <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3e76:	81 e0       	ldi	r24, 0x01	; 1
    3e78:	90 e0       	ldi	r25, 0x00	; 0
    3e7a:	f3 cf       	rjmp	.-26     	; 0x3e62 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3e7c:	ff 91       	pop	r31
    3e7e:	ef 91       	pop	r30
    3e80:	9f 91       	pop	r25
    3e82:	8f 91       	pop	r24
    3e84:	3f 91       	pop	r19
    3e86:	2f 91       	pop	r18
    3e88:	0f 90       	pop	r0
    3e8a:	0b be       	out	0x3b, r0	; 59
    3e8c:	0f 90       	pop	r0
    3e8e:	08 be       	out	0x38, r0	; 56
    3e90:	0f 90       	pop	r0
    3e92:	0f be       	out	0x3f, r0	; 63
    3e94:	0f 90       	pop	r0
    3e96:	1f 90       	pop	r1
    3e98:	18 95       	reti

00003e9a <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3e9a:	1f 92       	push	r1
    3e9c:	0f 92       	push	r0
    3e9e:	0f b6       	in	r0, 0x3f	; 63
    3ea0:	0f 92       	push	r0
    3ea2:	11 24       	eor	r1, r1
    3ea4:	08 b6       	in	r0, 0x38	; 56
    3ea6:	0f 92       	push	r0
    3ea8:	18 be       	out	0x38, r1	; 56
    3eaa:	0b b6       	in	r0, 0x3b	; 59
    3eac:	0f 92       	push	r0
    3eae:	1b be       	out	0x3b, r1	; 59
    3eb0:	2f 93       	push	r18
    3eb2:	3f 93       	push	r19
    3eb4:	8f 93       	push	r24
    3eb6:	9f 93       	push	r25
    3eb8:	ef 93       	push	r30
    3eba:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3ebc:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3ec0:	e0 91 34 31 	lds	r30, 0x3134	; 0x803134 <rcvD0_buffer>
    3ec4:	f0 91 35 31 	lds	r31, 0x3135	; 0x803135 <rcvD0_buffer+0x1>
    3ec8:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <rcvC0_write_index>
    3ecc:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <rcvC0_write_index+0x1>
    3ed0:	e8 0f       	add	r30, r24
    3ed2:	f9 1f       	adc	r31, r25
    3ed4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3ed6:	80 91 20 31 	lds	r24, 0x3120	; 0x803120 <rcvD0_write_index>
    3eda:	90 91 21 31 	lds	r25, 0x3121	; 0x803121 <rcvD0_write_index+0x1>
    3ede:	01 96       	adiw	r24, 0x01	; 1
    3ee0:	84 36       	cpi	r24, 0x64	; 100
    3ee2:	91 05       	cpc	r25, r1
    3ee4:	60 f4       	brcc	.+24     	; 0x3efe <__vector_88+0x64>
    3ee6:	80 93 20 31 	sts	0x3120, r24	; 0x803120 <rcvD0_write_index>
    3eea:	90 93 21 31 	sts	0x3121, r25	; 0x803121 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3eee:	20 91 2a 31 	lds	r18, 0x312A	; 0x80312a <rcvD0_read_index>
    3ef2:	30 91 2b 31 	lds	r19, 0x312B	; 0x80312b <rcvD0_read_index+0x1>
    3ef6:	82 17       	cp	r24, r18
    3ef8:	93 07       	cpc	r25, r19
    3efa:	f1 f4       	brne	.+60     	; 0x3f38 <__vector_88+0x9e>
    3efc:	0c c0       	rjmp	.+24     	; 0x3f16 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3efe:	10 92 20 31 	sts	0x3120, r1	; 0x803120 <rcvD0_write_index>
    3f02:	10 92 21 31 	sts	0x3121, r1	; 0x803121 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3f06:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD0_read_index>
    3f0a:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD0_read_index+0x1>
    3f0e:	18 16       	cp	r1, r24
    3f10:	19 06       	cpc	r1, r25
    3f12:	91 f4       	brne	.+36     	; 0x3f38 <__vector_88+0x9e>
    3f14:	0e c0       	rjmp	.+28     	; 0x3f32 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3f16:	01 96       	adiw	r24, 0x01	; 1
    3f18:	84 36       	cpi	r24, 0x64	; 100
    3f1a:	91 05       	cpc	r25, r1
    3f1c:	28 f4       	brcc	.+10     	; 0x3f28 <__vector_88+0x8e>
    3f1e:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD0_read_index>
    3f22:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD0_read_index+0x1>
    3f26:	08 c0       	rjmp	.+16     	; 0x3f38 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3f28:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD0_read_index>
    3f2c:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD0_read_index+0x1>
}
    3f30:	03 c0       	rjmp	.+6      	; 0x3f38 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3f32:	81 e0       	ldi	r24, 0x01	; 1
    3f34:	90 e0       	ldi	r25, 0x00	; 0
    3f36:	f3 cf       	rjmp	.-26     	; 0x3f1e <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3f38:	ff 91       	pop	r31
    3f3a:	ef 91       	pop	r30
    3f3c:	9f 91       	pop	r25
    3f3e:	8f 91       	pop	r24
    3f40:	3f 91       	pop	r19
    3f42:	2f 91       	pop	r18
    3f44:	0f 90       	pop	r0
    3f46:	0b be       	out	0x3b, r0	; 59
    3f48:	0f 90       	pop	r0
    3f4a:	08 be       	out	0x38, r0	; 56
    3f4c:	0f 90       	pop	r0
    3f4e:	0f be       	out	0x3f, r0	; 63
    3f50:	0f 90       	pop	r0
    3f52:	1f 90       	pop	r1
    3f54:	18 95       	reti

00003f56 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3f56:	1f 92       	push	r1
    3f58:	0f 92       	push	r0
    3f5a:	0f b6       	in	r0, 0x3f	; 63
    3f5c:	0f 92       	push	r0
    3f5e:	11 24       	eor	r1, r1
    3f60:	08 b6       	in	r0, 0x38	; 56
    3f62:	0f 92       	push	r0
    3f64:	18 be       	out	0x38, r1	; 56
    3f66:	0b b6       	in	r0, 0x3b	; 59
    3f68:	0f 92       	push	r0
    3f6a:	1b be       	out	0x3b, r1	; 59
    3f6c:	2f 93       	push	r18
    3f6e:	3f 93       	push	r19
    3f70:	8f 93       	push	r24
    3f72:	9f 93       	push	r25
    3f74:	ef 93       	push	r30
    3f76:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3f78:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3f7c:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <rcvD1_buffer>
    3f80:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <rcvD1_buffer+0x1>
    3f84:	80 91 1e 31 	lds	r24, 0x311E	; 0x80311e <rcvD1_write_index>
    3f88:	90 91 1f 31 	lds	r25, 0x311F	; 0x80311f <rcvD1_write_index+0x1>
    3f8c:	e8 0f       	add	r30, r24
    3f8e:	f9 1f       	adc	r31, r25
    3f90:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3f92:	80 91 1e 31 	lds	r24, 0x311E	; 0x80311e <rcvD1_write_index>
    3f96:	90 91 1f 31 	lds	r25, 0x311F	; 0x80311f <rcvD1_write_index+0x1>
    3f9a:	01 96       	adiw	r24, 0x01	; 1
    3f9c:	84 36       	cpi	r24, 0x64	; 100
    3f9e:	91 05       	cpc	r25, r1
    3fa0:	60 f4       	brcc	.+24     	; 0x3fba <__vector_91+0x64>
    3fa2:	80 93 1e 31 	sts	0x311E, r24	; 0x80311e <rcvD1_write_index>
    3fa6:	90 93 1f 31 	sts	0x311F, r25	; 0x80311f <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3faa:	20 91 28 31 	lds	r18, 0x3128	; 0x803128 <rcvD1_read_index>
    3fae:	30 91 29 31 	lds	r19, 0x3129	; 0x803129 <rcvD1_read_index+0x1>
    3fb2:	82 17       	cp	r24, r18
    3fb4:	93 07       	cpc	r25, r19
    3fb6:	f1 f4       	brne	.+60     	; 0x3ff4 <__vector_91+0x9e>
    3fb8:	0c c0       	rjmp	.+24     	; 0x3fd2 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3fba:	10 92 1e 31 	sts	0x311E, r1	; 0x80311e <rcvD1_write_index>
    3fbe:	10 92 1f 31 	sts	0x311F, r1	; 0x80311f <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3fc2:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvD1_read_index>
    3fc6:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvD1_read_index+0x1>
    3fca:	18 16       	cp	r1, r24
    3fcc:	19 06       	cpc	r1, r25
    3fce:	91 f4       	brne	.+36     	; 0x3ff4 <__vector_91+0x9e>
    3fd0:	0e c0       	rjmp	.+28     	; 0x3fee <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3fd2:	01 96       	adiw	r24, 0x01	; 1
    3fd4:	84 36       	cpi	r24, 0x64	; 100
    3fd6:	91 05       	cpc	r25, r1
    3fd8:	28 f4       	brcc	.+10     	; 0x3fe4 <__vector_91+0x8e>
    3fda:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvD1_read_index>
    3fde:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvD1_read_index+0x1>
    3fe2:	08 c0       	rjmp	.+16     	; 0x3ff4 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3fe4:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvD1_read_index>
    3fe8:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvD1_read_index+0x1>
}
    3fec:	03 c0       	rjmp	.+6      	; 0x3ff4 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3fee:	81 e0       	ldi	r24, 0x01	; 1
    3ff0:	90 e0       	ldi	r25, 0x00	; 0
    3ff2:	f3 cf       	rjmp	.-26     	; 0x3fda <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3ff4:	ff 91       	pop	r31
    3ff6:	ef 91       	pop	r30
    3ff8:	9f 91       	pop	r25
    3ffa:	8f 91       	pop	r24
    3ffc:	3f 91       	pop	r19
    3ffe:	2f 91       	pop	r18
    4000:	0f 90       	pop	r0
    4002:	0b be       	out	0x3b, r0	; 59
    4004:	0f 90       	pop	r0
    4006:	08 be       	out	0x38, r0	; 56
    4008:	0f 90       	pop	r0
    400a:	0f be       	out	0x3f, r0	; 63
    400c:	0f 90       	pop	r0
    400e:	1f 90       	pop	r1
    4010:	18 95       	reti

00004012 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    4012:	1f 92       	push	r1
    4014:	0f 92       	push	r0
    4016:	0f b6       	in	r0, 0x3f	; 63
    4018:	0f 92       	push	r0
    401a:	11 24       	eor	r1, r1
    401c:	08 b6       	in	r0, 0x38	; 56
    401e:	0f 92       	push	r0
    4020:	18 be       	out	0x38, r1	; 56
    4022:	0b b6       	in	r0, 0x3b	; 59
    4024:	0f 92       	push	r0
    4026:	1b be       	out	0x3b, r1	; 59
    4028:	2f 93       	push	r18
    402a:	3f 93       	push	r19
    402c:	8f 93       	push	r24
    402e:	9f 93       	push	r25
    4030:	ef 93       	push	r30
    4032:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    4034:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    4038:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <rcvE0_buffer>
    403c:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <rcvE0_buffer+0x1>
    4040:	80 91 1c 31 	lds	r24, 0x311C	; 0x80311c <rcvE0_write_index>
    4044:	90 91 1d 31 	lds	r25, 0x311D	; 0x80311d <rcvE0_write_index+0x1>
    4048:	e8 0f       	add	r30, r24
    404a:	f9 1f       	adc	r31, r25
    404c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    404e:	80 91 1c 31 	lds	r24, 0x311C	; 0x80311c <rcvE0_write_index>
    4052:	90 91 1d 31 	lds	r25, 0x311D	; 0x80311d <rcvE0_write_index+0x1>
    4056:	01 96       	adiw	r24, 0x01	; 1
    4058:	84 36       	cpi	r24, 0x64	; 100
    405a:	91 05       	cpc	r25, r1
    405c:	60 f4       	brcc	.+24     	; 0x4076 <__vector_58+0x64>
    405e:	80 93 1c 31 	sts	0x311C, r24	; 0x80311c <rcvE0_write_index>
    4062:	90 93 1d 31 	sts	0x311D, r25	; 0x80311d <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4066:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <rcvE0_read_index>
    406a:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <rcvE0_read_index+0x1>
    406e:	82 17       	cp	r24, r18
    4070:	93 07       	cpc	r25, r19
    4072:	f1 f4       	brne	.+60     	; 0x40b0 <__vector_58+0x9e>
    4074:	0c c0       	rjmp	.+24     	; 0x408e <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    4076:	10 92 1c 31 	sts	0x311C, r1	; 0x80311c <rcvE0_write_index>
    407a:	10 92 1d 31 	sts	0x311D, r1	; 0x80311d <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    407e:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <rcvE0_read_index>
    4082:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <rcvE0_read_index+0x1>
    4086:	18 16       	cp	r1, r24
    4088:	19 06       	cpc	r1, r25
    408a:	91 f4       	brne	.+36     	; 0x40b0 <__vector_58+0x9e>
    408c:	0e c0       	rjmp	.+28     	; 0x40aa <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    408e:	01 96       	adiw	r24, 0x01	; 1
    4090:	84 36       	cpi	r24, 0x64	; 100
    4092:	91 05       	cpc	r25, r1
    4094:	28 f4       	brcc	.+10     	; 0x40a0 <__vector_58+0x8e>
    4096:	80 93 26 31 	sts	0x3126, r24	; 0x803126 <rcvE0_read_index>
    409a:	90 93 27 31 	sts	0x3127, r25	; 0x803127 <rcvE0_read_index+0x1>
    409e:	08 c0       	rjmp	.+16     	; 0x40b0 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    40a0:	10 92 26 31 	sts	0x3126, r1	; 0x803126 <rcvE0_read_index>
    40a4:	10 92 27 31 	sts	0x3127, r1	; 0x803127 <rcvE0_read_index+0x1>
}
    40a8:	03 c0       	rjmp	.+6      	; 0x40b0 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    40aa:	81 e0       	ldi	r24, 0x01	; 1
    40ac:	90 e0       	ldi	r25, 0x00	; 0
    40ae:	f3 cf       	rjmp	.-26     	; 0x4096 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    40b0:	ff 91       	pop	r31
    40b2:	ef 91       	pop	r30
    40b4:	9f 91       	pop	r25
    40b6:	8f 91       	pop	r24
    40b8:	3f 91       	pop	r19
    40ba:	2f 91       	pop	r18
    40bc:	0f 90       	pop	r0
    40be:	0b be       	out	0x3b, r0	; 59
    40c0:	0f 90       	pop	r0
    40c2:	08 be       	out	0x38, r0	; 56
    40c4:	0f 90       	pop	r0
    40c6:	0f be       	out	0x3f, r0	; 63
    40c8:	0f 90       	pop	r0
    40ca:	1f 90       	pop	r1
    40cc:	18 95       	reti

000040ce <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    40ce:	0f 93       	push	r16
    40d0:	cf 93       	push	r28
    40d2:	df 93       	push	r29
    40d4:	1f 92       	push	r1
    40d6:	cd b7       	in	r28, 0x3d	; 61
    40d8:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    40da:	2f b7       	in	r18, 0x3f	; 63
    40dc:	29 83       	std	Y+1, r18	; 0x01
	cli();
    40de:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    40e0:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    40e2:	fc 01       	movw	r30, r24
    40e4:	08 ed       	ldi	r16, 0xD8	; 216
    40e6:	04 bf       	out	0x34, r16	; 52
    40e8:	60 83       	st	Z, r22

	SREG = saved_sreg;
    40ea:	89 81       	ldd	r24, Y+1	; 0x01
    40ec:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    40ee:	0f 90       	pop	r0
    40f0:	df 91       	pop	r29
    40f2:	cf 91       	pop	r28
    40f4:	0f 91       	pop	r16
    40f6:	08 95       	ret

000040f8 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    40f8:	0f 93       	push	r16
    40fa:	1f 93       	push	r17
    40fc:	cf 93       	push	r28
    40fe:	df 93       	push	r29
    4100:	cd b7       	in	r28, 0x3d	; 61
    4102:	de b7       	in	r29, 0x3e	; 62
    4104:	6d 97       	sbiw	r28, 0x1d	; 29
    4106:	cd bf       	out	0x3d, r28	; 61
    4108:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    410a:	e0 e6       	ldi	r30, 0x60	; 96
    410c:	f6 e0       	ldi	r31, 0x06	; 6
    410e:	80 e4       	ldi	r24, 0x40	; 64
    4110:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    4112:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    4114:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    4116:	e0 e5       	ldi	r30, 0x50	; 80
    4118:	f0 e0       	ldi	r31, 0x00	; 0
    411a:	80 81       	ld	r24, Z
    411c:	82 60       	ori	r24, 0x02	; 2
    411e:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    4120:	81 81       	ldd	r24, Z+1	; 0x01
    4122:	81 ff       	sbrs	r24, 1
    4124:	fd cf       	rjmp	.-6      	; 0x4120 <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    4126:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    412a:	68 7f       	andi	r22, 0xF8	; 248
    412c:	61 60       	ori	r22, 0x01	; 1
    412e:	80 e4       	ldi	r24, 0x40	; 64
    4130:	90 e0       	ldi	r25, 0x00	; 0
    4132:	0e 94 67 20 	call	0x40ce	; 0x40ce <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    4136:	e0 e5       	ldi	r30, 0x50	; 80
    4138:	f0 e0       	ldi	r31, 0x00	; 0
    413a:	80 81       	ld	r24, Z
    413c:	8e 7f       	andi	r24, 0xFE	; 254
    413e:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    4140:	9d ef       	ldi	r25, 0xFD	; 253
    4142:	88 ed       	ldi	r24, 0xD8	; 216
    4144:	08 b6       	in	r0, 0x38	; 56
    4146:	18 be       	out	0x38, r1	; 56
    4148:	84 bf       	out	0x34, r24	; 52
    414a:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    414e:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    4150:	40 eb       	ldi	r20, 0xB0	; 176
    4152:	58 e0       	ldi	r21, 0x08	; 8
    4154:	60 e0       	ldi	r22, 0x00	; 0
    4156:	70 e0       	ldi	r23, 0x00	; 0
    4158:	ce 01       	movw	r24, r28
    415a:	01 96       	adiw	r24, 0x01	; 1
    415c:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    4160:	67 e0       	ldi	r22, 0x07	; 7
    4162:	ce 01       	movw	r24, r28
    4164:	01 96       	adiw	r24, 0x01	; 1
    4166:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    416a:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    416c:	6b e6       	ldi	r22, 0x6B	; 107
    416e:	70 e2       	ldi	r23, 0x20	; 32
    4170:	0e 94 37 1c 	call	0x386e	; 0x386e <_ZN8emstream4putsEPKc>
    4174:	66 e0       	ldi	r22, 0x06	; 6
    4176:	c8 01       	movw	r24, r16
    4178:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
    417c:	66 e0       	ldi	r22, 0x06	; 6
    417e:	0e 94 6e 1c 	call	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    4182:	82 e1       	ldi	r24, 0x12	; 18
    4184:	90 e0       	ldi	r25, 0x00	; 0
    4186:	0e 94 83 1b 	call	0x3706	; 0x3706 <_Znwj>
    418a:	8e 01       	movw	r16, r28
    418c:	0f 5f       	subi	r16, 0xFF	; 255
    418e:	1f 4f       	sbci	r17, 0xFF	; 255
    4190:	24 e0       	ldi	r18, 0x04	; 4
    4192:	31 e0       	ldi	r19, 0x01	; 1
    4194:	40 e0       	ldi	r20, 0x00	; 0
    4196:	6a e8       	ldi	r22, 0x8A	; 138
    4198:	70 e2       	ldi	r23, 0x20	; 32
    419a:	0e 94 b3 08 	call	0x1166	; 0x1166 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    419e:	82 e1       	ldi	r24, 0x12	; 18
    41a0:	90 e0       	ldi	r25, 0x00	; 0
    41a2:	0e 94 83 1b 	call	0x3706	; 0x3706 <_Znwj>
    41a6:	24 e0       	ldi	r18, 0x04	; 4
    41a8:	31 e0       	ldi	r19, 0x01	; 1
    41aa:	42 e0       	ldi	r20, 0x02	; 2
    41ac:	62 e9       	ldi	r22, 0x92	; 146
    41ae:	70 e2       	ldi	r23, 0x20	; 32
    41b0:	0e 94 4b 04 	call	0x896	; 0x896 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    41b4:	82 e1       	ldi	r24, 0x12	; 18
    41b6:	90 e0       	ldi	r25, 0x00	; 0
    41b8:	0e 94 83 1b 	call	0x3706	; 0x3706 <_Znwj>
    41bc:	24 e0       	ldi	r18, 0x04	; 4
    41be:	31 e0       	ldi	r19, 0x01	; 1
    41c0:	43 e0       	ldi	r20, 0x03	; 3
    41c2:	69 e9       	ldi	r22, 0x99	; 153
    41c4:	70 e2       	ldi	r23, 0x20	; 32
    41c6:	0e 94 a4 04 	call	0x948	; 0x948 <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    41ca:	82 e1       	ldi	r24, 0x12	; 18
    41cc:	90 e0       	ldi	r25, 0x00	; 0
    41ce:	0e 94 83 1b 	call	0x3706	; 0x3706 <_Znwj>
    41d2:	24 e0       	ldi	r18, 0x04	; 4
    41d4:	31 e0       	ldi	r19, 0x01	; 1
    41d6:	44 e0       	ldi	r20, 0x04	; 4
    41d8:	60 ea       	ldi	r22, 0xA0	; 160
    41da:	70 e2       	ldi	r23, 0x20	; 32
    41dc:	0e 94 09 05 	call	0xa12	; 0xa12 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    41e0:	8c e6       	ldi	r24, 0x6C	; 108
    41e2:	90 e0       	ldi	r25, 0x00	; 0
    41e4:	0e 94 83 1b 	call	0x3706	; 0x3706 <_Znwj>
    41e8:	24 e0       	ldi	r18, 0x04	; 4
    41ea:	31 e0       	ldi	r19, 0x01	; 1
    41ec:	43 e0       	ldi	r20, 0x03	; 3
    41ee:	69 ea       	ldi	r22, 0xA9	; 169
    41f0:	70 e2       	ldi	r23, 0x20	; 32
    41f2:	0e 94 75 08 	call	0x10ea	; 0x10ea <_ZN5MotorC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    41f6:	87 e0       	ldi	r24, 0x07	; 7
    41f8:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    41fc:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    41fe:	0e 94 95 12 	call	0x252a	; 0x252a <vTaskStartScheduler>
	
	
	return 0;
    4202:	80 e0       	ldi	r24, 0x00	; 0
    4204:	90 e0       	ldi	r25, 0x00	; 0
    4206:	6d 96       	adiw	r28, 0x1d	; 29
    4208:	cd bf       	out	0x3d, r28	; 61
    420a:	de bf       	out	0x3e, r29	; 62
    420c:	df 91       	pop	r29
    420e:	cf 91       	pop	r28
    4210:	1f 91       	pop	r17
    4212:	0f 91       	pop	r16
    4214:	08 95       	ret

00004216 <_GLOBAL__sub_I_counter>:
    4216:	0f 93       	push	r16
    4218:	1f 93       	push	r17
#include "Motor.h"							// Inverted Pendulum file
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    421a:	0a e0       	ldi	r16, 0x0A	; 10
    421c:	10 e0       	ldi	r17, 0x00	; 0
    421e:	20 e0       	ldi	r18, 0x00	; 0
    4220:	30 e0       	ldi	r19, 0x00	; 0
    4222:	40 e0       	ldi	r20, 0x00	; 0
    4224:	50 e0       	ldi	r21, 0x00	; 0
    4226:	60 e2       	ldi	r22, 0x20	; 32
    4228:	70 e0       	ldi	r23, 0x00	; 0
    422a:	88 e4       	ldi	r24, 0x48	; 72
    422c:	91 e3       	ldi	r25, 0x31	; 49
    422e:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    4232:	1f 91       	pop	r17
    4234:	0f 91       	pop	r16
    4236:	08 95       	ret

00004238 <__cmpsf2>:
    4238:	0e 94 5e 21 	call	0x42bc	; 0x42bc <__fp_cmp>
    423c:	08 f4       	brcc	.+2      	; 0x4240 <__cmpsf2+0x8>
    423e:	81 e0       	ldi	r24, 0x01	; 1
    4240:	08 95       	ret

00004242 <__floatunsisf>:
    4242:	e8 94       	clt
    4244:	09 c0       	rjmp	.+18     	; 0x4258 <__floatsisf+0x12>

00004246 <__floatsisf>:
    4246:	97 fb       	bst	r25, 7
    4248:	3e f4       	brtc	.+14     	; 0x4258 <__floatsisf+0x12>
    424a:	90 95       	com	r25
    424c:	80 95       	com	r24
    424e:	70 95       	com	r23
    4250:	61 95       	neg	r22
    4252:	7f 4f       	sbci	r23, 0xFF	; 255
    4254:	8f 4f       	sbci	r24, 0xFF	; 255
    4256:	9f 4f       	sbci	r25, 0xFF	; 255
    4258:	99 23       	and	r25, r25
    425a:	a9 f0       	breq	.+42     	; 0x4286 <__floatsisf+0x40>
    425c:	f9 2f       	mov	r31, r25
    425e:	96 e9       	ldi	r25, 0x96	; 150
    4260:	bb 27       	eor	r27, r27
    4262:	93 95       	inc	r25
    4264:	f6 95       	lsr	r31
    4266:	87 95       	ror	r24
    4268:	77 95       	ror	r23
    426a:	67 95       	ror	r22
    426c:	b7 95       	ror	r27
    426e:	f1 11       	cpse	r31, r1
    4270:	f8 cf       	rjmp	.-16     	; 0x4262 <__floatsisf+0x1c>
    4272:	fa f4       	brpl	.+62     	; 0x42b2 <__floatsisf+0x6c>
    4274:	bb 0f       	add	r27, r27
    4276:	11 f4       	brne	.+4      	; 0x427c <__floatsisf+0x36>
    4278:	60 ff       	sbrs	r22, 0
    427a:	1b c0       	rjmp	.+54     	; 0x42b2 <__floatsisf+0x6c>
    427c:	6f 5f       	subi	r22, 0xFF	; 255
    427e:	7f 4f       	sbci	r23, 0xFF	; 255
    4280:	8f 4f       	sbci	r24, 0xFF	; 255
    4282:	9f 4f       	sbci	r25, 0xFF	; 255
    4284:	16 c0       	rjmp	.+44     	; 0x42b2 <__floatsisf+0x6c>
    4286:	88 23       	and	r24, r24
    4288:	11 f0       	breq	.+4      	; 0x428e <__floatsisf+0x48>
    428a:	96 e9       	ldi	r25, 0x96	; 150
    428c:	11 c0       	rjmp	.+34     	; 0x42b0 <__floatsisf+0x6a>
    428e:	77 23       	and	r23, r23
    4290:	21 f0       	breq	.+8      	; 0x429a <__floatsisf+0x54>
    4292:	9e e8       	ldi	r25, 0x8E	; 142
    4294:	87 2f       	mov	r24, r23
    4296:	76 2f       	mov	r23, r22
    4298:	05 c0       	rjmp	.+10     	; 0x42a4 <__floatsisf+0x5e>
    429a:	66 23       	and	r22, r22
    429c:	71 f0       	breq	.+28     	; 0x42ba <__floatsisf+0x74>
    429e:	96 e8       	ldi	r25, 0x86	; 134
    42a0:	86 2f       	mov	r24, r22
    42a2:	70 e0       	ldi	r23, 0x00	; 0
    42a4:	60 e0       	ldi	r22, 0x00	; 0
    42a6:	2a f0       	brmi	.+10     	; 0x42b2 <__floatsisf+0x6c>
    42a8:	9a 95       	dec	r25
    42aa:	66 0f       	add	r22, r22
    42ac:	77 1f       	adc	r23, r23
    42ae:	88 1f       	adc	r24, r24
    42b0:	da f7       	brpl	.-10     	; 0x42a8 <__floatsisf+0x62>
    42b2:	88 0f       	add	r24, r24
    42b4:	96 95       	lsr	r25
    42b6:	87 95       	ror	r24
    42b8:	97 f9       	bld	r25, 7
    42ba:	08 95       	ret

000042bc <__fp_cmp>:
    42bc:	99 0f       	add	r25, r25
    42be:	00 08       	sbc	r0, r0
    42c0:	55 0f       	add	r21, r21
    42c2:	aa 0b       	sbc	r26, r26
    42c4:	e0 e8       	ldi	r30, 0x80	; 128
    42c6:	fe ef       	ldi	r31, 0xFE	; 254
    42c8:	16 16       	cp	r1, r22
    42ca:	17 06       	cpc	r1, r23
    42cc:	e8 07       	cpc	r30, r24
    42ce:	f9 07       	cpc	r31, r25
    42d0:	c0 f0       	brcs	.+48     	; 0x4302 <__fp_cmp+0x46>
    42d2:	12 16       	cp	r1, r18
    42d4:	13 06       	cpc	r1, r19
    42d6:	e4 07       	cpc	r30, r20
    42d8:	f5 07       	cpc	r31, r21
    42da:	98 f0       	brcs	.+38     	; 0x4302 <__fp_cmp+0x46>
    42dc:	62 1b       	sub	r22, r18
    42de:	73 0b       	sbc	r23, r19
    42e0:	84 0b       	sbc	r24, r20
    42e2:	95 0b       	sbc	r25, r21
    42e4:	39 f4       	brne	.+14     	; 0x42f4 <__fp_cmp+0x38>
    42e6:	0a 26       	eor	r0, r26
    42e8:	61 f0       	breq	.+24     	; 0x4302 <__fp_cmp+0x46>
    42ea:	23 2b       	or	r18, r19
    42ec:	24 2b       	or	r18, r20
    42ee:	25 2b       	or	r18, r21
    42f0:	21 f4       	brne	.+8      	; 0x42fa <__fp_cmp+0x3e>
    42f2:	08 95       	ret
    42f4:	0a 26       	eor	r0, r26
    42f6:	09 f4       	brne	.+2      	; 0x42fa <__fp_cmp+0x3e>
    42f8:	a1 40       	sbci	r26, 0x01	; 1
    42fa:	a6 95       	lsr	r26
    42fc:	8f ef       	ldi	r24, 0xFF	; 255
    42fe:	81 1d       	adc	r24, r1
    4300:	81 1d       	adc	r24, r1
    4302:	08 95       	ret

00004304 <__gesf2>:
    4304:	0e 94 5e 21 	call	0x42bc	; 0x42bc <__fp_cmp>
    4308:	08 f4       	brcc	.+2      	; 0x430c <__gesf2+0x8>
    430a:	8f ef       	ldi	r24, 0xFF	; 255
    430c:	08 95       	ret

0000430e <__mulsi3>:
    430e:	db 01       	movw	r26, r22
    4310:	8f 93       	push	r24
    4312:	9f 93       	push	r25
    4314:	0e 94 13 22 	call	0x4426	; 0x4426 <__muluhisi3>
    4318:	bf 91       	pop	r27
    431a:	af 91       	pop	r26
    431c:	a2 9f       	mul	r26, r18
    431e:	80 0d       	add	r24, r0
    4320:	91 1d       	adc	r25, r1
    4322:	a3 9f       	mul	r26, r19
    4324:	90 0d       	add	r25, r0
    4326:	b2 9f       	mul	r27, r18
    4328:	90 0d       	add	r25, r0
    432a:	11 24       	eor	r1, r1
    432c:	08 95       	ret

0000432e <__divmodhi4>:
    432e:	97 fb       	bst	r25, 7
    4330:	07 2e       	mov	r0, r23
    4332:	16 f4       	brtc	.+4      	; 0x4338 <__divmodhi4+0xa>
    4334:	00 94       	com	r0
    4336:	07 d0       	rcall	.+14     	; 0x4346 <__divmodhi4_neg1>
    4338:	77 fd       	sbrc	r23, 7
    433a:	09 d0       	rcall	.+18     	; 0x434e <__divmodhi4_neg2>
    433c:	0e 94 26 22 	call	0x444c	; 0x444c <__udivmodhi4>
    4340:	07 fc       	sbrc	r0, 7
    4342:	05 d0       	rcall	.+10     	; 0x434e <__divmodhi4_neg2>
    4344:	3e f4       	brtc	.+14     	; 0x4354 <__divmodhi4_exit>

00004346 <__divmodhi4_neg1>:
    4346:	90 95       	com	r25
    4348:	81 95       	neg	r24
    434a:	9f 4f       	sbci	r25, 0xFF	; 255
    434c:	08 95       	ret

0000434e <__divmodhi4_neg2>:
    434e:	70 95       	com	r23
    4350:	61 95       	neg	r22
    4352:	7f 4f       	sbci	r23, 0xFF	; 255

00004354 <__divmodhi4_exit>:
    4354:	08 95       	ret

00004356 <__udivmodsi4>:
    4356:	a1 e2       	ldi	r26, 0x21	; 33
    4358:	1a 2e       	mov	r1, r26
    435a:	aa 1b       	sub	r26, r26
    435c:	bb 1b       	sub	r27, r27
    435e:	fd 01       	movw	r30, r26
    4360:	0d c0       	rjmp	.+26     	; 0x437c <__udivmodsi4_ep>

00004362 <__udivmodsi4_loop>:
    4362:	aa 1f       	adc	r26, r26
    4364:	bb 1f       	adc	r27, r27
    4366:	ee 1f       	adc	r30, r30
    4368:	ff 1f       	adc	r31, r31
    436a:	a2 17       	cp	r26, r18
    436c:	b3 07       	cpc	r27, r19
    436e:	e4 07       	cpc	r30, r20
    4370:	f5 07       	cpc	r31, r21
    4372:	20 f0       	brcs	.+8      	; 0x437c <__udivmodsi4_ep>
    4374:	a2 1b       	sub	r26, r18
    4376:	b3 0b       	sbc	r27, r19
    4378:	e4 0b       	sbc	r30, r20
    437a:	f5 0b       	sbc	r31, r21

0000437c <__udivmodsi4_ep>:
    437c:	66 1f       	adc	r22, r22
    437e:	77 1f       	adc	r23, r23
    4380:	88 1f       	adc	r24, r24
    4382:	99 1f       	adc	r25, r25
    4384:	1a 94       	dec	r1
    4386:	69 f7       	brne	.-38     	; 0x4362 <__udivmodsi4_loop>
    4388:	60 95       	com	r22
    438a:	70 95       	com	r23
    438c:	80 95       	com	r24
    438e:	90 95       	com	r25
    4390:	9b 01       	movw	r18, r22
    4392:	ac 01       	movw	r20, r24
    4394:	bd 01       	movw	r22, r26
    4396:	cf 01       	movw	r24, r30
    4398:	08 95       	ret

0000439a <__divmodsi4>:
    439a:	05 2e       	mov	r0, r21
    439c:	97 fb       	bst	r25, 7
    439e:	1e f4       	brtc	.+6      	; 0x43a6 <__divmodsi4+0xc>
    43a0:	00 94       	com	r0
    43a2:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <__negsi2>
    43a6:	57 fd       	sbrc	r21, 7
    43a8:	07 d0       	rcall	.+14     	; 0x43b8 <__divmodsi4_neg2>
    43aa:	0e 94 ab 21 	call	0x4356	; 0x4356 <__udivmodsi4>
    43ae:	07 fc       	sbrc	r0, 7
    43b0:	03 d0       	rcall	.+6      	; 0x43b8 <__divmodsi4_neg2>
    43b2:	4e f4       	brtc	.+18     	; 0x43c6 <__divmodsi4_exit>
    43b4:	0c 94 e4 21 	jmp	0x43c8	; 0x43c8 <__negsi2>

000043b8 <__divmodsi4_neg2>:
    43b8:	50 95       	com	r21
    43ba:	40 95       	com	r20
    43bc:	30 95       	com	r19
    43be:	21 95       	neg	r18
    43c0:	3f 4f       	sbci	r19, 0xFF	; 255
    43c2:	4f 4f       	sbci	r20, 0xFF	; 255
    43c4:	5f 4f       	sbci	r21, 0xFF	; 255

000043c6 <__divmodsi4_exit>:
    43c6:	08 95       	ret

000043c8 <__negsi2>:
    43c8:	90 95       	com	r25
    43ca:	80 95       	com	r24
    43cc:	70 95       	com	r23
    43ce:	61 95       	neg	r22
    43d0:	7f 4f       	sbci	r23, 0xFF	; 255
    43d2:	8f 4f       	sbci	r24, 0xFF	; 255
    43d4:	9f 4f       	sbci	r25, 0xFF	; 255
    43d6:	08 95       	ret

000043d8 <__tablejump2__>:
    43d8:	ee 0f       	add	r30, r30
    43da:	ff 1f       	adc	r31, r31
    43dc:	88 1f       	adc	r24, r24
    43de:	8b bf       	out	0x3b, r24	; 59
    43e0:	07 90       	elpm	r0, Z+
    43e2:	f6 91       	elpm	r31, Z
    43e4:	e0 2d       	mov	r30, r0
    43e6:	1b be       	out	0x3b, r1	; 59
    43e8:	19 94       	eijmp

000043ea <__mulhisi3>:
    43ea:	0e 94 fd 21 	call	0x43fa	; 0x43fa <__umulhisi3>
    43ee:	33 23       	and	r19, r19
    43f0:	12 f4       	brpl	.+4      	; 0x43f6 <__mulhisi3+0xc>
    43f2:	8a 1b       	sub	r24, r26
    43f4:	9b 0b       	sbc	r25, r27
    43f6:	0c 94 0e 22 	jmp	0x441c	; 0x441c <__usmulhisi3_tail>

000043fa <__umulhisi3>:
    43fa:	a2 9f       	mul	r26, r18
    43fc:	b0 01       	movw	r22, r0
    43fe:	b3 9f       	mul	r27, r19
    4400:	c0 01       	movw	r24, r0
    4402:	a3 9f       	mul	r26, r19
    4404:	70 0d       	add	r23, r0
    4406:	81 1d       	adc	r24, r1
    4408:	11 24       	eor	r1, r1
    440a:	91 1d       	adc	r25, r1
    440c:	b2 9f       	mul	r27, r18
    440e:	70 0d       	add	r23, r0
    4410:	81 1d       	adc	r24, r1
    4412:	11 24       	eor	r1, r1
    4414:	91 1d       	adc	r25, r1
    4416:	08 95       	ret

00004418 <__usmulhisi3>:
    4418:	0e 94 fd 21 	call	0x43fa	; 0x43fa <__umulhisi3>

0000441c <__usmulhisi3_tail>:
    441c:	b7 ff       	sbrs	r27, 7
    441e:	08 95       	ret
    4420:	82 1b       	sub	r24, r18
    4422:	93 0b       	sbc	r25, r19
    4424:	08 95       	ret

00004426 <__muluhisi3>:
    4426:	0e 94 fd 21 	call	0x43fa	; 0x43fa <__umulhisi3>
    442a:	a5 9f       	mul	r26, r21
    442c:	90 0d       	add	r25, r0
    442e:	b4 9f       	mul	r27, r20
    4430:	90 0d       	add	r25, r0
    4432:	a4 9f       	mul	r26, r20
    4434:	80 0d       	add	r24, r0
    4436:	91 1d       	adc	r25, r1
    4438:	11 24       	eor	r1, r1
    443a:	08 95       	ret

0000443c <__mulshisi3>:
    443c:	b7 ff       	sbrs	r27, 7
    443e:	0c 94 13 22 	jmp	0x4426	; 0x4426 <__muluhisi3>

00004442 <__mulohisi3>:
    4442:	0e 94 13 22 	call	0x4426	; 0x4426 <__muluhisi3>
    4446:	82 1b       	sub	r24, r18
    4448:	93 0b       	sbc	r25, r19
    444a:	08 95       	ret

0000444c <__udivmodhi4>:
    444c:	aa 1b       	sub	r26, r26
    444e:	bb 1b       	sub	r27, r27
    4450:	51 e1       	ldi	r21, 0x11	; 17
    4452:	07 c0       	rjmp	.+14     	; 0x4462 <__udivmodhi4_ep>

00004454 <__udivmodhi4_loop>:
    4454:	aa 1f       	adc	r26, r26
    4456:	bb 1f       	adc	r27, r27
    4458:	a6 17       	cp	r26, r22
    445a:	b7 07       	cpc	r27, r23
    445c:	10 f0       	brcs	.+4      	; 0x4462 <__udivmodhi4_ep>
    445e:	a6 1b       	sub	r26, r22
    4460:	b7 0b       	sbc	r27, r23

00004462 <__udivmodhi4_ep>:
    4462:	88 1f       	adc	r24, r24
    4464:	99 1f       	adc	r25, r25
    4466:	5a 95       	dec	r21
    4468:	a9 f7       	brne	.-22     	; 0x4454 <__udivmodhi4_loop>
    446a:	80 95       	com	r24
    446c:	90 95       	com	r25
    446e:	bc 01       	movw	r22, r24
    4470:	cd 01       	movw	r24, r26
    4472:	08 95       	ret

00004474 <memcpy>:
    4474:	fb 01       	movw	r30, r22
    4476:	dc 01       	movw	r26, r24
    4478:	02 c0       	rjmp	.+4      	; 0x447e <memcpy+0xa>
    447a:	01 90       	ld	r0, Z+
    447c:	0d 92       	st	X+, r0
    447e:	41 50       	subi	r20, 0x01	; 1
    4480:	50 40       	sbci	r21, 0x00	; 0
    4482:	d8 f7       	brcc	.-10     	; 0x447a <memcpy+0x6>
    4484:	08 95       	ret

00004486 <memset>:
    4486:	dc 01       	movw	r26, r24
    4488:	01 c0       	rjmp	.+2      	; 0x448c <memset+0x6>
    448a:	6d 93       	st	X+, r22
    448c:	41 50       	subi	r20, 0x01	; 1
    448e:	50 40       	sbci	r21, 0x00	; 0
    4490:	e0 f7       	brcc	.-8      	; 0x448a <memset+0x4>
    4492:	08 95       	ret

00004494 <strncpy>:
    4494:	fb 01       	movw	r30, r22
    4496:	dc 01       	movw	r26, r24
    4498:	41 50       	subi	r20, 0x01	; 1
    449a:	50 40       	sbci	r21, 0x00	; 0
    449c:	48 f0       	brcs	.+18     	; 0x44b0 <strncpy+0x1c>
    449e:	01 90       	ld	r0, Z+
    44a0:	0d 92       	st	X+, r0
    44a2:	00 20       	and	r0, r0
    44a4:	c9 f7       	brne	.-14     	; 0x4498 <strncpy+0x4>
    44a6:	01 c0       	rjmp	.+2      	; 0x44aa <strncpy+0x16>
    44a8:	1d 92       	st	X+, r1
    44aa:	41 50       	subi	r20, 0x01	; 1
    44ac:	50 40       	sbci	r21, 0x00	; 0
    44ae:	e0 f7       	brcc	.-8      	; 0x44a8 <strncpy+0x14>
    44b0:	08 95       	ret

000044b2 <ultoa>:
    44b2:	25 32       	cpi	r18, 0x25	; 37
    44b4:	31 05       	cpc	r19, r1
    44b6:	20 f4       	brcc	.+8      	; 0x44c0 <ultoa+0xe>
    44b8:	22 30       	cpi	r18, 0x02	; 2
    44ba:	10 f0       	brcs	.+4      	; 0x44c0 <ultoa+0xe>
    44bc:	0c 94 64 22 	jmp	0x44c8	; 0x44c8 <__ultoa_ncheck>
    44c0:	fa 01       	movw	r30, r20
    44c2:	10 82       	st	Z, r1
    44c4:	ca 01       	movw	r24, r20
    44c6:	08 95       	ret

000044c8 <__ultoa_ncheck>:
    44c8:	bb 27       	eor	r27, r27

000044ca <__ultoa_common>:
    44ca:	fa 01       	movw	r30, r20
    44cc:	a6 2f       	mov	r26, r22
    44ce:	62 17       	cp	r22, r18
    44d0:	71 05       	cpc	r23, r1
    44d2:	81 05       	cpc	r24, r1
    44d4:	91 05       	cpc	r25, r1
    44d6:	33 0b       	sbc	r19, r19
    44d8:	30 fb       	bst	r19, 0
    44da:	66 f0       	brts	.+24     	; 0x44f4 <__ultoa_common+0x2a>
    44dc:	aa 27       	eor	r26, r26
    44de:	66 0f       	add	r22, r22
    44e0:	77 1f       	adc	r23, r23
    44e2:	88 1f       	adc	r24, r24
    44e4:	99 1f       	adc	r25, r25
    44e6:	aa 1f       	adc	r26, r26
    44e8:	a2 17       	cp	r26, r18
    44ea:	10 f0       	brcs	.+4      	; 0x44f0 <__ultoa_common+0x26>
    44ec:	a2 1b       	sub	r26, r18
    44ee:	63 95       	inc	r22
    44f0:	38 50       	subi	r19, 0x08	; 8
    44f2:	a9 f7       	brne	.-22     	; 0x44de <__ultoa_common+0x14>
    44f4:	a0 5d       	subi	r26, 0xD0	; 208
    44f6:	aa 33       	cpi	r26, 0x3A	; 58
    44f8:	08 f0       	brcs	.+2      	; 0x44fc <__ultoa_common+0x32>
    44fa:	a9 5d       	subi	r26, 0xD9	; 217
    44fc:	a1 93       	st	Z+, r26
    44fe:	36 f7       	brtc	.-52     	; 0x44cc <__ultoa_common+0x2>
    4500:	b1 11       	cpse	r27, r1
    4502:	b1 93       	st	Z+, r27
    4504:	10 82       	st	Z, r1
    4506:	ca 01       	movw	r24, r20
    4508:	0c 94 ab 22 	jmp	0x4556	; 0x4556 <strrev>

0000450c <utoa>:
    450c:	45 32       	cpi	r20, 0x25	; 37
    450e:	51 05       	cpc	r21, r1
    4510:	20 f4       	brcc	.+8      	; 0x451a <utoa+0xe>
    4512:	42 30       	cpi	r20, 0x02	; 2
    4514:	10 f0       	brcs	.+4      	; 0x451a <utoa+0xe>
    4516:	0c 94 91 22 	jmp	0x4522	; 0x4522 <__utoa_ncheck>
    451a:	fb 01       	movw	r30, r22
    451c:	10 82       	st	Z, r1
    451e:	cb 01       	movw	r24, r22
    4520:	08 95       	ret

00004522 <__utoa_ncheck>:
    4522:	bb 27       	eor	r27, r27

00004524 <__utoa_common>:
    4524:	fb 01       	movw	r30, r22
    4526:	55 27       	eor	r21, r21
    4528:	aa 27       	eor	r26, r26
    452a:	88 0f       	add	r24, r24
    452c:	99 1f       	adc	r25, r25
    452e:	aa 1f       	adc	r26, r26
    4530:	a4 17       	cp	r26, r20
    4532:	10 f0       	brcs	.+4      	; 0x4538 <__utoa_common+0x14>
    4534:	a4 1b       	sub	r26, r20
    4536:	83 95       	inc	r24
    4538:	50 51       	subi	r21, 0x10	; 16
    453a:	b9 f7       	brne	.-18     	; 0x452a <__utoa_common+0x6>
    453c:	a0 5d       	subi	r26, 0xD0	; 208
    453e:	aa 33       	cpi	r26, 0x3A	; 58
    4540:	08 f0       	brcs	.+2      	; 0x4544 <__utoa_common+0x20>
    4542:	a9 5d       	subi	r26, 0xD9	; 217
    4544:	a1 93       	st	Z+, r26
    4546:	00 97       	sbiw	r24, 0x00	; 0
    4548:	79 f7       	brne	.-34     	; 0x4528 <__utoa_common+0x4>
    454a:	b1 11       	cpse	r27, r1
    454c:	b1 93       	st	Z+, r27
    454e:	11 92       	st	Z+, r1
    4550:	cb 01       	movw	r24, r22
    4552:	0c 94 ab 22 	jmp	0x4556	; 0x4556 <strrev>

00004556 <strrev>:
    4556:	dc 01       	movw	r26, r24
    4558:	fc 01       	movw	r30, r24
    455a:	67 2f       	mov	r22, r23
    455c:	71 91       	ld	r23, Z+
    455e:	77 23       	and	r23, r23
    4560:	e1 f7       	brne	.-8      	; 0x455a <strrev+0x4>
    4562:	32 97       	sbiw	r30, 0x02	; 2
    4564:	04 c0       	rjmp	.+8      	; 0x456e <strrev+0x18>
    4566:	7c 91       	ld	r23, X
    4568:	6d 93       	st	X+, r22
    456a:	70 83       	st	Z, r23
    456c:	62 91       	ld	r22, -Z
    456e:	ae 17       	cp	r26, r30
    4570:	bf 07       	cpc	r27, r31
    4572:	c8 f3       	brcs	.-14     	; 0x4566 <strrev+0x10>
    4574:	08 95       	ret

00004576 <_exit>:
    4576:	f8 94       	cli

00004578 <__stop_program>:
    4578:	ff cf       	rjmp	.-2      	; 0x4578 <__stop_program>
