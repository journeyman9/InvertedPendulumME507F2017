
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004110  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000bc  00802000  00004110  000041a4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a6  008020bc  008020bc  00004260  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004260  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004290  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006e8  00000000  00000000  000042d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012307  00000000  00000000  000049b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000666d  00000000  00000000  00016cbf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000545a  00000000  00000000  0001d32c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012dc  00000000  00000000  00022788  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000061ef  00000000  00000000  00023a64  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005e42  00000000  00000000  00029c53  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000590  00000000  00000000  0002fa95  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a9 02 	jmp	0x552	; 0x552 <__ctors_end>
       4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      10:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      14:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      18:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      1c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      20:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      24:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      28:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      2c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      30:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      34:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      38:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      3c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      40:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      44:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      48:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      4c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      50:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      54:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      58:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      5c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      60:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      64:	0c 94 46 1c 	jmp	0x388c	; 0x388c <__vector_25>
      68:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      6c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      70:	0c 94 a4 1c 	jmp	0x3948	; 0x3948 <__vector_28>
      74:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      78:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      7c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      80:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      84:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      88:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      8c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      90:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      94:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      98:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      9c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c4:	0c 94 37 0c 	jmp	0x186e	; 0x186e <__vector_49>
      c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e8:	0c 94 be 1d 	jmp	0x3b7c	; 0x3b7c <__vector_58>
      ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      fc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     100:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     104:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     108:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     10c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     110:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     114:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     118:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     11c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     120:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     124:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     128:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     12c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     130:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     134:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     138:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     13c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     140:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     144:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     148:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     14c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     150:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     154:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     158:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     15c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     160:	0c 94 02 1d 	jmp	0x3a04	; 0x3a04 <__vector_88>
     164:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     168:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     16c:	0c 94 60 1d 	jmp	0x3ac0	; 0x3ac0 <__vector_91>
     170:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     174:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     178:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     17c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     180:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     184:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     188:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     18c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     190:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     194:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     198:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     19c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1fc:	09 1a       	sub	r0, r25
     1fe:	0c 1a       	sub	r0, r28
     200:	0f 1a       	sub	r0, r31
     202:	12 1a       	sub	r1, r18
     204:	15 1a       	sub	r1, r21
     206:	18 1a       	sub	r1, r24
     208:	1a 1a       	sub	r1, r26
     20a:	2b 1a       	sub	r2, r27
     20c:	33 1a       	sub	r3, r19
     20e:	3d 1a       	sub	r3, r29
     210:	3b 1a       	sub	r3, r27

00000212 <__trampolines_start>:
     212:	0c 94 aa 1b 	jmp	0x3754	; 0x3754 <_ZN5rs23214check_for_charEv>
     216:	0c 94 cb 1e 	jmp	0x3d96	; 0x3d96 <_GLOBAL__sub_I_counter>
     21a:	0c 94 09 1a 	jmp	0x3412	; 0x3412 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     21e:	0c 94 34 17 	jmp	0x2e68	; 0x2e68 <_ZN14frt_text_queue7getcharEv>
     222:	0c 94 b4 19 	jmp	0x3368	; 0x3368 <_ZN8emstream12clear_screenEv>
     226:	0c 94 ae 19 	jmp	0x335c	; 0x335c <_ZN8emstream7getcharEv>
     22a:	0c 94 13 08 	jmp	0x1026	; 0x1026 <_ZN9task_user3runEv>
     22e:	0c 94 0c 1a 	jmp	0x3418	; 0x3418 <_ZN8emstreamlsE15ser_manipulator+0x24>
     232:	0c 94 b1 19 	jmp	0x3362	; 0x3362 <_ZN8emstream14check_for_charEv>
     236:	0c 94 b3 19 	jmp	0x3366	; 0x3366 <_ZN8emstream12transmit_nowEv>
     23a:	0c 94 3d 1a 	jmp	0x347a	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x86>
     23e:	0c 94 15 1a 	jmp	0x342a	; 0x342a <_ZN8emstreamlsE15ser_manipulator+0x36>
     242:	0c 94 22 04 	jmp	0x844	; 0x844 <_ZN5Motor3runEv>
     246:	0c 94 5d 17 	jmp	0x2eba	; 0x2eba <_ZN14frt_text_queue7putcharEc>
     24a:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <prvIdleTask>
     24e:	0c 94 15 19 	jmp	0x322a	; 0x322a <__cxa_pure_virtual>
     252:	0c 94 bd 03 	jmp	0x77a	; 0x77a <_ZN13LimitSwitches3runEv>
     256:	0c 94 64 03 	jmp	0x6c8	; 0x6c8 <_ZN15EncoderPendulum3runEv>
     25a:	0c 94 a6 02 	jmp	0x54c	; 0x54c <_call_static_run_method>
     25e:	0c 94 52 17 	jmp	0x2ea4	; 0x2ea4 <_ZN14frt_text_queue14check_for_charEv>
     262:	0c 94 1a 1a 	jmp	0x3434	; 0x3434 <_ZN8emstreamlsE15ser_manipulator+0x40>
     266:	0c 94 ac 19 	jmp	0x3358	; 0x3358 <_ZN8emstream13ready_to_sendEv>
     26a:	0c 94 3b 1a 	jmp	0x3476	; 0x3476 <_ZN8emstreamlsE15ser_manipulator+0x82>
     26e:	0c 94 33 1a 	jmp	0x3466	; 0x3466 <_ZN8emstreamlsE15ser_manipulator+0x72>
     272:	0c 94 ea 15 	jmp	0x2bd4	; 0x2bd4 <_ZN8frt_task12print_statusER8emstream>
     276:	0c 94 12 1a 	jmp	0x3424	; 0x3424 <_ZN8emstreamlsE15ser_manipulator+0x30>
     27a:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <_ZN12EncoderMotor3runEv>
     27e:	0c 94 60 1b 	jmp	0x36c0	; 0x36c0 <_ZN5rs2327putcharEc>
     282:	0c 94 18 1a 	jmp	0x3430	; 0x3430 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     286:	0c 94 2b 1a 	jmp	0x3456	; 0x3456 <_ZN8emstreamlsE15ser_manipulator+0x62>
     28a:	0c 94 bd 1b 	jmp	0x377a	; 0x377a <_ZN5rs23212clear_screenEv>
     28e:	0c 94 2c 06 	jmp	0xc58	; 0xc58 <_ZN9PWMdriver3runEv>
     292:	0c 94 0f 1a 	jmp	0x341e	; 0x341e <_ZN8emstreamlsE15ser_manipulator+0x2a>
     296:	0c 94 84 1b 	jmp	0x3708	; 0x3708 <_ZN5rs2327getcharEv>

0000029a <__trampolines_end>:
     29a:	2c 20       	and	r2, r12
     29c:	54 43       	sbci	r21, 0x34	; 52
     29e:	43 30       	cpi	r20, 0x03	; 3
     2a0:	43 43       	sbci	r20, 0x33	; 51
     2a2:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a5 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a5:	2f 00                                               /.

000002a7 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a7:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b5 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b5:	54 69 6d 65 3a 20 00                                Time: .

000002bc <_ZZN9task_user11show_statusEvE3__c_0>:
     2bc:	44 65 63 20 20 35 20 32 30 31 37 00                 Dec  5 2017.

000002c8 <_ZZN9task_user11show_statusEvE3__c>:
     2c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e7 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e7:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f6 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f6:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     306:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000311 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     311:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     321:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032f <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32f:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33f:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34f:	6d 61 74 69 6f 6e 00                                mation.

00000356 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     356:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     366:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000377 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     377:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     387:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038f <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38f:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39f:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003ab <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3ab:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3bb:	68 65 20 41 56 52 00                                he AVR.

000003c2 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3c2:	20 68 65 6c 70 00                                    help.

000003c8 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e7 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e7:	1b 5b 33 30 6d 00                                   .[30m.

000003ed <_ZZN9task_user18print_help_messageEvE3__c>:
     3ed:	1b 5b 34 36 6d 00                                   .[46m.

000003f3 <_ZZN9task_user3runEvE3__c_3>:
     3f3:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     403:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000410 <_ZZN9task_user3runEvE3__c_2>:
     410:	3a 57 54 46 3f 00                                   :WTF?.

00000416 <_ZZN9task_user3runEvE3__c_1>:
     416:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     426:	65 00                                               e.

00000428 <_ZZN9task_user3runEvE3__c_0>:
     428:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000436 <_ZZN9task_user3runEvE3__c>:
     436:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     446:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000454 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     454:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045e <_ZZN8frt_task15emergency_resetEvE3__c>:
     45e:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000046d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     46d:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     47d:	61 73 6b 20 00                                      ask .

00000482 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     482:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000490 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     490:	20 63 72 65 61 74 65 64 00                           created.

00000499 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     499:	54 61 73 6b 20 00                                   Task .

0000049f <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49f:	1b 5b 32 32 6d 00                                   .[22m.

000004a5 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a5:	54 61 73 6b 3a 20 00                                Task: .

000004ac <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4ac:	1b 5b 31 6d 00                                      .[1m.

000004b1 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4b1:	1b 5b 32 32 6d 00                                   .[22m.

000004b7 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b7:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004c2 <_ZZ17print_task_stacksP8emstreamE3__c>:
     4c2:	1b 5b 31 6d 00                                      .[1m.

000004c7 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c7:	09 09 00                                            ...

000004ca <_ZZ15print_task_listP8emstreamE3__c_8>:
     4ca:	2f 00                                               /.

000004cc <_ZZ15print_task_listP8emstreamE3__c_7>:
     4cc:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d7 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d7:	09 2d 2d 2d 2d 00                                   .----.

000004dd <_ZZ15print_task_listP8emstreamE3__c_5>:
     4dd:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e9 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e9:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004fa <_ZZ15print_task_listP8emstreamE3__c_3>:
     4fa:	09 52 75 6e 73 00                                   .Runs.

00000500 <_ZZ15print_task_listP8emstreamE3__c_2>:
     500:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000050c <_ZZ15print_task_listP8emstreamE3__c_1>:
     50c:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

0000051d <_ZZ15print_task_listP8emstreamE3__c_0>:
     51d:	09 53 74 61 63 6b 00                                .Stack.

00000524 <_ZZ15print_task_listP8emstreamE3__c>:
     524:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52f:	09 00                                               ..

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     533:	2f 00                                               /.

00000535 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     535:	09 00                                               ..

00000537 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     537:	09 00                                               ..

00000539 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     539:	1b 5b 32 32 6d 00                                   .[22m.

0000053f <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53f:	1b 5b 31 6d 00                                      .[1m.

00000544 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     544:	1b 5b 31 6d 00                                      .[1m.

00000549 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     549:	20 20 00                                              .

0000054c <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     54c:	0e 94 82 14 	call	0x2904	; 0x2904 <_ZN8frt_task22_call_users_run_methodEPS_>

00000550 <__ctors_start>:
     550:	cb 1e       	adc	r12, r27

00000552 <__ctors_end>:
     552:	11 24       	eor	r1, r1
     554:	1f be       	out	0x3f, r1	; 63
     556:	cf ef       	ldi	r28, 0xFF	; 255
     558:	cd bf       	out	0x3d, r28	; 61
     55a:	df e3       	ldi	r29, 0x3F	; 63
     55c:	de bf       	out	0x3e, r29	; 62
     55e:	00 e0       	ldi	r16, 0x00	; 0
     560:	0c bf       	out	0x3c, r16	; 60
     562:	18 be       	out	0x38, r1	; 56
     564:	19 be       	out	0x39, r1	; 57
     566:	1a be       	out	0x3a, r1	; 58
     568:	1b be       	out	0x3b, r1	; 59

0000056a <__do_copy_data>:
     56a:	10 e2       	ldi	r17, 0x20	; 32
     56c:	a0 e0       	ldi	r26, 0x00	; 0
     56e:	b0 e2       	ldi	r27, 0x20	; 32
     570:	e0 e1       	ldi	r30, 0x10	; 16
     572:	f1 e4       	ldi	r31, 0x41	; 65
     574:	00 e0       	ldi	r16, 0x00	; 0
     576:	0b bf       	out	0x3b, r16	; 59
     578:	02 c0       	rjmp	.+4      	; 0x57e <__do_copy_data+0x14>
     57a:	07 90       	elpm	r0, Z+
     57c:	0d 92       	st	X+, r0
     57e:	ac 3b       	cpi	r26, 0xBC	; 188
     580:	b1 07       	cpc	r27, r17
     582:	d9 f7       	brne	.-10     	; 0x57a <__do_copy_data+0x10>
     584:	1b be       	out	0x3b, r1	; 59

00000586 <__do_clear_bss>:
     586:	21 e3       	ldi	r18, 0x31	; 49
     588:	ac eb       	ldi	r26, 0xBC	; 188
     58a:	b0 e2       	ldi	r27, 0x20	; 32
     58c:	01 c0       	rjmp	.+2      	; 0x590 <.do_clear_bss_start>

0000058e <.do_clear_bss_loop>:
     58e:	1d 92       	st	X+, r1

00000590 <.do_clear_bss_start>:
     590:	a2 36       	cpi	r26, 0x62	; 98
     592:	b2 07       	cpc	r27, r18
     594:	e1 f7       	brne	.-8      	; 0x58e <.do_clear_bss_loop>

00000596 <__do_global_ctors>:
     596:	12 e0       	ldi	r17, 0x02	; 2
     598:	c9 ea       	ldi	r28, 0xA9	; 169
     59a:	d2 e0       	ldi	r29, 0x02	; 2
     59c:	00 e0       	ldi	r16, 0x00	; 0
     59e:	06 c0       	rjmp	.+12     	; 0x5ac <__do_global_ctors+0x16>
     5a0:	21 97       	sbiw	r28, 0x01	; 1
     5a2:	01 09       	sbc	r16, r1
     5a4:	80 2f       	mov	r24, r16
     5a6:	fe 01       	movw	r30, r28
     5a8:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <__tablejump2__>
     5ac:	c8 3a       	cpi	r28, 0xA8	; 168
     5ae:	d1 07       	cpc	r29, r17
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	08 07       	cpc	r16, r24
     5b4:	a9 f7       	brne	.-22     	; 0x5a0 <__do_global_ctors+0xa>
     5b6:	0e 94 31 1e 	call	0x3c62	; 0x3c62 <main>
     5ba:	0c 94 86 20 	jmp	0x410c	; 0x410c <_exit>

000005be <__bad_interrupt>:
     5be:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005c2 <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	00 d0       	rcall	.+0      	; 0x5c8 <_ZN12EncoderMotor3runEv+0x6>
     5c8:	1f 92       	push	r1
     5ca:	cd b7       	in	r28, 0x3d	; 61
     5cc:	de b7       	in	r29, 0x3e	; 62
     5ce:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5d0:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskGetTickCount>
     5d4:	69 83       	std	Y+1, r22	; 0x01
     5d6:	7a 83       	std	Y+2, r23	; 0x02
     5d8:	8b 83       	std	Y+3, r24	; 0x03
     5da:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = PIN2_bm | PIN3_bm;										// Set both CHa and CHb for input
     5dc:	e0 e8       	ldi	r30, 0x80	; 128
     5de:	f6 e0       	ldi	r31, 0x06	; 6
     5e0:	8c e0       	ldi	r24, 0x0C	; 12
     5e2:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN2CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e4:	82 89       	ldd	r24, Z+18	; 0x12
     5e6:	83 60       	ori	r24, 0x03	; 3
     5e8:	82 8b       	std	Z+18, r24	; 0x12
	PORTE.PIN3CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5ea:	83 89       	ldd	r24, Z+19	; 0x13
     5ec:	83 60       	ori	r24, 0x03	; 3
     5ee:	83 8b       	std	Z+19, r24	; 0x13
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTE_PIN2_gc;								// Configure CHa as a multiplexer input for event channel 0
     5f0:	e0 e8       	ldi	r30, 0x80	; 128
     5f2:	f1 e0       	ldi	r31, 0x01	; 1
     5f4:	82 e7       	ldi	r24, 0x72	; 114
     5f6:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5f8:	89 e0       	ldi	r24, 0x09	; 9
     5fa:	80 87       	std	Z+8, r24	; 0x08
	
	TCD0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     5fc:	e0 e0       	ldi	r30, 0x00	; 0
     5fe:	f9 e0       	ldi	r31, 0x09	; 9
     600:	88 e6       	ldi	r24, 0x68	; 104
     602:	83 83       	std	Z+3, r24	; 0x03
	TCD0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     604:	8f ef       	ldi	r24, 0xFF	; 255
     606:	9f ef       	ldi	r25, 0xFF	; 255
     608:	86 a3       	std	Z+38, r24	; 0x26
     60a:	97 a3       	std	Z+39, r25	; 0x27
	TCD0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     60c:	81 e0       	ldi	r24, 0x01	; 1
     60e:	80 83       	st	Z, r24
	int16_t angularVelocity;
	int16_t x;

	while(1){
		
		encoder_count = TCD0.CNT;											// get count
     610:	0f 2e       	mov	r0, r31
     612:	a1 2c       	mov	r10, r1
     614:	f9 e0       	ldi	r31, 0x09	; 9
     616:	bf 2e       	mov	r11, r31
     618:	f0 2d       	mov	r31, r0
     61a:	f5 01       	movw	r30, r10
     61c:	00 a1       	ldd	r16, Z+32	; 0x20
     61e:	11 a1       	ldd	r17, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     620:	0f b6       	in	r0, 0x3f	; 63
     622:	f8 94       	cli
     624:	0f 92       	push	r0
			the_data = new_data;
     626:	c8 01       	movw	r24, r16
     628:	01 2e       	mov	r0, r17
     62a:	00 0c       	add	r0, r0
     62c:	aa 0b       	sbc	r26, r26
     62e:	bb 0b       	sbc	r27, r27
     630:	ac 01       	movw	r20, r24
     632:	bd 01       	movw	r22, r26
     634:	44 0f       	add	r20, r20
     636:	55 1f       	adc	r21, r21
     638:	66 1f       	adc	r22, r22
     63a:	77 1f       	adc	r23, r23
     63c:	3a 01       	movw	r6, r20
     63e:	4b 01       	movw	r8, r22
     640:	68 0e       	add	r6, r24
     642:	79 1e       	adc	r7, r25
     644:	8a 1e       	adc	r8, r26
     646:	9b 1e       	adc	r9, r27
     648:	c4 01       	movw	r24, r8
     64a:	b3 01       	movw	r22, r6
     64c:	24 e6       	ldi	r18, 0x64	; 100
     64e:	30 e0       	ldi	r19, 0x00	; 0
     650:	40 e0       	ldi	r20, 0x00	; 0
     652:	50 e0       	ldi	r21, 0x00	; 0
     654:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <__divmodsi4>
     658:	20 93 4e 31 	sts	0x314E, r18	; 0x80314e <linear_position>
     65c:	30 93 4f 31 	sts	0x314F, r19	; 0x80314f <linear_position+0x1>
			portEXIT_CRITICAL ();
     660:	0f 90       	pop	r0
     662:	0f be       	out	0x3f, r0	; 63
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     664:	0f b6       	in	r0, 0x3f	; 63
     666:	f8 94       	cli
     668:	0f 92       	push	r0
			the_data = new_data;
     66a:	c8 01       	movw	r24, r16
     66c:	8c 19       	sub	r24, r12
     66e:	9d 09       	sbc	r25, r13
     670:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <thdMotor>
     674:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <thdMotor+0x1>
			portEXIT_CRITICAL ();
     678:	0f 90       	pop	r0
     67a:	0f be       	out	0x3f, r0	; 63
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
		
		// Increment counter for debugging
		runs++;
     67c:	f7 01       	movw	r30, r14
     67e:	86 85       	ldd	r24, Z+14	; 0x0e
     680:	97 85       	ldd	r25, Z+15	; 0x0f
     682:	a0 89       	ldd	r26, Z+16	; 0x10
     684:	b1 89       	ldd	r27, Z+17	; 0x11
     686:	01 96       	adiw	r24, 0x01	; 1
     688:	a1 1d       	adc	r26, r1
     68a:	b1 1d       	adc	r27, r1
     68c:	86 87       	std	Z+14, r24	; 0x0e
     68e:	97 87       	std	Z+15, r25	; 0x0f
     690:	a0 8b       	std	Z+16, r26	; 0x10
     692:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     694:	41 e0       	ldi	r20, 0x01	; 1
     696:	50 e0       	ldi	r21, 0x00	; 0
     698:	60 e0       	ldi	r22, 0x00	; 0
     69a:	70 e0       	ldi	r23, 0x00	; 0
     69c:	ce 01       	movw	r24, r28
     69e:	01 96       	adiw	r24, 0x01	; 1
     6a0:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <vTaskDelayUntil>
			*p_serial << ticks_per_ms << endl;
			*p_serial << "angularVelocity: " << angularVelocity << " [RPM]" << endl;
		}
		*/
		
		last_encoder_count = encoder_count;									// make present encoder_count the previous for the next calculation
     6a4:	68 01       	movw	r12, r16
     6a6:	b9 cf       	rjmp	.-142    	; 0x61a <_ZN12EncoderMotor3runEv+0x58>

000006a8 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     6a8:	0f 93       	push	r16
     6aa:	1f 93       	push	r17
     6ac:	cf 93       	push	r28
     6ae:	df 93       	push	r29
     6b0:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     6b2:	0e 94 95 14 	call	0x292a	; 0x292a <_ZN8frt_taskC1EPKchjP8emstream>
     6b6:	8a e0       	ldi	r24, 0x0A	; 10
     6b8:	90 e2       	ldi	r25, 0x20	; 32
     6ba:	88 83       	st	Y, r24
     6bc:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     6be:	df 91       	pop	r29
     6c0:	cf 91       	pop	r28
     6c2:	1f 91       	pop	r17
     6c4:	0f 91       	pop	r16
     6c6:	08 95       	ret

000006c8 <_ZN15EncoderPendulum3runEv>:
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void)
{
     6c8:	cf 93       	push	r28
     6ca:	df 93       	push	r29
     6cc:	00 d0       	rcall	.+0      	; 0x6ce <_ZN15EncoderPendulum3runEv+0x6>
     6ce:	1f 92       	push	r1
     6d0:	cd b7       	in	r28, 0x3d	; 61
     6d2:	de b7       	in	r29, 0x3e	; 62
     6d4:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     6d6:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskGetTickCount>
     6da:	69 83       	std	Y+1, r22	; 0x01
     6dc:	7a 83       	std	Y+2, r23	; 0x02
     6de:	8b 83       	std	Y+3, r24	; 0x03
     6e0:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTE.DIRCLR = (PIN0_bm | PIN1_bm);							// set E0 & E1 as inputs
     6e2:	e0 e8       	ldi	r30, 0x80	; 128
     6e4:	f6 e0       	ldi	r31, 0x06	; 6
     6e6:	83 e0       	ldi	r24, 0x03	; 3
     6e8:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN0CTRL = PORT_ISC_LEVEL_gc;							// set E0 for level sensing
     6ea:	80 8b       	std	Z+16, r24	; 0x10
	PORTE.PIN1CTRL = PORT_ISC_LEVEL_gc;							// set E1 for level sensing
     6ec:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH2MUX = EVSYS_CHMUX_PORTE_PIN0_gc;					// set PE0 as Multiplexer for Event Chan 2
     6ee:	e0 e8       	ldi	r30, 0x80	; 128
     6f0:	f1 e0       	ldi	r31, 0x01	; 1
     6f2:	80 e7       	ldi	r24, 0x70	; 112
     6f4:	82 83       	std	Z+2, r24	; 0x02
	EVSYS.CH2CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     6f6:	89 e0       	ldi	r24, 0x09	; 9
     6f8:	82 87       	std	Z+10, r24	; 0x0a
	
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH2_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     6fa:	e0 e4       	ldi	r30, 0x40	; 64
     6fc:	f8 e0       	ldi	r31, 0x08	; 8
     6fe:	8a e6       	ldi	r24, 0x6A	; 106
     700:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0x5A0;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     702:	80 ea       	ldi	r24, 0xA0	; 160
     704:	95 e0       	ldi	r25, 0x05	; 5
     706:	86 a3       	std	Z+38, r24	; 0x26
     708:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	80 83       	st	Z, r24
	
	int16_t count; // contains the current encoder value
	
	while(1)
	{
		count = TCC1.CNT; // read value from hardware counter
     70e:	68 94       	set
     710:	ee 24       	eor	r14, r14
     712:	e6 f8       	bld	r14, 6
     714:	ff 24       	eor	r15, r15
     716:	f3 f8       	bld	r15, 3
     718:	f7 01       	movw	r30, r14
     71a:	80 a1       	ldd	r24, Z+32	; 0x20
     71c:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     71e:	0f b6       	in	r0, 0x3f	; 63
     720:	f8 94       	cli
     722:	0f 92       	push	r0
			the_data = new_data;
     724:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <thPendulum>
     728:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <thPendulum+0x1>
			portEXIT_CRITICAL ();
     72c:	0f 90       	pop	r0
     72e:	0f be       	out	0x3f, r0	; 63
		//theta_pendulum = ( (int32_t) count*100/4);			// count/(4*360)*360 degrees * 100
		
		thPendulum.put(count); // push angular position [ticks] to pendulum controller task
		
		// Increment counter for debugging
		runs++;
     730:	f8 01       	movw	r30, r16
     732:	86 85       	ldd	r24, Z+14	; 0x0e
     734:	97 85       	ldd	r25, Z+15	; 0x0f
     736:	a0 89       	ldd	r26, Z+16	; 0x10
     738:	b1 89       	ldd	r27, Z+17	; 0x11
     73a:	01 96       	adiw	r24, 0x01	; 1
     73c:	a1 1d       	adc	r26, r1
     73e:	b1 1d       	adc	r27, r1
     740:	86 87       	std	Z+14, r24	; 0x0e
     742:	97 87       	std	Z+15, r25	; 0x0f
     744:	a0 8b       	std	Z+16, r26	; 0x10
     746:	b1 8b       	std	Z+17, r27	; 0x11
     748:	41 e0       	ldi	r20, 0x01	; 1
     74a:	50 e0       	ldi	r21, 0x00	; 0
     74c:	60 e0       	ldi	r22, 0x00	; 0
     74e:	70 e0       	ldi	r23, 0x00	; 0
     750:	ce 01       	movw	r24, r28
     752:	01 96       	adiw	r24, 0x01	; 1
     754:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <vTaskDelayUntil>
     758:	df cf       	rjmp	.-66     	; 0x718 <_ZN15EncoderPendulum3runEv+0x50>

0000075a <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     75a:	0f 93       	push	r16
     75c:	1f 93       	push	r17
     75e:	cf 93       	push	r28
     760:	df 93       	push	r29
     762:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     764:	0e 94 95 14 	call	0x292a	; 0x292a <_ZN8frt_taskC1EPKchjP8emstream>
     768:	82 e1       	ldi	r24, 0x12	; 18
     76a:	90 e2       	ldi	r25, 0x20	; 32
     76c:	88 83       	st	Y, r24
     76e:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	1f 91       	pop	r17
     776:	0f 91       	pop	r16
     778:	08 95       	ret

0000077a <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     77a:	cf 93       	push	r28
     77c:	df 93       	push	r29
     77e:	00 d0       	rcall	.+0      	; 0x780 <_ZN13LimitSwitches3runEv+0x6>
     780:	1f 92       	push	r1
     782:	cd b7       	in	r28, 0x3d	; 61
     784:	de b7       	in	r29, 0x3e	; 62
     786:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     788:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskGetTickCount>
     78c:	69 83       	std	Y+1, r22	; 0x01
     78e:	7a 83       	std	Y+2, r23	; 0x02
     790:	8b 83       	std	Y+3, r24	; 0x03
     792:	9c 83       	std	Y+4, r25	; 0x04
	
	// Setup pins for Limit Switch (PD0 & PD1) and LED output
	PORTD.DIRCLR = PIN0_bm;									// set D0 as input left limit
     794:	e0 e6       	ldi	r30, 0x60	; 96
     796:	f6 e0       	ldi	r31, 0x06	; 6
     798:	81 e0       	ldi	r24, 0x01	; 1
     79a:	82 83       	std	Z+2, r24	; 0x02
	PORTD.DIRCLR = PIN2_bm;									// set D2 as input right limit
     79c:	84 e0       	ldi	r24, 0x04	; 4
     79e:	82 83       	std	Z+2, r24	; 0x02
	PORTD.PIN0CTRL = PORT_OPC_PULLUP_gc;					// set D0 as pullup
     7a0:	88 e1       	ldi	r24, 0x18	; 24
     7a2:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN2CTRL = PORT_OPC_PULLUP_gc;					// set D2 as pullup
     7a4:	82 8b       	std	Z+18, r24	; 0x12
	bool leftLimit = false;
		
	while(1){
		
		
		if(!(PORTD_IN & PIN0_bm))							// check whether limit is pressed (pin D0 is high)
     7a6:	08 e6       	ldi	r16, 0x68	; 104
     7a8:	16 e0       	ldi	r17, 0x06	; 6
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     7aa:	dd 24       	eor	r13, r13
     7ac:	d3 94       	inc	r13
     7ae:	f8 01       	movw	r30, r16
     7b0:	80 81       	ld	r24, Z
     7b2:	80 fd       	sbrc	r24, 0
     7b4:	08 c0       	rjmp	.+16     	; 0x7c6 <_ZN13LimitSwitches3runEv+0x4c>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7b6:	0f b6       	in	r0, 0x3f	; 63
     7b8:	f8 94       	cli
     7ba:	0f 92       	push	r0
			the_data = new_data;
     7bc:	d0 92 49 31 	sts	0x3149, r13	; 0x803149 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7c0:	0f 90       	pop	r0
     7c2:	0f be       	out	0x3f, r0	; 63
     7c4:	07 c0       	rjmp	.+14     	; 0x7d4 <_ZN13LimitSwitches3runEv+0x5a>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7c6:	0f b6       	in	r0, 0x3f	; 63
     7c8:	f8 94       	cli
     7ca:	0f 92       	push	r0
			the_data = new_data;
     7cc:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <leftLimitSwitch>
			portEXIT_CRITICAL ();
     7d0:	0f 90       	pop	r0
     7d2:	0f be       	out	0x3f, r0	; 63
			*/

		}
		
		
		if (!(PORTD_IN & PIN2_bm))						// check whether limit is pressed (pin D1 is high)
     7d4:	f8 01       	movw	r30, r16
     7d6:	80 81       	ld	r24, Z
     7d8:	82 fd       	sbrc	r24, 2
     7da:	08 c0       	rjmp	.+16     	; 0x7ec <_ZN13LimitSwitches3runEv+0x72>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7dc:	0f b6       	in	r0, 0x3f	; 63
     7de:	f8 94       	cli
     7e0:	0f 92       	push	r0
			the_data = new_data;
     7e2:	d0 92 48 31 	sts	0x3148, r13	; 0x803148 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     7e6:	0f 90       	pop	r0
     7e8:	0f be       	out	0x3f, r0	; 63
     7ea:	07 c0       	rjmp	.+14     	; 0x7fa <_ZN13LimitSwitches3runEv+0x80>
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     7ec:	0f b6       	in	r0, 0x3f	; 63
     7ee:	f8 94       	cli
     7f0:	0f 92       	push	r0
			the_data = new_data;
     7f2:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <rightLimitSwitch>
			portEXIT_CRITICAL ();
     7f6:	0f 90       	pop	r0
     7f8:	0f be       	out	0x3f, r0	; 63
			}
			*/

		
		// Increment counter for debugging
		runs++;
     7fa:	f7 01       	movw	r30, r14
     7fc:	86 85       	ldd	r24, Z+14	; 0x0e
     7fe:	97 85       	ldd	r25, Z+15	; 0x0f
     800:	a0 89       	ldd	r26, Z+16	; 0x10
     802:	b1 89       	ldd	r27, Z+17	; 0x11
     804:	01 96       	adiw	r24, 0x01	; 1
     806:	a1 1d       	adc	r26, r1
     808:	b1 1d       	adc	r27, r1
     80a:	86 87       	std	Z+14, r24	; 0x0e
     80c:	97 87       	std	Z+15, r25	; 0x0f
     80e:	a0 8b       	std	Z+16, r26	; 0x10
     810:	b1 8b       	std	Z+17, r27	; 0x11
     812:	45 e0       	ldi	r20, 0x05	; 5
     814:	50 e0       	ldi	r21, 0x00	; 0
     816:	60 e0       	ldi	r22, 0x00	; 0
     818:	70 e0       	ldi	r23, 0x00	; 0
     81a:	ce 01       	movw	r24, r28
     81c:	01 96       	adiw	r24, 0x01	; 1
     81e:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <vTaskDelayUntil>
     822:	c5 cf       	rjmp	.-118    	; 0x7ae <_ZN13LimitSwitches3runEv+0x34>

00000824 <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     824:	0f 93       	push	r16
     826:	1f 93       	push	r17
     828:	cf 93       	push	r28
     82a:	df 93       	push	r29
     82c:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     82e:	0e 94 95 14 	call	0x292a	; 0x292a <_ZN8frt_taskC1EPKchjP8emstream>
     832:	8a e1       	ldi	r24, 0x1A	; 26
     834:	90 e2       	ldi	r25, 0x20	; 32
     836:	88 83       	st	Y, r24
     838:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     83a:	df 91       	pop	r29
     83c:	cf 91       	pop	r28
     83e:	1f 91       	pop	r17
     840:	0f 91       	pop	r16
     842:	08 95       	ret

00000844 <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     844:	cf 93       	push	r28
     846:	df 93       	push	r29
     848:	cd b7       	in	r28, 0x3d	; 61
     84a:	de b7       	in	r29, 0x3e	; 62
     84c:	66 97       	sbiw	r28, 0x16	; 22
     84e:	cd bf       	out	0x3d, r28	; 61
     850:	de bf       	out	0x3e, r29	; 62
     852:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     854:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskGetTickCount>
     858:	69 83       	std	Y+1, r22	; 0x01
     85a:	7a 83       	std	Y+2, r23	; 0x02
     85c:	8b 83       	std	Y+3, r24	; 0x03
     85e:	9c 83       	std	Y+4, r25	; 0x04

	dt = 5; // [ms]
     860:	f8 01       	movw	r30, r16
     862:	fe 96       	adiw	r30, 0x3e	; 62
     864:	85 e0       	ldi	r24, 0x05	; 5
     866:	90 e0       	ldi	r25, 0x00	; 0
     868:	a0 e0       	ldi	r26, 0x00	; 0
     86a:	b0 e0       	ldi	r27, 0x00	; 0
     86c:	80 83       	st	Z, r24
     86e:	91 83       	std	Z+1, r25	; 0x01
     870:	a2 83       	std	Z+2, r26	; 0x02
     872:	b3 83       	std	Z+3, r27	; 0x03
	inc = 1;
     874:	81 e0       	ldi	r24, 0x01	; 1
     876:	90 e0       	ldi	r25, 0x00	; 0
     878:	f8 01       	movw	r30, r16
     87a:	84 af       	std	Z+60, r24	; 0x3c
     87c:	95 af       	std	Z+61, r25	; 0x3d
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 7.1;
     87e:	98 01       	movw	r18, r16
     880:	28 5b       	subi	r18, 0xB8	; 184
     882:	3f 4f       	sbci	r19, 0xFF	; 255
     884:	2d 83       	std	Y+5, r18	; 0x05
     886:	3e 83       	std	Y+6, r19	; 0x06
     888:	37 e0       	ldi	r19, 0x07	; 7
     88a:	3d 8b       	std	Y+21, r19	; 0x15
     88c:	1e 8a       	std	Y+22, r1	; 0x16
		_Ki = .71*256;
     88e:	a8 01       	movw	r20, r16
     890:	44 5b       	subi	r20, 0xB4	; 180
     892:	5f 4f       	sbci	r21, 0xFF	; 255
     894:	4f 83       	std	Y+7, r20	; 0x07
     896:	58 87       	std	Y+8, r21	; 0x08
		_Kd = 0;
     898:	c8 01       	movw	r24, r16
     89a:	86 5b       	subi	r24, 0xB6	; 182
     89c:	9f 4f       	sbci	r25, 0xFF	; 255
     89e:	8f 87       	std	Y+15, r24	; 0x0f
     8a0:	98 8b       	std	Y+16, r25	; 0x10
		antiwind_gain = .96*256;
     8a2:	ec 59       	subi	r30, 0x9C	; 156
     8a4:	ff 4f       	sbci	r31, 0xFF	; 255
     8a6:	e9 87       	std	Y+9, r30	; 0x09
     8a8:	fa 87       	std	Y+10, r31	; 0x0a
		
		_max = 1600;
     8aa:	98 01       	movw	r18, r16
     8ac:	2c 5b       	subi	r18, 0xBC	; 188
     8ae:	3f 4f       	sbci	r19, 0xFF	; 255
     8b0:	2b 87       	std	Y+11, r18	; 0x0b
     8b2:	3c 87       	std	Y+12, r19	; 0x0c
		_min = -1600;
     8b4:	46 50       	subi	r20, 0x06	; 6
     8b6:	51 09       	sbc	r21, r1
     8b8:	4d 87       	std	Y+13, r20	; 0x0d
     8ba:	5e 87       	std	Y+14, r21	; 0x0e
		int32_t error = omegam_set - omegam_measured;
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     8bc:	42 96       	adiw	r24, 0x12	; 18
     8be:	89 8b       	std	Y+17, r24	; 0x11
     8c0:	9a 8b       	std	Y+18, r25	; 0x12

		// Integral term
		error_int = error - antiwind_correct;
     8c2:	18 01       	movw	r2, r16
     8c4:	96 e6       	ldi	r25, 0x66	; 102
     8c6:	29 0e       	add	r2, r25
     8c8:	31 1c       	adc	r3, r1
     8ca:	34 96       	adiw	r30, 0x04	; 4
     8cc:	eb 8b       	std	Y+19, r30	; 0x13
     8ce:	fc 8b       	std	Y+20, r31	; 0x14
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     8d0:	48 01       	movw	r8, r16
     8d2:	fe e3       	ldi	r31, 0x3E	; 62
     8d4:	8f 0e       	add	r8, r31
     8d6:	91 1c       	adc	r9, r1
     8d8:	58 01       	movw	r10, r16
     8da:	20 e5       	ldi	r18, 0x50	; 80
     8dc:	a2 0e       	add	r10, r18
     8de:	b1 1c       	adc	r11, r1

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);

		output_correct = output;
     8e0:	68 01       	movw	r12, r16
     8e2:	3e e5       	ldi	r19, 0x5E	; 94
     8e4:	c3 0e       	add	r12, r19
     8e6:	d1 1c       	adc	r13, r1
	dt = 5; // [ms]
	inc = 1;
	
	while(1){
		// Increment counter for debugging
		runs++;
     8e8:	f8 01       	movw	r30, r16
     8ea:	86 85       	ldd	r24, Z+14	; 0x0e
     8ec:	97 85       	ldd	r25, Z+15	; 0x0f
     8ee:	a0 89       	ldd	r26, Z+16	; 0x10
     8f0:	b1 89       	ldd	r27, Z+17	; 0x11
     8f2:	01 96       	adiw	r24, 0x01	; 1
     8f4:	a1 1d       	adc	r26, r1
     8f6:	b1 1d       	adc	r27, r1
     8f8:	86 87       	std	Z+14, r24	; 0x0e
     8fa:	97 87       	std	Z+15, r25	; 0x0f
     8fc:	a0 8b       	std	Z+16, r26	; 0x10
     8fe:	b1 8b       	std	Z+17, r27	; 0x11
		
		// Actual motor code
		// Right now just working with speed control for motor.
		// Previously commented code extends to be a position control.
		
		omegam_set = 100; // [ticks/ms]
     900:	24 e6       	ldi	r18, 0x64	; 100
     902:	30 e0       	ldi	r19, 0x00	; 0
     904:	22 8f       	std	Z+26, r18	; 0x1a
     906:	33 8f       	std	Z+27, r19	; 0x1b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     908:	0f b6       	in	r0, 0x3f	; 63
     90a:	f8 94       	cli
     90c:	0f 92       	push	r0
			temporary_copy = the_data;
     90e:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <thdMotor>
     912:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <thdMotor+0x1>
			portEXIT_CRITICAL ();
     916:	0f 90       	pop	r0
     918:	0f be       	out	0x3f, r0	; 63

		// omegam_measured will be the derivative of theta_measured from the encoder
		omegam_measured = thdMotor.get();
     91a:	86 8f       	std	Z+30, r24	; 0x1e
     91c:	97 8f       	std	Z+31, r25	; 0x1f
		// PID to get Tset from Omegam_set with a max torque value
		// PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
		// PID pidTorque = PID(1, 1600, -1600, 10, 0, 1); // PID output
		//uint16_t error_sum = pidTorque.get_Integral();
		
		_Kp = 7.1;
     91e:	4d 89       	ldd	r20, Y+21	; 0x15
     920:	ed 81       	ldd	r30, Y+5	; 0x05
     922:	fe 81       	ldd	r31, Y+6	; 0x06
     924:	40 83       	st	Z, r20
     926:	5e 89       	ldd	r21, Y+22	; 0x16
     928:	51 83       	std	Z+1, r21	; 0x01
		_Ki = .71*256;
     92a:	45 eb       	ldi	r20, 0xB5	; 181
     92c:	50 e0       	ldi	r21, 0x00	; 0
     92e:	ef 81       	ldd	r30, Y+7	; 0x07
     930:	f8 85       	ldd	r31, Y+8	; 0x08
     932:	40 83       	st	Z, r20
     934:	51 83       	std	Z+1, r21	; 0x01
		_Kd = 0;
     936:	ef 85       	ldd	r30, Y+15	; 0x0f
     938:	f8 89       	ldd	r31, Y+16	; 0x10
     93a:	10 82       	st	Z, r1
     93c:	11 82       	std	Z+1, r1	; 0x01
		antiwind_gain = .96*256;
     93e:	45 ef       	ldi	r20, 0xF5	; 245
     940:	50 e0       	ldi	r21, 0x00	; 0
     942:	e9 85       	ldd	r30, Y+9	; 0x09
     944:	fa 85       	ldd	r31, Y+10	; 0x0a
     946:	40 83       	st	Z, r20
     948:	51 83       	std	Z+1, r21	; 0x01
		
		_max = 1600;
     94a:	40 e4       	ldi	r20, 0x40	; 64
     94c:	56 e0       	ldi	r21, 0x06	; 6
     94e:	eb 85       	ldd	r30, Y+11	; 0x0b
     950:	fc 85       	ldd	r31, Y+12	; 0x0c
     952:	40 83       	st	Z, r20
     954:	51 83       	std	Z+1, r21	; 0x01
		_min = -1600;
     956:	40 ec       	ldi	r20, 0xC0	; 192
     958:	59 ef       	ldi	r21, 0xF9	; 249
     95a:	ed 85       	ldd	r30, Y+13	; 0x0d
     95c:	fe 85       	ldd	r31, Y+14	; 0x0e
     95e:	40 83       	st	Z, r20
     960:	51 83       	std	Z+1, r21	; 0x01
		
		// Calculate error
		int32_t error = omegam_set - omegam_measured;
     962:	79 01       	movw	r14, r18
     964:	e8 1a       	sub	r14, r24
     966:	f9 0a       	sbc	r15, r25
		
		
		// Proportional term
		//int16_t Pout = ((_Kp) * error);
		Pout = ssmul(_Kp,error);
     968:	b7 01       	movw	r22, r14
     96a:	87 e0       	ldi	r24, 0x07	; 7
     96c:	90 e0       	ldi	r25, 0x00	; 0
     96e:	0e 94 be 06 	call	0xd7c	; 0xd7c <_ZN7satmath20signed_saturated_mulEii>
     972:	2b 01       	movw	r4, r22
     974:	3c 01       	movw	r6, r24
     976:	e9 89       	ldd	r30, Y+17	; 0x11
     978:	fa 89       	ldd	r31, Y+18	; 0x12
     97a:	60 83       	st	Z, r22
     97c:	71 83       	std	Z+1, r23	; 0x01

		// Integral term
		error_int = error - antiwind_correct;
     97e:	f1 01       	movw	r30, r2
     980:	80 81       	ld	r24, Z
     982:	91 81       	ldd	r25, Z+1	; 0x01
     984:	97 01       	movw	r18, r14
     986:	28 1b       	sub	r18, r24
     988:	39 0b       	sbc	r19, r25
     98a:	c9 01       	movw	r24, r18
     98c:	eb 89       	ldd	r30, Y+19	; 0x13
     98e:	fc 89       	ldd	r31, Y+20	; 0x14
     990:	20 83       	st	Z, r18
     992:	31 83       	std	Z+1, r19	; 0x01
		error_int_gain = (_Ki * error_int);
     994:	ef 81       	ldd	r30, Y+7	; 0x07
     996:	f8 85       	ldd	r31, Y+8	; 0x08
     998:	20 81       	ld	r18, Z
     99a:	31 81       	ldd	r19, Z+1	; 0x01
     99c:	82 9f       	mul	r24, r18
     99e:	d0 01       	movw	r26, r0
     9a0:	83 9f       	mul	r24, r19
     9a2:	b0 0d       	add	r27, r0
     9a4:	92 9f       	mul	r25, r18
     9a6:	b0 0d       	add	r27, r0
     9a8:	11 24       	eor	r1, r1
     9aa:	f8 01       	movw	r30, r16
     9ac:	e6 59       	subi	r30, 0x96	; 150
     9ae:	ff 4f       	sbci	r31, 0xFF	; 255
     9b0:	a0 83       	st	Z, r26
     9b2:	b1 83       	std	Z+1, r27	; 0x01
		_integral += (error_int_gain * dt)/256;
     9b4:	f4 01       	movw	r30, r8
     9b6:	20 81       	ld	r18, Z
     9b8:	31 81       	ldd	r19, Z+1	; 0x01
     9ba:	42 81       	ldd	r20, Z+2	; 0x02
     9bc:	53 81       	ldd	r21, Z+3	; 0x03
     9be:	0e 94 de 1f 	call	0x3fbc	; 0x3fbc <__mulshisi3>
     9c2:	9b 01       	movw	r18, r22
     9c4:	ac 01       	movw	r20, r24
     9c6:	99 23       	and	r25, r25
     9c8:	24 f4       	brge	.+8      	; 0x9d2 <_ZN5Motor3runEv+0x18e>
     9ca:	21 50       	subi	r18, 0x01	; 1
     9cc:	3f 4f       	sbci	r19, 0xFF	; 255
     9ce:	4f 4f       	sbci	r20, 0xFF	; 255
     9d0:	5f 4f       	sbci	r21, 0xFF	; 255
     9d2:	bb 27       	eor	r27, r27
     9d4:	57 fd       	sbrc	r21, 7
     9d6:	ba 95       	dec	r27
     9d8:	a5 2f       	mov	r26, r21
     9da:	94 2f       	mov	r25, r20
     9dc:	83 2f       	mov	r24, r19
     9de:	f5 01       	movw	r30, r10
     9e0:	40 81       	ld	r20, Z
     9e2:	51 81       	ldd	r21, Z+1	; 0x01
     9e4:	62 81       	ldd	r22, Z+2	; 0x02
     9e6:	73 81       	ldd	r23, Z+3	; 0x03
     9e8:	84 0f       	add	r24, r20
     9ea:	95 1f       	adc	r25, r21
     9ec:	a6 1f       	adc	r26, r22
     9ee:	b7 1f       	adc	r27, r23
		if(_integral > 1000000000)
     9f0:	81 30       	cpi	r24, 0x01	; 1
     9f2:	fa ec       	ldi	r31, 0xCA	; 202
     9f4:	9f 07       	cpc	r25, r31
     9f6:	fa e9       	ldi	r31, 0x9A	; 154
     9f8:	af 07       	cpc	r26, r31
     9fa:	fb e3       	ldi	r31, 0x3B	; 59
     9fc:	bf 07       	cpc	r27, r31
     9fe:	54 f0       	brlt	.+20     	; 0xa14 <_ZN5Motor3runEv+0x1d0>
		{
			_integral = 1000000000;
     a00:	80 e0       	ldi	r24, 0x00	; 0
     a02:	9a ec       	ldi	r25, 0xCA	; 202
     a04:	aa e9       	ldi	r26, 0x9A	; 154
     a06:	bb e3       	ldi	r27, 0x3B	; 59
     a08:	f5 01       	movw	r30, r10
     a0a:	80 83       	st	Z, r24
     a0c:	91 83       	std	Z+1, r25	; 0x01
     a0e:	a2 83       	std	Z+2, r26	; 0x02
     a10:	b3 83       	std	Z+3, r27	; 0x03
     a12:	17 c0       	rjmp	.+46     	; 0xa42 <_ZN5Motor3runEv+0x1fe>
		}
		else if(_integral < -1000000000)
     a14:	81 15       	cp	r24, r1
     a16:	f6 e3       	ldi	r31, 0x36	; 54
     a18:	9f 07       	cpc	r25, r31
     a1a:	f5 e6       	ldi	r31, 0x65	; 101
     a1c:	af 07       	cpc	r26, r31
     a1e:	f4 ec       	ldi	r31, 0xC4	; 196
     a20:	bf 07       	cpc	r27, r31
     a22:	34 f0       	brlt	.+12     	; 0xa30 <_ZN5Motor3runEv+0x1ec>
		Pout = ssmul(_Kp,error);

		// Integral term
		error_int = error - antiwind_correct;
		error_int_gain = (_Ki * error_int);
		_integral += (error_int_gain * dt)/256;
     a24:	f5 01       	movw	r30, r10
     a26:	80 83       	st	Z, r24
     a28:	91 83       	std	Z+1, r25	; 0x01
     a2a:	a2 83       	std	Z+2, r26	; 0x02
     a2c:	b3 83       	std	Z+3, r27	; 0x03
     a2e:	09 c0       	rjmp	.+18     	; 0xa42 <_ZN5Motor3runEv+0x1fe>
		{
			_integral = 1000000000;
		}
		else if(_integral < -1000000000)
		{
			_integral = -1000000000;
     a30:	80 e0       	ldi	r24, 0x00	; 0
     a32:	96 e3       	ldi	r25, 0x36	; 54
     a34:	a5 e6       	ldi	r26, 0x65	; 101
     a36:	b4 ec       	ldi	r27, 0xC4	; 196
     a38:	f5 01       	movw	r30, r10
     a3a:	80 83       	st	Z, r24
     a3c:	91 83       	std	Z+1, r25	; 0x01
     a3e:	a2 83       	std	Z+2, r26	; 0x02
     a40:	b3 83       	std	Z+3, r27	; 0x03
		int16_t derivative = (error - _pre_error) / dt;
		int16_t Dout = _Kd * derivative;

		// Calculate total output	
		// int16_t output = Pout + Iout + Dout;
		output = ssadd(Pout, _integral);
     a42:	f5 01       	movw	r30, r10
     a44:	60 81       	ld	r22, Z
     a46:	71 81       	ldd	r23, Z+1	; 0x01
     a48:	c2 01       	movw	r24, r4
     a4a:	0e 94 a2 06 	call	0xd44	; 0xd44 <_ZN7satmath20signed_saturated_addEii>
     a4e:	f8 01       	movw	r30, r16
     a50:	e0 5a       	subi	r30, 0xA0	; 160
     a52:	ff 4f       	sbci	r31, 0xFF	; 255
     a54:	80 83       	st	Z, r24
     a56:	91 83       	std	Z+1, r25	; 0x01

		output_correct = output;
     a58:	f6 01       	movw	r30, r12
     a5a:	80 83       	st	Z, r24
     a5c:	91 83       	std	Z+1, r25	; 0x01
		// Restrict to max/min
		if( output_correct > _max )
     a5e:	eb 85       	ldd	r30, Y+11	; 0x0b
     a60:	fc 85       	ldd	r31, Y+12	; 0x0c
     a62:	20 81       	ld	r18, Z
     a64:	31 81       	ldd	r19, Z+1	; 0x01
     a66:	28 17       	cp	r18, r24
     a68:	39 07       	cpc	r19, r25
     a6a:	24 f4       	brge	.+8      	; 0xa74 <_ZN5Motor3runEv+0x230>
		output_correct = _max;
     a6c:	f6 01       	movw	r30, r12
     a6e:	20 83       	st	Z, r18
     a70:	31 83       	std	Z+1, r19	; 0x01
     a72:	0a c0       	rjmp	.+20     	; 0xa88 <_ZN5Motor3runEv+0x244>
		else if( output_correct < _min )
     a74:	ed 85       	ldd	r30, Y+13	; 0x0d
     a76:	fe 85       	ldd	r31, Y+14	; 0x0e
     a78:	20 81       	ld	r18, Z
     a7a:	31 81       	ldd	r19, Z+1	; 0x01
     a7c:	82 17       	cp	r24, r18
     a7e:	93 07       	cpc	r25, r19
     a80:	1c f4       	brge	.+6      	; 0xa88 <_ZN5Motor3runEv+0x244>
		output_correct = _min;
     a82:	f6 01       	movw	r30, r12
     a84:	20 83       	st	Z, r18
     a86:	31 83       	std	Z+1, r19	; 0x01

		// Save error to previous error
		_pre_error = error;
     a88:	f8 01       	movw	r30, r16
     a8a:	e2 5b       	subi	r30, 0xB2	; 178
     a8c:	ff 4f       	sbci	r31, 0xFF	; 255
     a8e:	e0 82       	st	Z, r14
     a90:	f1 82       	std	Z+1, r15	; 0x01
		
		// Anti-windup correction
		antiwind_error = output - output_correct;
     a92:	f6 01       	movw	r30, r12
     a94:	20 81       	ld	r18, Z
     a96:	31 81       	ldd	r19, Z+1	; 0x01
     a98:	82 1b       	sub	r24, r18
     a9a:	93 0b       	sbc	r25, r19
     a9c:	f8 01       	movw	r30, r16
     a9e:	ee 59       	subi	r30, 0x9E	; 158
     aa0:	ff 4f       	sbci	r31, 0xFF	; 255
     aa2:	80 83       	st	Z, r24
     aa4:	91 83       	std	Z+1, r25	; 0x01
		
		antiwind_correct = (antiwind_error*antiwind_gain)/256;
     aa6:	e9 85       	ldd	r30, Y+9	; 0x09
     aa8:	fa 85       	ldd	r31, Y+10	; 0x0a
     aaa:	40 81       	ld	r20, Z
     aac:	51 81       	ldd	r21, Z+1	; 0x01
     aae:	84 9f       	mul	r24, r20
     ab0:	90 01       	movw	r18, r0
     ab2:	85 9f       	mul	r24, r21
     ab4:	30 0d       	add	r19, r0
     ab6:	94 9f       	mul	r25, r20
     ab8:	30 0d       	add	r19, r0
     aba:	11 24       	eor	r1, r1
     abc:	33 23       	and	r19, r19
     abe:	14 f4       	brge	.+4      	; 0xac4 <_ZN5Motor3runEv+0x280>
     ac0:	21 50       	subi	r18, 0x01	; 1
     ac2:	3f 4f       	sbci	r19, 0xFF	; 255
     ac4:	83 2f       	mov	r24, r19
     ac6:	88 0f       	add	r24, r24
     ac8:	88 0b       	sbc	r24, r24
     aca:	f1 01       	movw	r30, r2
     acc:	30 83       	st	Z, r19
     ace:	81 83       	std	Z+1, r24	; 0x01
		
		
			if(runs%5==0){
     ad0:	f8 01       	movw	r30, r16
     ad2:	66 85       	ldd	r22, Z+14	; 0x0e
     ad4:	77 85       	ldd	r23, Z+15	; 0x0f
     ad6:	80 89       	ldd	r24, Z+16	; 0x10
     ad8:	91 89       	ldd	r25, Z+17	; 0x11
     ada:	25 e0       	ldi	r18, 0x05	; 5
     adc:	30 e0       	ldi	r19, 0x00	; 0
     ade:	40 e0       	ldi	r20, 0x00	; 0
     ae0:	50 e0       	ldi	r21, 0x00	; 0
     ae2:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <__udivmodsi4>
     ae6:	67 2b       	or	r22, r23
     ae8:	68 2b       	or	r22, r24
     aea:	69 2b       	or	r22, r25
     aec:	51 f4       	brne	.+20     	; 0xb02 <_ZN5Motor3runEv+0x2be>
				//*p_serial << "Pout: " << Pout << endl;
				//*p_serial << "error: " << error << endl;
				//*p_serial << "Integral: " << _integral << endl;
				//*p_serial << "Measured: " << omegam_measured << endl;
				//*p_serial << "PWM Signal: " << output_correct << endl;
				*p_serial << omegam_measured << endl;
     aee:	f8 01       	movw	r30, r16
     af0:	66 8d       	ldd	r22, Z+30	; 0x1e
     af2:	77 8d       	ldd	r23, Z+31	; 0x1f
     af4:	86 81       	ldd	r24, Z+6	; 0x06
     af6:	97 81       	ldd	r25, Z+7	; 0x07
     af8:	0e 94 41 1a 	call	0x3482	; 0x3482 <_ZN8emstreamlsEi>
     afc:	66 e0       	ldi	r22, 0x06	; 6
     afe:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b02:	0f b6       	in	r0, 0x3f	; 63
     b04:	f8 94       	cli
     b06:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b08:	0f 90       	pop	r0
     b0a:	0f be       	out	0x3f, r0	; 63
			}
		
		if (leftLimitSwitch.get() || rightLimitSwitch.get())
     b0c:	80 91 49 31 	lds	r24, 0x3149	; 0x803149 <leftLimitSwitch>
     b10:	81 11       	cpse	r24, r1
     b12:	09 c0       	rjmp	.+18     	; 0xb26 <_ZN5Motor3runEv+0x2e2>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     b14:	0f b6       	in	r0, 0x3f	; 63
     b16:	f8 94       	cli
     b18:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     b1a:	0f 90       	pop	r0
     b1c:	0f be       	out	0x3f, r0	; 63
     b1e:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rightLimitSwitch>
     b22:	88 23       	and	r24, r24
     b24:	59 f0       	breq	.+22     	; 0xb3c <_ZN5Motor3runEv+0x2f8>
		{
			omegam_set = 0; // [ticks/ms]
     b26:	f8 01       	movw	r30, r16
     b28:	12 8e       	std	Z+26, r1	; 0x1a
     b2a:	13 8e       	std	Z+27, r1	; 0x1b
			//Pout = 0;
			//Iout = 0;
			_integral = 0;
     b2c:	f5 01       	movw	r30, r10
     b2e:	10 82       	st	Z, r1
     b30:	11 82       	std	Z+1, r1	; 0x01
     b32:	12 82       	std	Z+2, r1	; 0x02
     b34:	13 82       	std	Z+3, r1	; 0x03
			output_correct = 0;
     b36:	f6 01       	movw	r30, r12
     b38:	10 82       	st	Z, r1
     b3a:	11 82       	std	Z+1, r1	; 0x01
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     b3c:	0f b6       	in	r0, 0x3f	; 63
     b3e:	f8 94       	cli
     b40:	0f 92       	push	r0
			the_data = new_data;
     b42:	f6 01       	movw	r30, r12
     b44:	80 81       	ld	r24, Z
     b46:	91 81       	ldd	r25, Z+1	; 0x01
     b48:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <PWMvalue>
     b4c:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <PWMvalue+0x1>
			portEXIT_CRITICAL ();
     b50:	0f 90       	pop	r0
     b52:	0f be       	out	0x3f, r0	; 63
			}
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
     b54:	f8 01       	movw	r30, r16
     b56:	10 a6       	std	Z+40, r1	; 0x28
     b58:	11 a6       	std	Z+41, r1	; 0x29
		Im_set = Tset/K_T;
     b5a:	82 a1       	ldd	r24, Z+34	; 0x22
     b5c:	93 a1       	ldd	r25, Z+35	; 0x23
     b5e:	60 e0       	ldi	r22, 0x00	; 0
     b60:	70 e0       	ldi	r23, 0x00	; 0
     b62:	0e 94 57 1f 	call	0x3eae	; 0x3eae <__divmodhi4>
     b66:	7b 01       	movw	r14, r22

		// Saturater for current
		
		if(Im_set > 17.4) {
     b68:	07 2e       	mov	r0, r23
     b6a:	00 0c       	add	r0, r0
     b6c:	88 0b       	sbc	r24, r24
     b6e:	99 0b       	sbc	r25, r25
     b70:	0e 94 e3 1e 	call	0x3dc6	; 0x3dc6 <__floatsisf>
     b74:	2b 01       	movw	r4, r22
     b76:	3c 01       	movw	r6, r24
     b78:	23 e3       	ldi	r18, 0x33	; 51
     b7a:	33 e3       	ldi	r19, 0x33	; 51
     b7c:	4b e8       	ldi	r20, 0x8B	; 139
     b7e:	51 e4       	ldi	r21, 0x41	; 65
     b80:	0e 94 42 1f 	call	0x3e84	; 0x3e84 <__gesf2>
     b84:	18 16       	cp	r1, r24
     b86:	34 f4       	brge	.+12     	; 0xb94 <_ZN5Motor3runEv+0x350>
			Im_set = 17.4;
     b88:	81 e1       	ldi	r24, 0x11	; 17
     b8a:	90 e0       	ldi	r25, 0x00	; 0
     b8c:	f8 01       	movw	r30, r16
     b8e:	84 a3       	std	Z+36, r24	; 0x24
     b90:	95 a3       	std	Z+37, r25	; 0x25
     b92:	13 c0       	rjmp	.+38     	; 0xbba <_ZN5Motor3runEv+0x376>
		} else if(Im_set < -17.4) {
     b94:	23 e3       	ldi	r18, 0x33	; 51
     b96:	33 e3       	ldi	r19, 0x33	; 51
     b98:	4b e8       	ldi	r20, 0x8B	; 139
     b9a:	51 ec       	ldi	r21, 0xC1	; 193
     b9c:	c3 01       	movw	r24, r6
     b9e:	b2 01       	movw	r22, r4
     ba0:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <__cmpsf2>
     ba4:	88 23       	and	r24, r24
     ba6:	24 f0       	brlt	.+8      	; 0xbb0 <_ZN5Motor3runEv+0x36c>
		*/		
		

		
		K_T = 0.065; // Nm/A. Taken from Pittman 14203 series motor documentation page G 21
		Im_set = Tset/K_T;
     ba8:	f8 01       	movw	r30, r16
     baa:	e4 a2       	std	Z+36, r14	; 0x24
     bac:	f5 a2       	std	Z+37, r15	; 0x25
     bae:	05 c0       	rjmp	.+10     	; 0xbba <_ZN5Motor3runEv+0x376>
		// Saturater for current
		
		if(Im_set > 17.4) {
			Im_set = 17.4;
		} else if(Im_set < -17.4) {
			Im_set = -17.4;
     bb0:	8f ee       	ldi	r24, 0xEF	; 239
     bb2:	9f ef       	ldi	r25, 0xFF	; 255
     bb4:	f8 01       	movw	r30, r16
     bb6:	84 a3       	std	Z+36, r24	; 0x24
     bb8:	95 a3       	std	Z+37, r25	; 0x25
		//I_error = Im_set - I_actuator;

		// This sums the I_error. The [Kp/(Ti S)] block in diagram
		//i_error_sum = i_error_sum + I_error;

		K_v = 0.065; // V/rad/s. Taken from Pittman 14203 series motor documentation page G 21
     bba:	f8 01       	movw	r30, r16
     bbc:	16 aa       	std	Z+54, r1	; 0x36
     bbe:	17 aa       	std	Z+55, r1	; 0x37
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
     bc0:	12 aa       	std	Z+50, r1	; 0x32
     bc2:	13 aa       	std	Z+51, r1	; 0x33
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;
     bc4:	14 aa       	std	Z+52, r1	; 0x34
     bc6:	15 aa       	std	Z+53, r1	; 0x35

		V_m = V_R + V_E;
     bc8:	80 a9       	ldd	r24, Z+48	; 0x30
     bca:	91 a9       	ldd	r25, Z+49	; 0x31

		// Saturater for voltage
		if (V_m > 24) {
     bcc:	89 31       	cpi	r24, 0x19	; 25
     bce:	91 05       	cpc	r25, r1
     bd0:	2c f0       	brlt	.+10     	; 0xbdc <_ZN5Motor3runEv+0x398>
			V_m = 24;
     bd2:	88 e1       	ldi	r24, 0x18	; 24
     bd4:	90 e0       	ldi	r25, 0x00	; 0
     bd6:	80 af       	std	Z+56, r24	; 0x38
     bd8:	91 af       	std	Z+57, r25	; 0x39
     bda:	0d c0       	rjmp	.+26     	; 0xbf6 <_ZN5Motor3runEv+0x3b2>
		} else if(V_m < -24) {
     bdc:	88 3e       	cpi	r24, 0xE8	; 232
     bde:	ff ef       	ldi	r31, 0xFF	; 255
     be0:	9f 07       	cpc	r25, r31
     be2:	24 f0       	brlt	.+8      	; 0xbec <_ZN5Motor3runEv+0x3a8>
		K_p = K_T*(1/1.21E-5)*K_v; // (Nm/A)([rad/s]/Nm)(V/[rad/s]) so (V/A)
		//V_R = i_error_sum - K_p*I_actuator;

		V_E = K_v*omegam_measured;

		V_m = V_R + V_E;
     be4:	f8 01       	movw	r30, r16
     be6:	80 af       	std	Z+56, r24	; 0x38
     be8:	91 af       	std	Z+57, r25	; 0x39
     bea:	05 c0       	rjmp	.+10     	; 0xbf6 <_ZN5Motor3runEv+0x3b2>

		// Saturater for voltage
		if (V_m > 24) {
			V_m = 24;
		} else if(V_m < -24) {
			V_m = -24;
     bec:	88 ee       	ldi	r24, 0xE8	; 232
     bee:	9f ef       	ldi	r25, 0xFF	; 255
     bf0:	f8 01       	movw	r30, r16
     bf2:	80 af       	std	Z+56, r24	; 0x38
     bf4:	91 af       	std	Z+57, r25	; 0x39

		// set dt
		// This is a method we use to cause a task to make one run through its task
		// loop every N milliseconds and let other tasks run at other times
		
		delay_from_to (previousTicks, configMS_TO_TICKS (dt));
     bf6:	f4 01       	movw	r30, r8
     bf8:	20 81       	ld	r18, Z
     bfa:	31 81       	ldd	r19, Z+1	; 0x01
     bfc:	42 81       	ldd	r20, Z+2	; 0x02
     bfe:	53 81       	ldd	r21, Z+3	; 0x03
     c00:	a8 ee       	ldi	r26, 0xE8	; 232
     c02:	b3 e0       	ldi	r27, 0x03	; 3
     c04:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <__muluhisi3>
     c08:	68 3e       	cpi	r22, 0xE8	; 232
     c0a:	f3 e0       	ldi	r31, 0x03	; 3
     c0c:	7f 07       	cpc	r23, r31
     c0e:	81 05       	cpc	r24, r1
     c10:	91 05       	cpc	r25, r1
     c12:	48 f0       	brcs	.+18     	; 0xc26 <_ZN5Motor3runEv+0x3e2>
     c14:	28 ee       	ldi	r18, 0xE8	; 232
     c16:	33 e0       	ldi	r19, 0x03	; 3
     c18:	40 e0       	ldi	r20, 0x00	; 0
     c1a:	50 e0       	ldi	r21, 0x00	; 0
     c1c:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <__udivmodsi4>
     c20:	ba 01       	movw	r22, r20
     c22:	a9 01       	movw	r20, r18
     c24:	04 c0       	rjmp	.+8      	; 0xc2e <_ZN5Motor3runEv+0x3ea>
     c26:	41 e0       	ldi	r20, 0x01	; 1
     c28:	50 e0       	ldi	r21, 0x00	; 0
     c2a:	60 e0       	ldi	r22, 0x00	; 0
     c2c:	70 e0       	ldi	r23, 0x00	; 0
     c2e:	ce 01       	movw	r24, r28
     c30:	01 96       	adiw	r24, 0x01	; 1
     c32:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <vTaskDelayUntil>
     c36:	58 ce       	rjmp	.-848    	; 0x8e8 <_ZN5Motor3runEv+0xa4>

00000c38 <_ZN5MotorC1EPKchjP8emstream>:
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file
#include "satmath.h"


Motor::Motor(const char* a_name,
     c38:	0f 93       	push	r16
     c3a:	1f 93       	push	r17
     c3c:	cf 93       	push	r28
     c3e:	df 93       	push	r29
     c40:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     c42:	0e 94 95 14 	call	0x292a	; 0x292a <_ZN8frt_taskC1EPKchjP8emstream>
     c46:	82 e2       	ldi	r24, 0x22	; 34
     c48:	90 e2       	ldi	r25, 0x20	; 32
     c4a:	88 83       	st	Y, r24
     c4c:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     c4e:	df 91       	pop	r29
     c50:	cf 91       	pop	r28
     c52:	1f 91       	pop	r17
     c54:	0f 91       	pop	r16
     c56:	08 95       	ret

00000c58 <_ZN9PWMdriver3runEv>:
		// Nothing to do in this constructor other than call the parent constructor
	}



void PWMdriver::run(void){
     c58:	cf 93       	push	r28
     c5a:	df 93       	push	r29
     c5c:	00 d0       	rcall	.+0      	; 0xc5e <_ZN9PWMdriver3runEv+0x6>
     c5e:	1f 92       	push	r1
     c60:	cd b7       	in	r28, 0x3d	; 61
     c62:	de b7       	in	r29, 0x3e	; 62
     c64:	7c 01       	movw	r14, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     c66:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskGetTickCount>
     c6a:	69 83       	std	Y+1, r22	; 0x01
     c6c:	7a 83       	std	Y+2, r23	; 0x02
     c6e:	8b 83       	std	Y+3, r24	; 0x03
     c70:	9c 83       	std	Y+4, r25	; 0x04
	//PC0 - MD0
	//PC1 - MD1
	
	PORTC.DIRSET = PIN0_bm | PIN1_bm | PIN2_bm;			// Configure PC0 and PC1 as outputs
     c72:	a0 e4       	ldi	r26, 0x40	; 64
     c74:	b6 e0       	ldi	r27, 0x06	; 6
     c76:	87 e0       	ldi	r24, 0x07	; 7
     c78:	11 96       	adiw	r26, 0x01	; 1
     c7a:	8c 93       	st	X, r24
     c7c:	11 97       	sbiw	r26, 0x01	; 1
	PORTC.OUTSET = PIN2_bm;								// disable sleep mode
     c7e:	84 e0       	ldi	r24, 0x04	; 4
     c80:	15 96       	adiw	r26, 0x05	; 5
     c82:	8c 93       	st	X, r24
     c84:	15 97       	sbiw	r26, 0x05	; 5
	TCC0.CTRLA = TC0_CLKSEL0_bm;						// Configures Clock select bits for divide by 1
     c86:	e0 e0       	ldi	r30, 0x00	; 0
     c88:	f8 e0       	ldi	r31, 0x08	; 8
     c8a:	81 e0       	ldi	r24, 0x01	; 1
     c8c:	80 83       	st	Z, r24
	TCC0.CTRLB = TC0_WGMODE0_bm | TC0_WGMODE1_bm;		// Configures waveform generation mode to single slope PWM
     c8e:	83 e0       	ldi	r24, 0x03	; 3
     c90:	81 83       	std	Z+1, r24	; 0x01
	TCC0.PER = 1600;									// Configures period to be 320 counts for a pwm freq 20kHz with 20% duty cycle
     c92:	a6 a3       	std	Z+38, r26	; 0x26
     c94:	b7 a3       	std	Z+39, r27	; 0x27
	TCC0.CCA = 0;										// Ensure channel A is off when enabled
     c96:	10 a6       	std	Z+40, r1	; 0x28
     c98:	11 a6       	std	Z+41, r1	; 0x29
	TCC0.CCB  = 0;										// Ensure channel B is off when enabled
     c9a:	12 a6       	std	Z+42, r1	; 0x2a
     c9c:	13 a6       	std	Z+43, r1	; 0x2b
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
     c9e:	81 81       	ldd	r24, Z+1	; 0x01
     ca0:	80 63       	ori	r24, 0x30	; 48
     ca2:	81 83       	std	Z+1, r24	; 0x01
	
	while(1){
		// Increment counter for debugging
		runs++;
		
		TCC0.CCA = PWMvalue.get();
     ca4:	00 e0       	ldi	r16, 0x00	; 0
     ca6:	18 e0       	ldi	r17, 0x08	; 8
	
	TCC0.CTRLB |= TC0_CCAEN_bm | TC0_CCBEN_bm;			// Enable output compare on channels A and B
	
	while(1){
		// Increment counter for debugging
		runs++;
     ca8:	f7 01       	movw	r30, r14
     caa:	86 85       	ldd	r24, Z+14	; 0x0e
     cac:	97 85       	ldd	r25, Z+15	; 0x0f
     cae:	a0 89       	ldd	r26, Z+16	; 0x10
     cb0:	b1 89       	ldd	r27, Z+17	; 0x11
     cb2:	01 96       	adiw	r24, 0x01	; 1
     cb4:	a1 1d       	adc	r26, r1
     cb6:	b1 1d       	adc	r27, r1
     cb8:	86 87       	std	Z+14, r24	; 0x0e
     cba:	97 87       	std	Z+15, r25	; 0x0f
     cbc:	a0 8b       	std	Z+16, r26	; 0x10
     cbe:	b1 8b       	std	Z+17, r27	; 0x11
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     cc0:	0f b6       	in	r0, 0x3f	; 63
     cc2:	f8 94       	cli
     cc4:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cc6:	0f 90       	pop	r0
     cc8:	0f be       	out	0x3f, r0	; 63
		
		TCC0.CCA = PWMvalue.get();
     cca:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <PWMvalue>
     cce:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <PWMvalue+0x1>
     cd2:	f8 01       	movw	r30, r16
     cd4:	80 a7       	std	Z+40, r24	; 0x28
     cd6:	91 a7       	std	Z+41, r25	; 0x29
		TCC0.CCB = 0;
     cd8:	12 a6       	std	Z+42, r1	; 0x2a
     cda:	13 a6       	std	Z+43, r1	; 0x2b
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     cdc:	0f b6       	in	r0, 0x3f	; 63
     cde:	f8 94       	cli
     ce0:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     ce2:	0f 90       	pop	r0
     ce4:	0f be       	out	0x3f, r0	; 63
		if(runs%100==0){
			*p_serial << PWMvalue.get() << endl;
		}	
		*/
		
		if (!leftLimitSwitch.get() && !rightLimitSwitch.get())
     ce6:	20 91 49 31 	lds	r18, 0x3149	; 0x803149 <leftLimitSwitch>
     cea:	21 11       	cpse	r18, r1
     cec:	12 c0       	rjmp	.+36     	; 0xd12 <_ZN9PWMdriver3runEv+0xba>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     cf4:	0f 90       	pop	r0
     cf6:	0f be       	out	0x3f, r0	; 63
     cf8:	20 91 48 31 	lds	r18, 0x3148	; 0x803148 <rightLimitSwitch>
     cfc:	21 11       	cpse	r18, r1
     cfe:	09 c0       	rjmp	.+18     	; 0xd12 <_ZN9PWMdriver3runEv+0xba>
			// It's necessary to make an extra, temporary copy of the data so that the
			// temporary copy can be returned. We can't call return() from within the
			// critical section for reasons that are obvious if you think about it
			data_type temporary_copy;

			portENTER_CRITICAL ();
     d00:	0f b6       	in	r0, 0x3f	; 63
     d02:	f8 94       	cli
     d04:	0f 92       	push	r0
			temporary_copy = the_data;
			portEXIT_CRITICAL ();
     d06:	0f 90       	pop	r0
     d08:	0f be       	out	0x3f, r0	; 63
		{
			TCC0.CCA = PWMvalue.get();
     d0a:	80 a7       	std	Z+40, r24	; 0x28
     d0c:	91 a7       	std	Z+41, r25	; 0x29
			TCC0.CCB = 0;
     d0e:	12 a6       	std	Z+42, r1	; 0x2a
     d10:	13 a6       	std	Z+43, r1	; 0x2b
     d12:	44 e1       	ldi	r20, 0x14	; 20
     d14:	50 e0       	ldi	r21, 0x00	; 0
     d16:	60 e0       	ldi	r22, 0x00	; 0
     d18:	70 e0       	ldi	r23, 0x00	; 0
     d1a:	ce 01       	movw	r24, r28
     d1c:	01 96       	adiw	r24, 0x01	; 1
     d1e:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <vTaskDelayUntil>
     d22:	c2 cf       	rjmp	.-124    	; 0xca8 <_ZN9PWMdriver3runEv+0x50>

00000d24 <_ZN9PWMdriverC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

PWMdriver::PWMdriver(const char* a_name,
     d24:	0f 93       	push	r16
     d26:	1f 93       	push	r17
     d28:	cf 93       	push	r28
     d2a:	df 93       	push	r29
     d2c:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d2e:	0e 94 95 14 	call	0x292a	; 0x292a <_ZN8frt_taskC1EPKchjP8emstream>
     d32:	8a e2       	ldi	r24, 0x2A	; 42
     d34:	90 e2       	ldi	r25, 0x20	; 32
     d36:	88 83       	st	Y, r24
     d38:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     d3a:	df 91       	pop	r29
     d3c:	cf 91       	pop	r28
     d3e:	1f 91       	pop	r17
     d40:	0f 91       	pop	r16
     d42:	08 95       	ret

00000d44 <_ZN7satmath20signed_saturated_addEii>:
 *  @return Absolute value
 */
int16_t satmath::saturated_abs(int16_t x)
{
	return (x == 0x8000L) ? 0x7fffL:abs(x);
}
     d44:	9c 01       	movw	r18, r24
     d46:	93 2f       	mov	r25, r19
     d48:	99 1f       	adc	r25, r25
     d4a:	99 27       	eor	r25, r25
     d4c:	99 1f       	adc	r25, r25
     d4e:	89 2f       	mov	r24, r25
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	81 50       	subi	r24, 0x01	; 1
     d54:	90 48       	sbci	r25, 0x80	; 128
     d56:	43 2f       	mov	r20, r19
     d58:	40 95       	com	r20
     d5a:	44 1f       	adc	r20, r20
     d5c:	44 27       	eor	r20, r20
     d5e:	44 1f       	adc	r20, r20
     d60:	fc 01       	movw	r30, r24
     d62:	e2 1b       	sub	r30, r18
     d64:	f3 0b       	sbc	r31, r19
     d66:	51 e0       	ldi	r21, 0x01	; 1
     d68:	e6 17       	cp	r30, r22
     d6a:	f7 07       	cpc	r31, r23
     d6c:	0c f0       	brlt	.+2      	; 0xd70 <_ZN7satmath20signed_saturated_addEii+0x2c>
     d6e:	50 e0       	ldi	r21, 0x00	; 0
     d70:	45 17       	cp	r20, r21
     d72:	19 f0       	breq	.+6      	; 0xd7a <_ZN7satmath20signed_saturated_addEii+0x36>
     d74:	c9 01       	movw	r24, r18
     d76:	86 0f       	add	r24, r22
     d78:	97 1f       	adc	r25, r23
     d7a:	08 95       	ret

00000d7c <_ZN7satmath20signed_saturated_mulEii>:
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     d7c:	81 15       	cp	r24, r1
     d7e:	20 e8       	ldi	r18, 0x80	; 128
     d80:	92 07       	cpc	r25, r18
     d82:	21 f4       	brne	.+8      	; 0xd8c <_ZN7satmath20signed_saturated_mulEii+0x10>
     d84:	61 15       	cp	r22, r1
     d86:	20 e8       	ldi	r18, 0x80	; 128
     d88:	72 07       	cpc	r23, r18
     d8a:	29 f0       	breq	.+10     	; 0xd96 <_ZN7satmath20signed_saturated_mulEii+0x1a>
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
     d8c:	9c 01       	movw	r18, r24
     d8e:	db 01       	movw	r26, r22
     d90:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <__mulhisi3>
     d94:	08 95       	ret
 *  @param y Multiplier
 *  @return Product
 */
int32_t satmath::signed_saturated_mul(int16_t x, int16_t y)
{
	if (x==INT16_MIN && y==INT16_MIN) return INT32_MAX;
     d96:	6f ef       	ldi	r22, 0xFF	; 255
     d98:	7f ef       	ldi	r23, 0xFF	; 255
     d9a:	8f ef       	ldi	r24, 0xFF	; 255
     d9c:	9f e7       	ldi	r25, 0x7F	; 127
	return (int32_t)(int16_t)x * (int32_t)(int16_t)y;
}
     d9e:	08 95       	ret

00000da0 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     da0:	0f 93       	push	r16
     da2:	1f 93       	push	r17
     da4:	cf 93       	push	r28
     da6:	df 93       	push	r29
     da8:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     daa:	0e 94 95 14 	call	0x292a	; 0x292a <_ZN8frt_taskC1EPKchjP8emstream>
     dae:	82 e3       	ldi	r24, 0x32	; 50
     db0:	90 e2       	ldi	r25, 0x20	; 32
     db2:	88 83       	st	Y, r24
     db4:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     db6:	df 91       	pop	r29
     db8:	cf 91       	pop	r28
     dba:	1f 91       	pop	r17
     dbc:	0f 91       	pop	r16
     dbe:	08 95       	ret

00000dc0 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     dc0:	0f 93       	push	r16
     dc2:	1f 93       	push	r17
     dc4:	cf 93       	push	r28
     dc6:	df 93       	push	r29
     dc8:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     dca:	6a e0       	ldi	r22, 0x0A	; 10
     dcc:	8e 81       	ldd	r24, Y+6	; 0x06
     dce:	9f 81       	ldd	r25, Y+7	; 0x07
     dd0:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     dd4:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     dd6:	6d ee       	ldi	r22, 0xED	; 237
     dd8:	73 e0       	ldi	r23, 0x03	; 3
     dda:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     dde:	6a e0       	ldi	r22, 0x0A	; 10
     de0:	c8 01       	movw	r24, r16
     de2:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     de6:	8c 01       	movw	r16, r24
     de8:	67 ee       	ldi	r22, 0xE7	; 231
     dea:	73 e0       	ldi	r23, 0x03	; 3
     dec:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     df0:	67 e0       	ldi	r22, 0x07	; 7
     df2:	c8 01       	movw	r24, r16
     df4:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     df8:	6a e0       	ldi	r22, 0x0A	; 10
     dfa:	8e 81       	ldd	r24, Y+6	; 0x06
     dfc:	9f 81       	ldd	r25, Y+7	; 0x07
     dfe:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     e02:	8c 01       	movw	r16, r24
     e04:	68 ec       	ldi	r22, 0xC8	; 200
     e06:	73 e0       	ldi	r23, 0x03	; 3
     e08:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     e0c:	6a e0       	ldi	r22, 0x0A	; 10
     e0e:	c8 01       	movw	r24, r16
     e10:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     e14:	8c 01       	movw	r16, r24
     e16:	62 ec       	ldi	r22, 0xC2	; 194
     e18:	73 e0       	ldi	r23, 0x03	; 3
     e1a:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     e1e:	66 e0       	ldi	r22, 0x06	; 6
     e20:	c8 01       	movw	r24, r16
     e22:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     e26:	6a e0       	ldi	r22, 0x0A	; 10
     e28:	8e 81       	ldd	r24, Y+6	; 0x06
     e2a:	9f 81       	ldd	r25, Y+7	; 0x07
     e2c:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     e30:	8c 01       	movw	r16, r24
     e32:	6b ea       	ldi	r22, 0xAB	; 171
     e34:	73 e0       	ldi	r23, 0x03	; 3
     e36:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     e3a:	66 e0       	ldi	r22, 0x06	; 6
     e3c:	c8 01       	movw	r24, r16
     e3e:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     e42:	6a e0       	ldi	r22, 0x0A	; 10
     e44:	8e 81       	ldd	r24, Y+6	; 0x06
     e46:	9f 81       	ldd	r25, Y+7	; 0x07
     e48:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     e4c:	8c 01       	movw	r16, r24
     e4e:	6f e8       	ldi	r22, 0x8F	; 143
     e50:	73 e0       	ldi	r23, 0x03	; 3
     e52:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     e56:	66 e0       	ldi	r22, 0x06	; 6
     e58:	c8 01       	movw	r24, r16
     e5a:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     e5e:	6a e0       	ldi	r22, 0x0A	; 10
     e60:	8e 81       	ldd	r24, Y+6	; 0x06
     e62:	9f 81       	ldd	r25, Y+7	; 0x07
     e64:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     e68:	8c 01       	movw	r16, r24
     e6a:	67 e7       	ldi	r22, 0x77	; 119
     e6c:	73 e0       	ldi	r23, 0x03	; 3
     e6e:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     e72:	66 e0       	ldi	r22, 0x06	; 6
     e74:	c8 01       	movw	r24, r16
     e76:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     e7a:	6a e0       	ldi	r22, 0x0A	; 10
     e7c:	8e 81       	ldd	r24, Y+6	; 0x06
     e7e:	9f 81       	ldd	r25, Y+7	; 0x07
     e80:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     e84:	8c 01       	movw	r16, r24
     e86:	66 e5       	ldi	r22, 0x56	; 86
     e88:	73 e0       	ldi	r23, 0x03	; 3
     e8a:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     e8e:	66 e0       	ldi	r22, 0x06	; 6
     e90:	c8 01       	movw	r24, r16
     e92:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     e96:	6a e0       	ldi	r22, 0x0A	; 10
     e98:	8e 81       	ldd	r24, Y+6	; 0x06
     e9a:	9f 81       	ldd	r25, Y+7	; 0x07
     e9c:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     ea0:	8c 01       	movw	r16, r24
     ea2:	6f e2       	ldi	r22, 0x2F	; 47
     ea4:	73 e0       	ldi	r23, 0x03	; 3
     ea6:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     eaa:	66 e0       	ldi	r22, 0x06	; 6
     eac:	c8 01       	movw	r24, r16
     eae:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     eb2:	6a e0       	ldi	r22, 0x0A	; 10
     eb4:	8e 81       	ldd	r24, Y+6	; 0x06
     eb6:	9f 81       	ldd	r25, Y+7	; 0x07
     eb8:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     ebc:	8c 01       	movw	r16, r24
     ebe:	61 e1       	ldi	r22, 0x11	; 17
     ec0:	73 e0       	ldi	r23, 0x03	; 3
     ec2:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     ec6:	66 e0       	ldi	r22, 0x06	; 6
     ec8:	c8 01       	movw	r24, r16
     eca:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     ece:	6a e0       	ldi	r22, 0x0A	; 10
     ed0:	8e 81       	ldd	r24, Y+6	; 0x06
     ed2:	9f 81       	ldd	r25, Y+7	; 0x07
     ed4:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     ed8:	8c 01       	movw	r16, r24
     eda:	66 ef       	ldi	r22, 0xF6	; 246
     edc:	72 e0       	ldi	r23, 0x02	; 2
     ede:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     ee2:	66 e0       	ldi	r22, 0x06	; 6
     ee4:	c8 01       	movw	r24, r16
     ee6:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     eea:	6a e0       	ldi	r22, 0x0A	; 10
     eec:	8e 81       	ldd	r24, Y+6	; 0x06
     eee:	9f 81       	ldd	r25, Y+7	; 0x07
     ef0:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     ef4:	ec 01       	movw	r28, r24
     ef6:	67 ee       	ldi	r22, 0xE7	; 231
     ef8:	72 e0       	ldi	r23, 0x02	; 2
     efa:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     efe:	66 e0       	ldi	r22, 0x06	; 6
     f00:	ce 01       	movw	r24, r28
     f02:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
}
     f06:	df 91       	pop	r29
     f08:	cf 91       	pop	r28
     f0a:	1f 91       	pop	r17
     f0c:	0f 91       	pop	r16
     f0e:	08 95       	ret

00000f10 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     f10:	af 92       	push	r10
     f12:	bf 92       	push	r11
     f14:	cf 92       	push	r12
     f16:	df 92       	push	r13
     f18:	ef 92       	push	r14
     f1a:	ff 92       	push	r15
     f1c:	0f 93       	push	r16
     f1e:	1f 93       	push	r17
     f20:	cf 93       	push	r28
     f22:	df 93       	push	r29
     f24:	00 d0       	rcall	.+0      	; 0xf26 <_ZN9task_user11show_statusEv+0x16>
     f26:	00 d0       	rcall	.+0      	; 0xf28 <_ZN9task_user11show_statusEv+0x18>
     f28:	cd b7       	in	r28, 0x3d	; 61
     f2a:	de b7       	in	r29, 0x3e	; 62
     f2c:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     f2e:	19 82       	std	Y+1, r1	; 0x01
     f30:	1a 82       	std	Y+2, r1	; 0x02
     f32:	1b 82       	std	Y+3, r1	; 0x03
     f34:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     f36:	1d 82       	std	Y+5, r1	; 0x05
     f38:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     f3a:	0e 94 0d 0a 	call	0x141a	; 0x141a <xPortGetFreeHeapSize>
     f3e:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     f40:	ce 01       	movw	r24, r28
     f42:	01 96       	adiw	r24, 0x01	; 1
     f44:	0e 94 46 18 	call	0x308c	; 0x308c <_ZN10time_stamp10set_to_nowEv>
     f48:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     f4a:	66 e0       	ldi	r22, 0x06	; 6
     f4c:	f8 01       	movw	r30, r16
     f4e:	86 81       	ldd	r24, Z+6	; 0x06
     f50:	97 81       	ldd	r25, Z+7	; 0x07
     f52:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     f56:	6a e0       	ldi	r22, 0x0A	; 10
     f58:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     f5c:	7c 01       	movw	r14, r24
     f5e:	68 ec       	ldi	r22, 0xC8	; 200
     f60:	72 e0       	ldi	r23, 0x02	; 2
     f62:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     f66:	6a e0       	ldi	r22, 0x0A	; 10
     f68:	c7 01       	movw	r24, r14
     f6a:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     f6e:	7c 01       	movw	r14, r24
     f70:	6c eb       	ldi	r22, 0xBC	; 188
     f72:	72 e0       	ldi	r23, 0x02	; 2
     f74:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     f78:	66 e0       	ldi	r22, 0x06	; 6
     f7a:	c7 01       	movw	r24, r14
     f7c:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     f80:	6a e0       	ldi	r22, 0x0A	; 10
     f82:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     f86:	7c 01       	movw	r14, r24
     f88:	65 eb       	ldi	r22, 0xB5	; 181
     f8a:	72 e0       	ldi	r23, 0x02	; 2
     f8c:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     f90:	b5 01       	movw	r22, r10
     f92:	c7 01       	movw	r24, r14
     f94:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     f98:	6a e0       	ldi	r22, 0x0A	; 10
     f9a:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     f9e:	7c 01       	movw	r14, r24
     fa0:	67 ea       	ldi	r22, 0xA7	; 167
     fa2:	72 e0       	ldi	r23, 0x02	; 2
     fa4:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     fa8:	b6 01       	movw	r22, r12
     faa:	c7 01       	movw	r24, r14
     fac:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <_ZN8emstreamlsEj>
     fb0:	6a e0       	ldi	r22, 0x0A	; 10
     fb2:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     fb6:	7c 01       	movw	r14, r24
     fb8:	65 ea       	ldi	r22, 0xA5	; 165
     fba:	72 e0       	ldi	r23, 0x02	; 2
     fbc:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     fc0:	4f ef       	ldi	r20, 0xFF	; 255
     fc2:	5f e0       	ldi	r21, 0x0F	; 15
     fc4:	60 e0       	ldi	r22, 0x00	; 0
     fc6:	70 e0       	ldi	r23, 0x00	; 0
     fc8:	c7 01       	movw	r24, r14
     fca:	0e 94 9e 1a 	call	0x353c	; 0x353c <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     fce:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     fd2:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     fd6:	6a e0       	ldi	r22, 0x0A	; 10
     fd8:	f8 01       	movw	r30, r16
     fda:	86 81       	ldd	r24, Z+6	; 0x06
     fdc:	97 81       	ldd	r25, Z+7	; 0x07
     fde:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     fe2:	7c 01       	movw	r14, r24
     fe4:	6a e9       	ldi	r22, 0x9A	; 154
     fe6:	72 e0       	ldi	r23, 0x02	; 2
     fe8:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
     fec:	b6 01       	movw	r22, r12
     fee:	c7 01       	movw	r24, r14
     ff0:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <_ZN8emstreamlsEj>
     ff4:	66 e0       	ldi	r22, 0x06	; 6
     ff6:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
     ffa:	66 e0       	ldi	r22, 0x06	; 6
     ffc:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1000:	f8 01       	movw	r30, r16
    1002:	86 81       	ldd	r24, Z+6	; 0x06
    1004:	97 81       	ldd	r25, Z+7	; 0x07
    1006:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <_Z15print_task_listP8emstream>
}
    100a:	26 96       	adiw	r28, 0x06	; 6
    100c:	cd bf       	out	0x3d, r28	; 61
    100e:	de bf       	out	0x3e, r29	; 62
    1010:	df 91       	pop	r29
    1012:	cf 91       	pop	r28
    1014:	1f 91       	pop	r17
    1016:	0f 91       	pop	r16
    1018:	ff 90       	pop	r15
    101a:	ef 90       	pop	r14
    101c:	df 90       	pop	r13
    101e:	cf 90       	pop	r12
    1020:	bf 90       	pop	r11
    1022:	af 90       	pop	r10
    1024:	08 95       	ret

00001026 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1026:	cf 93       	push	r28
    1028:	df 93       	push	r29
    102a:	00 d0       	rcall	.+0      	; 0x102c <_ZN9task_user3runEv+0x6>
    102c:	00 d0       	rcall	.+0      	; 0x102e <_ZN9task_user3runEv+0x8>
    102e:	cd b7       	in	r28, 0x3d	; 61
    1030:	de b7       	in	r29, 0x3e	; 62
    1032:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1034:	19 82       	std	Y+1, r1	; 0x01
    1036:	1a 82       	std	Y+2, r1	; 0x02
    1038:	1b 82       	std	Y+3, r1	; 0x03
    103a:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    103c:	1d 82       	std	Y+5, r1	; 0x05
    103e:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1040:	6a e0       	ldi	r22, 0x0A	; 10
    1042:	dc 01       	movw	r26, r24
    1044:	16 96       	adiw	r26, 0x06	; 6
    1046:	8d 91       	ld	r24, X+
    1048:	9c 91       	ld	r25, X
    104a:	17 97       	sbiw	r26, 0x07	; 7
    104c:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    1050:	7c 01       	movw	r14, r24
    1052:	66 e3       	ldi	r22, 0x36	; 54
    1054:	74 e0       	ldi	r23, 0x04	; 4
    1056:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    105a:	66 e0       	ldi	r22, 0x06	; 6
    105c:	c7 01       	movw	r24, r14
    105e:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1062:	f8 01       	movw	r30, r16
    1064:	84 85       	ldd	r24, Z+12	; 0x0c
    1066:	88 23       	and	r24, r24
    1068:	21 f0       	breq	.+8      	; 0x1072 <_ZN9task_user3runEv+0x4c>
    106a:	81 30       	cpi	r24, 0x01	; 1
    106c:	09 f4       	brne	.+2      	; 0x1070 <_ZN9task_user3runEv+0x4a>
    106e:	5d c0       	rjmp	.+186    	; 0x112a <_ZN9task_user3runEv+0x104>
    1070:	d8 c0       	rjmp	.+432    	; 0x1222 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1072:	86 81       	ldd	r24, Z+6	; 0x06
    1074:	97 81       	ldd	r25, Z+7	; 0x07
    1076:	dc 01       	movw	r26, r24
    1078:	ed 91       	ld	r30, X+
    107a:	fc 91       	ld	r31, X
    107c:	04 80       	ldd	r0, Z+4	; 0x04
    107e:	f5 81       	ldd	r31, Z+5	; 0x05
    1080:	e0 2d       	mov	r30, r0
    1082:	19 95       	eicall
    1084:	88 23       	and	r24, r24
    1086:	a9 f1       	breq	.+106    	; 0x10f2 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1088:	f8 01       	movw	r30, r16
    108a:	86 81       	ldd	r24, Z+6	; 0x06
    108c:	97 81       	ldd	r25, Z+7	; 0x07
    108e:	dc 01       	movw	r26, r24
    1090:	ed 91       	ld	r30, X+
    1092:	fc 91       	ld	r31, X
    1094:	06 80       	ldd	r0, Z+6	; 0x06
    1096:	f7 81       	ldd	r31, Z+7	; 0x07
    1098:	e0 2d       	mov	r30, r0
    109a:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    109c:	99 27       	eor	r25, r25
    109e:	81 30       	cpi	r24, 0x01	; 1
    10a0:	91 05       	cpc	r25, r1
    10a2:	f9 f0       	breq	.+62     	; 0x10e2 <_ZN9task_user3runEv+0xbc>
    10a4:	03 97       	sbiw	r24, 0x03	; 3
    10a6:	09 f0       	breq	.+2      	; 0x10aa <_ZN9task_user3runEv+0x84>
    10a8:	d8 c0       	rjmp	.+432    	; 0x125a <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    10aa:	6a e0       	ldi	r22, 0x0A	; 10
    10ac:	f8 01       	movw	r30, r16
    10ae:	86 81       	ldd	r24, Z+6	; 0x06
    10b0:	97 81       	ldd	r25, Z+7	; 0x07
    10b2:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    10b6:	8c 01       	movw	r16, r24
    10b8:	68 e2       	ldi	r22, 0x28	; 40
    10ba:	74 e0       	ldi	r23, 0x04	; 4
    10bc:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    10c0:	66 e0       	ldi	r22, 0x06	; 6
    10c2:	c8 01       	movw	r24, r16
    10c4:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    10c8:	93 e0       	ldi	r25, 0x03	; 3
    10ca:	88 ed       	ldi	r24, 0xD8	; 216
    10cc:	08 b6       	in	r0, 0x38	; 56
    10ce:	18 be       	out	0x38, r1	; 56
    10d0:	84 bf       	out	0x34, r24	; 52
    10d2:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    10d6:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    10da:	81 fd       	sbrc	r24, 1
    10dc:	fc cf       	rjmp	.-8      	; 0x10d6 <_ZN9task_user3runEv+0xb0>
    10de:	08 be       	out	0x38, r0	; 56
    10e0:	ff cf       	rjmp	.-2      	; 0x10e0 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    10e2:	c8 01       	movw	r24, r16
    10e4:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    10e8:	61 e0       	ldi	r22, 0x01	; 1
    10ea:	c8 01       	movw	r24, r16
    10ec:	0e 94 91 14 	call	0x2922	; 0x2922 <_ZN8frt_task13transition_toEh>
							break;
    10f0:	b4 c0       	rjmp	.+360    	; 0x125a <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    10f2:	80 e5       	ldi	r24, 0x50	; 80
    10f4:	91 e3       	ldi	r25, 0x31	; 49
    10f6:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <_ZN14frt_text_queue14check_for_charEv>
    10fa:	88 23       	and	r24, r24
    10fc:	09 f4       	brne	.+2      	; 0x1100 <_ZN9task_user3runEv+0xda>
    10fe:	ad c0       	rjmp	.+346    	; 0x125a <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1100:	d8 01       	movw	r26, r16
    1102:	16 96       	adiw	r26, 0x06	; 6
    1104:	ed 91       	ld	r30, X+
    1106:	fc 91       	ld	r31, X
    1108:	17 97       	sbiw	r26, 0x07	; 7
    110a:	01 90       	ld	r0, Z+
    110c:	f0 81       	ld	r31, Z
    110e:	e0 2d       	mov	r30, r0
    1110:	e2 80       	ldd	r14, Z+2	; 0x02
    1112:	f3 80       	ldd	r15, Z+3	; 0x03
    1114:	80 e5       	ldi	r24, 0x50	; 80
    1116:	91 e3       	ldi	r25, 0x31	; 49
    1118:	0e 94 34 17 	call	0x2e68	; 0x2e68 <_ZN14frt_text_queue7getcharEv>
    111c:	68 2f       	mov	r22, r24
    111e:	f8 01       	movw	r30, r16
    1120:	86 81       	ldd	r24, Z+6	; 0x06
    1122:	97 81       	ldd	r25, Z+7	; 0x07
    1124:	f7 01       	movw	r30, r14
    1126:	19 95       	eicall
    1128:	98 c0       	rjmp	.+304    	; 0x125a <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    112a:	86 81       	ldd	r24, Z+6	; 0x06
    112c:	97 81       	ldd	r25, Z+7	; 0x07
    112e:	dc 01       	movw	r26, r24
    1130:	ed 91       	ld	r30, X+
    1132:	fc 91       	ld	r31, X
    1134:	04 80       	ldd	r0, Z+4	; 0x04
    1136:	f5 81       	ldd	r31, Z+5	; 0x05
    1138:	e0 2d       	mov	r30, r0
    113a:	19 95       	eicall
    113c:	88 23       	and	r24, r24
    113e:	09 f4       	brne	.+2      	; 0x1142 <_ZN9task_user3runEv+0x11c>
    1140:	8c c0       	rjmp	.+280    	; 0x125a <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1142:	f8 01       	movw	r30, r16
    1144:	86 81       	ldd	r24, Z+6	; 0x06
    1146:	97 81       	ldd	r25, Z+7	; 0x07
    1148:	dc 01       	movw	r26, r24
    114a:	ed 91       	ld	r30, X+
    114c:	fc 91       	ld	r31, X
    114e:	06 80       	ldd	r0, Z+6	; 0x06
    1150:	f7 81       	ldd	r31, Z+7	; 0x07
    1152:	e0 2d       	mov	r30, r0
    1154:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1156:	9c 01       	movw	r18, r24
    1158:	33 27       	eor	r19, r19
    115a:	28 36       	cpi	r18, 0x68	; 104
    115c:	31 05       	cpc	r19, r1
    115e:	59 f1       	breq	.+86     	; 0x11b6 <_ZN9task_user3runEv+0x190>
    1160:	3c f4       	brge	.+14     	; 0x1170 <_ZN9task_user3runEv+0x14a>
    1162:	2b 31       	cpi	r18, 0x1B	; 27
    1164:	31 05       	cpc	r19, r1
    1166:	59 f1       	breq	.+86     	; 0x11be <_ZN9task_user3runEv+0x198>
    1168:	25 36       	cpi	r18, 0x65	; 101
    116a:	31 05       	cpc	r19, r1
    116c:	41 f1       	breq	.+80     	; 0x11be <_ZN9task_user3runEv+0x198>
    116e:	3b c0       	rjmp	.+118    	; 0x11e6 <_ZN9task_user3runEv+0x1c0>
    1170:	23 37       	cpi	r18, 0x73	; 115
    1172:	31 05       	cpc	r19, r1
    1174:	c1 f0       	breq	.+48     	; 0x11a6 <_ZN9task_user3runEv+0x180>
    1176:	26 37       	cpi	r18, 0x76	; 118
    1178:	31 05       	cpc	r19, r1
    117a:	89 f0       	breq	.+34     	; 0x119e <_ZN9task_user3runEv+0x178>
    117c:	2e 36       	cpi	r18, 0x6E	; 110
    117e:	31 05       	cpc	r19, r1
    1180:	91 f5       	brne	.+100    	; 0x11e6 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1182:	ce 01       	movw	r24, r28
    1184:	01 96       	adiw	r24, 0x01	; 1
    1186:	0e 94 46 18 	call	0x308c	; 0x308c <_ZN10time_stamp10set_to_nowEv>
    118a:	bc 01       	movw	r22, r24
    118c:	f8 01       	movw	r30, r16
    118e:	86 81       	ldd	r24, Z+6	; 0x06
    1190:	97 81       	ldd	r25, Z+7	; 0x07
    1192:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <_ZlsR8emstreamR10time_stamp>
    1196:	66 e0       	ldi	r22, 0x06	; 6
    1198:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
							break;
    119c:	5e c0       	rjmp	.+188    	; 0x125a <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    119e:	c8 01       	movw	r24, r16
    11a0:	0e 94 88 07 	call	0xf10	; 0xf10 <_ZN9task_user11show_statusEv>
							break;
    11a4:	5a c0       	rjmp	.+180    	; 0x125a <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    11a6:	d8 01       	movw	r26, r16
    11a8:	16 96       	adiw	r26, 0x06	; 6
    11aa:	8d 91       	ld	r24, X+
    11ac:	9c 91       	ld	r25, X
    11ae:	17 97       	sbiw	r26, 0x07	; 7
    11b0:	0e 94 aa 15 	call	0x2b54	; 0x2b54 <_Z17print_task_stacksP8emstream>
							break;
    11b4:	52 c0       	rjmp	.+164    	; 0x125a <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    11b6:	c8 01       	movw	r24, r16
    11b8:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <_ZN9task_user18print_help_messageEv>
							break;
    11bc:	4e c0       	rjmp	.+156    	; 0x125a <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    11be:	6a e0       	ldi	r22, 0x0A	; 10
    11c0:	f8 01       	movw	r30, r16
    11c2:	86 81       	ldd	r24, Z+6	; 0x06
    11c4:	97 81       	ldd	r25, Z+7	; 0x07
    11c6:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    11ca:	7c 01       	movw	r14, r24
    11cc:	66 e1       	ldi	r22, 0x16	; 22
    11ce:	74 e0       	ldi	r23, 0x04	; 4
    11d0:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    11d4:	66 e0       	ldi	r22, 0x06	; 6
    11d6:	c7 01       	movw	r24, r14
    11d8:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    11dc:	60 e0       	ldi	r22, 0x00	; 0
    11de:	c8 01       	movw	r24, r16
    11e0:	0e 94 91 14 	call	0x2922	; 0x2922 <_ZN8frt_task13transition_toEh>
							break;
    11e4:	3a c0       	rjmp	.+116    	; 0x125a <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    11e6:	f8 01       	movw	r30, r16
    11e8:	a6 81       	ldd	r26, Z+6	; 0x06
    11ea:	b7 81       	ldd	r27, Z+7	; 0x07
    11ec:	ed 91       	ld	r30, X+
    11ee:	fc 91       	ld	r31, X
    11f0:	11 97       	sbiw	r26, 0x01	; 1
    11f2:	02 80       	ldd	r0, Z+2	; 0x02
    11f4:	f3 81       	ldd	r31, Z+3	; 0x03
    11f6:	e0 2d       	mov	r30, r0
    11f8:	68 2f       	mov	r22, r24
    11fa:	cd 01       	movw	r24, r26
    11fc:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    11fe:	6a e0       	ldi	r22, 0x0A	; 10
    1200:	d8 01       	movw	r26, r16
    1202:	16 96       	adiw	r26, 0x06	; 6
    1204:	8d 91       	ld	r24, X+
    1206:	9c 91       	ld	r25, X
    1208:	17 97       	sbiw	r26, 0x07	; 7
    120a:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    120e:	7c 01       	movw	r14, r24
    1210:	60 e1       	ldi	r22, 0x10	; 16
    1212:	74 e0       	ldi	r23, 0x04	; 4
    1214:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    1218:	66 e0       	ldi	r22, 0x06	; 6
    121a:	c7 01       	movw	r24, r14
    121c:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1220:	1c c0       	rjmp	.+56     	; 0x125a <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1222:	6a e0       	ldi	r22, 0x0A	; 10
    1224:	f8 01       	movw	r30, r16
    1226:	86 81       	ldd	r24, Z+6	; 0x06
    1228:	97 81       	ldd	r25, Z+7	; 0x07
    122a:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    122e:	8c 01       	movw	r16, r24
    1230:	63 ef       	ldi	r22, 0xF3	; 243
    1232:	73 e0       	ldi	r23, 0x03	; 3
    1234:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    1238:	66 e0       	ldi	r22, 0x06	; 6
    123a:	c8 01       	movw	r24, r16
    123c:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1240:	93 e0       	ldi	r25, 0x03	; 3
    1242:	88 ed       	ldi	r24, 0xD8	; 216
    1244:	08 b6       	in	r0, 0x38	; 56
    1246:	18 be       	out	0x38, r1	; 56
    1248:	84 bf       	out	0x34, r24	; 52
    124a:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    124e:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1252:	81 fd       	sbrc	r24, 1
    1254:	fc cf       	rjmp	.-8      	; 0x124e <_ZN9task_user3runEv+0x228>
    1256:	08 be       	out	0x38, r0	; 56
    1258:	ff cf       	rjmp	.-2      	; 0x1258 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    125a:	f8 01       	movw	r30, r16
    125c:	86 85       	ldd	r24, Z+14	; 0x0e
    125e:	97 85       	ldd	r25, Z+15	; 0x0f
    1260:	a0 89       	ldd	r26, Z+16	; 0x10
    1262:	b1 89       	ldd	r27, Z+17	; 0x11
    1264:	01 96       	adiw	r24, 0x01	; 1
    1266:	a1 1d       	adc	r26, r1
    1268:	b1 1d       	adc	r27, r1
    126a:	86 87       	std	Z+14, r24	; 0x0e
    126c:	97 87       	std	Z+15, r25	; 0x0f
    126e:	a0 8b       	std	Z+16, r26	; 0x10
    1270:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    1272:	61 e0       	ldi	r22, 0x01	; 1
    1274:	70 e0       	ldi	r23, 0x00	; 0
    1276:	80 e0       	ldi	r24, 0x00	; 0
    1278:	90 e0       	ldi	r25, 0x00	; 0
    127a:	0e 94 65 12 	call	0x24ca	; 0x24ca <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    127e:	f1 ce       	rjmp	.-542    	; 0x1062 <_ZN9task_user3runEv+0x3c>

00001280 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1280:	0f 93       	push	r16
    1282:	1f 93       	push	r17
    1284:	cf 93       	push	r28
    1286:	df 93       	push	r29
    1288:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    128a:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    128e:	80 91 bc 20 	lds	r24, 0x20BC	; 0x8020bc <__data_end>
    1292:	81 11       	cpse	r24, r1
    1294:	1d c0       	rjmp	.+58     	; 0x12d0 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1296:	a1 ec       	ldi	r26, 0xC1	; 193
    1298:	b0 e2       	ldi	r27, 0x20	; 32
    129a:	e5 ec       	ldi	r30, 0xC5	; 197
    129c:	f0 e2       	ldi	r31, 0x20	; 32
    129e:	ed 93       	st	X+, r30
    12a0:	fc 93       	st	X, r31
    12a2:	11 97       	sbiw	r26, 0x01	; 1
    12a4:	12 96       	adiw	r26, 0x02	; 2
    12a6:	1d 92       	st	X+, r1
    12a8:	1c 92       	st	X, r1
    12aa:	13 97       	sbiw	r26, 0x03	; 3
    12ac:	ad eb       	ldi	r26, 0xBD	; 189
    12ae:	b0 e2       	ldi	r27, 0x20	; 32
    12b0:	8f ef       	ldi	r24, 0xFF	; 255
    12b2:	9f e0       	ldi	r25, 0x0F	; 15
    12b4:	12 96       	adiw	r26, 0x02	; 2
    12b6:	8d 93       	st	X+, r24
    12b8:	9c 93       	st	X, r25
    12ba:	13 97       	sbiw	r26, 0x03	; 3
    12bc:	1d 92       	st	X+, r1
    12be:	1c 92       	st	X, r1
    12c0:	11 97       	sbiw	r26, 0x01	; 1
    12c2:	82 83       	std	Z+2, r24	; 0x02
    12c4:	93 83       	std	Z+3, r25	; 0x03
    12c6:	a0 83       	st	Z, r26
    12c8:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    12ca:	81 e0       	ldi	r24, 0x01	; 1
    12cc:	80 93 bc 20 	sts	0x20BC, r24	; 0x8020bc <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    12d0:	20 97       	sbiw	r28, 0x00	; 0
    12d2:	09 f4       	brne	.+2      	; 0x12d6 <pvPortMalloc+0x56>
    12d4:	5f c0       	rjmp	.+190    	; 0x1394 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    12d6:	9e 01       	movw	r18, r28
    12d8:	2b 5f       	subi	r18, 0xFB	; 251
    12da:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    12dc:	24 96       	adiw	r28, 0x04	; 4
    12de:	ce 3f       	cpi	r28, 0xFE	; 254
    12e0:	df 40       	sbci	r29, 0x0F	; 15
    12e2:	08 f0       	brcs	.+2      	; 0x12e6 <pvPortMalloc+0x66>
    12e4:	5a c0       	rjmp	.+180    	; 0x139a <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    12e6:	e0 91 c1 20 	lds	r30, 0x20C1	; 0x8020c1 <xStart>
    12ea:	f0 91 c2 20 	lds	r31, 0x20C2	; 0x8020c2 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    12ee:	a1 ec       	ldi	r26, 0xC1	; 193
    12f0:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12f2:	02 c0       	rjmp	.+4      	; 0x12f8 <pvPortMalloc+0x78>
    12f4:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    12f6:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    12f8:	82 81       	ldd	r24, Z+2	; 0x02
    12fa:	93 81       	ldd	r25, Z+3	; 0x03
    12fc:	82 17       	cp	r24, r18
    12fe:	93 07       	cpc	r25, r19
    1300:	20 f4       	brcc	.+8      	; 0x130a <pvPortMalloc+0x8a>
    1302:	80 81       	ld	r24, Z
    1304:	91 81       	ldd	r25, Z+1	; 0x01
    1306:	00 97       	sbiw	r24, 0x00	; 0
    1308:	a9 f7       	brne	.-22     	; 0x12f4 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    130a:	c0 e2       	ldi	r28, 0x20	; 32
    130c:	ed 3b       	cpi	r30, 0xBD	; 189
    130e:	fc 07       	cpc	r31, r28
    1310:	09 f4       	brne	.+2      	; 0x1314 <pvPortMalloc+0x94>
    1312:	46 c0       	rjmp	.+140    	; 0x13a0 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1314:	cd 91       	ld	r28, X+
    1316:	dc 91       	ld	r29, X
    1318:	11 97       	sbiw	r26, 0x01	; 1
    131a:	8e 01       	movw	r16, r28
    131c:	0b 5f       	subi	r16, 0xFB	; 251
    131e:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1320:	80 81       	ld	r24, Z
    1322:	91 81       	ldd	r25, Z+1	; 0x01
    1324:	8d 93       	st	X+, r24
    1326:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1328:	82 81       	ldd	r24, Z+2	; 0x02
    132a:	93 81       	ldd	r25, Z+3	; 0x03
    132c:	82 1b       	sub	r24, r18
    132e:	93 0b       	sbc	r25, r19
    1330:	8b 30       	cpi	r24, 0x0B	; 11
    1332:	91 05       	cpc	r25, r1
    1334:	10 f1       	brcs	.+68     	; 0x137a <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1336:	bf 01       	movw	r22, r30
    1338:	62 0f       	add	r22, r18
    133a:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    133c:	db 01       	movw	r26, r22
    133e:	12 96       	adiw	r26, 0x02	; 2
    1340:	8d 93       	st	X+, r24
    1342:	9c 93       	st	X, r25
    1344:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1346:	22 83       	std	Z+2, r18	; 0x02
    1348:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    134a:	12 96       	adiw	r26, 0x02	; 2
    134c:	4d 91       	ld	r20, X+
    134e:	5c 91       	ld	r21, X
    1350:	13 97       	sbiw	r26, 0x03	; 3
    1352:	81 ec       	ldi	r24, 0xC1	; 193
    1354:	90 e2       	ldi	r25, 0x20	; 32
    1356:	01 c0       	rjmp	.+2      	; 0x135a <pvPortMalloc+0xda>
    1358:	cd 01       	movw	r24, r26
    135a:	ec 01       	movw	r28, r24
    135c:	a8 81       	ld	r26, Y
    135e:	b9 81       	ldd	r27, Y+1	; 0x01
    1360:	12 96       	adiw	r26, 0x02	; 2
    1362:	2d 91       	ld	r18, X+
    1364:	3c 91       	ld	r19, X
    1366:	13 97       	sbiw	r26, 0x03	; 3
    1368:	24 17       	cp	r18, r20
    136a:	35 07       	cpc	r19, r21
    136c:	a8 f3       	brcs	.-22     	; 0x1358 <pvPortMalloc+0xd8>
    136e:	eb 01       	movw	r28, r22
    1370:	a8 83       	st	Y, r26
    1372:	b9 83       	std	Y+1, r27	; 0x01
    1374:	dc 01       	movw	r26, r24
    1376:	6d 93       	st	X+, r22
    1378:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    137a:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    137e:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1382:	22 81       	ldd	r18, Z+2	; 0x02
    1384:	33 81       	ldd	r19, Z+3	; 0x03
    1386:	82 1b       	sub	r24, r18
    1388:	93 0b       	sbc	r25, r19
    138a:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    138e:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1392:	08 c0       	rjmp	.+16     	; 0x13a4 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1394:	00 e0       	ldi	r16, 0x00	; 0
    1396:	10 e0       	ldi	r17, 0x00	; 0
    1398:	05 c0       	rjmp	.+10     	; 0x13a4 <pvPortMalloc+0x124>
    139a:	00 e0       	ldi	r16, 0x00	; 0
    139c:	10 e0       	ldi	r17, 0x00	; 0
    139e:	02 c0       	rjmp	.+4      	; 0x13a4 <pvPortMalloc+0x124>
    13a0:	00 e0       	ldi	r16, 0x00	; 0
    13a2:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    13a4:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    13a8:	c8 01       	movw	r24, r16
    13aa:	df 91       	pop	r29
    13ac:	cf 91       	pop	r28
    13ae:	1f 91       	pop	r17
    13b0:	0f 91       	pop	r16
    13b2:	08 95       	ret

000013b4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    13b4:	0f 93       	push	r16
    13b6:	1f 93       	push	r17
    13b8:	cf 93       	push	r28
    13ba:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    13bc:	00 97       	sbiw	r24, 0x00	; 0
    13be:	41 f1       	breq	.+80     	; 0x1410 <vPortFree+0x5c>
    13c0:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    13c2:	8c 01       	movw	r16, r24
    13c4:	05 50       	subi	r16, 0x05	; 5
    13c6:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    13c8:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    13cc:	f8 01       	movw	r30, r16
    13ce:	42 81       	ldd	r20, Z+2	; 0x02
    13d0:	53 81       	ldd	r21, Z+3	; 0x03
    13d2:	a1 ec       	ldi	r26, 0xC1	; 193
    13d4:	b0 e2       	ldi	r27, 0x20	; 32
    13d6:	01 c0       	rjmp	.+2      	; 0x13da <vPortFree+0x26>
    13d8:	df 01       	movw	r26, r30
    13da:	ed 91       	ld	r30, X+
    13dc:	fc 91       	ld	r31, X
    13de:	11 97       	sbiw	r26, 0x01	; 1
    13e0:	22 81       	ldd	r18, Z+2	; 0x02
    13e2:	33 81       	ldd	r19, Z+3	; 0x03
    13e4:	24 17       	cp	r18, r20
    13e6:	35 07       	cpc	r19, r21
    13e8:	b8 f3       	brcs	.-18     	; 0x13d8 <vPortFree+0x24>
    13ea:	25 97       	sbiw	r28, 0x05	; 5
    13ec:	e8 83       	st	Y, r30
    13ee:	f9 83       	std	Y+1, r31	; 0x01
    13f0:	0d 93       	st	X+, r16
    13f2:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    13f4:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    13f8:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    13fc:	8a 81       	ldd	r24, Y+2	; 0x02
    13fe:	9b 81       	ldd	r25, Y+3	; 0x03
    1400:	82 0f       	add	r24, r18
    1402:	93 1f       	adc	r25, r19
    1404:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1408:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    140c:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
	}
}
    1410:	df 91       	pop	r29
    1412:	cf 91       	pop	r28
    1414:	1f 91       	pop	r17
    1416:	0f 91       	pop	r16
    1418:	08 95       	ret

0000141a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    141a:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    141e:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1422:	08 95       	ret

00001424 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1424:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1426:	03 96       	adiw	r24, 0x03	; 3
    1428:	81 83       	std	Z+1, r24	; 0x01
    142a:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    142c:	4f ef       	ldi	r20, 0xFF	; 255
    142e:	5f ef       	ldi	r21, 0xFF	; 255
    1430:	ba 01       	movw	r22, r20
    1432:	43 83       	std	Z+3, r20	; 0x03
    1434:	54 83       	std	Z+4, r21	; 0x04
    1436:	65 83       	std	Z+5, r22	; 0x05
    1438:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    143a:	87 83       	std	Z+7, r24	; 0x07
    143c:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    143e:	81 87       	std	Z+9, r24	; 0x09
    1440:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1442:	10 82       	st	Z, r1
    1444:	08 95       	ret

00001446 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1446:	fc 01       	movw	r30, r24
    1448:	12 86       	std	Z+10, r1	; 0x0a
    144a:	13 86       	std	Z+11, r1	; 0x0b
    144c:	08 95       	ret

0000144e <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    144e:	cf 93       	push	r28
    1450:	df 93       	push	r29
    1452:	fc 01       	movw	r30, r24
    1454:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1456:	21 81       	ldd	r18, Z+1	; 0x01
    1458:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    145a:	e9 01       	movw	r28, r18
    145c:	8c 81       	ldd	r24, Y+4	; 0x04
    145e:	9d 81       	ldd	r25, Y+5	; 0x05
    1460:	14 96       	adiw	r26, 0x04	; 4
    1462:	8d 93       	st	X+, r24
    1464:	9c 93       	st	X, r25
    1466:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1468:	81 81       	ldd	r24, Z+1	; 0x01
    146a:	92 81       	ldd	r25, Z+2	; 0x02
    146c:	16 96       	adiw	r26, 0x06	; 6
    146e:	8d 93       	st	X+, r24
    1470:	9c 93       	st	X, r25
    1472:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1474:	8c 81       	ldd	r24, Y+4	; 0x04
    1476:	9d 81       	ldd	r25, Y+5	; 0x05
    1478:	ec 01       	movw	r28, r24
    147a:	6e 83       	std	Y+6, r22	; 0x06
    147c:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    147e:	e9 01       	movw	r28, r18
    1480:	6c 83       	std	Y+4, r22	; 0x04
    1482:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1484:	61 83       	std	Z+1, r22	; 0x01
    1486:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1488:	1a 96       	adiw	r26, 0x0a	; 10
    148a:	ed 93       	st	X+, r30
    148c:	fc 93       	st	X, r31
    148e:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1490:	80 81       	ld	r24, Z
    1492:	8f 5f       	subi	r24, 0xFF	; 255
    1494:	80 83       	st	Z, r24
}
    1496:	df 91       	pop	r29
    1498:	cf 91       	pop	r28
    149a:	08 95       	ret

0000149c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    149c:	0f 93       	push	r16
    149e:	1f 93       	push	r17
    14a0:	cf 93       	push	r28
    14a2:	df 93       	push	r29
    14a4:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    14a6:	08 81       	ld	r16, Y
    14a8:	19 81       	ldd	r17, Y+1	; 0x01
    14aa:	2a 81       	ldd	r18, Y+2	; 0x02
    14ac:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    14ae:	0f 3f       	cpi	r16, 0xFF	; 255
    14b0:	4f ef       	ldi	r20, 0xFF	; 255
    14b2:	14 07       	cpc	r17, r20
    14b4:	24 07       	cpc	r18, r20
    14b6:	34 07       	cpc	r19, r20
    14b8:	31 f4       	brne	.+12     	; 0x14c6 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    14ba:	dc 01       	movw	r26, r24
    14bc:	19 96       	adiw	r26, 0x09	; 9
    14be:	ed 91       	ld	r30, X+
    14c0:	fc 91       	ld	r31, X
    14c2:	1a 97       	sbiw	r26, 0x0a	; 10
    14c4:	1f c0       	rjmp	.+62     	; 0x1504 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    14c6:	fc 01       	movw	r30, r24
    14c8:	33 96       	adiw	r30, 0x03	; 3
    14ca:	dc 01       	movw	r26, r24
    14cc:	17 96       	adiw	r26, 0x07	; 7
    14ce:	4d 91       	ld	r20, X+
    14d0:	5c 91       	ld	r21, X
    14d2:	18 97       	sbiw	r26, 0x08	; 8
    14d4:	da 01       	movw	r26, r20
    14d6:	4d 91       	ld	r20, X+
    14d8:	5d 91       	ld	r21, X+
    14da:	6d 91       	ld	r22, X+
    14dc:	7c 91       	ld	r23, X
    14de:	04 17       	cp	r16, r20
    14e0:	15 07       	cpc	r17, r21
    14e2:	26 07       	cpc	r18, r22
    14e4:	37 07       	cpc	r19, r23
    14e6:	70 f0       	brcs	.+28     	; 0x1504 <vListInsert+0x68>
    14e8:	04 80       	ldd	r0, Z+4	; 0x04
    14ea:	f5 81       	ldd	r31, Z+5	; 0x05
    14ec:	e0 2d       	mov	r30, r0
    14ee:	a4 81       	ldd	r26, Z+4	; 0x04
    14f0:	b5 81       	ldd	r27, Z+5	; 0x05
    14f2:	4d 91       	ld	r20, X+
    14f4:	5d 91       	ld	r21, X+
    14f6:	6d 91       	ld	r22, X+
    14f8:	7c 91       	ld	r23, X
    14fa:	04 17       	cp	r16, r20
    14fc:	15 07       	cpc	r17, r21
    14fe:	26 07       	cpc	r18, r22
    1500:	37 07       	cpc	r19, r23
    1502:	90 f7       	brcc	.-28     	; 0x14e8 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1504:	a4 81       	ldd	r26, Z+4	; 0x04
    1506:	b5 81       	ldd	r27, Z+5	; 0x05
    1508:	ac 83       	std	Y+4, r26	; 0x04
    150a:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    150c:	16 96       	adiw	r26, 0x06	; 6
    150e:	cd 93       	st	X+, r28
    1510:	dc 93       	st	X, r29
    1512:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1514:	ee 83       	std	Y+6, r30	; 0x06
    1516:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1518:	c4 83       	std	Z+4, r28	; 0x04
    151a:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    151c:	8a 87       	std	Y+10, r24	; 0x0a
    151e:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1520:	fc 01       	movw	r30, r24
    1522:	20 81       	ld	r18, Z
    1524:	2f 5f       	subi	r18, 0xFF	; 255
    1526:	20 83       	st	Z, r18
}
    1528:	df 91       	pop	r29
    152a:	cf 91       	pop	r28
    152c:	1f 91       	pop	r17
    152e:	0f 91       	pop	r16
    1530:	08 95       	ret

00001532 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1532:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1534:	a4 81       	ldd	r26, Z+4	; 0x04
    1536:	b5 81       	ldd	r27, Z+5	; 0x05
    1538:	86 81       	ldd	r24, Z+6	; 0x06
    153a:	97 81       	ldd	r25, Z+7	; 0x07
    153c:	16 96       	adiw	r26, 0x06	; 6
    153e:	8d 93       	st	X+, r24
    1540:	9c 93       	st	X, r25
    1542:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1544:	a6 81       	ldd	r26, Z+6	; 0x06
    1546:	b7 81       	ldd	r27, Z+7	; 0x07
    1548:	84 81       	ldd	r24, Z+4	; 0x04
    154a:	95 81       	ldd	r25, Z+5	; 0x05
    154c:	14 96       	adiw	r26, 0x04	; 4
    154e:	8d 93       	st	X+, r24
    1550:	9c 93       	st	X, r25
    1552:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1554:	a2 85       	ldd	r26, Z+10	; 0x0a
    1556:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1558:	11 96       	adiw	r26, 0x01	; 1
    155a:	8d 91       	ld	r24, X+
    155c:	9c 91       	ld	r25, X
    155e:	12 97       	sbiw	r26, 0x02	; 2
    1560:	e8 17       	cp	r30, r24
    1562:	f9 07       	cpc	r31, r25
    1564:	31 f4       	brne	.+12     	; 0x1572 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1566:	86 81       	ldd	r24, Z+6	; 0x06
    1568:	97 81       	ldd	r25, Z+7	; 0x07
    156a:	11 96       	adiw	r26, 0x01	; 1
    156c:	8d 93       	st	X+, r24
    156e:	9c 93       	st	X, r25
    1570:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1572:	12 86       	std	Z+10, r1	; 0x0a
    1574:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1576:	8c 91       	ld	r24, X
    1578:	81 50       	subi	r24, 0x01	; 1
    157a:	8c 93       	st	X, r24
    157c:	08 95       	ret

0000157e <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    157e:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <portStackTopForTask>
    1582:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <portStackTopForTask+0x1>
    1586:	31 e1       	ldi	r19, 0x11	; 17
    1588:	fc 01       	movw	r30, r24
    158a:	30 83       	st	Z, r19
    158c:	31 97       	sbiw	r30, 0x01	; 1
    158e:	22 e2       	ldi	r18, 0x22	; 34
    1590:	20 83       	st	Z, r18
    1592:	31 97       	sbiw	r30, 0x01	; 1
    1594:	a3 e3       	ldi	r26, 0x33	; 51
    1596:	a0 83       	st	Z, r26
    1598:	31 97       	sbiw	r30, 0x01	; 1
    159a:	60 83       	st	Z, r22
    159c:	31 97       	sbiw	r30, 0x01	; 1
    159e:	70 83       	st	Z, r23
    15a0:	31 97       	sbiw	r30, 0x01	; 1
    15a2:	10 82       	st	Z, r1
    15a4:	31 97       	sbiw	r30, 0x01	; 1
    15a6:	10 82       	st	Z, r1
    15a8:	31 97       	sbiw	r30, 0x01	; 1
    15aa:	60 e8       	ldi	r22, 0x80	; 128
    15ac:	60 83       	st	Z, r22
    15ae:	31 97       	sbiw	r30, 0x01	; 1
    15b0:	10 82       	st	Z, r1
    15b2:	31 97       	sbiw	r30, 0x01	; 1
    15b4:	10 82       	st	Z, r1
    15b6:	31 97       	sbiw	r30, 0x01	; 1
    15b8:	10 82       	st	Z, r1
    15ba:	31 97       	sbiw	r30, 0x01	; 1
    15bc:	62 e0       	ldi	r22, 0x02	; 2
    15be:	60 83       	st	Z, r22
    15c0:	31 97       	sbiw	r30, 0x01	; 1
    15c2:	63 e0       	ldi	r22, 0x03	; 3
    15c4:	60 83       	st	Z, r22
    15c6:	31 97       	sbiw	r30, 0x01	; 1
    15c8:	64 e0       	ldi	r22, 0x04	; 4
    15ca:	60 83       	st	Z, r22
    15cc:	31 97       	sbiw	r30, 0x01	; 1
    15ce:	65 e0       	ldi	r22, 0x05	; 5
    15d0:	60 83       	st	Z, r22
    15d2:	31 97       	sbiw	r30, 0x01	; 1
    15d4:	66 e0       	ldi	r22, 0x06	; 6
    15d6:	60 83       	st	Z, r22
    15d8:	31 97       	sbiw	r30, 0x01	; 1
    15da:	67 e0       	ldi	r22, 0x07	; 7
    15dc:	60 83       	st	Z, r22
    15de:	31 97       	sbiw	r30, 0x01	; 1
    15e0:	68 e0       	ldi	r22, 0x08	; 8
    15e2:	60 83       	st	Z, r22
    15e4:	31 97       	sbiw	r30, 0x01	; 1
    15e6:	69 e0       	ldi	r22, 0x09	; 9
    15e8:	60 83       	st	Z, r22
    15ea:	31 97       	sbiw	r30, 0x01	; 1
    15ec:	60 e1       	ldi	r22, 0x10	; 16
    15ee:	60 83       	st	Z, r22
    15f0:	31 97       	sbiw	r30, 0x01	; 1
    15f2:	30 83       	st	Z, r19
    15f4:	31 97       	sbiw	r30, 0x01	; 1
    15f6:	32 e1       	ldi	r19, 0x12	; 18
    15f8:	30 83       	st	Z, r19
    15fa:	31 97       	sbiw	r30, 0x01	; 1
    15fc:	33 e1       	ldi	r19, 0x13	; 19
    15fe:	30 83       	st	Z, r19
    1600:	31 97       	sbiw	r30, 0x01	; 1
    1602:	34 e1       	ldi	r19, 0x14	; 20
    1604:	30 83       	st	Z, r19
    1606:	31 97       	sbiw	r30, 0x01	; 1
    1608:	35 e1       	ldi	r19, 0x15	; 21
    160a:	30 83       	st	Z, r19
    160c:	31 97       	sbiw	r30, 0x01	; 1
    160e:	36 e1       	ldi	r19, 0x16	; 22
    1610:	30 83       	st	Z, r19
    1612:	31 97       	sbiw	r30, 0x01	; 1
    1614:	37 e1       	ldi	r19, 0x17	; 23
    1616:	30 83       	st	Z, r19
    1618:	31 97       	sbiw	r30, 0x01	; 1
    161a:	38 e1       	ldi	r19, 0x18	; 24
    161c:	30 83       	st	Z, r19
    161e:	31 97       	sbiw	r30, 0x01	; 1
    1620:	39 e1       	ldi	r19, 0x19	; 25
    1622:	30 83       	st	Z, r19
    1624:	31 97       	sbiw	r30, 0x01	; 1
    1626:	30 e2       	ldi	r19, 0x20	; 32
    1628:	30 83       	st	Z, r19
    162a:	31 97       	sbiw	r30, 0x01	; 1
    162c:	31 e2       	ldi	r19, 0x21	; 33
    162e:	30 83       	st	Z, r19
    1630:	31 97       	sbiw	r30, 0x01	; 1
    1632:	20 83       	st	Z, r18
    1634:	31 97       	sbiw	r30, 0x01	; 1
    1636:	23 e2       	ldi	r18, 0x23	; 35
    1638:	20 83       	st	Z, r18
    163a:	31 97       	sbiw	r30, 0x01	; 1
    163c:	40 83       	st	Z, r20
    163e:	31 97       	sbiw	r30, 0x01	; 1
    1640:	50 83       	st	Z, r21
    1642:	31 97       	sbiw	r30, 0x01	; 1
    1644:	26 e2       	ldi	r18, 0x26	; 38
    1646:	20 83       	st	Z, r18
    1648:	31 97       	sbiw	r30, 0x01	; 1
    164a:	27 e2       	ldi	r18, 0x27	; 39
    164c:	20 83       	st	Z, r18
    164e:	31 97       	sbiw	r30, 0x01	; 1
    1650:	28 e2       	ldi	r18, 0x28	; 40
    1652:	20 83       	st	Z, r18
    1654:	31 97       	sbiw	r30, 0x01	; 1
    1656:	29 e2       	ldi	r18, 0x29	; 41
    1658:	20 83       	st	Z, r18
    165a:	31 97       	sbiw	r30, 0x01	; 1
    165c:	20 e3       	ldi	r18, 0x30	; 48
    165e:	20 83       	st	Z, r18
    1660:	31 97       	sbiw	r30, 0x01	; 1
    1662:	21 e3       	ldi	r18, 0x31	; 49
    1664:	20 83       	st	Z, r18
    1666:	89 97       	sbiw	r24, 0x29	; 41
    1668:	08 95       	ret

0000166a <xPortStartScheduler>:
    166a:	8c e7       	ldi	r24, 0x7C	; 124
    166c:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    1670:	8f ef       	ldi	r24, 0xFF	; 255
    1672:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    1676:	81 e0       	ldi	r24, 0x01	; 1
    1678:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    167c:	91 e1       	ldi	r25, 0x11	; 17
    167e:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    1682:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    1686:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    168a:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    168e:	cd 91       	ld	r28, X+
    1690:	cd bf       	out	0x3d, r28	; 61
    1692:	dd 91       	ld	r29, X+
    1694:	de bf       	out	0x3e, r29	; 62
    1696:	ff 91       	pop	r31
    1698:	ef 91       	pop	r30
    169a:	df 91       	pop	r29
    169c:	cf 91       	pop	r28
    169e:	bf 91       	pop	r27
    16a0:	af 91       	pop	r26
    16a2:	9f 91       	pop	r25
    16a4:	8f 91       	pop	r24
    16a6:	7f 91       	pop	r23
    16a8:	6f 91       	pop	r22
    16aa:	5f 91       	pop	r21
    16ac:	4f 91       	pop	r20
    16ae:	3f 91       	pop	r19
    16b0:	2f 91       	pop	r18
    16b2:	1f 91       	pop	r17
    16b4:	0f 91       	pop	r16
    16b6:	ff 90       	pop	r15
    16b8:	ef 90       	pop	r14
    16ba:	df 90       	pop	r13
    16bc:	cf 90       	pop	r12
    16be:	bf 90       	pop	r11
    16c0:	af 90       	pop	r10
    16c2:	9f 90       	pop	r9
    16c4:	8f 90       	pop	r8
    16c6:	7f 90       	pop	r7
    16c8:	6f 90       	pop	r6
    16ca:	5f 90       	pop	r5
    16cc:	4f 90       	pop	r4
    16ce:	3f 90       	pop	r3
    16d0:	2f 90       	pop	r2
    16d2:	1f 90       	pop	r1
    16d4:	0f 90       	pop	r0
    16d6:	0c be       	out	0x3c, r0	; 60
    16d8:	0f 90       	pop	r0
    16da:	0b be       	out	0x3b, r0	; 59
    16dc:	0f 90       	pop	r0
    16de:	0f be       	out	0x3f, r0	; 63
    16e0:	0f 90       	pop	r0
    16e2:	08 95       	ret
    16e4:	08 95       	ret

000016e6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    16e6:	0f 92       	push	r0
    16e8:	0f b6       	in	r0, 0x3f	; 63
    16ea:	f8 94       	cli
    16ec:	0f 92       	push	r0
    16ee:	0b b6       	in	r0, 0x3b	; 59
    16f0:	0f 92       	push	r0
    16f2:	0c b6       	in	r0, 0x3c	; 60
    16f4:	0f 92       	push	r0
    16f6:	1f 92       	push	r1
    16f8:	11 24       	eor	r1, r1
    16fa:	2f 92       	push	r2
    16fc:	3f 92       	push	r3
    16fe:	4f 92       	push	r4
    1700:	5f 92       	push	r5
    1702:	6f 92       	push	r6
    1704:	7f 92       	push	r7
    1706:	8f 92       	push	r8
    1708:	9f 92       	push	r9
    170a:	af 92       	push	r10
    170c:	bf 92       	push	r11
    170e:	cf 92       	push	r12
    1710:	df 92       	push	r13
    1712:	ef 92       	push	r14
    1714:	ff 92       	push	r15
    1716:	0f 93       	push	r16
    1718:	1f 93       	push	r17
    171a:	2f 93       	push	r18
    171c:	3f 93       	push	r19
    171e:	4f 93       	push	r20
    1720:	5f 93       	push	r21
    1722:	6f 93       	push	r22
    1724:	7f 93       	push	r23
    1726:	8f 93       	push	r24
    1728:	9f 93       	push	r25
    172a:	af 93       	push	r26
    172c:	bf 93       	push	r27
    172e:	cf 93       	push	r28
    1730:	df 93       	push	r29
    1732:	ef 93       	push	r30
    1734:	ff 93       	push	r31
    1736:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    173a:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    173e:	0d b6       	in	r0, 0x3d	; 61
    1740:	0d 92       	st	X+, r0
    1742:	0e b6       	in	r0, 0x3e	; 62
    1744:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1746:	0e 94 93 12 	call	0x2526	; 0x2526 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    174a:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    174e:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1752:	cd 91       	ld	r28, X+
    1754:	cd bf       	out	0x3d, r28	; 61
    1756:	dd 91       	ld	r29, X+
    1758:	de bf       	out	0x3e, r29	; 62
    175a:	ff 91       	pop	r31
    175c:	ef 91       	pop	r30
    175e:	df 91       	pop	r29
    1760:	cf 91       	pop	r28
    1762:	bf 91       	pop	r27
    1764:	af 91       	pop	r26
    1766:	9f 91       	pop	r25
    1768:	8f 91       	pop	r24
    176a:	7f 91       	pop	r23
    176c:	6f 91       	pop	r22
    176e:	5f 91       	pop	r21
    1770:	4f 91       	pop	r20
    1772:	3f 91       	pop	r19
    1774:	2f 91       	pop	r18
    1776:	1f 91       	pop	r17
    1778:	0f 91       	pop	r16
    177a:	ff 90       	pop	r15
    177c:	ef 90       	pop	r14
    177e:	df 90       	pop	r13
    1780:	cf 90       	pop	r12
    1782:	bf 90       	pop	r11
    1784:	af 90       	pop	r10
    1786:	9f 90       	pop	r9
    1788:	8f 90       	pop	r8
    178a:	7f 90       	pop	r7
    178c:	6f 90       	pop	r6
    178e:	5f 90       	pop	r5
    1790:	4f 90       	pop	r4
    1792:	3f 90       	pop	r3
    1794:	2f 90       	pop	r2
    1796:	1f 90       	pop	r1
    1798:	0f 90       	pop	r0
    179a:	0c be       	out	0x3c, r0	; 60
    179c:	0f 90       	pop	r0
    179e:	0b be       	out	0x3b, r0	; 59
    17a0:	0f 90       	pop	r0
    17a2:	0f be       	out	0x3f, r0	; 63
    17a4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17a6:	08 95       	ret

000017a8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17a8:	0f 92       	push	r0
    17aa:	0f b6       	in	r0, 0x3f	; 63
    17ac:	f8 94       	cli
    17ae:	0f 92       	push	r0
    17b0:	0b b6       	in	r0, 0x3b	; 59
    17b2:	0f 92       	push	r0
    17b4:	0c b6       	in	r0, 0x3c	; 60
    17b6:	0f 92       	push	r0
    17b8:	1f 92       	push	r1
    17ba:	11 24       	eor	r1, r1
    17bc:	2f 92       	push	r2
    17be:	3f 92       	push	r3
    17c0:	4f 92       	push	r4
    17c2:	5f 92       	push	r5
    17c4:	6f 92       	push	r6
    17c6:	7f 92       	push	r7
    17c8:	8f 92       	push	r8
    17ca:	9f 92       	push	r9
    17cc:	af 92       	push	r10
    17ce:	bf 92       	push	r11
    17d0:	cf 92       	push	r12
    17d2:	df 92       	push	r13
    17d4:	ef 92       	push	r14
    17d6:	ff 92       	push	r15
    17d8:	0f 93       	push	r16
    17da:	1f 93       	push	r17
    17dc:	2f 93       	push	r18
    17de:	3f 93       	push	r19
    17e0:	4f 93       	push	r20
    17e2:	5f 93       	push	r21
    17e4:	6f 93       	push	r22
    17e6:	7f 93       	push	r23
    17e8:	8f 93       	push	r24
    17ea:	9f 93       	push	r25
    17ec:	af 93       	push	r26
    17ee:	bf 93       	push	r27
    17f0:	cf 93       	push	r28
    17f2:	df 93       	push	r29
    17f4:	ef 93       	push	r30
    17f6:	ff 93       	push	r31
    17f8:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    17fc:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1800:	0d b6       	in	r0, 0x3d	; 61
    1802:	0d 92       	st	X+, r0
    1804:	0e b6       	in	r0, 0x3e	; 62
    1806:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1808:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskIncrementTick>
	vTaskSwitchContext();
    180c:	0e 94 93 12 	call	0x2526	; 0x2526 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1810:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    1814:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1818:	cd 91       	ld	r28, X+
    181a:	cd bf       	out	0x3d, r28	; 61
    181c:	dd 91       	ld	r29, X+
    181e:	de bf       	out	0x3e, r29	; 62
    1820:	ff 91       	pop	r31
    1822:	ef 91       	pop	r30
    1824:	df 91       	pop	r29
    1826:	cf 91       	pop	r28
    1828:	bf 91       	pop	r27
    182a:	af 91       	pop	r26
    182c:	9f 91       	pop	r25
    182e:	8f 91       	pop	r24
    1830:	7f 91       	pop	r23
    1832:	6f 91       	pop	r22
    1834:	5f 91       	pop	r21
    1836:	4f 91       	pop	r20
    1838:	3f 91       	pop	r19
    183a:	2f 91       	pop	r18
    183c:	1f 91       	pop	r17
    183e:	0f 91       	pop	r16
    1840:	ff 90       	pop	r15
    1842:	ef 90       	pop	r14
    1844:	df 90       	pop	r13
    1846:	cf 90       	pop	r12
    1848:	bf 90       	pop	r11
    184a:	af 90       	pop	r10
    184c:	9f 90       	pop	r9
    184e:	8f 90       	pop	r8
    1850:	7f 90       	pop	r7
    1852:	6f 90       	pop	r6
    1854:	5f 90       	pop	r5
    1856:	4f 90       	pop	r4
    1858:	3f 90       	pop	r3
    185a:	2f 90       	pop	r2
    185c:	1f 90       	pop	r1
    185e:	0f 90       	pop	r0
    1860:	0c be       	out	0x3c, r0	; 60
    1862:	0f 90       	pop	r0
    1864:	0b be       	out	0x3b, r0	; 59
    1866:	0f 90       	pop	r0
    1868:	0f be       	out	0x3f, r0	; 63
    186a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    186c:	08 95       	ret

0000186e <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    186e:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1872:	18 95       	reti

00001874 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1874:	cf 93       	push	r28
    1876:	df 93       	push	r29
    1878:	ec 01       	movw	r28, r24
    187a:	88 a1       	ldd	r24, Y+32	; 0x20
    187c:	81 11       	cpse	r24, r1
    187e:	0b c0       	rjmp	.+22     	; 0x1896 <prvCopyDataToQueue+0x22>
    1880:	88 81       	ld	r24, Y
    1882:	99 81       	ldd	r25, Y+1	; 0x01
    1884:	89 2b       	or	r24, r25
    1886:	e1 f5       	brne	.+120    	; 0x1900 <prvCopyDataToQueue+0x8c>
    1888:	8a 81       	ldd	r24, Y+2	; 0x02
    188a:	9b 81       	ldd	r25, Y+3	; 0x03
    188c:	0e 94 4e 14 	call	0x289c	; 0x289c <vTaskPriorityDisinherit>
    1890:	1a 82       	std	Y+2, r1	; 0x02
    1892:	1b 82       	std	Y+3, r1	; 0x03
    1894:	35 c0       	rjmp	.+106    	; 0x1900 <prvCopyDataToQueue+0x8c>
    1896:	41 11       	cpse	r20, r1
    1898:	17 c0       	rjmp	.+46     	; 0x18c8 <prvCopyDataToQueue+0x54>
    189a:	48 2f       	mov	r20, r24
    189c:	50 e0       	ldi	r21, 0x00	; 0
    189e:	8c 81       	ldd	r24, Y+4	; 0x04
    18a0:	9d 81       	ldd	r25, Y+5	; 0x05
    18a2:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <memcpy>
    18a6:	28 a1       	ldd	r18, Y+32	; 0x20
    18a8:	8c 81       	ldd	r24, Y+4	; 0x04
    18aa:	9d 81       	ldd	r25, Y+5	; 0x05
    18ac:	82 0f       	add	r24, r18
    18ae:	91 1d       	adc	r25, r1
    18b0:	8c 83       	std	Y+4, r24	; 0x04
    18b2:	9d 83       	std	Y+5, r25	; 0x05
    18b4:	2a 81       	ldd	r18, Y+2	; 0x02
    18b6:	3b 81       	ldd	r19, Y+3	; 0x03
    18b8:	82 17       	cp	r24, r18
    18ba:	93 07       	cpc	r25, r19
    18bc:	08 f1       	brcs	.+66     	; 0x1900 <prvCopyDataToQueue+0x8c>
    18be:	88 81       	ld	r24, Y
    18c0:	99 81       	ldd	r25, Y+1	; 0x01
    18c2:	8c 83       	std	Y+4, r24	; 0x04
    18c4:	9d 83       	std	Y+5, r25	; 0x05
    18c6:	1c c0       	rjmp	.+56     	; 0x1900 <prvCopyDataToQueue+0x8c>
    18c8:	48 2f       	mov	r20, r24
    18ca:	50 e0       	ldi	r21, 0x00	; 0
    18cc:	8e 81       	ldd	r24, Y+6	; 0x06
    18ce:	9f 81       	ldd	r25, Y+7	; 0x07
    18d0:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <memcpy>
    18d4:	88 a1       	ldd	r24, Y+32	; 0x20
    18d6:	90 e0       	ldi	r25, 0x00	; 0
    18d8:	91 95       	neg	r25
    18da:	81 95       	neg	r24
    18dc:	91 09       	sbc	r25, r1
    18de:	2e 81       	ldd	r18, Y+6	; 0x06
    18e0:	3f 81       	ldd	r19, Y+7	; 0x07
    18e2:	28 0f       	add	r18, r24
    18e4:	39 1f       	adc	r19, r25
    18e6:	2e 83       	std	Y+6, r18	; 0x06
    18e8:	3f 83       	std	Y+7, r19	; 0x07
    18ea:	48 81       	ld	r20, Y
    18ec:	59 81       	ldd	r21, Y+1	; 0x01
    18ee:	24 17       	cp	r18, r20
    18f0:	35 07       	cpc	r19, r21
    18f2:	30 f4       	brcc	.+12     	; 0x1900 <prvCopyDataToQueue+0x8c>
    18f4:	2a 81       	ldd	r18, Y+2	; 0x02
    18f6:	3b 81       	ldd	r19, Y+3	; 0x03
    18f8:	82 0f       	add	r24, r18
    18fa:	93 1f       	adc	r25, r19
    18fc:	8e 83       	std	Y+6, r24	; 0x06
    18fe:	9f 83       	std	Y+7, r25	; 0x07
    1900:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1902:	8f 5f       	subi	r24, 0xFF	; 255
    1904:	8e 8f       	std	Y+30, r24	; 0x1e
    1906:	df 91       	pop	r29
    1908:	cf 91       	pop	r28
    190a:	08 95       	ret

0000190c <prvCopyDataFromQueue>:
    190c:	fc 01       	movw	r30, r24
    190e:	80 81       	ld	r24, Z
    1910:	91 81       	ldd	r25, Z+1	; 0x01
    1912:	00 97       	sbiw	r24, 0x00	; 0
    1914:	a1 f0       	breq	.+40     	; 0x193e <prvCopyDataFromQueue+0x32>
    1916:	40 a1       	ldd	r20, Z+32	; 0x20
    1918:	50 e0       	ldi	r21, 0x00	; 0
    191a:	26 81       	ldd	r18, Z+6	; 0x06
    191c:	37 81       	ldd	r19, Z+7	; 0x07
    191e:	24 0f       	add	r18, r20
    1920:	35 1f       	adc	r19, r21
    1922:	26 83       	std	Z+6, r18	; 0x06
    1924:	37 83       	std	Z+7, r19	; 0x07
    1926:	a2 81       	ldd	r26, Z+2	; 0x02
    1928:	b3 81       	ldd	r27, Z+3	; 0x03
    192a:	2a 17       	cp	r18, r26
    192c:	3b 07       	cpc	r19, r27
    192e:	10 f0       	brcs	.+4      	; 0x1934 <prvCopyDataFromQueue+0x28>
    1930:	86 83       	std	Z+6, r24	; 0x06
    1932:	97 83       	std	Z+7, r25	; 0x07
    1934:	cb 01       	movw	r24, r22
    1936:	66 81       	ldd	r22, Z+6	; 0x06
    1938:	77 81       	ldd	r23, Z+7	; 0x07
    193a:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <memcpy>
    193e:	08 95       	ret

00001940 <prvUnlockQueue>:
    1940:	0f 93       	push	r16
    1942:	1f 93       	push	r17
    1944:	cf 93       	push	r28
    1946:	df 93       	push	r29
    1948:	ec 01       	movw	r28, r24
    194a:	0f b6       	in	r0, 0x3f	; 63
    194c:	f8 94       	cli
    194e:	0f 92       	push	r0
    1950:	8a a1       	ldd	r24, Y+34	; 0x22
    1952:	18 16       	cp	r1, r24
    1954:	b4 f4       	brge	.+44     	; 0x1982 <prvUnlockQueue+0x42>
    1956:	8b 89       	ldd	r24, Y+19	; 0x13
    1958:	81 11       	cpse	r24, r1
    195a:	05 c0       	rjmp	.+10     	; 0x1966 <prvUnlockQueue+0x26>
    195c:	12 c0       	rjmp	.+36     	; 0x1982 <prvUnlockQueue+0x42>
    195e:	8b 89       	ldd	r24, Y+19	; 0x13
    1960:	81 11       	cpse	r24, r1
    1962:	04 c0       	rjmp	.+8      	; 0x196c <prvUnlockQueue+0x2c>
    1964:	0e c0       	rjmp	.+28     	; 0x1982 <prvUnlockQueue+0x42>
    1966:	8e 01       	movw	r16, r28
    1968:	0d 5e       	subi	r16, 0xED	; 237
    196a:	1f 4f       	sbci	r17, 0xFF	; 255
    196c:	c8 01       	movw	r24, r16
    196e:	0e 94 1a 13 	call	0x2634	; 0x2634 <xTaskRemoveFromEventList>
    1972:	81 11       	cpse	r24, r1
    1974:	0e 94 d7 13 	call	0x27ae	; 0x27ae <vTaskMissedYield>
    1978:	8a a1       	ldd	r24, Y+34	; 0x22
    197a:	81 50       	subi	r24, 0x01	; 1
    197c:	8a a3       	std	Y+34, r24	; 0x22
    197e:	18 16       	cp	r1, r24
    1980:	74 f3       	brlt	.-36     	; 0x195e <prvUnlockQueue+0x1e>
    1982:	8f ef       	ldi	r24, 0xFF	; 255
    1984:	8a a3       	std	Y+34, r24	; 0x22
    1986:	0f 90       	pop	r0
    1988:	0f be       	out	0x3f, r0	; 63
    198a:	0f b6       	in	r0, 0x3f	; 63
    198c:	f8 94       	cli
    198e:	0f 92       	push	r0
    1990:	89 a1       	ldd	r24, Y+33	; 0x21
    1992:	18 16       	cp	r1, r24
    1994:	b4 f4       	brge	.+44     	; 0x19c2 <prvUnlockQueue+0x82>
    1996:	88 85       	ldd	r24, Y+8	; 0x08
    1998:	81 11       	cpse	r24, r1
    199a:	05 c0       	rjmp	.+10     	; 0x19a6 <prvUnlockQueue+0x66>
    199c:	12 c0       	rjmp	.+36     	; 0x19c2 <prvUnlockQueue+0x82>
    199e:	88 85       	ldd	r24, Y+8	; 0x08
    19a0:	81 11       	cpse	r24, r1
    19a2:	04 c0       	rjmp	.+8      	; 0x19ac <prvUnlockQueue+0x6c>
    19a4:	0e c0       	rjmp	.+28     	; 0x19c2 <prvUnlockQueue+0x82>
    19a6:	8e 01       	movw	r16, r28
    19a8:	08 5f       	subi	r16, 0xF8	; 248
    19aa:	1f 4f       	sbci	r17, 0xFF	; 255
    19ac:	c8 01       	movw	r24, r16
    19ae:	0e 94 1a 13 	call	0x2634	; 0x2634 <xTaskRemoveFromEventList>
    19b2:	81 11       	cpse	r24, r1
    19b4:	0e 94 d7 13 	call	0x27ae	; 0x27ae <vTaskMissedYield>
    19b8:	89 a1       	ldd	r24, Y+33	; 0x21
    19ba:	81 50       	subi	r24, 0x01	; 1
    19bc:	89 a3       	std	Y+33, r24	; 0x21
    19be:	18 16       	cp	r1, r24
    19c0:	74 f3       	brlt	.-36     	; 0x199e <prvUnlockQueue+0x5e>
    19c2:	8f ef       	ldi	r24, 0xFF	; 255
    19c4:	89 a3       	std	Y+33, r24	; 0x21
    19c6:	0f 90       	pop	r0
    19c8:	0f be       	out	0x3f, r0	; 63
    19ca:	df 91       	pop	r29
    19cc:	cf 91       	pop	r28
    19ce:	1f 91       	pop	r17
    19d0:	0f 91       	pop	r16
    19d2:	08 95       	ret

000019d4 <xQueueGenericReset>:
    19d4:	1f 93       	push	r17
    19d6:	cf 93       	push	r28
    19d8:	df 93       	push	r29
    19da:	61 30       	cpi	r22, 0x01	; 1
    19dc:	59 f0       	breq	.+22     	; 0x19f4 <xQueueGenericReset+0x20>
    19de:	fc 01       	movw	r30, r24
    19e0:	23 89       	ldd	r18, Z+19	; 0x13
    19e2:	30 85       	ldd	r19, Z+8	; 0x08
    19e4:	31 11       	cpse	r19, r1
    19e6:	2c c0       	rjmp	.+88     	; 0x1a40 <xQueueGenericReset+0x6c>
    19e8:	11 e0       	ldi	r17, 0x01	; 1
    19ea:	21 11       	cpse	r18, r1
    19ec:	10 e0       	ldi	r17, 0x00	; 0
    19ee:	21 11       	cpse	r18, r1
    19f0:	28 c0       	rjmp	.+80     	; 0x1a42 <xQueueGenericReset+0x6e>
    19f2:	01 c0       	rjmp	.+2      	; 0x19f6 <xQueueGenericReset+0x22>
    19f4:	11 e0       	ldi	r17, 0x01	; 1
    19f6:	ec 01       	movw	r28, r24
    19f8:	48 81       	ld	r20, Y
    19fa:	59 81       	ldd	r21, Y+1	; 0x01
    19fc:	28 a1       	ldd	r18, Y+32	; 0x20
    19fe:	30 e0       	ldi	r19, 0x00	; 0
    1a00:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1a02:	62 9f       	mul	r22, r18
    1a04:	c0 01       	movw	r24, r0
    1a06:	63 9f       	mul	r22, r19
    1a08:	90 0d       	add	r25, r0
    1a0a:	11 24       	eor	r1, r1
    1a0c:	ba 01       	movw	r22, r20
    1a0e:	68 0f       	add	r22, r24
    1a10:	79 1f       	adc	r23, r25
    1a12:	6a 83       	std	Y+2, r22	; 0x02
    1a14:	7b 83       	std	Y+3, r23	; 0x03
    1a16:	1e 8e       	std	Y+30, r1	; 0x1e
    1a18:	4c 83       	std	Y+4, r20	; 0x04
    1a1a:	5d 83       	std	Y+5, r21	; 0x05
    1a1c:	82 1b       	sub	r24, r18
    1a1e:	93 0b       	sbc	r25, r19
    1a20:	84 0f       	add	r24, r20
    1a22:	95 1f       	adc	r25, r21
    1a24:	8e 83       	std	Y+6, r24	; 0x06
    1a26:	9f 83       	std	Y+7, r25	; 0x07
    1a28:	8f ef       	ldi	r24, 0xFF	; 255
    1a2a:	89 a3       	std	Y+33, r24	; 0x21
    1a2c:	8a a3       	std	Y+34, r24	; 0x22
    1a2e:	ce 01       	movw	r24, r28
    1a30:	08 96       	adiw	r24, 0x08	; 8
    1a32:	0e 94 12 0a 	call	0x1424	; 0x1424 <vListInitialise>
    1a36:	ce 01       	movw	r24, r28
    1a38:	43 96       	adiw	r24, 0x13	; 19
    1a3a:	0e 94 12 0a 	call	0x1424	; 0x1424 <vListInitialise>
    1a3e:	01 c0       	rjmp	.+2      	; 0x1a42 <xQueueGenericReset+0x6e>
    1a40:	10 e0       	ldi	r17, 0x00	; 0
    1a42:	81 2f       	mov	r24, r17
    1a44:	df 91       	pop	r29
    1a46:	cf 91       	pop	r28
    1a48:	1f 91       	pop	r17
    1a4a:	08 95       	ret

00001a4c <xQueueGenericCreate>:
    1a4c:	0f 93       	push	r16
    1a4e:	1f 93       	push	r17
    1a50:	cf 93       	push	r28
    1a52:	df 93       	push	r29
    1a54:	88 23       	and	r24, r24
    1a56:	01 f1       	breq	.+64     	; 0x1a98 <xQueueGenericCreate+0x4c>
    1a58:	06 2f       	mov	r16, r22
    1a5a:	18 2f       	mov	r17, r24
    1a5c:	83 e2       	ldi	r24, 0x23	; 35
    1a5e:	90 e0       	ldi	r25, 0x00	; 0
    1a60:	0e 94 40 09 	call	0x1280	; 0x1280 <pvPortMalloc>
    1a64:	ec 01       	movw	r28, r24
    1a66:	89 2b       	or	r24, r25
    1a68:	c9 f0       	breq	.+50     	; 0x1a9c <xQueueGenericCreate+0x50>
    1a6a:	10 9f       	mul	r17, r16
    1a6c:	c0 01       	movw	r24, r0
    1a6e:	11 24       	eor	r1, r1
    1a70:	01 96       	adiw	r24, 0x01	; 1
    1a72:	0e 94 40 09 	call	0x1280	; 0x1280 <pvPortMalloc>
    1a76:	88 83       	st	Y, r24
    1a78:	99 83       	std	Y+1, r25	; 0x01
    1a7a:	89 2b       	or	r24, r25
    1a7c:	39 f0       	breq	.+14     	; 0x1a8c <xQueueGenericCreate+0x40>
    1a7e:	1f 8f       	std	Y+31, r17	; 0x1f
    1a80:	08 a3       	std	Y+32, r16	; 0x20
    1a82:	61 e0       	ldi	r22, 0x01	; 1
    1a84:	ce 01       	movw	r24, r28
    1a86:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <xQueueGenericReset>
    1a8a:	08 c0       	rjmp	.+16     	; 0x1a9c <xQueueGenericCreate+0x50>
    1a8c:	ce 01       	movw	r24, r28
    1a8e:	0e 94 da 09 	call	0x13b4	; 0x13b4 <vPortFree>
    1a92:	c0 e0       	ldi	r28, 0x00	; 0
    1a94:	d0 e0       	ldi	r29, 0x00	; 0
    1a96:	02 c0       	rjmp	.+4      	; 0x1a9c <xQueueGenericCreate+0x50>
    1a98:	c0 e0       	ldi	r28, 0x00	; 0
    1a9a:	d0 e0       	ldi	r29, 0x00	; 0
    1a9c:	ce 01       	movw	r24, r28
    1a9e:	df 91       	pop	r29
    1aa0:	cf 91       	pop	r28
    1aa2:	1f 91       	pop	r17
    1aa4:	0f 91       	pop	r16
    1aa6:	08 95       	ret

00001aa8 <xQueueGenericSend>:
    1aa8:	af 92       	push	r10
    1aaa:	bf 92       	push	r11
    1aac:	cf 92       	push	r12
    1aae:	df 92       	push	r13
    1ab0:	ef 92       	push	r14
    1ab2:	ff 92       	push	r15
    1ab4:	0f 93       	push	r16
    1ab6:	1f 93       	push	r17
    1ab8:	cf 93       	push	r28
    1aba:	df 93       	push	r29
    1abc:	cd b7       	in	r28, 0x3d	; 61
    1abe:	de b7       	in	r29, 0x3e	; 62
    1ac0:	29 97       	sbiw	r28, 0x09	; 9
    1ac2:	cd bf       	out	0x3d, r28	; 61
    1ac4:	de bf       	out	0x3e, r29	; 62
    1ac6:	7c 01       	movw	r14, r24
    1ac8:	5b 01       	movw	r10, r22
    1aca:	2e 83       	std	Y+6, r18	; 0x06
    1acc:	3f 83       	std	Y+7, r19	; 0x07
    1ace:	48 87       	std	Y+8, r20	; 0x08
    1ad0:	59 87       	std	Y+9, r21	; 0x09
    1ad2:	10 e0       	ldi	r17, 0x00	; 0
    1ad4:	6c 01       	movw	r12, r24
    1ad6:	88 e0       	ldi	r24, 0x08	; 8
    1ad8:	c8 0e       	add	r12, r24
    1ada:	d1 1c       	adc	r13, r1
    1adc:	0f b6       	in	r0, 0x3f	; 63
    1ade:	f8 94       	cli
    1ae0:	0f 92       	push	r0
    1ae2:	f7 01       	movw	r30, r14
    1ae4:	96 8d       	ldd	r25, Z+30	; 0x1e
    1ae6:	87 8d       	ldd	r24, Z+31	; 0x1f
    1ae8:	98 17       	cp	r25, r24
    1aea:	a8 f4       	brcc	.+42     	; 0x1b16 <xQueueGenericSend+0x6e>
    1aec:	40 2f       	mov	r20, r16
    1aee:	b5 01       	movw	r22, r10
    1af0:	c7 01       	movw	r24, r14
    1af2:	0e 94 3a 0c 	call	0x1874	; 0x1874 <prvCopyDataToQueue>
    1af6:	f7 01       	movw	r30, r14
    1af8:	83 89       	ldd	r24, Z+19	; 0x13
    1afa:	88 23       	and	r24, r24
    1afc:	41 f0       	breq	.+16     	; 0x1b0e <xQueueGenericSend+0x66>
    1afe:	c7 01       	movw	r24, r14
    1b00:	43 96       	adiw	r24, 0x13	; 19
    1b02:	0e 94 1a 13 	call	0x2634	; 0x2634 <xTaskRemoveFromEventList>
    1b06:	81 30       	cpi	r24, 0x01	; 1
    1b08:	11 f4       	brne	.+4      	; 0x1b0e <xQueueGenericSend+0x66>
    1b0a:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <vPortYield>
    1b0e:	0f 90       	pop	r0
    1b10:	0f be       	out	0x3f, r0	; 63
    1b12:	81 e0       	ldi	r24, 0x01	; 1
    1b14:	56 c0       	rjmp	.+172    	; 0x1bc2 <xQueueGenericSend+0x11a>
    1b16:	8e 81       	ldd	r24, Y+6	; 0x06
    1b18:	9f 81       	ldd	r25, Y+7	; 0x07
    1b1a:	a8 85       	ldd	r26, Y+8	; 0x08
    1b1c:	b9 85       	ldd	r27, Y+9	; 0x09
    1b1e:	89 2b       	or	r24, r25
    1b20:	8a 2b       	or	r24, r26
    1b22:	8b 2b       	or	r24, r27
    1b24:	21 f4       	brne	.+8      	; 0x1b2e <xQueueGenericSend+0x86>
    1b26:	0f 90       	pop	r0
    1b28:	0f be       	out	0x3f, r0	; 63
    1b2a:	80 e0       	ldi	r24, 0x00	; 0
    1b2c:	4a c0       	rjmp	.+148    	; 0x1bc2 <xQueueGenericSend+0x11a>
    1b2e:	11 11       	cpse	r17, r1
    1b30:	05 c0       	rjmp	.+10     	; 0x1b3c <xQueueGenericSend+0x94>
    1b32:	ce 01       	movw	r24, r28
    1b34:	01 96       	adiw	r24, 0x01	; 1
    1b36:	0e 94 59 13 	call	0x26b2	; 0x26b2 <vTaskSetTimeOutState>
    1b3a:	11 e0       	ldi	r17, 0x01	; 1
    1b3c:	0f 90       	pop	r0
    1b3e:	0f be       	out	0x3f, r0	; 63
    1b40:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vTaskSuspendAll>
    1b44:	0f b6       	in	r0, 0x3f	; 63
    1b46:	f8 94       	cli
    1b48:	0f 92       	push	r0
    1b4a:	f7 01       	movw	r30, r14
    1b4c:	81 a1       	ldd	r24, Z+33	; 0x21
    1b4e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b50:	09 f4       	brne	.+2      	; 0x1b54 <xQueueGenericSend+0xac>
    1b52:	11 a2       	std	Z+33, r1	; 0x21
    1b54:	f7 01       	movw	r30, r14
    1b56:	82 a1       	ldd	r24, Z+34	; 0x22
    1b58:	8f 3f       	cpi	r24, 0xFF	; 255
    1b5a:	09 f4       	brne	.+2      	; 0x1b5e <xQueueGenericSend+0xb6>
    1b5c:	12 a2       	std	Z+34, r1	; 0x22
    1b5e:	0f 90       	pop	r0
    1b60:	0f be       	out	0x3f, r0	; 63
    1b62:	be 01       	movw	r22, r28
    1b64:	6a 5f       	subi	r22, 0xFA	; 250
    1b66:	7f 4f       	sbci	r23, 0xFF	; 255
    1b68:	ce 01       	movw	r24, r28
    1b6a:	01 96       	adiw	r24, 0x01	; 1
    1b6c:	0e 94 6a 13 	call	0x26d4	; 0x26d4 <xTaskCheckForTimeOut>
    1b70:	81 11       	cpse	r24, r1
    1b72:	21 c0       	rjmp	.+66     	; 0x1bb6 <xQueueGenericSend+0x10e>
    1b74:	0f b6       	in	r0, 0x3f	; 63
    1b76:	f8 94       	cli
    1b78:	0f 92       	push	r0
    1b7a:	f7 01       	movw	r30, r14
    1b7c:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b7e:	0f 90       	pop	r0
    1b80:	0f be       	out	0x3f, r0	; 63
    1b82:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b84:	98 13       	cpse	r25, r24
    1b86:	11 c0       	rjmp	.+34     	; 0x1baa <xQueueGenericSend+0x102>
    1b88:	4e 81       	ldd	r20, Y+6	; 0x06
    1b8a:	5f 81       	ldd	r21, Y+7	; 0x07
    1b8c:	68 85       	ldd	r22, Y+8	; 0x08
    1b8e:	79 85       	ldd	r23, Y+9	; 0x09
    1b90:	c6 01       	movw	r24, r12
    1b92:	0e 94 f0 12 	call	0x25e0	; 0x25e0 <vTaskPlaceOnEventList>
    1b96:	c7 01       	movw	r24, r14
    1b98:	0e 94 a0 0c 	call	0x1940	; 0x1940 <prvUnlockQueue>
    1b9c:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    1ba0:	81 11       	cpse	r24, r1
    1ba2:	9c cf       	rjmp	.-200    	; 0x1adc <xQueueGenericSend+0x34>
    1ba4:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <vPortYield>
    1ba8:	99 cf       	rjmp	.-206    	; 0x1adc <xQueueGenericSend+0x34>
    1baa:	c7 01       	movw	r24, r14
    1bac:	0e 94 a0 0c 	call	0x1940	; 0x1940 <prvUnlockQueue>
    1bb0:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    1bb4:	93 cf       	rjmp	.-218    	; 0x1adc <xQueueGenericSend+0x34>
    1bb6:	c7 01       	movw	r24, r14
    1bb8:	0e 94 a0 0c 	call	0x1940	; 0x1940 <prvUnlockQueue>
    1bbc:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    1bc0:	80 e0       	ldi	r24, 0x00	; 0
    1bc2:	29 96       	adiw	r28, 0x09	; 9
    1bc4:	cd bf       	out	0x3d, r28	; 61
    1bc6:	de bf       	out	0x3e, r29	; 62
    1bc8:	df 91       	pop	r29
    1bca:	cf 91       	pop	r28
    1bcc:	1f 91       	pop	r17
    1bce:	0f 91       	pop	r16
    1bd0:	ff 90       	pop	r15
    1bd2:	ef 90       	pop	r14
    1bd4:	df 90       	pop	r13
    1bd6:	cf 90       	pop	r12
    1bd8:	bf 90       	pop	r11
    1bda:	af 90       	pop	r10
    1bdc:	08 95       	ret

00001bde <xQueueGenericReceive>:
    1bde:	af 92       	push	r10
    1be0:	bf 92       	push	r11
    1be2:	cf 92       	push	r12
    1be4:	df 92       	push	r13
    1be6:	ef 92       	push	r14
    1be8:	ff 92       	push	r15
    1bea:	0f 93       	push	r16
    1bec:	1f 93       	push	r17
    1bee:	cf 93       	push	r28
    1bf0:	df 93       	push	r29
    1bf2:	cd b7       	in	r28, 0x3d	; 61
    1bf4:	de b7       	in	r29, 0x3e	; 62
    1bf6:	29 97       	sbiw	r28, 0x09	; 9
    1bf8:	cd bf       	out	0x3d, r28	; 61
    1bfa:	de bf       	out	0x3e, r29	; 62
    1bfc:	7c 01       	movw	r14, r24
    1bfe:	5b 01       	movw	r10, r22
    1c00:	2e 83       	std	Y+6, r18	; 0x06
    1c02:	3f 83       	std	Y+7, r19	; 0x07
    1c04:	48 87       	std	Y+8, r20	; 0x08
    1c06:	59 87       	std	Y+9, r21	; 0x09
    1c08:	10 e0       	ldi	r17, 0x00	; 0
    1c0a:	6c 01       	movw	r12, r24
    1c0c:	83 e1       	ldi	r24, 0x13	; 19
    1c0e:	c8 0e       	add	r12, r24
    1c10:	d1 1c       	adc	r13, r1
    1c12:	0f b6       	in	r0, 0x3f	; 63
    1c14:	f8 94       	cli
    1c16:	0f 92       	push	r0
    1c18:	f7 01       	movw	r30, r14
    1c1a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c1c:	88 23       	and	r24, r24
    1c1e:	99 f1       	breq	.+102    	; 0x1c86 <xQueueGenericReceive+0xa8>
    1c20:	c6 80       	ldd	r12, Z+6	; 0x06
    1c22:	d7 80       	ldd	r13, Z+7	; 0x07
    1c24:	b5 01       	movw	r22, r10
    1c26:	c7 01       	movw	r24, r14
    1c28:	0e 94 86 0c 	call	0x190c	; 0x190c <prvCopyDataFromQueue>
    1c2c:	01 11       	cpse	r16, r1
    1c2e:	1a c0       	rjmp	.+52     	; 0x1c64 <xQueueGenericReceive+0x86>
    1c30:	f7 01       	movw	r30, r14
    1c32:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c34:	81 50       	subi	r24, 0x01	; 1
    1c36:	86 8f       	std	Z+30, r24	; 0x1e
    1c38:	80 81       	ld	r24, Z
    1c3a:	91 81       	ldd	r25, Z+1	; 0x01
    1c3c:	89 2b       	or	r24, r25
    1c3e:	29 f4       	brne	.+10     	; 0x1c4a <xQueueGenericReceive+0x6c>
    1c40:	0e 94 f4 13 	call	0x27e8	; 0x27e8 <xTaskGetCurrentTaskHandle>
    1c44:	f7 01       	movw	r30, r14
    1c46:	82 83       	std	Z+2, r24	; 0x02
    1c48:	93 83       	std	Z+3, r25	; 0x03
    1c4a:	f7 01       	movw	r30, r14
    1c4c:	80 85       	ldd	r24, Z+8	; 0x08
    1c4e:	88 23       	and	r24, r24
    1c50:	b1 f0       	breq	.+44     	; 0x1c7e <xQueueGenericReceive+0xa0>
    1c52:	c7 01       	movw	r24, r14
    1c54:	08 96       	adiw	r24, 0x08	; 8
    1c56:	0e 94 1a 13 	call	0x2634	; 0x2634 <xTaskRemoveFromEventList>
    1c5a:	81 30       	cpi	r24, 0x01	; 1
    1c5c:	81 f4       	brne	.+32     	; 0x1c7e <xQueueGenericReceive+0xa0>
    1c5e:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <vPortYield>
    1c62:	0d c0       	rjmp	.+26     	; 0x1c7e <xQueueGenericReceive+0xa0>
    1c64:	f7 01       	movw	r30, r14
    1c66:	c6 82       	std	Z+6, r12	; 0x06
    1c68:	d7 82       	std	Z+7, r13	; 0x07
    1c6a:	83 89       	ldd	r24, Z+19	; 0x13
    1c6c:	88 23       	and	r24, r24
    1c6e:	39 f0       	breq	.+14     	; 0x1c7e <xQueueGenericReceive+0xa0>
    1c70:	c7 01       	movw	r24, r14
    1c72:	43 96       	adiw	r24, 0x13	; 19
    1c74:	0e 94 1a 13 	call	0x2634	; 0x2634 <xTaskRemoveFromEventList>
    1c78:	81 11       	cpse	r24, r1
    1c7a:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <vPortYield>
    1c7e:	0f 90       	pop	r0
    1c80:	0f be       	out	0x3f, r0	; 63
    1c82:	81 e0       	ldi	r24, 0x01	; 1
    1c84:	62 c0       	rjmp	.+196    	; 0x1d4a <xQueueGenericReceive+0x16c>
    1c86:	8e 81       	ldd	r24, Y+6	; 0x06
    1c88:	9f 81       	ldd	r25, Y+7	; 0x07
    1c8a:	a8 85       	ldd	r26, Y+8	; 0x08
    1c8c:	b9 85       	ldd	r27, Y+9	; 0x09
    1c8e:	89 2b       	or	r24, r25
    1c90:	8a 2b       	or	r24, r26
    1c92:	8b 2b       	or	r24, r27
    1c94:	21 f4       	brne	.+8      	; 0x1c9e <xQueueGenericReceive+0xc0>
    1c96:	0f 90       	pop	r0
    1c98:	0f be       	out	0x3f, r0	; 63
    1c9a:	80 e0       	ldi	r24, 0x00	; 0
    1c9c:	56 c0       	rjmp	.+172    	; 0x1d4a <xQueueGenericReceive+0x16c>
    1c9e:	11 11       	cpse	r17, r1
    1ca0:	05 c0       	rjmp	.+10     	; 0x1cac <xQueueGenericReceive+0xce>
    1ca2:	ce 01       	movw	r24, r28
    1ca4:	01 96       	adiw	r24, 0x01	; 1
    1ca6:	0e 94 59 13 	call	0x26b2	; 0x26b2 <vTaskSetTimeOutState>
    1caa:	11 e0       	ldi	r17, 0x01	; 1
    1cac:	0f 90       	pop	r0
    1cae:	0f be       	out	0x3f, r0	; 63
    1cb0:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vTaskSuspendAll>
    1cb4:	0f b6       	in	r0, 0x3f	; 63
    1cb6:	f8 94       	cli
    1cb8:	0f 92       	push	r0
    1cba:	f7 01       	movw	r30, r14
    1cbc:	81 a1       	ldd	r24, Z+33	; 0x21
    1cbe:	8f 3f       	cpi	r24, 0xFF	; 255
    1cc0:	09 f4       	brne	.+2      	; 0x1cc4 <xQueueGenericReceive+0xe6>
    1cc2:	11 a2       	std	Z+33, r1	; 0x21
    1cc4:	f7 01       	movw	r30, r14
    1cc6:	82 a1       	ldd	r24, Z+34	; 0x22
    1cc8:	8f 3f       	cpi	r24, 0xFF	; 255
    1cca:	09 f4       	brne	.+2      	; 0x1cce <xQueueGenericReceive+0xf0>
    1ccc:	12 a2       	std	Z+34, r1	; 0x22
    1cce:	0f 90       	pop	r0
    1cd0:	0f be       	out	0x3f, r0	; 63
    1cd2:	be 01       	movw	r22, r28
    1cd4:	6a 5f       	subi	r22, 0xFA	; 250
    1cd6:	7f 4f       	sbci	r23, 0xFF	; 255
    1cd8:	ce 01       	movw	r24, r28
    1cda:	01 96       	adiw	r24, 0x01	; 1
    1cdc:	0e 94 6a 13 	call	0x26d4	; 0x26d4 <xTaskCheckForTimeOut>
    1ce0:	81 11       	cpse	r24, r1
    1ce2:	2d c0       	rjmp	.+90     	; 0x1d3e <xQueueGenericReceive+0x160>
    1ce4:	0f b6       	in	r0, 0x3f	; 63
    1ce6:	f8 94       	cli
    1ce8:	0f 92       	push	r0
    1cea:	f7 01       	movw	r30, r14
    1cec:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cee:	0f 90       	pop	r0
    1cf0:	0f be       	out	0x3f, r0	; 63
    1cf2:	81 11       	cpse	r24, r1
    1cf4:	1e c0       	rjmp	.+60     	; 0x1d32 <xQueueGenericReceive+0x154>
    1cf6:	80 81       	ld	r24, Z
    1cf8:	91 81       	ldd	r25, Z+1	; 0x01
    1cfa:	89 2b       	or	r24, r25
    1cfc:	49 f4       	brne	.+18     	; 0x1d10 <xQueueGenericReceive+0x132>
    1cfe:	0f b6       	in	r0, 0x3f	; 63
    1d00:	f8 94       	cli
    1d02:	0f 92       	push	r0
    1d04:	82 81       	ldd	r24, Z+2	; 0x02
    1d06:	93 81       	ldd	r25, Z+3	; 0x03
    1d08:	0e 94 f9 13 	call	0x27f2	; 0x27f2 <vTaskPriorityInherit>
    1d0c:	0f 90       	pop	r0
    1d0e:	0f be       	out	0x3f, r0	; 63
    1d10:	4e 81       	ldd	r20, Y+6	; 0x06
    1d12:	5f 81       	ldd	r21, Y+7	; 0x07
    1d14:	68 85       	ldd	r22, Y+8	; 0x08
    1d16:	79 85       	ldd	r23, Y+9	; 0x09
    1d18:	c6 01       	movw	r24, r12
    1d1a:	0e 94 f0 12 	call	0x25e0	; 0x25e0 <vTaskPlaceOnEventList>
    1d1e:	c7 01       	movw	r24, r14
    1d20:	0e 94 a0 0c 	call	0x1940	; 0x1940 <prvUnlockQueue>
    1d24:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    1d28:	81 11       	cpse	r24, r1
    1d2a:	73 cf       	rjmp	.-282    	; 0x1c12 <xQueueGenericReceive+0x34>
    1d2c:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <vPortYield>
    1d30:	70 cf       	rjmp	.-288    	; 0x1c12 <xQueueGenericReceive+0x34>
    1d32:	c7 01       	movw	r24, r14
    1d34:	0e 94 a0 0c 	call	0x1940	; 0x1940 <prvUnlockQueue>
    1d38:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    1d3c:	6a cf       	rjmp	.-300    	; 0x1c12 <xQueueGenericReceive+0x34>
    1d3e:	c7 01       	movw	r24, r14
    1d40:	0e 94 a0 0c 	call	0x1940	; 0x1940 <prvUnlockQueue>
    1d44:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
    1d48:	80 e0       	ldi	r24, 0x00	; 0
    1d4a:	29 96       	adiw	r28, 0x09	; 9
    1d4c:	cd bf       	out	0x3d, r28	; 61
    1d4e:	de bf       	out	0x3e, r29	; 62
    1d50:	df 91       	pop	r29
    1d52:	cf 91       	pop	r28
    1d54:	1f 91       	pop	r17
    1d56:	0f 91       	pop	r16
    1d58:	ff 90       	pop	r15
    1d5a:	ef 90       	pop	r14
    1d5c:	df 90       	pop	r13
    1d5e:	cf 90       	pop	r12
    1d60:	bf 90       	pop	r11
    1d62:	af 90       	pop	r10
    1d64:	08 95       	ret

00001d66 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d66:	0f b6       	in	r0, 0x3f	; 63
    1d68:	f8 94       	cli
    1d6a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d6c:	fc 01       	movw	r30, r24
    1d6e:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1d70:	0f 90       	pop	r0
    1d72:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1d74:	08 95       	ret

00001d76 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1d76:	c8 ef       	ldi	r28, 0xF8	; 248
    1d78:	d0 e3       	ldi	r29, 0x30	; 48
    1d7a:	88 81       	ld	r24, Y
    1d7c:	82 30       	cpi	r24, 0x02	; 2
    1d7e:	e8 f3       	brcs	.-6      	; 0x1d7a <prvIdleTask+0x4>
    1d80:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <vPortYield>
    1d84:	fa cf       	rjmp	.-12     	; 0x1d7a <prvIdleTask+0x4>

00001d86 <prvAddCurrentTaskToDelayedList>:
    1d86:	cf 92       	push	r12
    1d88:	df 92       	push	r13
    1d8a:	ef 92       	push	r14
    1d8c:	ff 92       	push	r15
    1d8e:	6b 01       	movw	r12, r22
    1d90:	7c 01       	movw	r14, r24
    1d92:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    1d96:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1d9a:	62 83       	std	Z+2, r22	; 0x02
    1d9c:	73 83       	std	Z+3, r23	; 0x03
    1d9e:	84 83       	std	Z+4, r24	; 0x04
    1da0:	95 83       	std	Z+5, r25	; 0x05
    1da2:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    1da6:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    1daa:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    1dae:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    1db2:	c8 16       	cp	r12, r24
    1db4:	d9 06       	cpc	r13, r25
    1db6:	ea 06       	cpc	r14, r26
    1db8:	fb 06       	cpc	r15, r27
    1dba:	68 f4       	brcc	.+26     	; 0x1dd6 <prvAddCurrentTaskToDelayedList+0x50>
    1dbc:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    1dc0:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1dc4:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    1dc8:	90 91 df 30 	lds	r25, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    1dcc:	6e 5f       	subi	r22, 0xFE	; 254
    1dce:	7f 4f       	sbci	r23, 0xFF	; 255
    1dd0:	0e 94 4e 0a 	call	0x149c	; 0x149c <vListInsert>
    1dd4:	21 c0       	rjmp	.+66     	; 0x1e18 <prvAddCurrentTaskToDelayedList+0x92>
    1dd6:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    1dda:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1dde:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    1de2:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    1de6:	6e 5f       	subi	r22, 0xFE	; 254
    1de8:	7f 4f       	sbci	r23, 0xFF	; 255
    1dea:	0e 94 4e 0a 	call	0x149c	; 0x149c <vListInsert>
    1dee:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1df2:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1df6:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1dfa:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1dfe:	c8 16       	cp	r12, r24
    1e00:	d9 06       	cpc	r13, r25
    1e02:	ea 06       	cpc	r14, r26
    1e04:	fb 06       	cpc	r15, r27
    1e06:	40 f4       	brcc	.+16     	; 0x1e18 <prvAddCurrentTaskToDelayedList+0x92>
    1e08:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1e0c:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e10:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e14:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e18:	ff 90       	pop	r15
    1e1a:	ef 90       	pop	r14
    1e1c:	df 90       	pop	r13
    1e1e:	cf 90       	pop	r12
    1e20:	08 95       	ret

00001e22 <xTaskGenericCreate>:
    1e22:	4f 92       	push	r4
    1e24:	5f 92       	push	r5
    1e26:	6f 92       	push	r6
    1e28:	7f 92       	push	r7
    1e2a:	8f 92       	push	r8
    1e2c:	9f 92       	push	r9
    1e2e:	af 92       	push	r10
    1e30:	bf 92       	push	r11
    1e32:	cf 92       	push	r12
    1e34:	df 92       	push	r13
    1e36:	ef 92       	push	r14
    1e38:	ff 92       	push	r15
    1e3a:	0f 93       	push	r16
    1e3c:	1f 93       	push	r17
    1e3e:	cf 93       	push	r28
    1e40:	df 93       	push	r29
    1e42:	5c 01       	movw	r10, r24
    1e44:	4b 01       	movw	r8, r22
    1e46:	3a 01       	movw	r6, r20
    1e48:	29 01       	movw	r4, r18
    1e4a:	88 e2       	ldi	r24, 0x28	; 40
    1e4c:	90 e0       	ldi	r25, 0x00	; 0
    1e4e:	0e 94 40 09 	call	0x1280	; 0x1280 <pvPortMalloc>
    1e52:	ec 01       	movw	r28, r24
    1e54:	89 2b       	or	r24, r25
    1e56:	09 f4       	brne	.+2      	; 0x1e5a <xTaskGenericCreate+0x38>
    1e58:	d4 c0       	rjmp	.+424    	; 0x2002 <xTaskGenericCreate+0x1e0>
    1e5a:	c1 14       	cp	r12, r1
    1e5c:	d1 04       	cpc	r13, r1
    1e5e:	09 f0       	breq	.+2      	; 0x1e62 <xTaskGenericCreate+0x40>
    1e60:	cc c0       	rjmp	.+408    	; 0x1ffa <xTaskGenericCreate+0x1d8>
    1e62:	c3 01       	movw	r24, r6
    1e64:	0e 94 40 09 	call	0x1280	; 0x1280 <pvPortMalloc>
    1e68:	8b 8f       	std	Y+27, r24	; 0x1b
    1e6a:	9c 8f       	std	Y+28, r25	; 0x1c
    1e6c:	00 97       	sbiw	r24, 0x00	; 0
    1e6e:	21 f4       	brne	.+8      	; 0x1e78 <xTaskGenericCreate+0x56>
    1e70:	ce 01       	movw	r24, r28
    1e72:	0e 94 da 09 	call	0x13b4	; 0x13b4 <vPortFree>
    1e76:	c5 c0       	rjmp	.+394    	; 0x2002 <xTaskGenericCreate+0x1e0>
    1e78:	a3 01       	movw	r20, r6
    1e7a:	61 e1       	ldi	r22, 0x11	; 17
    1e7c:	70 e0       	ldi	r23, 0x00	; 0
    1e7e:	0e 94 03 20 	call	0x4006	; 0x4006 <memset>
    1e82:	93 01       	movw	r18, r6
    1e84:	21 50       	subi	r18, 0x01	; 1
    1e86:	31 09       	sbc	r19, r1
    1e88:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e8a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e8c:	3c 01       	movw	r6, r24
    1e8e:	62 0e       	add	r6, r18
    1e90:	73 1e       	adc	r7, r19
    1e92:	4a e0       	ldi	r20, 0x0A	; 10
    1e94:	50 e0       	ldi	r21, 0x00	; 0
    1e96:	b4 01       	movw	r22, r8
    1e98:	ce 01       	movw	r24, r28
    1e9a:	4d 96       	adiw	r24, 0x1d	; 29
    1e9c:	0e 94 0a 20 	call	0x4014	; 0x4014 <strncpy>
    1ea0:	1e a2       	std	Y+38, r1	; 0x26
    1ea2:	10 2f       	mov	r17, r16
    1ea4:	04 30       	cpi	r16, 0x04	; 4
    1ea6:	08 f0       	brcs	.+2      	; 0x1eaa <xTaskGenericCreate+0x88>
    1ea8:	13 e0       	ldi	r17, 0x03	; 3
    1eaa:	1a 8f       	std	Y+26, r17	; 0x1a
    1eac:	1f a3       	std	Y+39, r17	; 0x27
    1eae:	6e 01       	movw	r12, r28
    1eb0:	22 e0       	ldi	r18, 0x02	; 2
    1eb2:	c2 0e       	add	r12, r18
    1eb4:	d1 1c       	adc	r13, r1
    1eb6:	c6 01       	movw	r24, r12
    1eb8:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInitialiseItem>
    1ebc:	ce 01       	movw	r24, r28
    1ebe:	0e 96       	adiw	r24, 0x0e	; 14
    1ec0:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInitialiseItem>
    1ec4:	ca 87       	std	Y+10, r28	; 0x0a
    1ec6:	db 87       	std	Y+11, r29	; 0x0b
    1ec8:	84 e0       	ldi	r24, 0x04	; 4
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	a0 e0       	ldi	r26, 0x00	; 0
    1ece:	b0 e0       	ldi	r27, 0x00	; 0
    1ed0:	81 1b       	sub	r24, r17
    1ed2:	91 09       	sbc	r25, r1
    1ed4:	a1 09       	sbc	r26, r1
    1ed6:	b1 09       	sbc	r27, r1
    1ed8:	8e 87       	std	Y+14, r24	; 0x0e
    1eda:	9f 87       	std	Y+15, r25	; 0x0f
    1edc:	a8 8b       	std	Y+16, r26	; 0x10
    1ede:	b9 8b       	std	Y+17, r27	; 0x11
    1ee0:	ce 8b       	std	Y+22, r28	; 0x16
    1ee2:	df 8b       	std	Y+23, r29	; 0x17
    1ee4:	a2 01       	movw	r20, r4
    1ee6:	b5 01       	movw	r22, r10
    1ee8:	c3 01       	movw	r24, r6
    1eea:	0e 94 bf 0a 	call	0x157e	; 0x157e <pxPortInitialiseStack>
    1eee:	88 83       	st	Y, r24
    1ef0:	99 83       	std	Y+1, r25	; 0x01
    1ef2:	e1 14       	cp	r14, r1
    1ef4:	f1 04       	cpc	r15, r1
    1ef6:	19 f0       	breq	.+6      	; 0x1efe <xTaskGenericCreate+0xdc>
    1ef8:	f7 01       	movw	r30, r14
    1efa:	c0 83       	st	Z, r28
    1efc:	d1 83       	std	Z+1, r29	; 0x01
    1efe:	0f b6       	in	r0, 0x3f	; 63
    1f00:	f8 94       	cli
    1f02:	0f 92       	push	r0
    1f04:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    1f08:	8f 5f       	subi	r24, 0xFF	; 255
    1f0a:	80 93 d0 30 	sts	0x30D0, r24	; 0x8030d0 <uxCurrentNumberOfTasks>
    1f0e:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    1f12:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1f16:	89 2b       	or	r24, r25
    1f18:	89 f5       	brne	.+98     	; 0x1f7c <xTaskGenericCreate+0x15a>
    1f1a:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    1f1e:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    1f22:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    1f26:	81 30       	cpi	r24, 0x01	; 1
    1f28:	c1 f5       	brne	.+112    	; 0x1f9a <xTaskGenericCreate+0x178>
    1f2a:	88 ef       	ldi	r24, 0xF8	; 248
    1f2c:	90 e3       	ldi	r25, 0x30	; 48
    1f2e:	0e 94 12 0a 	call	0x1424	; 0x1424 <vListInitialise>
    1f32:	83 e0       	ldi	r24, 0x03	; 3
    1f34:	91 e3       	ldi	r25, 0x31	; 49
    1f36:	0e 94 12 0a 	call	0x1424	; 0x1424 <vListInitialise>
    1f3a:	8e e0       	ldi	r24, 0x0E	; 14
    1f3c:	91 e3       	ldi	r25, 0x31	; 49
    1f3e:	0e 94 12 0a 	call	0x1424	; 0x1424 <vListInitialise>
    1f42:	89 e1       	ldi	r24, 0x19	; 25
    1f44:	91 e3       	ldi	r25, 0x31	; 49
    1f46:	0e 94 12 0a 	call	0x1424	; 0x1424 <vListInitialise>
    1f4a:	8d ee       	ldi	r24, 0xED	; 237
    1f4c:	90 e3       	ldi	r25, 0x30	; 48
    1f4e:	0e 94 12 0a 	call	0x1424	; 0x1424 <vListInitialise>
    1f52:	82 ee       	ldi	r24, 0xE2	; 226
    1f54:	90 e3       	ldi	r25, 0x30	; 48
    1f56:	0e 94 12 0a 	call	0x1424	; 0x1424 <vListInitialise>
    1f5a:	83 ed       	ldi	r24, 0xD3	; 211
    1f5c:	90 e3       	ldi	r25, 0x30	; 48
    1f5e:	0e 94 12 0a 	call	0x1424	; 0x1424 <vListInitialise>
    1f62:	8d ee       	ldi	r24, 0xED	; 237
    1f64:	90 e3       	ldi	r25, 0x30	; 48
    1f66:	80 93 e0 30 	sts	0x30E0, r24	; 0x8030e0 <pxDelayedTaskList>
    1f6a:	90 93 e1 30 	sts	0x30E1, r25	; 0x8030e1 <pxDelayedTaskList+0x1>
    1f6e:	82 ee       	ldi	r24, 0xE2	; 226
    1f70:	90 e3       	ldi	r25, 0x30	; 48
    1f72:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    1f76:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    1f7a:	0f c0       	rjmp	.+30     	; 0x1f9a <xTaskGenericCreate+0x178>
    1f7c:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    1f80:	81 11       	cpse	r24, r1
    1f82:	0b c0       	rjmp	.+22     	; 0x1f9a <xTaskGenericCreate+0x178>
    1f84:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    1f88:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1f8c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f8e:	08 17       	cp	r16, r24
    1f90:	20 f0       	brcs	.+8      	; 0x1f9a <xTaskGenericCreate+0x178>
    1f92:	c0 93 24 31 	sts	0x3124, r28	; 0x803124 <pxCurrentTCB>
    1f96:	d0 93 25 31 	sts	0x3125, r29	; 0x803125 <pxCurrentTCB+0x1>
    1f9a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f9c:	90 91 cb 30 	lds	r25, 0x30CB	; 0x8030cb <uxTopUsedPriority>
    1fa0:	98 17       	cp	r25, r24
    1fa2:	10 f4       	brcc	.+4      	; 0x1fa8 <xTaskGenericCreate+0x186>
    1fa4:	80 93 cb 30 	sts	0x30CB, r24	; 0x8030cb <uxTopUsedPriority>
    1fa8:	90 91 c4 30 	lds	r25, 0x30C4	; 0x8030c4 <uxTaskNumber>
    1fac:	9f 5f       	subi	r25, 0xFF	; 255
    1fae:	90 93 c4 30 	sts	0x30C4, r25	; 0x8030c4 <uxTaskNumber>
    1fb2:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    1fb6:	98 17       	cp	r25, r24
    1fb8:	10 f4       	brcc	.+4      	; 0x1fbe <xTaskGenericCreate+0x19c>
    1fba:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    1fbe:	fb e0       	ldi	r31, 0x0B	; 11
    1fc0:	8f 9f       	mul	r24, r31
    1fc2:	c0 01       	movw	r24, r0
    1fc4:	11 24       	eor	r1, r1
    1fc6:	b6 01       	movw	r22, r12
    1fc8:	88 50       	subi	r24, 0x08	; 8
    1fca:	9f 4c       	sbci	r25, 0xCF	; 207
    1fcc:	0e 94 27 0a 	call	0x144e	; 0x144e <vListInsertEnd>
    1fd0:	0f 90       	pop	r0
    1fd2:	0f be       	out	0x3f, r0	; 63
    1fd4:	80 91 c9 30 	lds	r24, 0x30C9	; 0x8030c9 <xSchedulerRunning>
    1fd8:	88 23       	and	r24, r24
    1fda:	59 f0       	breq	.+22     	; 0x1ff2 <xTaskGenericCreate+0x1d0>
    1fdc:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    1fe0:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    1fe4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fe6:	80 17       	cp	r24, r16
    1fe8:	30 f4       	brcc	.+12     	; 0x1ff6 <xTaskGenericCreate+0x1d4>
    1fea:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <vPortYield>
    1fee:	81 e0       	ldi	r24, 0x01	; 1
    1ff0:	09 c0       	rjmp	.+18     	; 0x2004 <xTaskGenericCreate+0x1e2>
    1ff2:	81 e0       	ldi	r24, 0x01	; 1
    1ff4:	07 c0       	rjmp	.+14     	; 0x2004 <xTaskGenericCreate+0x1e2>
    1ff6:	81 e0       	ldi	r24, 0x01	; 1
    1ff8:	05 c0       	rjmp	.+10     	; 0x2004 <xTaskGenericCreate+0x1e2>
    1ffa:	cb 8e       	std	Y+27, r12	; 0x1b
    1ffc:	dc 8e       	std	Y+28, r13	; 0x1c
    1ffe:	c6 01       	movw	r24, r12
    2000:	3b cf       	rjmp	.-394    	; 0x1e78 <xTaskGenericCreate+0x56>
    2002:	8f ef       	ldi	r24, 0xFF	; 255
    2004:	df 91       	pop	r29
    2006:	cf 91       	pop	r28
    2008:	1f 91       	pop	r17
    200a:	0f 91       	pop	r16
    200c:	ff 90       	pop	r15
    200e:	ef 90       	pop	r14
    2010:	df 90       	pop	r13
    2012:	cf 90       	pop	r12
    2014:	bf 90       	pop	r11
    2016:	af 90       	pop	r10
    2018:	9f 90       	pop	r9
    201a:	8f 90       	pop	r8
    201c:	7f 90       	pop	r7
    201e:	6f 90       	pop	r6
    2020:	5f 90       	pop	r5
    2022:	4f 90       	pop	r4
    2024:	08 95       	ret

00002026 <uxTaskPriorityGet>:
    2026:	0f b6       	in	r0, 0x3f	; 63
    2028:	f8 94       	cli
    202a:	0f 92       	push	r0
    202c:	00 97       	sbiw	r24, 0x00	; 0
    202e:	21 f4       	brne	.+8      	; 0x2038 <uxTaskPriorityGet+0x12>
    2030:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2034:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2038:	0f 90       	pop	r0
    203a:	0f be       	out	0x3f, r0	; 63
    203c:	fc 01       	movw	r30, r24
    203e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2040:	08 95       	ret

00002042 <vTaskStartScheduler>:
    2042:	af 92       	push	r10
    2044:	bf 92       	push	r11
    2046:	cf 92       	push	r12
    2048:	df 92       	push	r13
    204a:	ef 92       	push	r14
    204c:	ff 92       	push	r15
    204e:	0f 93       	push	r16
    2050:	a1 2c       	mov	r10, r1
    2052:	b1 2c       	mov	r11, r1
    2054:	c1 2c       	mov	r12, r1
    2056:	d1 2c       	mov	r13, r1
    2058:	0f 2e       	mov	r0, r31
    205a:	f1 ed       	ldi	r31, 0xD1	; 209
    205c:	ef 2e       	mov	r14, r31
    205e:	f0 e3       	ldi	r31, 0x30	; 48
    2060:	ff 2e       	mov	r15, r31
    2062:	f0 2d       	mov	r31, r0
    2064:	00 e0       	ldi	r16, 0x00	; 0
    2066:	20 e0       	ldi	r18, 0x00	; 0
    2068:	30 e0       	ldi	r19, 0x00	; 0
    206a:	44 e6       	ldi	r20, 0x64	; 100
    206c:	50 e0       	ldi	r21, 0x00	; 0
    206e:	66 e3       	ldi	r22, 0x36	; 54
    2070:	70 e2       	ldi	r23, 0x20	; 32
    2072:	8b eb       	ldi	r24, 0xBB	; 187
    2074:	9e e0       	ldi	r25, 0x0E	; 14
    2076:	0e 94 11 0f 	call	0x1e22	; 0x1e22 <xTaskGenericCreate>
    207a:	81 30       	cpi	r24, 0x01	; 1
    207c:	69 f4       	brne	.+26     	; 0x2098 <vTaskStartScheduler+0x56>
    207e:	f8 94       	cli
    2080:	80 93 c9 30 	sts	0x30C9, r24	; 0x8030c9 <xSchedulerRunning>
    2084:	10 92 cc 30 	sts	0x30CC, r1	; 0x8030cc <xTickCount>
    2088:	10 92 cd 30 	sts	0x30CD, r1	; 0x8030cd <xTickCount+0x1>
    208c:	10 92 ce 30 	sts	0x30CE, r1	; 0x8030ce <xTickCount+0x2>
    2090:	10 92 cf 30 	sts	0x30CF, r1	; 0x8030cf <xTickCount+0x3>
    2094:	0e 94 35 0b 	call	0x166a	; 0x166a <xPortStartScheduler>
    2098:	0f 91       	pop	r16
    209a:	ff 90       	pop	r15
    209c:	ef 90       	pop	r14
    209e:	df 90       	pop	r13
    20a0:	cf 90       	pop	r12
    20a2:	bf 90       	pop	r11
    20a4:	af 90       	pop	r10
    20a6:	08 95       	ret

000020a8 <vTaskSuspendAll>:
    20a8:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    20ac:	8f 5f       	subi	r24, 0xFF	; 255
    20ae:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>
    20b2:	08 95       	ret

000020b4 <xTaskGetTickCount>:
    20b4:	0f b6       	in	r0, 0x3f	; 63
    20b6:	f8 94       	cli
    20b8:	0f 92       	push	r0
    20ba:	60 91 cc 30 	lds	r22, 0x30CC	; 0x8030cc <xTickCount>
    20be:	70 91 cd 30 	lds	r23, 0x30CD	; 0x8030cd <xTickCount+0x1>
    20c2:	80 91 ce 30 	lds	r24, 0x30CE	; 0x8030ce <xTickCount+0x2>
    20c6:	90 91 cf 30 	lds	r25, 0x30CF	; 0x8030cf <xTickCount+0x3>
    20ca:	0f 90       	pop	r0
    20cc:	0f be       	out	0x3f, r0	; 63
    20ce:	08 95       	ret

000020d0 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20d0:	00 97       	sbiw	r24, 0x00	; 0
    20d2:	21 f4       	brne	.+8      	; 0x20dc <pcTaskGetTaskName+0xc>
    20d4:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    20d8:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    20dc:	4d 96       	adiw	r24, 0x1d	; 29
    20de:	08 95       	ret

000020e0 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    20e0:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xIdleTaskHandle>
    20e4:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <xIdleTaskHandle+0x1>
    20e8:	08 95       	ret

000020ea <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    20ea:	ff 92       	push	r15
    20ec:	0f 93       	push	r16
    20ee:	1f 93       	push	r17
    20f0:	cf 93       	push	r28
    20f2:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20f4:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    20f8:	81 11       	cpse	r24, r1
    20fa:	ed c0       	rjmp	.+474    	; 0x22d6 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    20fc:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2100:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2104:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2108:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    210c:	01 96       	adiw	r24, 0x01	; 1
    210e:	a1 1d       	adc	r26, r1
    2110:	b1 1d       	adc	r27, r1
    2112:	80 93 cc 30 	sts	0x30CC, r24	; 0x8030cc <xTickCount>
    2116:	90 93 cd 30 	sts	0x30CD, r25	; 0x8030cd <xTickCount+0x1>
    211a:	a0 93 ce 30 	sts	0x30CE, r26	; 0x8030ce <xTickCount+0x2>
    211e:	b0 93 cf 30 	sts	0x30CF, r27	; 0x8030cf <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    2122:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2126:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    212a:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    212e:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2132:	89 2b       	or	r24, r25
    2134:	8a 2b       	or	r24, r26
    2136:	8b 2b       	or	r24, r27
    2138:	f1 f5       	brne	.+124    	; 0x21b6 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    213a:	80 91 e0 30 	lds	r24, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    213e:	90 91 e1 30 	lds	r25, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2142:	20 91 de 30 	lds	r18, 0x30DE	; 0x8030de <pxOverflowDelayedTaskList>
    2146:	30 91 df 30 	lds	r19, 0x30DF	; 0x8030df <pxOverflowDelayedTaskList+0x1>
    214a:	20 93 e0 30 	sts	0x30E0, r18	; 0x8030e0 <pxDelayedTaskList>
    214e:	30 93 e1 30 	sts	0x30E1, r19	; 0x8030e1 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    2152:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <pxOverflowDelayedTaskList>
    2156:	90 93 df 30 	sts	0x30DF, r25	; 0x8030df <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    215a:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    215e:	8f 5f       	subi	r24, 0xFF	; 255
    2160:	80 93 c5 30 	sts	0x30C5, r24	; 0x8030c5 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2164:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    2168:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    216c:	80 81       	ld	r24, Z
    216e:	81 11       	cpse	r24, r1
    2170:	0c c0       	rjmp	.+24     	; 0x218a <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2172:	8f ef       	ldi	r24, 0xFF	; 255
    2174:	9f ef       	ldi	r25, 0xFF	; 255
    2176:	dc 01       	movw	r26, r24
    2178:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    217c:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2180:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2184:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2188:	16 c0       	rjmp	.+44     	; 0x21b6 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    218a:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    218e:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    2192:	07 80       	ldd	r0, Z+7	; 0x07
    2194:	f0 85       	ldd	r31, Z+8	; 0x08
    2196:	e0 2d       	mov	r30, r0
    2198:	00 84       	ldd	r0, Z+8	; 0x08
    219a:	f1 85       	ldd	r31, Z+9	; 0x09
    219c:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    219e:	82 81       	ldd	r24, Z+2	; 0x02
    21a0:	93 81       	ldd	r25, Z+3	; 0x03
    21a2:	a4 81       	ldd	r26, Z+4	; 0x04
    21a4:	b5 81       	ldd	r27, Z+5	; 0x05
    21a6:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21aa:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21ae:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    21b2:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    21b6:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    21ba:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    21be:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    21c2:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    21c6:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    21ca:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    21ce:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    21d2:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    21d6:	48 17       	cp	r20, r24
    21d8:	59 07       	cpc	r21, r25
    21da:	6a 07       	cpc	r22, r26
    21dc:	7b 07       	cpc	r23, r27
    21de:	08 f4       	brcc	.+2      	; 0x21e2 <vTaskIncrementTick+0xf8>
    21e0:	7f c0       	rjmp	.+254    	; 0x22e0 <vTaskIncrementTick+0x1f6>
    21e2:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    21e6:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    21ea:	80 81       	ld	r24, Z
    21ec:	88 23       	and	r24, r24
    21ee:	f9 f0       	breq	.+62     	; 0x222e <vTaskIncrementTick+0x144>
    21f0:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    21f4:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    21f8:	07 80       	ldd	r0, Z+7	; 0x07
    21fa:	f0 85       	ldd	r31, Z+8	; 0x08
    21fc:	e0 2d       	mov	r30, r0
    21fe:	c0 85       	ldd	r28, Z+8	; 0x08
    2200:	d1 85       	ldd	r29, Z+9	; 0x09
    2202:	8a 81       	ldd	r24, Y+2	; 0x02
    2204:	9b 81       	ldd	r25, Y+3	; 0x03
    2206:	ac 81       	ldd	r26, Y+4	; 0x04
    2208:	bd 81       	ldd	r27, Y+5	; 0x05
    220a:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    220e:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2212:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2216:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    221a:	48 17       	cp	r20, r24
    221c:	59 07       	cpc	r21, r25
    221e:	6a 07       	cpc	r22, r26
    2220:	7b 07       	cpc	r23, r27
    2222:	58 f1       	brcs	.+86     	; 0x227a <vTaskIncrementTick+0x190>
    2224:	0f 2e       	mov	r0, r31
    2226:	fb e0       	ldi	r31, 0x0B	; 11
    2228:	ff 2e       	mov	r15, r31
    222a:	f0 2d       	mov	r31, r0
    222c:	2f c0       	rjmp	.+94     	; 0x228c <vTaskIncrementTick+0x1a2>
    222e:	8f ef       	ldi	r24, 0xFF	; 255
    2230:	9f ef       	ldi	r25, 0xFF	; 255
    2232:	dc 01       	movw	r26, r24
    2234:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2238:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    223c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2240:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2244:	4d c0       	rjmp	.+154    	; 0x22e0 <vTaskIncrementTick+0x1f6>
    2246:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    224a:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    224e:	07 80       	ldd	r0, Z+7	; 0x07
    2250:	f0 85       	ldd	r31, Z+8	; 0x08
    2252:	e0 2d       	mov	r30, r0
    2254:	c0 85       	ldd	r28, Z+8	; 0x08
    2256:	d1 85       	ldd	r29, Z+9	; 0x09
    2258:	8a 81       	ldd	r24, Y+2	; 0x02
    225a:	9b 81       	ldd	r25, Y+3	; 0x03
    225c:	ac 81       	ldd	r26, Y+4	; 0x04
    225e:	bd 81       	ldd	r27, Y+5	; 0x05
    2260:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    2264:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2268:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    226c:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2270:	48 17       	cp	r20, r24
    2272:	59 07       	cpc	r21, r25
    2274:	6a 07       	cpc	r22, r26
    2276:	7b 07       	cpc	r23, r27
    2278:	48 f4       	brcc	.+18     	; 0x228c <vTaskIncrementTick+0x1a2>
    227a:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    227e:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2282:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2286:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    228a:	2a c0       	rjmp	.+84     	; 0x22e0 <vTaskIncrementTick+0x1f6>
    228c:	8e 01       	movw	r16, r28
    228e:	0e 5f       	subi	r16, 0xFE	; 254
    2290:	1f 4f       	sbci	r17, 0xFF	; 255
    2292:	c8 01       	movw	r24, r16
    2294:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListRemove>
    2298:	88 8d       	ldd	r24, Y+24	; 0x18
    229a:	99 8d       	ldd	r25, Y+25	; 0x19
    229c:	89 2b       	or	r24, r25
    229e:	21 f0       	breq	.+8      	; 0x22a8 <vTaskIncrementTick+0x1be>
    22a0:	ce 01       	movw	r24, r28
    22a2:	0e 96       	adiw	r24, 0x0e	; 14
    22a4:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListRemove>
    22a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22aa:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    22ae:	98 17       	cp	r25, r24
    22b0:	10 f4       	brcc	.+4      	; 0x22b6 <vTaskIncrementTick+0x1cc>
    22b2:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    22b6:	f8 9e       	mul	r15, r24
    22b8:	c0 01       	movw	r24, r0
    22ba:	11 24       	eor	r1, r1
    22bc:	b8 01       	movw	r22, r16
    22be:	88 50       	subi	r24, 0x08	; 8
    22c0:	9f 4c       	sbci	r25, 0xCF	; 207
    22c2:	0e 94 27 0a 	call	0x144e	; 0x144e <vListInsertEnd>
    22c6:	e0 91 e0 30 	lds	r30, 0x30E0	; 0x8030e0 <pxDelayedTaskList>
    22ca:	f0 91 e1 30 	lds	r31, 0x30E1	; 0x8030e1 <pxDelayedTaskList+0x1>
    22ce:	80 81       	ld	r24, Z
    22d0:	81 11       	cpse	r24, r1
    22d2:	b9 cf       	rjmp	.-142    	; 0x2246 <vTaskIncrementTick+0x15c>
    22d4:	ac cf       	rjmp	.-168    	; 0x222e <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    22d6:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    22da:	8f 5f       	subi	r24, 0xFF	; 255
    22dc:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    22e0:	df 91       	pop	r29
    22e2:	cf 91       	pop	r28
    22e4:	1f 91       	pop	r17
    22e6:	0f 91       	pop	r16
    22e8:	ff 90       	pop	r15
    22ea:	08 95       	ret

000022ec <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    22ec:	cf 92       	push	r12
    22ee:	df 92       	push	r13
    22f0:	ef 92       	push	r14
    22f2:	ff 92       	push	r15
    22f4:	0f 93       	push	r16
    22f6:	1f 93       	push	r17
    22f8:	cf 93       	push	r28
    22fa:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    22fc:	0f b6       	in	r0, 0x3f	; 63
    22fe:	f8 94       	cli
    2300:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2302:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2306:	81 50       	subi	r24, 0x01	; 1
    2308:	80 93 c8 30 	sts	0x30C8, r24	; 0x8030c8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    230c:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    2310:	81 11       	cpse	r24, r1
    2312:	60 c0       	rjmp	.+192    	; 0x23d4 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2314:	80 91 d0 30 	lds	r24, 0x30D0	; 0x8030d0 <uxCurrentNumberOfTasks>
    2318:	81 11       	cpse	r24, r1
    231a:	2c c0       	rjmp	.+88     	; 0x2374 <xTaskResumeAll+0x88>
    231c:	5e c0       	rjmp	.+188    	; 0x23da <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    231e:	d7 01       	movw	r26, r14
    2320:	17 96       	adiw	r26, 0x07	; 7
    2322:	ed 91       	ld	r30, X+
    2324:	fc 91       	ld	r31, X
    2326:	18 97       	sbiw	r26, 0x08	; 8
    2328:	c0 85       	ldd	r28, Z+8	; 0x08
    232a:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    232c:	ce 01       	movw	r24, r28
    232e:	0e 96       	adiw	r24, 0x0e	; 14
    2330:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2334:	8e 01       	movw	r16, r28
    2336:	0e 5f       	subi	r16, 0xFE	; 254
    2338:	1f 4f       	sbci	r17, 0xFF	; 255
    233a:	c8 01       	movw	r24, r16
    233c:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2340:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2342:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2346:	98 17       	cp	r25, r24
    2348:	10 f4       	brcc	.+4      	; 0x234e <xTaskResumeAll+0x62>
    234a:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    234e:	d8 9e       	mul	r13, r24
    2350:	c0 01       	movw	r24, r0
    2352:	11 24       	eor	r1, r1
    2354:	b8 01       	movw	r22, r16
    2356:	88 50       	subi	r24, 0x08	; 8
    2358:	9f 4c       	sbci	r25, 0xCF	; 207
    235a:	0e 94 27 0a 	call	0x144e	; 0x144e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    235e:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2362:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2366:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2368:	82 8d       	ldd	r24, Z+26	; 0x1a
    236a:	98 17       	cp	r25, r24
    236c:	70 f0       	brcs	.+28     	; 0x238a <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    236e:	cc 24       	eor	r12, r12
    2370:	c3 94       	inc	r12
    2372:	0b c0       	rjmp	.+22     	; 0x238a <xTaskResumeAll+0x9e>
    2374:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2376:	0f 2e       	mov	r0, r31
    2378:	f3 ed       	ldi	r31, 0xD3	; 211
    237a:	ef 2e       	mov	r14, r31
    237c:	f0 e3       	ldi	r31, 0x30	; 48
    237e:	ff 2e       	mov	r15, r31
    2380:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    2382:	0f 2e       	mov	r0, r31
    2384:	fb e0       	ldi	r31, 0x0B	; 11
    2386:	df 2e       	mov	r13, r31
    2388:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    238a:	f7 01       	movw	r30, r14
    238c:	80 81       	ld	r24, Z
    238e:	81 11       	cpse	r24, r1
    2390:	c6 cf       	rjmp	.-116    	; 0x231e <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2392:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    2396:	88 23       	and	r24, r24
    2398:	81 f0       	breq	.+32     	; 0x23ba <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    239a:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    239e:	88 23       	and	r24, r24
    23a0:	99 f0       	breq	.+38     	; 0x23c8 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    23a2:	0e 94 75 10 	call	0x20ea	; 0x20ea <vTaskIncrementTick>
						--uxMissedTicks;
    23a6:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    23aa:	81 50       	subi	r24, 0x01	; 1
    23ac:	80 93 c7 30 	sts	0x30C7, r24	; 0x8030c7 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23b0:	80 91 c7 30 	lds	r24, 0x30C7	; 0x8030c7 <uxMissedTicks>
    23b4:	81 11       	cpse	r24, r1
    23b6:	f5 cf       	rjmp	.-22     	; 0x23a2 <xTaskResumeAll+0xb6>
    23b8:	07 c0       	rjmp	.+14     	; 0x23c8 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    23ba:	f1 e0       	ldi	r31, 0x01	; 1
    23bc:	cf 16       	cp	r12, r31
    23be:	21 f0       	breq	.+8      	; 0x23c8 <xTaskResumeAll+0xdc>
    23c0:	80 91 c6 30 	lds	r24, 0x30C6	; 0x8030c6 <xMissedYield>
    23c4:	81 30       	cpi	r24, 0x01	; 1
    23c6:	41 f4       	brne	.+16     	; 0x23d8 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    23c8:	10 92 c6 30 	sts	0x30C6, r1	; 0x8030c6 <xMissedYield>
					portYIELD_WITHIN_API();
    23cc:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    23d0:	81 e0       	ldi	r24, 0x01	; 1
    23d2:	03 c0       	rjmp	.+6      	; 0x23da <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    23d4:	80 e0       	ldi	r24, 0x00	; 0
    23d6:	01 c0       	rjmp	.+2      	; 0x23da <xTaskResumeAll+0xee>
    23d8:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    23da:	0f 90       	pop	r0
    23dc:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    23de:	df 91       	pop	r29
    23e0:	cf 91       	pop	r28
    23e2:	1f 91       	pop	r17
    23e4:	0f 91       	pop	r16
    23e6:	ff 90       	pop	r15
    23e8:	ef 90       	pop	r14
    23ea:	df 90       	pop	r13
    23ec:	cf 90       	pop	r12
    23ee:	08 95       	ret

000023f0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    23f0:	cf 92       	push	r12
    23f2:	df 92       	push	r13
    23f4:	ef 92       	push	r14
    23f6:	ff 92       	push	r15
    23f8:	cf 93       	push	r28
    23fa:	df 93       	push	r29
    23fc:	ec 01       	movw	r28, r24
    23fe:	6a 01       	movw	r12, r20
    2400:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2402:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2406:	88 81       	ld	r24, Y
    2408:	99 81       	ldd	r25, Y+1	; 0x01
    240a:	aa 81       	ldd	r26, Y+2	; 0x02
    240c:	bb 81       	ldd	r27, Y+3	; 0x03
    240e:	c8 0e       	add	r12, r24
    2410:	d9 1e       	adc	r13, r25
    2412:	ea 1e       	adc	r14, r26
    2414:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2416:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    241a:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    241e:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2422:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2426:	48 17       	cp	r20, r24
    2428:	59 07       	cpc	r21, r25
    242a:	6a 07       	cpc	r22, r26
    242c:	7b 07       	cpc	r23, r27
    242e:	b8 f4       	brcc	.+46     	; 0x245e <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2430:	c8 16       	cp	r12, r24
    2432:	d9 06       	cpc	r13, r25
    2434:	ea 06       	cpc	r14, r26
    2436:	fb 06       	cpc	r15, r27
    2438:	e0 f5       	brcc	.+120    	; 0x24b2 <vTaskDelayUntil+0xc2>
    243a:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    243e:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2442:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2446:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    244a:	c8 82       	st	Y, r12
    244c:	d9 82       	std	Y+1, r13	; 0x01
    244e:	ea 82       	std	Y+2, r14	; 0x02
    2450:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2452:	8c 15       	cp	r24, r12
    2454:	9d 05       	cpc	r25, r13
    2456:	ae 05       	cpc	r26, r14
    2458:	bf 05       	cpc	r27, r15
    245a:	f8 f4       	brcc	.+62     	; 0x249a <vTaskDelayUntil+0xaa>
    245c:	13 c0       	rjmp	.+38     	; 0x2484 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    245e:	c8 16       	cp	r12, r24
    2460:	d9 06       	cpc	r13, r25
    2462:	ea 06       	cpc	r14, r26
    2464:	fb 06       	cpc	r15, r27
    2466:	00 f1       	brcs	.+64     	; 0x24a8 <vTaskDelayUntil+0xb8>
    2468:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    246c:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2470:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2474:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2478:	8c 15       	cp	r24, r12
    247a:	9d 05       	cpc	r25, r13
    247c:	ae 05       	cpc	r26, r14
    247e:	bf 05       	cpc	r27, r15
    2480:	98 f0       	brcs	.+38     	; 0x24a8 <vTaskDelayUntil+0xb8>
    2482:	17 c0       	rjmp	.+46     	; 0x24b2 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2484:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2488:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    248c:	02 96       	adiw	r24, 0x02	; 2
    248e:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2492:	c7 01       	movw	r24, r14
    2494:	b6 01       	movw	r22, r12
    2496:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    249a:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    249e:	81 11       	cpse	r24, r1
    24a0:	0d c0       	rjmp	.+26     	; 0x24bc <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    24a2:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <vPortYield>
		}
	}
    24a6:	0a c0       	rjmp	.+20     	; 0x24bc <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24a8:	c8 82       	st	Y, r12
    24aa:	d9 82       	std	Y+1, r13	; 0x01
    24ac:	ea 82       	std	Y+2, r14	; 0x02
    24ae:	fb 82       	std	Y+3, r15	; 0x03
    24b0:	e9 cf       	rjmp	.-46     	; 0x2484 <vTaskDelayUntil+0x94>
    24b2:	c8 82       	st	Y, r12
    24b4:	d9 82       	std	Y+1, r13	; 0x01
    24b6:	ea 82       	std	Y+2, r14	; 0x02
    24b8:	fb 82       	std	Y+3, r15	; 0x03
    24ba:	ef cf       	rjmp	.-34     	; 0x249a <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    24bc:	df 91       	pop	r29
    24be:	cf 91       	pop	r28
    24c0:	ff 90       	pop	r15
    24c2:	ef 90       	pop	r14
    24c4:	df 90       	pop	r13
    24c6:	cf 90       	pop	r12
    24c8:	08 95       	ret

000024ca <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    24ca:	cf 92       	push	r12
    24cc:	df 92       	push	r13
    24ce:	ef 92       	push	r14
    24d0:	ff 92       	push	r15
    24d2:	6b 01       	movw	r12, r22
    24d4:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    24d6:	67 2b       	or	r22, r23
    24d8:	68 2b       	or	r22, r24
    24da:	69 2b       	or	r22, r25
    24dc:	e9 f0       	breq	.+58     	; 0x2518 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    24de:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    24e2:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    24e6:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    24ea:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    24ee:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    24f2:	c8 0e       	add	r12, r24
    24f4:	d9 1e       	adc	r13, r25
    24f6:	ea 1e       	adc	r14, r26
    24f8:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24fa:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    24fe:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2502:	02 96       	adiw	r24, 0x02	; 2
    2504:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2508:	c7 01       	movw	r24, r14
    250a:	b6 01       	movw	r22, r12
    250c:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2510:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2514:	81 11       	cpse	r24, r1
    2516:	02 c0       	rjmp	.+4      	; 0x251c <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2518:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <vPortYield>
		}
	}
    251c:	ff 90       	pop	r15
    251e:	ef 90       	pop	r14
    2520:	df 90       	pop	r13
    2522:	cf 90       	pop	r12
    2524:	08 95       	ret

00002526 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2526:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    252a:	81 11       	cpse	r24, r1
    252c:	0c c0       	rjmp	.+24     	; 0x2546 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    252e:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2532:	4b e0       	ldi	r20, 0x0B	; 11
    2534:	e4 9f       	mul	r30, r20
    2536:	f0 01       	movw	r30, r0
    2538:	11 24       	eor	r1, r1
    253a:	e8 50       	subi	r30, 0x08	; 8
    253c:	ff 4c       	sbci	r31, 0xCF	; 207
    253e:	80 81       	ld	r24, Z
    2540:	88 23       	and	r24, r24
    2542:	29 f0       	breq	.+10     	; 0x254e <vTaskSwitchContext+0x28>
    2544:	14 c0       	rjmp	.+40     	; 0x256e <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2546:	81 e0       	ldi	r24, 0x01	; 1
    2548:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    254c:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    254e:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2550:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2554:	81 50       	subi	r24, 0x01	; 1
    2556:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    255a:	e0 91 ca 30 	lds	r30, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    255e:	9e 9f       	mul	r25, r30
    2560:	f0 01       	movw	r30, r0
    2562:	11 24       	eor	r1, r1
    2564:	e8 50       	subi	r30, 0x08	; 8
    2566:	ff 4c       	sbci	r31, 0xCF	; 207
    2568:	80 81       	ld	r24, Z
    256a:	88 23       	and	r24, r24
    256c:	89 f3       	breq	.-30     	; 0x2550 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    256e:	80 91 ca 30 	lds	r24, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2572:	28 2f       	mov	r18, r24
    2574:	30 e0       	ldi	r19, 0x00	; 0
    2576:	4b e0       	ldi	r20, 0x0B	; 11
    2578:	84 9f       	mul	r24, r20
    257a:	c0 01       	movw	r24, r0
    257c:	11 24       	eor	r1, r1
    257e:	dc 01       	movw	r26, r24
    2580:	a8 50       	subi	r26, 0x08	; 8
    2582:	bf 4c       	sbci	r27, 0xCF	; 207
    2584:	11 96       	adiw	r26, 0x01	; 1
    2586:	ed 91       	ld	r30, X+
    2588:	fc 91       	ld	r31, X
    258a:	12 97       	sbiw	r26, 0x02	; 2
    258c:	04 80       	ldd	r0, Z+4	; 0x04
    258e:	f5 81       	ldd	r31, Z+5	; 0x05
    2590:	e0 2d       	mov	r30, r0
    2592:	11 96       	adiw	r26, 0x01	; 1
    2594:	ed 93       	st	X+, r30
    2596:	fc 93       	st	X, r31
    2598:	12 97       	sbiw	r26, 0x02	; 2
    259a:	85 50       	subi	r24, 0x05	; 5
    259c:	9f 4c       	sbci	r25, 0xCF	; 207
    259e:	e8 17       	cp	r30, r24
    25a0:	f9 07       	cpc	r31, r25
    25a2:	61 f4       	brne	.+24     	; 0x25bc <vTaskSwitchContext+0x96>
    25a4:	84 81       	ldd	r24, Z+4	; 0x04
    25a6:	95 81       	ldd	r25, Z+5	; 0x05
    25a8:	4b e0       	ldi	r20, 0x0B	; 11
    25aa:	42 9f       	mul	r20, r18
    25ac:	f0 01       	movw	r30, r0
    25ae:	43 9f       	mul	r20, r19
    25b0:	f0 0d       	add	r31, r0
    25b2:	11 24       	eor	r1, r1
    25b4:	e8 50       	subi	r30, 0x08	; 8
    25b6:	ff 4c       	sbci	r31, 0xCF	; 207
    25b8:	81 83       	std	Z+1, r24	; 0x01
    25ba:	92 83       	std	Z+2, r25	; 0x02
    25bc:	8b e0       	ldi	r24, 0x0B	; 11
    25be:	82 9f       	mul	r24, r18
    25c0:	f0 01       	movw	r30, r0
    25c2:	83 9f       	mul	r24, r19
    25c4:	f0 0d       	add	r31, r0
    25c6:	11 24       	eor	r1, r1
    25c8:	e8 50       	subi	r30, 0x08	; 8
    25ca:	ff 4c       	sbci	r31, 0xCF	; 207
    25cc:	01 80       	ldd	r0, Z+1	; 0x01
    25ce:	f2 81       	ldd	r31, Z+2	; 0x02
    25d0:	e0 2d       	mov	r30, r0
    25d2:	80 85       	ldd	r24, Z+8	; 0x08
    25d4:	91 85       	ldd	r25, Z+9	; 0x09
    25d6:	80 93 24 31 	sts	0x3124, r24	; 0x803124 <pxCurrentTCB>
    25da:	90 93 25 31 	sts	0x3125, r25	; 0x803125 <pxCurrentTCB+0x1>
    25de:	08 95       	ret

000025e0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    25e0:	cf 92       	push	r12
    25e2:	df 92       	push	r13
    25e4:	ef 92       	push	r14
    25e6:	ff 92       	push	r15
    25e8:	6a 01       	movw	r12, r20
    25ea:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    25ec:	60 91 24 31 	lds	r22, 0x3124	; 0x803124 <pxCurrentTCB>
    25f0:	70 91 25 31 	lds	r23, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    25f4:	62 5f       	subi	r22, 0xF2	; 242
    25f6:	7f 4f       	sbci	r23, 0xFF	; 255
    25f8:	0e 94 4e 0a 	call	0x149c	; 0x149c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25fc:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    2600:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2604:	02 96       	adiw	r24, 0x02	; 2
    2606:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    260a:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    260e:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2612:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2616:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    261a:	bc 01       	movw	r22, r24
    261c:	cd 01       	movw	r24, r26
    261e:	6c 0d       	add	r22, r12
    2620:	7d 1d       	adc	r23, r13
    2622:	8e 1d       	adc	r24, r14
    2624:	9f 1d       	adc	r25, r15
    2626:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    262a:	ff 90       	pop	r15
    262c:	ef 90       	pop	r14
    262e:	df 90       	pop	r13
    2630:	cf 90       	pop	r12
    2632:	08 95       	ret

00002634 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2634:	0f 93       	push	r16
    2636:	1f 93       	push	r17
    2638:	cf 93       	push	r28
    263a:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    263c:	dc 01       	movw	r26, r24
    263e:	17 96       	adiw	r26, 0x07	; 7
    2640:	ed 91       	ld	r30, X+
    2642:	fc 91       	ld	r31, X
    2644:	18 97       	sbiw	r26, 0x08	; 8
    2646:	c0 85       	ldd	r28, Z+8	; 0x08
    2648:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    264a:	8e 01       	movw	r16, r28
    264c:	02 5f       	subi	r16, 0xF2	; 242
    264e:	1f 4f       	sbci	r17, 0xFF	; 255
    2650:	c8 01       	movw	r24, r16
    2652:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2656:	80 91 c8 30 	lds	r24, 0x30C8	; 0x8030c8 <uxSchedulerSuspended>
    265a:	81 11       	cpse	r24, r1
    265c:	16 c0       	rjmp	.+44     	; 0x268a <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    265e:	0c 50       	subi	r16, 0x0C	; 12
    2660:	11 09       	sbc	r17, r1
    2662:	c8 01       	movw	r24, r16
    2664:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2668:	8a 8d       	ldd	r24, Y+26	; 0x1a
    266a:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    266e:	98 17       	cp	r25, r24
    2670:	10 f4       	brcc	.+4      	; 0x2676 <xTaskRemoveFromEventList+0x42>
    2672:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2676:	bb e0       	ldi	r27, 0x0B	; 11
    2678:	8b 9f       	mul	r24, r27
    267a:	c0 01       	movw	r24, r0
    267c:	11 24       	eor	r1, r1
    267e:	b8 01       	movw	r22, r16
    2680:	88 50       	subi	r24, 0x08	; 8
    2682:	9f 4c       	sbci	r25, 0xCF	; 207
    2684:	0e 94 27 0a 	call	0x144e	; 0x144e <vListInsertEnd>
    2688:	05 c0       	rjmp	.+10     	; 0x2694 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    268a:	b8 01       	movw	r22, r16
    268c:	83 ed       	ldi	r24, 0xD3	; 211
    268e:	90 e3       	ldi	r25, 0x30	; 48
    2690:	0e 94 27 0a 	call	0x144e	; 0x144e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2694:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    2698:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    269c:	81 e0       	ldi	r24, 0x01	; 1
    269e:	2a 8d       	ldd	r18, Y+26	; 0x1a
    26a0:	92 8d       	ldd	r25, Z+26	; 0x1a
    26a2:	29 17       	cp	r18, r25
    26a4:	08 f4       	brcc	.+2      	; 0x26a8 <xTaskRemoveFromEventList+0x74>
    26a6:	80 e0       	ldi	r24, 0x00	; 0
}
    26a8:	df 91       	pop	r29
    26aa:	cf 91       	pop	r28
    26ac:	1f 91       	pop	r17
    26ae:	0f 91       	pop	r16
    26b0:	08 95       	ret

000026b2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    26b2:	20 91 c5 30 	lds	r18, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    26b6:	fc 01       	movw	r30, r24
    26b8:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    26ba:	40 91 cc 30 	lds	r20, 0x30CC	; 0x8030cc <xTickCount>
    26be:	50 91 cd 30 	lds	r21, 0x30CD	; 0x8030cd <xTickCount+0x1>
    26c2:	60 91 ce 30 	lds	r22, 0x30CE	; 0x8030ce <xTickCount+0x2>
    26c6:	70 91 cf 30 	lds	r23, 0x30CF	; 0x8030cf <xTickCount+0x3>
    26ca:	41 83       	std	Z+1, r20	; 0x01
    26cc:	52 83       	std	Z+2, r21	; 0x02
    26ce:	63 83       	std	Z+3, r22	; 0x03
    26d0:	74 83       	std	Z+4, r23	; 0x04
    26d2:	08 95       	ret

000026d4 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    26d4:	8f 92       	push	r8
    26d6:	9f 92       	push	r9
    26d8:	af 92       	push	r10
    26da:	bf 92       	push	r11
    26dc:	cf 92       	push	r12
    26de:	df 92       	push	r13
    26e0:	ef 92       	push	r14
    26e2:	ff 92       	push	r15
    26e4:	0f 93       	push	r16
    26e6:	1f 93       	push	r17
    26e8:	cf 93       	push	r28
    26ea:	df 93       	push	r29
    26ec:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    26ee:	0f b6       	in	r0, 0x3f	; 63
    26f0:	f8 94       	cli
    26f2:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    26f4:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xNumOfOverflows>
    26f8:	90 81       	ld	r25, Z
    26fa:	98 17       	cp	r25, r24
    26fc:	89 f0       	breq	.+34     	; 0x2720 <xTaskCheckForTimeOut+0x4c>
    26fe:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2702:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2706:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    270a:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    270e:	01 81       	ldd	r16, Z+1	; 0x01
    2710:	12 81       	ldd	r17, Z+2	; 0x02
    2712:	23 81       	ldd	r18, Z+3	; 0x03
    2714:	34 81       	ldd	r19, Z+4	; 0x04
    2716:	80 17       	cp	r24, r16
    2718:	91 07       	cpc	r25, r17
    271a:	a2 07       	cpc	r26, r18
    271c:	b3 07       	cpc	r27, r19
    271e:	a8 f5       	brcc	.+106    	; 0x278a <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2720:	80 91 cc 30 	lds	r24, 0x30CC	; 0x8030cc <xTickCount>
    2724:	90 91 cd 30 	lds	r25, 0x30CD	; 0x8030cd <xTickCount+0x1>
    2728:	a0 91 ce 30 	lds	r26, 0x30CE	; 0x8030ce <xTickCount+0x2>
    272c:	b0 91 cf 30 	lds	r27, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2730:	c1 80       	ldd	r12, Z+1	; 0x01
    2732:	d2 80       	ldd	r13, Z+2	; 0x02
    2734:	e3 80       	ldd	r14, Z+3	; 0x03
    2736:	f4 80       	ldd	r15, Z+4	; 0x04
    2738:	eb 01       	movw	r28, r22
    273a:	08 81       	ld	r16, Y
    273c:	19 81       	ldd	r17, Y+1	; 0x01
    273e:	2a 81       	ldd	r18, Y+2	; 0x02
    2740:	3b 81       	ldd	r19, Y+3	; 0x03
    2742:	8c 19       	sub	r24, r12
    2744:	9d 09       	sbc	r25, r13
    2746:	ae 09       	sbc	r26, r14
    2748:	bf 09       	sbc	r27, r15
    274a:	80 17       	cp	r24, r16
    274c:	91 07       	cpc	r25, r17
    274e:	a2 07       	cpc	r26, r18
    2750:	b3 07       	cpc	r27, r19
    2752:	e8 f4       	brcc	.+58     	; 0x278e <xTaskCheckForTimeOut+0xba>
    2754:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2756:	80 90 cc 30 	lds	r8, 0x30CC	; 0x8030cc <xTickCount>
    275a:	90 90 cd 30 	lds	r9, 0x30CD	; 0x8030cd <xTickCount+0x1>
    275e:	a0 90 ce 30 	lds	r10, 0x30CE	; 0x8030ce <xTickCount+0x2>
    2762:	b0 90 cf 30 	lds	r11, 0x30CF	; 0x8030cf <xTickCount+0x3>
    2766:	b5 01       	movw	r22, r10
    2768:	a4 01       	movw	r20, r8
    276a:	4c 19       	sub	r20, r12
    276c:	5d 09       	sbc	r21, r13
    276e:	6e 09       	sbc	r22, r14
    2770:	7f 09       	sbc	r23, r15
    2772:	04 1b       	sub	r16, r20
    2774:	15 0b       	sbc	r17, r21
    2776:	26 0b       	sbc	r18, r22
    2778:	37 0b       	sbc	r19, r23
    277a:	08 83       	st	Y, r16
    277c:	19 83       	std	Y+1, r17	; 0x01
    277e:	2a 83       	std	Y+2, r18	; 0x02
    2780:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2782:	0e 94 59 13 	call	0x26b2	; 0x26b2 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2786:	80 e0       	ldi	r24, 0x00	; 0
    2788:	03 c0       	rjmp	.+6      	; 0x2790 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    278a:	81 e0       	ldi	r24, 0x01	; 1
    278c:	01 c0       	rjmp	.+2      	; 0x2790 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    278e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2790:	0f 90       	pop	r0
    2792:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2794:	df 91       	pop	r29
    2796:	cf 91       	pop	r28
    2798:	1f 91       	pop	r17
    279a:	0f 91       	pop	r16
    279c:	ff 90       	pop	r15
    279e:	ef 90       	pop	r14
    27a0:	df 90       	pop	r13
    27a2:	cf 90       	pop	r12
    27a4:	bf 90       	pop	r11
    27a6:	af 90       	pop	r10
    27a8:	9f 90       	pop	r9
    27aa:	8f 90       	pop	r8
    27ac:	08 95       	ret

000027ae <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    27ae:	81 e0       	ldi	r24, 0x01	; 1
    27b0:	80 93 c6 30 	sts	0x30C6, r24	; 0x8030c6 <xMissedYield>
    27b4:	08 95       	ret

000027b6 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    27b6:	00 97       	sbiw	r24, 0x00	; 0
    27b8:	21 f4       	brne	.+8      	; 0x27c2 <uxTaskGetStackHighWaterMark+0xc>
    27ba:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    27be:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    27c2:	dc 01       	movw	r26, r24
    27c4:	5b 96       	adiw	r26, 0x1b	; 27
    27c6:	ed 91       	ld	r30, X+
    27c8:	fc 91       	ld	r31, X
    27ca:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27cc:	80 81       	ld	r24, Z
    27ce:	81 31       	cpi	r24, 0x11	; 17
    27d0:	41 f4       	brne	.+16     	; 0x27e2 <uxTaskGetStackHighWaterMark+0x2c>
    27d2:	31 96       	adiw	r30, 0x01	; 1
    27d4:	80 e0       	ldi	r24, 0x00	; 0
    27d6:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    27d8:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27da:	21 91       	ld	r18, Z+
    27dc:	21 31       	cpi	r18, 0x11	; 17
    27de:	e1 f3       	breq	.-8      	; 0x27d8 <uxTaskGetStackHighWaterMark+0x22>
    27e0:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    27e2:	80 e0       	ldi	r24, 0x00	; 0
    27e4:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    27e6:	08 95       	ret

000027e8 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    27e8:	80 91 24 31 	lds	r24, 0x3124	; 0x803124 <pxCurrentTCB>
    27ec:	90 91 25 31 	lds	r25, 0x3125	; 0x803125 <pxCurrentTCB+0x1>

		return xReturn;
	}
    27f0:	08 95       	ret

000027f2 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    27f2:	0f 93       	push	r16
    27f4:	1f 93       	push	r17
    27f6:	cf 93       	push	r28
    27f8:	df 93       	push	r29
    27fa:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    27fc:	22 8d       	ldd	r18, Z+26	; 0x1a
    27fe:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2802:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2806:	5a 96       	adiw	r26, 0x1a	; 26
    2808:	8c 91       	ld	r24, X
    280a:	28 17       	cp	r18, r24
    280c:	08 f0       	brcs	.+2      	; 0x2810 <vTaskPriorityInherit+0x1e>
    280e:	41 c0       	rjmp	.+130    	; 0x2892 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2810:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2814:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    2818:	5a 96       	adiw	r26, 0x1a	; 26
    281a:	3c 91       	ld	r19, X
    281c:	84 e0       	ldi	r24, 0x04	; 4
    281e:	90 e0       	ldi	r25, 0x00	; 0
    2820:	a0 e0       	ldi	r26, 0x00	; 0
    2822:	b0 e0       	ldi	r27, 0x00	; 0
    2824:	83 1b       	sub	r24, r19
    2826:	91 09       	sbc	r25, r1
    2828:	a1 09       	sbc	r26, r1
    282a:	b1 09       	sbc	r27, r1
    282c:	86 87       	std	Z+14, r24	; 0x0e
    282e:	97 87       	std	Z+15, r25	; 0x0f
    2830:	a0 8b       	std	Z+16, r26	; 0x10
    2832:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2834:	8b e0       	ldi	r24, 0x0B	; 11
    2836:	28 9f       	mul	r18, r24
    2838:	90 01       	movw	r18, r0
    283a:	11 24       	eor	r1, r1
    283c:	28 50       	subi	r18, 0x08	; 8
    283e:	3f 4c       	sbci	r19, 0xCF	; 207
    2840:	84 85       	ldd	r24, Z+12	; 0x0c
    2842:	95 85       	ldd	r25, Z+13	; 0x0d
    2844:	82 17       	cp	r24, r18
    2846:	93 07       	cpc	r25, r19
    2848:	e9 f4       	brne	.+58     	; 0x2884 <vTaskPriorityInherit+0x92>
    284a:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    284c:	ef 01       	movw	r28, r30
    284e:	22 96       	adiw	r28, 0x02	; 2
    2850:	ce 01       	movw	r24, r28
    2852:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2856:	e0 91 24 31 	lds	r30, 0x3124	; 0x803124 <pxCurrentTCB>
    285a:	f0 91 25 31 	lds	r31, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    285e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2860:	f8 01       	movw	r30, r16
    2862:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2864:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    2868:	98 17       	cp	r25, r24
    286a:	10 f4       	brcc	.+4      	; 0x2870 <vTaskPriorityInherit+0x7e>
    286c:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    2870:	fb e0       	ldi	r31, 0x0B	; 11
    2872:	8f 9f       	mul	r24, r31
    2874:	c0 01       	movw	r24, r0
    2876:	11 24       	eor	r1, r1
    2878:	be 01       	movw	r22, r28
    287a:	88 50       	subi	r24, 0x08	; 8
    287c:	9f 4c       	sbci	r25, 0xCF	; 207
    287e:	0e 94 27 0a 	call	0x144e	; 0x144e <vListInsertEnd>
    2882:	07 c0       	rjmp	.+14     	; 0x2892 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2884:	a0 91 24 31 	lds	r26, 0x3124	; 0x803124 <pxCurrentTCB>
    2888:	b0 91 25 31 	lds	r27, 0x3125	; 0x803125 <pxCurrentTCB+0x1>
    288c:	5a 96       	adiw	r26, 0x1a	; 26
    288e:	8c 91       	ld	r24, X
    2890:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2892:	df 91       	pop	r29
    2894:	cf 91       	pop	r28
    2896:	1f 91       	pop	r17
    2898:	0f 91       	pop	r16
    289a:	08 95       	ret

0000289c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    289c:	0f 93       	push	r16
    289e:	1f 93       	push	r17
    28a0:	cf 93       	push	r28
    28a2:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    28a4:	00 97       	sbiw	r24, 0x00	; 0
    28a6:	49 f1       	breq	.+82     	; 0x28fa <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    28a8:	fc 01       	movw	r30, r24
    28aa:	32 8d       	ldd	r19, Z+26	; 0x1a
    28ac:	27 a1       	ldd	r18, Z+39	; 0x27
    28ae:	32 17       	cp	r19, r18
    28b0:	21 f1       	breq	.+72     	; 0x28fa <vTaskPriorityDisinherit+0x5e>
    28b2:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    28b4:	8c 01       	movw	r16, r24
    28b6:	0e 5f       	subi	r16, 0xFE	; 254
    28b8:	1f 4f       	sbci	r17, 0xFF	; 255
    28ba:	c8 01       	movw	r24, r16
    28bc:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    28c0:	8f a1       	ldd	r24, Y+39	; 0x27
    28c2:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    28c4:	44 e0       	ldi	r20, 0x04	; 4
    28c6:	50 e0       	ldi	r21, 0x00	; 0
    28c8:	60 e0       	ldi	r22, 0x00	; 0
    28ca:	70 e0       	ldi	r23, 0x00	; 0
    28cc:	48 1b       	sub	r20, r24
    28ce:	51 09       	sbc	r21, r1
    28d0:	61 09       	sbc	r22, r1
    28d2:	71 09       	sbc	r23, r1
    28d4:	4e 87       	std	Y+14, r20	; 0x0e
    28d6:	5f 87       	std	Y+15, r21	; 0x0f
    28d8:	68 8b       	std	Y+16, r22	; 0x10
    28da:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    28dc:	90 91 ca 30 	lds	r25, 0x30CA	; 0x8030ca <uxTopReadyPriority>
    28e0:	98 17       	cp	r25, r24
    28e2:	10 f4       	brcc	.+4      	; 0x28e8 <vTaskPriorityDisinherit+0x4c>
    28e4:	80 93 ca 30 	sts	0x30CA, r24	; 0x8030ca <uxTopReadyPriority>
    28e8:	fb e0       	ldi	r31, 0x0B	; 11
    28ea:	8f 9f       	mul	r24, r31
    28ec:	c0 01       	movw	r24, r0
    28ee:	11 24       	eor	r1, r1
    28f0:	b8 01       	movw	r22, r16
    28f2:	88 50       	subi	r24, 0x08	; 8
    28f4:	9f 4c       	sbci	r25, 0xCF	; 207
    28f6:	0e 94 27 0a 	call	0x144e	; 0x144e <vListInsertEnd>
			}
		}
	}
    28fa:	df 91       	pop	r29
    28fc:	cf 91       	pop	r28
    28fe:	1f 91       	pop	r17
    2900:	0f 91       	pop	r16
    2902:	08 95       	ret

00002904 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2904:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2906:	e8 81       	ld	r30, Y
    2908:	f9 81       	ldd	r31, Y+1	; 0x01
    290a:	01 90       	ld	r0, Z+
    290c:	f0 81       	ld	r31, Z
    290e:	e0 2d       	mov	r30, r0
    2910:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2912:	1a 82       	std	Y+2, r1	; 0x02
    2914:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2916:	6f ef       	ldi	r22, 0xFF	; 255
    2918:	7f ef       	ldi	r23, 0xFF	; 255
    291a:	cb 01       	movw	r24, r22
    291c:	0e 94 65 12 	call	0x24ca	; 0x24ca <vTaskDelay>
    2920:	fa cf       	rjmp	.-12     	; 0x2916 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002922 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2922:	fc 01       	movw	r30, r24
    2924:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2926:	65 87       	std	Z+13, r22	; 0x0d
    2928:	08 95       	ret

0000292a <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    292a:	4f 92       	push	r4
    292c:	5f 92       	push	r5
    292e:	6f 92       	push	r6
    2930:	7f 92       	push	r7
    2932:	8f 92       	push	r8
    2934:	9f 92       	push	r9
    2936:	af 92       	push	r10
    2938:	bf 92       	push	r11
    293a:	cf 92       	push	r12
    293c:	df 92       	push	r13
    293e:	ef 92       	push	r14
    2940:	ff 92       	push	r15
    2942:	0f 93       	push	r16
    2944:	1f 93       	push	r17
    2946:	cf 93       	push	r28
    2948:	df 93       	push	r29
    294a:	cd b7       	in	r28, 0x3d	; 61
    294c:	de b7       	in	r29, 0x3e	; 62
    294e:	2a 97       	sbiw	r28, 0x0a	; 10
    2950:	cd bf       	out	0x3d, r28	; 61
    2952:	de bf       	out	0x3e, r29	; 62
    2954:	4c 01       	movw	r8, r24
    2956:	29 01       	movw	r4, r18
    2958:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    295a:	8f e3       	ldi	r24, 0x3F	; 63
    295c:	90 e2       	ldi	r25, 0x20	; 32
    295e:	f4 01       	movw	r30, r8
    2960:	80 83       	st	Z, r24
    2962:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2964:	fb 01       	movw	r30, r22
    2966:	80 81       	ld	r24, Z
    2968:	88 23       	and	r24, r24
    296a:	69 f0       	breq	.+26     	; 0x2986 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    296c:	de 01       	movw	r26, r28
    296e:	11 96       	adiw	r26, 0x01	; 1
    2970:	31 96       	adiw	r30, 0x01	; 1
    2972:	90 e0       	ldi	r25, 0x00	; 0
    2974:	02 c0       	rjmp	.+4      	; 0x297a <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2976:	99 30       	cpi	r25, 0x09	; 9
    2978:	39 f0       	breq	.+14     	; 0x2988 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    297a:	9f 5f       	subi	r25, 0xFF	; 255
    297c:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    297e:	81 91       	ld	r24, Z+
    2980:	81 11       	cpse	r24, r1
    2982:	f9 cf       	rjmp	.-14     	; 0x2976 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2984:	01 c0       	rjmp	.+2      	; 0x2988 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2986:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2988:	e1 e0       	ldi	r30, 0x01	; 1
    298a:	f0 e0       	ldi	r31, 0x00	; 0
    298c:	ec 0f       	add	r30, r28
    298e:	fd 1f       	adc	r31, r29
    2990:	e9 0f       	add	r30, r25
    2992:	f1 1d       	adc	r31, r1
    2994:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2996:	74 01       	movw	r14, r8
    2998:	f2 e0       	ldi	r31, 0x02	; 2
    299a:	ef 0e       	add	r14, r31
    299c:	f1 1c       	adc	r15, r1
    299e:	a1 2c       	mov	r10, r1
    29a0:	b1 2c       	mov	r11, r1
    29a2:	c1 2c       	mov	r12, r1
    29a4:	d1 2c       	mov	r13, r1
    29a6:	04 2f       	mov	r16, r20
    29a8:	94 01       	movw	r18, r8
    29aa:	a2 01       	movw	r20, r4
    29ac:	be 01       	movw	r22, r28
    29ae:	6f 5f       	subi	r22, 0xFF	; 255
    29b0:	7f 4f       	sbci	r23, 0xFF	; 255
    29b2:	86 ea       	ldi	r24, 0xA6	; 166
    29b4:	92 e0       	ldi	r25, 0x02	; 2
    29b6:	0e 94 11 0f 	call	0x1e22	; 0x1e22 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    29ba:	f4 01       	movw	r30, r8
    29bc:	66 82       	std	Z+6, r6	; 0x06
    29be:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    29c0:	40 86       	std	Z+8, r4	; 0x08
    29c2:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    29c4:	20 91 26 31 	lds	r18, 0x3126	; 0x803126 <last_created_task_pointer>
    29c8:	30 91 27 31 	lds	r19, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    29cc:	24 83       	std	Z+4, r18	; 0x04
    29ce:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    29d0:	80 92 26 31 	sts	0x3126, r8	; 0x803126 <last_created_task_pointer>
    29d4:	90 92 27 31 	sts	0x3127, r9	; 0x803127 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    29d8:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    29da:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    29dc:	40 90 60 31 	lds	r4, 0x3160	; 0x803160 <portStackTopForTask>
    29e0:	50 90 61 31 	lds	r5, 0x3161	; 0x803161 <portStackTopForTask+0x1>
    29e4:	ff ef       	ldi	r31, 0xFF	; 255
    29e6:	4f 1a       	sub	r4, r31
    29e8:	5f 0a       	sbc	r5, r31
    29ea:	40 92 60 31 	sts	0x3160, r4	; 0x803160 <portStackTopForTask>
    29ee:	50 92 61 31 	sts	0x3161, r5	; 0x803161 <portStackTopForTask+0x1>
    29f2:	f4 01       	movw	r30, r8
    29f4:	42 86       	std	Z+10, r4	; 0x0a
    29f6:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    29f8:	16 86       	std	Z+14, r1	; 0x0e
    29fa:	17 86       	std	Z+15, r1	; 0x0f
    29fc:	10 8a       	std	Z+16, r1	; 0x10
    29fe:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2a00:	61 14       	cp	r6, r1
    2a02:	71 04       	cpc	r7, r1
    2a04:	09 f4       	brne	.+2      	; 0x2a08 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2a06:	44 c0       	rjmp	.+136    	; 0x2a90 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2a08:	81 30       	cpi	r24, 0x01	; 1
    2a0a:	79 f5       	brne	.+94     	; 0x2a6a <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2a0c:	6a e0       	ldi	r22, 0x0A	; 10
    2a0e:	c3 01       	movw	r24, r6
    2a10:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2a14:	7c 01       	movw	r14, r24
    2a16:	69 e9       	ldi	r22, 0x99	; 153
    2a18:	74 e0       	ldi	r23, 0x04	; 4
    2a1a:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2a1e:	be 01       	movw	r22, r28
    2a20:	6f 5f       	subi	r22, 0xFF	; 255
    2a22:	7f 4f       	sbci	r23, 0xFF	; 255
    2a24:	c7 01       	movw	r24, r14
    2a26:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2a2a:	6a e0       	ldi	r22, 0x0A	; 10
    2a2c:	c7 01       	movw	r24, r14
    2a2e:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2a32:	7c 01       	movw	r14, r24
    2a34:	60 e9       	ldi	r22, 0x90	; 144
    2a36:	74 e0       	ldi	r23, 0x04	; 4
    2a38:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2a3c:	6a e0       	ldi	r22, 0x0A	; 10
    2a3e:	c7 01       	movw	r24, r14
    2a40:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2a44:	7c 01       	movw	r14, r24
    2a46:	62 e8       	ldi	r22, 0x82	; 130
    2a48:	74 e0       	ldi	r23, 0x04	; 4
    2a4a:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2a4e:	63 e0       	ldi	r22, 0x03	; 3
    2a50:	c7 01       	movw	r24, r14
    2a52:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2a56:	b2 01       	movw	r22, r4
    2a58:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <_ZN8emstreamlsEj>
    2a5c:	62 e0       	ldi	r22, 0x02	; 2
    2a5e:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2a62:	66 e0       	ldi	r22, 0x06	; 6
    2a64:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2a68:	13 c0       	rjmp	.+38     	; 0x2a90 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2a6a:	6a e0       	ldi	r22, 0x0A	; 10
    2a6c:	c3 01       	movw	r24, r6
    2a6e:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2a72:	4c 01       	movw	r8, r24
    2a74:	6d e6       	ldi	r22, 0x6D	; 109
    2a76:	74 e0       	ldi	r23, 0x04	; 4
    2a78:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2a7c:	be 01       	movw	r22, r28
    2a7e:	6f 5f       	subi	r22, 0xFF	; 255
    2a80:	7f 4f       	sbci	r23, 0xFF	; 255
    2a82:	c4 01       	movw	r24, r8
    2a84:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2a88:	66 e0       	ldi	r22, 0x06	; 6
    2a8a:	c4 01       	movw	r24, r8
    2a8c:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2a90:	2a 96       	adiw	r28, 0x0a	; 10
    2a92:	cd bf       	out	0x3d, r28	; 61
    2a94:	de bf       	out	0x3e, r29	; 62
    2a96:	df 91       	pop	r29
    2a98:	cf 91       	pop	r28
    2a9a:	1f 91       	pop	r17
    2a9c:	0f 91       	pop	r16
    2a9e:	ff 90       	pop	r15
    2aa0:	ef 90       	pop	r14
    2aa2:	df 90       	pop	r13
    2aa4:	cf 90       	pop	r12
    2aa6:	bf 90       	pop	r11
    2aa8:	af 90       	pop	r10
    2aaa:	9f 90       	pop	r9
    2aac:	8f 90       	pop	r8
    2aae:	7f 90       	pop	r7
    2ab0:	6f 90       	pop	r6
    2ab2:	5f 90       	pop	r5
    2ab4:	4f 90       	pop	r4
    2ab6:	08 95       	ret

00002ab8 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2ab8:	cf 92       	push	r12
    2aba:	df 92       	push	r13
    2abc:	ef 92       	push	r14
    2abe:	ff 92       	push	r15
    2ac0:	0f 93       	push	r16
    2ac2:	1f 93       	push	r17
    2ac4:	cf 93       	push	r28
    2ac6:	df 93       	push	r29
    2ac8:	ec 01       	movw	r28, r24
    2aca:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2acc:	8a 81       	ldd	r24, Y+2	; 0x02
    2ace:	9b 81       	ldd	r25, Y+3	; 0x03
    2ad0:	0e 94 68 10 	call	0x20d0	; 0x20d0 <pcTaskGetTaskName>
    2ad4:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2ad6:	6a e0       	ldi	r22, 0x0A	; 10
    2ad8:	c7 01       	movw	r24, r14
    2ada:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2ade:	8c 01       	movw	r16, r24
    2ae0:	6c ea       	ldi	r22, 0xAC	; 172
    2ae2:	74 e0       	ldi	r23, 0x04	; 4
    2ae4:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2ae8:	6a e0       	ldi	r22, 0x0A	; 10
    2aea:	c8 01       	movw	r24, r16
    2aec:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2af0:	8c 01       	movw	r16, r24
    2af2:	65 ea       	ldi	r22, 0xA5	; 165
    2af4:	74 e0       	ldi	r23, 0x04	; 4
    2af6:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2afa:	b6 01       	movw	r22, r12
    2afc:	c8 01       	movw	r24, r16
    2afe:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2b02:	6a e0       	ldi	r22, 0x0A	; 10
    2b04:	c8 01       	movw	r24, r16
    2b06:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2b0a:	8c 01       	movw	r16, r24
    2b0c:	6f e9       	ldi	r22, 0x9F	; 159
    2b0e:	74 e0       	ldi	r23, 0x04	; 4
    2b10:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2b14:	66 e0       	ldi	r22, 0x06	; 6
    2b16:	c8 01       	movw	r24, r16
    2b18:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2b1c:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b1e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b20:	e8 85       	ldd	r30, Y+8	; 0x08
    2b22:	f9 85       	ldd	r31, Y+9	; 0x09
    2b24:	01 e1       	ldi	r16, 0x11	; 17
    2b26:	21 e0       	ldi	r18, 0x01	; 1
    2b28:	a7 01       	movw	r20, r14
    2b2a:	bc 01       	movw	r22, r24
    2b2c:	8e 1b       	sub	r24, r30
    2b2e:	9f 0b       	sbc	r25, r31
    2b30:	0e 94 5e 18 	call	0x30bc	; 0x30bc <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2b34:	8c 81       	ldd	r24, Y+4	; 0x04
    2b36:	9d 81       	ldd	r25, Y+5	; 0x05
    2b38:	00 97       	sbiw	r24, 0x00	; 0
    2b3a:	19 f0       	breq	.+6      	; 0x2b42 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2b3c:	b7 01       	movw	r22, r14
    2b3e:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2b42:	df 91       	pop	r29
    2b44:	cf 91       	pop	r28
    2b46:	1f 91       	pop	r17
    2b48:	0f 91       	pop	r16
    2b4a:	ff 90       	pop	r15
    2b4c:	ef 90       	pop	r14
    2b4e:	df 90       	pop	r13
    2b50:	cf 90       	pop	r12
    2b52:	08 95       	ret

00002b54 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2b54:	0f 93       	push	r16
    2b56:	1f 93       	push	r17
    2b58:	cf 93       	push	r28
    2b5a:	df 93       	push	r29
    2b5c:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2b5e:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    2b62:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2b66:	00 97       	sbiw	r24, 0x00	; 0
    2b68:	19 f0       	breq	.+6      	; 0x2b70 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2b6a:	be 01       	movw	r22, r28
    2b6c:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2b70:	6a e0       	ldi	r22, 0x0A	; 10
    2b72:	ce 01       	movw	r24, r28
    2b74:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2b78:	8c 01       	movw	r16, r24
    2b7a:	62 ec       	ldi	r22, 0xC2	; 194
    2b7c:	74 e0       	ldi	r23, 0x04	; 4
    2b7e:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2b82:	6a e0       	ldi	r22, 0x0A	; 10
    2b84:	c8 01       	movw	r24, r16
    2b86:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2b8a:	8c 01       	movw	r16, r24
    2b8c:	67 eb       	ldi	r22, 0xB7	; 183
    2b8e:	74 e0       	ldi	r23, 0x04	; 4
    2b90:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2b94:	6a e0       	ldi	r22, 0x0A	; 10
    2b96:	c8 01       	movw	r24, r16
    2b98:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2b9c:	8c 01       	movw	r16, r24
    2b9e:	61 eb       	ldi	r22, 0xB1	; 177
    2ba0:	74 e0       	ldi	r23, 0x04	; 4
    2ba2:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2ba6:	66 e0       	ldi	r22, 0x06	; 6
    2ba8:	c8 01       	movw	r24, r16
    2baa:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2bae:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <portStackTopForTask>
    2bb2:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <portStackTopForTask+0x1>
    2bb6:	bc 01       	movw	r22, r24
    2bb8:	6f 5f       	subi	r22, 0xFF	; 255
    2bba:	7f 4f       	sbci	r23, 0xFF	; 255
    2bbc:	01 e1       	ldi	r16, 0x11	; 17
    2bbe:	21 e0       	ldi	r18, 0x01	; 1
    2bc0:	ae 01       	movw	r20, r28
    2bc2:	83 56       	subi	r24, 0x63	; 99
    2bc4:	91 09       	sbc	r25, r1
    2bc6:	0e 94 5e 18 	call	0x30bc	; 0x30bc <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2bca:	df 91       	pop	r29
    2bcc:	cf 91       	pop	r28
    2bce:	1f 91       	pop	r17
    2bd0:	0f 91       	pop	r16
    2bd2:	08 95       	ret

00002bd4 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2bd4:	8f 92       	push	r8
    2bd6:	9f 92       	push	r9
    2bd8:	af 92       	push	r10
    2bda:	bf 92       	push	r11
    2bdc:	cf 92       	push	r12
    2bde:	df 92       	push	r13
    2be0:	ef 92       	push	r14
    2be2:	ff 92       	push	r15
    2be4:	0f 93       	push	r16
    2be6:	1f 93       	push	r17
    2be8:	cf 93       	push	r28
    2bea:	df 93       	push	r29
    2bec:	ec 01       	movw	r28, r24
    2bee:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2bf0:	8a 81       	ldd	r24, Y+2	; 0x02
    2bf2:	9b 81       	ldd	r25, Y+3	; 0x03
    2bf4:	0e 94 68 10 	call	0x20d0	; 0x20d0 <pcTaskGetTaskName>
    2bf8:	bc 01       	movw	r22, r24
    2bfa:	c8 01       	movw	r24, r16
    2bfc:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2c00:	d8 01       	movw	r26, r16
    2c02:	ed 91       	ld	r30, X+
    2c04:	fc 91       	ld	r31, X
    2c06:	02 80       	ldd	r0, Z+2	; 0x02
    2c08:	f3 81       	ldd	r31, Z+3	; 0x03
    2c0a:	e0 2d       	mov	r30, r0
    2c0c:	69 e0       	ldi	r22, 0x09	; 9
    2c0e:	c8 01       	movw	r24, r16
    2c10:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2c12:	8a 81       	ldd	r24, Y+2	; 0x02
    2c14:	9b 81       	ldd	r25, Y+3	; 0x03
    2c16:	0e 94 68 10 	call	0x20d0	; 0x20d0 <pcTaskGetTaskName>
    2c1a:	fc 01       	movw	r30, r24
    2c1c:	01 90       	ld	r0, Z+
    2c1e:	00 20       	and	r0, r0
    2c20:	e9 f7       	brne	.-6      	; 0x2c1c <_ZN8frt_task12print_statusER8emstream+0x48>
    2c22:	31 97       	sbiw	r30, 0x01	; 1
    2c24:	e8 1b       	sub	r30, r24
    2c26:	f9 0b       	sbc	r31, r25
    2c28:	38 97       	sbiw	r30, 0x08	; 8
    2c2a:	48 f4       	brcc	.+18     	; 0x2c3e <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2c2c:	d8 01       	movw	r26, r16
    2c2e:	ed 91       	ld	r30, X+
    2c30:	fc 91       	ld	r31, X
    2c32:	02 80       	ldd	r0, Z+2	; 0x02
    2c34:	f3 81       	ldd	r31, Z+3	; 0x03
    2c36:	e0 2d       	mov	r30, r0
    2c38:	69 e0       	ldi	r22, 0x09	; 9
    2c3a:	c8 01       	movw	r24, r16
    2c3c:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2c3e:	ce 84       	ldd	r12, Y+14	; 0x0e
    2c40:	df 84       	ldd	r13, Y+15	; 0x0f
    2c42:	e8 88       	ldd	r14, Y+16	; 0x10
    2c44:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2c46:	a8 84       	ldd	r10, Y+8	; 0x08
    2c48:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c4a:	8a 81       	ldd	r24, Y+2	; 0x02
    2c4c:	9b 81       	ldd	r25, Y+3	; 0x03
    2c4e:	0e 94 db 13 	call	0x27b6	; 0x27b6 <uxTaskGetStackHighWaterMark>
    2c52:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2c54:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2c56:	8a 81       	ldd	r24, Y+2	; 0x02
    2c58:	9b 81       	ldd	r25, Y+3	; 0x03
    2c5a:	0e 94 13 10 	call	0x2026	; 0x2026 <uxTaskPriorityGet>
    2c5e:	68 2f       	mov	r22, r24
    2c60:	c8 01       	movw	r24, r16
    2c62:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <_ZN8emstreamlsEh>
    2c66:	6a e0       	ldi	r22, 0x0A	; 10
    2c68:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2c6c:	ec 01       	movw	r28, r24
    2c6e:	67 e3       	ldi	r22, 0x37	; 55
    2c70:	75 e0       	ldi	r23, 0x05	; 5
    2c72:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2c76:	68 2d       	mov	r22, r8
    2c78:	ce 01       	movw	r24, r28
    2c7a:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2c7e:	6a e0       	ldi	r22, 0x0A	; 10
    2c80:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2c84:	ec 01       	movw	r28, r24
    2c86:	65 e3       	ldi	r22, 0x35	; 53
    2c88:	75 e0       	ldi	r23, 0x05	; 5
    2c8a:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2c8e:	69 2d       	mov	r22, r9
    2c90:	ce 01       	movw	r24, r28
    2c92:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <_ZN8emstreamlsEh>
    2c96:	6a e0       	ldi	r22, 0x0A	; 10
    2c98:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2c9c:	ec 01       	movw	r28, r24
    2c9e:	63 e3       	ldi	r22, 0x33	; 51
    2ca0:	75 e0       	ldi	r23, 0x05	; 5
    2ca2:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2ca6:	b5 01       	movw	r22, r10
    2ca8:	ce 01       	movw	r24, r28
    2caa:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <_ZN8emstreamlsEj>
    2cae:	6a e0       	ldi	r22, 0x0A	; 10
    2cb0:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2cb4:	ec 01       	movw	r28, r24
    2cb6:	61 e3       	ldi	r22, 0x31	; 49
    2cb8:	75 e0       	ldi	r23, 0x05	; 5
    2cba:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2cbe:	6a e0       	ldi	r22, 0x0A	; 10
    2cc0:	ce 01       	movw	r24, r28
    2cc2:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2cc6:	ec 01       	movw	r28, r24
    2cc8:	6f e2       	ldi	r22, 0x2F	; 47
    2cca:	75 e0       	ldi	r23, 0x05	; 5
    2ccc:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2cd0:	b7 01       	movw	r22, r14
    2cd2:	a6 01       	movw	r20, r12
    2cd4:	ce 01       	movw	r24, r28
    2cd6:	0e 94 9e 1a 	call	0x353c	; 0x353c <_ZN8emstreamlsEm>
}
    2cda:	df 91       	pop	r29
    2cdc:	cf 91       	pop	r28
    2cde:	1f 91       	pop	r17
    2ce0:	0f 91       	pop	r16
    2ce2:	ff 90       	pop	r15
    2ce4:	ef 90       	pop	r14
    2ce6:	df 90       	pop	r13
    2ce8:	cf 90       	pop	r12
    2cea:	bf 90       	pop	r11
    2cec:	af 90       	pop	r10
    2cee:	9f 90       	pop	r9
    2cf0:	8f 90       	pop	r8
    2cf2:	08 95       	ret

00002cf4 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2cf4:	cf 93       	push	r28
    2cf6:	df 93       	push	r29
    2cf8:	ec 01       	movw	r28, r24
    2cfa:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2cfc:	db 01       	movw	r26, r22
    2cfe:	ed 91       	ld	r30, X+
    2d00:	fc 91       	ld	r31, X
    2d02:	02 80       	ldd	r0, Z+2	; 0x02
    2d04:	f3 81       	ldd	r31, Z+3	; 0x03
    2d06:	e0 2d       	mov	r30, r0
    2d08:	be 01       	movw	r22, r28
    2d0a:	19 95       	eicall
	return (ser_dev);
}
    2d0c:	ce 01       	movw	r24, r28
    2d0e:	df 91       	pop	r29
    2d10:	cf 91       	pop	r28
    2d12:	08 95       	ret

00002d14 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2d14:	0f 93       	push	r16
    2d16:	1f 93       	push	r17
    2d18:	cf 93       	push	r28
    2d1a:	df 93       	push	r29
    2d1c:	ec 01       	movw	r28, r24
    2d1e:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2d20:	bc 01       	movw	r22, r24
    2d22:	c8 01       	movw	r24, r16
    2d24:	0e 94 7a 16 	call	0x2cf4	; 0x2cf4 <_ZlsR8emstreamR8frt_task>
    2d28:	66 e0       	ldi	r22, 0x06	; 6
    2d2a:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2d2e:	8c 81       	ldd	r24, Y+4	; 0x04
    2d30:	9d 81       	ldd	r25, Y+5	; 0x05
    2d32:	00 97       	sbiw	r24, 0x00	; 0
    2d34:	19 f0       	breq	.+6      	; 0x2d3c <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2d36:	b8 01       	movw	r22, r16
    2d38:	0e 94 8a 16 	call	0x2d14	; 0x2d14 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2d3c:	df 91       	pop	r29
    2d3e:	cf 91       	pop	r28
    2d40:	1f 91       	pop	r17
    2d42:	0f 91       	pop	r16
    2d44:	08 95       	ret

00002d46 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2d46:	0f 93       	push	r16
    2d48:	1f 93       	push	r17
    2d4a:	cf 93       	push	r28
    2d4c:	df 93       	push	r29
    2d4e:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2d50:	6a e0       	ldi	r22, 0x0A	; 10
    2d52:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2d56:	8c 01       	movw	r16, r24
    2d58:	64 e2       	ldi	r22, 0x24	; 36
    2d5a:	75 e0       	ldi	r23, 0x05	; 5
    2d5c:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2d60:	6a e0       	ldi	r22, 0x0A	; 10
    2d62:	c8 01       	movw	r24, r16
    2d64:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2d68:	8c 01       	movw	r16, r24
    2d6a:	6d e1       	ldi	r22, 0x1D	; 29
    2d6c:	75 e0       	ldi	r23, 0x05	; 5
    2d6e:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2d72:	66 e0       	ldi	r22, 0x06	; 6
    2d74:	c8 01       	movw	r24, r16
    2d76:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2d7a:	6a e0       	ldi	r22, 0x0A	; 10
    2d7c:	ce 01       	movw	r24, r28
    2d7e:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2d82:	8c 01       	movw	r16, r24
    2d84:	6c e0       	ldi	r22, 0x0C	; 12
    2d86:	75 e0       	ldi	r23, 0x05	; 5
    2d88:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2d8c:	6a e0       	ldi	r22, 0x0A	; 10
    2d8e:	c8 01       	movw	r24, r16
    2d90:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2d94:	8c 01       	movw	r16, r24
    2d96:	60 e0       	ldi	r22, 0x00	; 0
    2d98:	75 e0       	ldi	r23, 0x05	; 5
    2d9a:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2d9e:	6a e0       	ldi	r22, 0x0A	; 10
    2da0:	c8 01       	movw	r24, r16
    2da2:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2da6:	8c 01       	movw	r16, r24
    2da8:	6a ef       	ldi	r22, 0xFA	; 250
    2daa:	74 e0       	ldi	r23, 0x04	; 4
    2dac:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2db0:	66 e0       	ldi	r22, 0x06	; 6
    2db2:	c8 01       	movw	r24, r16
    2db4:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2db8:	6a e0       	ldi	r22, 0x0A	; 10
    2dba:	ce 01       	movw	r24, r28
    2dbc:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2dc0:	8c 01       	movw	r16, r24
    2dc2:	69 ee       	ldi	r22, 0xE9	; 233
    2dc4:	74 e0       	ldi	r23, 0x04	; 4
    2dc6:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2dca:	6a e0       	ldi	r22, 0x0A	; 10
    2dcc:	c8 01       	movw	r24, r16
    2dce:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2dd2:	8c 01       	movw	r16, r24
    2dd4:	6d ed       	ldi	r22, 0xDD	; 221
    2dd6:	74 e0       	ldi	r23, 0x04	; 4
    2dd8:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2ddc:	6a e0       	ldi	r22, 0x0A	; 10
    2dde:	c8 01       	movw	r24, r16
    2de0:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2de4:	8c 01       	movw	r16, r24
    2de6:	67 ed       	ldi	r22, 0xD7	; 215
    2de8:	74 e0       	ldi	r23, 0x04	; 4
    2dea:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2dee:	66 e0       	ldi	r22, 0x06	; 6
    2df0:	c8 01       	movw	r24, r16
    2df2:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2df6:	80 91 26 31 	lds	r24, 0x3126	; 0x803126 <last_created_task_pointer>
    2dfa:	90 91 27 31 	lds	r25, 0x3127	; 0x803127 <last_created_task_pointer+0x1>
    2dfe:	00 97       	sbiw	r24, 0x00	; 0
    2e00:	19 f0       	breq	.+6      	; 0x2e08 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2e02:	be 01       	movw	r22, r28
    2e04:	0e 94 8a 16 	call	0x2d14	; 0x2d14 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e08:	0e 94 70 10 	call	0x20e0	; 0x20e0 <xTaskGetIdleTaskHandle>
    2e0c:	0e 94 db 13 	call	0x27b6	; 0x27b6 <uxTaskGetStackHighWaterMark>
    2e10:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2e12:	6a e0       	ldi	r22, 0x0A	; 10
    2e14:	ce 01       	movw	r24, r28
    2e16:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2e1a:	ec 01       	movw	r28, r24
    2e1c:	6c ec       	ldi	r22, 0xCC	; 204
    2e1e:	74 e0       	ldi	r23, 0x04	; 4
    2e20:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e24:	61 2f       	mov	r22, r17
    2e26:	ce 01       	movw	r24, r28
    2e28:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2e2c:	6a e0       	ldi	r22, 0x0A	; 10
    2e2e:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2e32:	ec 01       	movw	r28, r24
    2e34:	6a ec       	ldi	r22, 0xCA	; 202
    2e36:	74 e0       	ldi	r23, 0x04	; 4
    2e38:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    2e3c:	64 e6       	ldi	r22, 0x64	; 100
    2e3e:	70 e0       	ldi	r23, 0x00	; 0
    2e40:	ce 01       	movw	r24, r28
    2e42:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <_ZN8emstreamlsEj>
    2e46:	6a e0       	ldi	r22, 0x0A	; 10
    2e48:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    2e4c:	ec 01       	movw	r28, r24
    2e4e:	67 ec       	ldi	r22, 0xC7	; 199
    2e50:	74 e0       	ldi	r23, 0x04	; 4
    2e52:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2e56:	66 e0       	ldi	r22, 0x06	; 6
    2e58:	ce 01       	movw	r24, r28
    2e5a:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
}
    2e5e:	df 91       	pop	r29
    2e60:	cf 91       	pop	r28
    2e62:	1f 91       	pop	r17
    2e64:	0f 91       	pop	r16
    2e66:	08 95       	ret

00002e68 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2e68:	0f 93       	push	r16
    2e6a:	cf 93       	push	r28
    2e6c:	df 93       	push	r29
    2e6e:	1f 92       	push	r1
    2e70:	cd b7       	in	r28, 0x3d	; 61
    2e72:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2e74:	00 e0       	ldi	r16, 0x00	; 0
    2e76:	2f ef       	ldi	r18, 0xFF	; 255
    2e78:	3f ef       	ldi	r19, 0xFF	; 255
    2e7a:	a9 01       	movw	r20, r18
    2e7c:	be 01       	movw	r22, r28
    2e7e:	6f 5f       	subi	r22, 0xFF	; 255
    2e80:	7f 4f       	sbci	r23, 0xFF	; 255
    2e82:	fc 01       	movw	r30, r24
    2e84:	80 85       	ldd	r24, Z+8	; 0x08
    2e86:	91 85       	ldd	r25, Z+9	; 0x09
    2e88:	0e 94 ef 0d 	call	0x1bde	; 0x1bde <xQueueGenericReceive>
    2e8c:	81 30       	cpi	r24, 0x01	; 1
    2e8e:	19 f4       	brne	.+6      	; 0x2e96 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2e90:	89 81       	ldd	r24, Y+1	; 0x01
    2e92:	90 e0       	ldi	r25, 0x00	; 0
    2e94:	02 c0       	rjmp	.+4      	; 0x2e9a <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2e96:	8f ef       	ldi	r24, 0xFF	; 255
    2e98:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2e9a:	0f 90       	pop	r0
    2e9c:	df 91       	pop	r29
    2e9e:	cf 91       	pop	r28
    2ea0:	0f 91       	pop	r16
    2ea2:	08 95       	ret

00002ea4 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2ea4:	fc 01       	movw	r30, r24
    2ea6:	80 85       	ldd	r24, Z+8	; 0x08
    2ea8:	91 85       	ldd	r25, Z+9	; 0x09
    2eaa:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxQueueMessagesWaiting>
    2eae:	91 e0       	ldi	r25, 0x01	; 1
    2eb0:	81 11       	cpse	r24, r1
    2eb2:	01 c0       	rjmp	.+2      	; 0x2eb6 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2eb4:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2eb6:	89 2f       	mov	r24, r25
    2eb8:	08 95       	ret

00002eba <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2eba:	0f 93       	push	r16
    2ebc:	cf 93       	push	r28
    2ebe:	df 93       	push	r29
    2ec0:	1f 92       	push	r1
    2ec2:	cd b7       	in	r28, 0x3d	; 61
    2ec4:	de b7       	in	r29, 0x3e	; 62
    2ec6:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2ec8:	fc 01       	movw	r30, r24
    2eca:	22 85       	ldd	r18, Z+10	; 0x0a
    2ecc:	33 85       	ldd	r19, Z+11	; 0x0b
    2ece:	44 85       	ldd	r20, Z+12	; 0x0c
    2ed0:	55 85       	ldd	r21, Z+13	; 0x0d
    2ed2:	00 e0       	ldi	r16, 0x00	; 0
    2ed4:	be 01       	movw	r22, r28
    2ed6:	6f 5f       	subi	r22, 0xFF	; 255
    2ed8:	7f 4f       	sbci	r23, 0xFF	; 255
    2eda:	80 85       	ldd	r24, Z+8	; 0x08
    2edc:	91 85       	ldd	r25, Z+9	; 0x09
    2ede:	0e 94 54 0d 	call	0x1aa8	; 0x1aa8 <xQueueGenericSend>
    2ee2:	91 e0       	ldi	r25, 0x01	; 1
    2ee4:	81 11       	cpse	r24, r1
    2ee6:	01 c0       	rjmp	.+2      	; 0x2eea <_ZN14frt_text_queue7putcharEc+0x30>
    2ee8:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2eea:	89 2f       	mov	r24, r25
    2eec:	0f 90       	pop	r0
    2eee:	df 91       	pop	r29
    2ef0:	cf 91       	pop	r28
    2ef2:	0f 91       	pop	r16
    2ef4:	08 95       	ret

00002ef6 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2ef6:	8f 92       	push	r8
    2ef8:	9f 92       	push	r9
    2efa:	bf 92       	push	r11
    2efc:	cf 92       	push	r12
    2efe:	df 92       	push	r13
    2f00:	ef 92       	push	r14
    2f02:	ff 92       	push	r15
    2f04:	0f 93       	push	r16
    2f06:	1f 93       	push	r17
    2f08:	cf 93       	push	r28
    2f0a:	df 93       	push	r29
    2f0c:	ec 01       	movw	r28, r24
    2f0e:	b6 2e       	mov	r11, r22
    2f10:	4a 01       	movw	r8, r20
    2f12:	68 01       	movw	r12, r16
    2f14:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2f16:	0e 94 b5 19 	call	0x336a	; 0x336a <_ZN8emstreamC1Ev>
    2f1a:	87 e4       	ldi	r24, 0x47	; 71
    2f1c:	90 e2       	ldi	r25, 0x20	; 32
    2f1e:	88 83       	st	Y, r24
    2f20:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2f22:	8e 86       	std	Y+14, r8	; 0x0e
    2f24:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2f26:	40 e0       	ldi	r20, 0x00	; 0
    2f28:	61 e0       	ldi	r22, 0x01	; 1
    2f2a:	8b 2d       	mov	r24, r11
    2f2c:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <xQueueGenericCreate>
    2f30:	88 87       	std	Y+8, r24	; 0x08
    2f32:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2f34:	ca 86       	std	Y+10, r12	; 0x0a
    2f36:	db 86       	std	Y+11, r13	; 0x0b
    2f38:	ec 86       	std	Y+12, r14	; 0x0c
    2f3a:	fd 86       	std	Y+13, r15	; 0x0d
}
    2f3c:	df 91       	pop	r29
    2f3e:	cf 91       	pop	r28
    2f40:	1f 91       	pop	r17
    2f42:	0f 91       	pop	r16
    2f44:	ff 90       	pop	r15
    2f46:	ef 90       	pop	r14
    2f48:	df 90       	pop	r13
    2f4a:	cf 90       	pop	r12
    2f4c:	bf 90       	pop	r11
    2f4e:	9f 90       	pop	r9
    2f50:	8f 90       	pop	r8
    2f52:	08 95       	ret

00002f54 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2f54:	cf 92       	push	r12
    2f56:	df 92       	push	r13
    2f58:	ef 92       	push	r14
    2f5a:	ff 92       	push	r15
    2f5c:	cf 93       	push	r28
    2f5e:	df 93       	push	r29
    2f60:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2f62:	68 81       	ld	r22, Y
    2f64:	79 81       	ldd	r23, Y+1	; 0x01
    2f66:	8a 81       	ldd	r24, Y+2	; 0x02
    2f68:	9b 81       	ldd	r25, Y+3	; 0x03
    2f6a:	0f 2e       	mov	r0, r31
    2f6c:	f8 ee       	ldi	r31, 0xE8	; 232
    2f6e:	cf 2e       	mov	r12, r31
    2f70:	f3 e0       	ldi	r31, 0x03	; 3
    2f72:	df 2e       	mov	r13, r31
    2f74:	e1 2c       	mov	r14, r1
    2f76:	f1 2c       	mov	r15, r1
    2f78:	f0 2d       	mov	r31, r0
    2f7a:	a7 01       	movw	r20, r14
    2f7c:	96 01       	movw	r18, r12
    2f7e:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <__udivmodsi4>
    2f82:	9b 01       	movw	r18, r22
    2f84:	ac 01       	movw	r20, r24
    2f86:	60 e4       	ldi	r22, 0x40	; 64
    2f88:	72 e4       	ldi	r23, 0x42	; 66
    2f8a:	8f e0       	ldi	r24, 0x0F	; 15
    2f8c:	90 e0       	ldi	r25, 0x00	; 0
    2f8e:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <__mulsi3>
    2f92:	a7 01       	movw	r20, r14
    2f94:	96 01       	movw	r18, r12
    2f96:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <__udivmodsi4>
    2f9a:	69 01       	movw	r12, r18
    2f9c:	7a 01       	movw	r14, r20
    2f9e:	ac 81       	ldd	r26, Y+4	; 0x04
    2fa0:	bd 81       	ldd	r27, Y+5	; 0x05
    2fa2:	20 e4       	ldi	r18, 0x40	; 64
    2fa4:	32 e4       	ldi	r19, 0x42	; 66
    2fa6:	4f e0       	ldi	r20, 0x0F	; 15
    2fa8:	50 e0       	ldi	r21, 0x00	; 0
    2faa:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <__muluhisi3>
    2fae:	20 e0       	ldi	r18, 0x00	; 0
    2fb0:	38 e4       	ldi	r19, 0x48	; 72
    2fb2:	48 ee       	ldi	r20, 0xE8	; 232
    2fb4:	51 e0       	ldi	r21, 0x01	; 1
    2fb6:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <__udivmodsi4>
    2fba:	c7 01       	movw	r24, r14
    2fbc:	b6 01       	movw	r22, r12
    2fbe:	62 0f       	add	r22, r18
    2fc0:	73 1f       	adc	r23, r19
    2fc2:	84 1f       	adc	r24, r20
    2fc4:	95 1f       	adc	r25, r21
}
    2fc6:	df 91       	pop	r29
    2fc8:	cf 91       	pop	r28
    2fca:	ff 90       	pop	r15
    2fcc:	ef 90       	pop	r14
    2fce:	df 90       	pop	r13
    2fd0:	cf 90       	pop	r12
    2fd2:	08 95       	ret

00002fd4 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2fd4:	cf 92       	push	r12
    2fd6:	df 92       	push	r13
    2fd8:	ef 92       	push	r14
    2fda:	ff 92       	push	r15
    2fdc:	0f 93       	push	r16
    2fde:	1f 93       	push	r17
    2fe0:	cf 93       	push	r28
    2fe2:	df 93       	push	r29
    2fe4:	cd b7       	in	r28, 0x3d	; 61
    2fe6:	de b7       	in	r29, 0x3e	; 62
    2fe8:	2f 97       	sbiw	r28, 0x0f	; 15
    2fea:	cd bf       	out	0x3d, r28	; 61
    2fec:	de bf       	out	0x3e, r29	; 62
    2fee:	6c 01       	movw	r12, r24
    2ff0:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2ff2:	db 01       	movw	r26, r22
    2ff4:	6d 91       	ld	r22, X+
    2ff6:	7d 91       	ld	r23, X+
    2ff8:	8d 91       	ld	r24, X+
    2ffa:	9c 91       	ld	r25, X
    2ffc:	28 ee       	ldi	r18, 0xE8	; 232
    2ffe:	33 e0       	ldi	r19, 0x03	; 3
    3000:	40 e0       	ldi	r20, 0x00	; 0
    3002:	50 e0       	ldi	r21, 0x00	; 0
    3004:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <__udivmodsi4>
    3008:	ba 01       	movw	r22, r20
    300a:	a9 01       	movw	r20, r18
    300c:	c6 01       	movw	r24, r12
    300e:	0e 94 9e 1a 	call	0x353c	; 0x353c <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3012:	d6 01       	movw	r26, r12
    3014:	ed 91       	ld	r30, X+
    3016:	fc 91       	ld	r31, X
    3018:	02 80       	ldd	r0, Z+2	; 0x02
    301a:	f3 81       	ldd	r31, Z+3	; 0x03
    301c:	e0 2d       	mov	r30, r0
    301e:	6e e2       	ldi	r22, 0x2E	; 46
    3020:	c6 01       	movw	r24, r12
    3022:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3024:	c8 01       	movw	r24, r16
    3026:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <_ZN10time_stamp12get_microsecEv>
    302a:	8e 01       	movw	r16, r28
    302c:	09 5f       	subi	r16, 0xF9	; 249
    302e:	1f 4f       	sbci	r17, 0xFF	; 255
    3030:	fe 01       	movw	r30, r28
    3032:	31 96       	adiw	r30, 0x01	; 1
    3034:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3036:	2a e0       	ldi	r18, 0x0A	; 10
    3038:	30 e0       	ldi	r19, 0x00	; 0
    303a:	40 e0       	ldi	r20, 0x00	; 0
    303c:	50 e0       	ldi	r21, 0x00	; 0
    303e:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <__divmodsi4>
    3042:	e6 2f       	mov	r30, r22
    3044:	28 87       	std	Y+8, r18	; 0x08
    3046:	39 87       	std	Y+9, r19	; 0x09
    3048:	4a 87       	std	Y+10, r20	; 0x0a
    304a:	5b 87       	std	Y+11, r21	; 0x0b
    304c:	68 85       	ldd	r22, Y+8	; 0x08
    304e:	79 85       	ldd	r23, Y+9	; 0x09
    3050:	8a 85       	ldd	r24, Y+10	; 0x0a
    3052:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3054:	20 e3       	ldi	r18, 0x30	; 48
    3056:	2e 0f       	add	r18, r30
    3058:	d8 01       	movw	r26, r16
    305a:	2e 93       	st	-X, r18
    305c:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    305e:	ae 15       	cp	r26, r14
    3060:	bf 05       	cpc	r27, r15
    3062:	49 f7       	brne	.-46     	; 0x3036 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3064:	1f 82       	std	Y+7, r1	; 0x07
    3066:	be 01       	movw	r22, r28
    3068:	6f 5f       	subi	r22, 0xFF	; 255
    306a:	7f 4f       	sbci	r23, 0xFF	; 255
    306c:	c6 01       	movw	r24, r12
    306e:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3072:	c6 01       	movw	r24, r12
    3074:	2f 96       	adiw	r28, 0x0f	; 15
    3076:	cd bf       	out	0x3d, r28	; 61
    3078:	de bf       	out	0x3e, r29	; 62
    307a:	df 91       	pop	r29
    307c:	cf 91       	pop	r28
    307e:	1f 91       	pop	r17
    3080:	0f 91       	pop	r16
    3082:	ff 90       	pop	r15
    3084:	ef 90       	pop	r14
    3086:	df 90       	pop	r13
    3088:	cf 90       	pop	r12
    308a:	08 95       	ret

0000308c <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    308c:	cf 93       	push	r28
    308e:	df 93       	push	r29
    3090:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3092:	0f b6       	in	r0, 0x3f	; 63
    3094:	f8 94       	cli
    3096:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3098:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    309c:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    30a0:	8c 83       	std	Y+4, r24	; 0x04
    30a2:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    30a4:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <xTaskGetTickCount>
    30a8:	68 83       	st	Y, r22
    30aa:	79 83       	std	Y+1, r23	; 0x01
    30ac:	8a 83       	std	Y+2, r24	; 0x02
    30ae:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    30b0:	0f 90       	pop	r0
    30b2:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    30b4:	ce 01       	movw	r24, r28
    30b6:	df 91       	pop	r29
    30b8:	cf 91       	pop	r28
    30ba:	08 95       	ret

000030bc <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    30bc:	5f 92       	push	r5
    30be:	6f 92       	push	r6
    30c0:	7f 92       	push	r7
    30c2:	8f 92       	push	r8
    30c4:	9f 92       	push	r9
    30c6:	af 92       	push	r10
    30c8:	bf 92       	push	r11
    30ca:	cf 92       	push	r12
    30cc:	df 92       	push	r13
    30ce:	ef 92       	push	r14
    30d0:	ff 92       	push	r15
    30d2:	0f 93       	push	r16
    30d4:	1f 93       	push	r17
    30d6:	cf 93       	push	r28
    30d8:	df 93       	push	r29
    30da:	5c 01       	movw	r10, r24
    30dc:	4b 01       	movw	r8, r22
    30de:	7a 01       	movw	r14, r20
    30e0:	12 2f       	mov	r17, r18
    30e2:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    30e4:	63 e0       	ldi	r22, 0x03	; 3
    30e6:	ca 01       	movw	r24, r20
    30e8:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    30ec:	a8 14       	cp	r10, r8
    30ee:	b9 04       	cpc	r11, r9
    30f0:	08 f0       	brcs	.+2      	; 0x30f4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    30f2:	7d c0       	rjmp	.+250    	; 0x31ee <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    30f4:	65 01       	movw	r12, r10
    30f6:	84 e1       	ldi	r24, 0x14	; 20
    30f8:	c8 0e       	add	r12, r24
    30fa:	d1 1c       	adc	r13, r1
    30fc:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    30fe:	6a 2c       	mov	r6, r10
    3100:	5b 2c       	mov	r5, r11
    3102:	b5 01       	movw	r22, r10
    3104:	c7 01       	movw	r24, r14
    3106:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <_ZN8emstreamlsEj>
    310a:	6a e0       	ldi	r22, 0x0A	; 10
    310c:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    3110:	69 e4       	ldi	r22, 0x49	; 73
    3112:	75 e0       	ldi	r23, 0x05	; 5
    3114:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3118:	11 23       	and	r17, r17
    311a:	09 f4       	brne	.+2      	; 0x311e <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    311c:	6d c0       	rjmp	.+218    	; 0x31f8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    311e:	00 23       	and	r16, r16
    3120:	09 f4       	brne	.+2      	; 0x3124 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3122:	6a c0       	rjmp	.+212    	; 0x31f8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3124:	6a e0       	ldi	r22, 0x0A	; 10
    3126:	c7 01       	movw	r24, r14
    3128:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    312c:	64 e4       	ldi	r22, 0x44	; 68
    312e:	75 e0       	ldi	r23, 0x05	; 5
    3130:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    3134:	61 c0       	rjmp	.+194    	; 0x31f8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3136:	11 23       	and	r17, r17
    3138:	71 f0       	breq	.+28     	; 0x3156 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    313a:	01 11       	cpse	r16, r1
    313c:	0c c0       	rjmp	.+24     	; 0x3156 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    313e:	88 81       	ld	r24, Y
    3140:	87 15       	cp	r24, r7
    3142:	49 f0       	breq	.+18     	; 0x3156 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3144:	6a e0       	ldi	r22, 0x0A	; 10
    3146:	c7 01       	movw	r24, r14
    3148:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    314c:	6f e3       	ldi	r22, 0x3F	; 63
    314e:	75 e0       	ldi	r23, 0x05	; 5
    3150:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3154:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3156:	69 91       	ld	r22, Y+
    3158:	c7 01       	movw	r24, r14
    315a:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    315e:	dc 01       	movw	r26, r24
    3160:	ed 91       	ld	r30, X+
    3162:	fc 91       	ld	r31, X
    3164:	02 80       	ldd	r0, Z+2	; 0x02
    3166:	f3 81       	ldd	r31, Z+3	; 0x03
    3168:	e0 2d       	mov	r30, r0
    316a:	60 e2       	ldi	r22, 0x20	; 32
    316c:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    316e:	cc 16       	cp	r12, r28
    3170:	dd 06       	cpc	r13, r29
    3172:	09 f7       	brne	.-62     	; 0x3136 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3174:	11 23       	and	r17, r17
    3176:	89 f0       	breq	.+34     	; 0x319a <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3178:	6a e0       	ldi	r22, 0x0A	; 10
    317a:	c7 01       	movw	r24, r14
    317c:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    3180:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3182:	69 e3       	ldi	r22, 0x39	; 57
    3184:	75 e0       	ldi	r23, 0x05	; 5
    3186:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    318a:	e8 81       	ld	r30, Y
    318c:	f9 81       	ldd	r31, Y+1	; 0x01
    318e:	02 80       	ldd	r0, Z+2	; 0x02
    3190:	f3 81       	ldd	r31, Z+3	; 0x03
    3192:	e0 2d       	mov	r30, r0
    3194:	60 e2       	ldi	r22, 0x20	; 32
    3196:	ce 01       	movw	r24, r28
    3198:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    319a:	c6 2d       	mov	r28, r6
    319c:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    319e:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    31a0:	80 ee       	ldi	r24, 0xE0	; 224
    31a2:	86 0f       	add	r24, r22
    31a4:	8f 35       	cpi	r24, 0x5F	; 95
    31a6:	48 f4       	brcc	.+18     	; 0x31ba <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    31a8:	d7 01       	movw	r26, r14
    31aa:	ed 91       	ld	r30, X+
    31ac:	fc 91       	ld	r31, X
    31ae:	02 80       	ldd	r0, Z+2	; 0x02
    31b0:	f3 81       	ldd	r31, Z+3	; 0x03
    31b2:	e0 2d       	mov	r30, r0
    31b4:	c7 01       	movw	r24, r14
    31b6:	19 95       	eicall
    31b8:	09 c0       	rjmp	.+18     	; 0x31cc <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    31ba:	d7 01       	movw	r26, r14
    31bc:	ed 91       	ld	r30, X+
    31be:	fc 91       	ld	r31, X
    31c0:	02 80       	ldd	r0, Z+2	; 0x02
    31c2:	f3 81       	ldd	r31, Z+3	; 0x03
    31c4:	e0 2d       	mov	r30, r0
    31c6:	6e e2       	ldi	r22, 0x2E	; 46
    31c8:	c7 01       	movw	r24, r14
    31ca:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    31cc:	cc 16       	cp	r12, r28
    31ce:	dd 06       	cpc	r13, r29
    31d0:	31 f7       	brne	.-52     	; 0x319e <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    31d2:	b4 e1       	ldi	r27, 0x14	; 20
    31d4:	ab 0e       	add	r10, r27
    31d6:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    31d8:	66 e0       	ldi	r22, 0x06	; 6
    31da:	c7 01       	movw	r24, r14
    31dc:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    31e0:	84 e1       	ldi	r24, 0x14	; 20
    31e2:	c8 0e       	add	r12, r24
    31e4:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31e6:	a8 14       	cp	r10, r8
    31e8:	b9 04       	cpc	r11, r9
    31ea:	08 f4       	brcc	.+2      	; 0x31ee <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    31ec:	88 cf       	rjmp	.-240    	; 0x30fe <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    31ee:	62 e0       	ldi	r22, 0x02	; 2
    31f0:	c7 01       	movw	r24, r14
    31f2:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
}
    31f6:	03 c0       	rjmp	.+6      	; 0x31fe <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    31f8:	c6 2d       	mov	r28, r6
    31fa:	d5 2d       	mov	r29, r5
    31fc:	9c cf       	rjmp	.-200    	; 0x3136 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    31fe:	df 91       	pop	r29
    3200:	cf 91       	pop	r28
    3202:	1f 91       	pop	r17
    3204:	0f 91       	pop	r16
    3206:	ff 90       	pop	r15
    3208:	ef 90       	pop	r14
    320a:	df 90       	pop	r13
    320c:	cf 90       	pop	r12
    320e:	bf 90       	pop	r11
    3210:	af 90       	pop	r10
    3212:	9f 90       	pop	r9
    3214:	8f 90       	pop	r8
    3216:	7f 90       	pop	r7
    3218:	6f 90       	pop	r6
    321a:	5f 90       	pop	r5
    321c:	08 95       	ret

0000321e <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    321e:	0e 94 40 09 	call	0x1280	; 0x1280 <pvPortMalloc>
    3222:	08 95       	ret

00003224 <_Znaj>:
    3224:	0e 94 40 09 	call	0x1280	; 0x1280 <pvPortMalloc>
    3228:	08 95       	ret

0000322a <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    322a:	08 95       	ret

0000322c <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    322c:	cf 93       	push	r28
    322e:	df 93       	push	r29
    3230:	fc 01       	movw	r30, r24
    3232:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3234:	40 3a       	cpi	r20, 0xA0	; 160
    3236:	68 e0       	ldi	r22, 0x08	; 8
    3238:	56 07       	cpc	r21, r22
    323a:	49 f4       	brne	.+18     	; 0x324e <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    323c:	80 e4       	ldi	r24, 0x40	; 64
    323e:	96 e0       	ldi	r25, 0x06	; 6
    3240:	82 83       	std	Z+2, r24	; 0x02
    3242:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3244:	82 e0       	ldi	r24, 0x02	; 2
    3246:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3248:	83 e0       	ldi	r24, 0x03	; 3
    324a:	85 83       	std	Z+5, r24	; 0x05
    324c:	32 c0       	rjmp	.+100    	; 0x32b2 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    324e:	40 3b       	cpi	r20, 0xB0	; 176
    3250:	78 e0       	ldi	r23, 0x08	; 8
    3252:	57 07       	cpc	r21, r23
    3254:	49 f4       	brne	.+18     	; 0x3268 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3256:	80 e4       	ldi	r24, 0x40	; 64
    3258:	96 e0       	ldi	r25, 0x06	; 6
    325a:	82 83       	std	Z+2, r24	; 0x02
    325c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    325e:	86 e0       	ldi	r24, 0x06	; 6
    3260:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3262:	87 e0       	ldi	r24, 0x07	; 7
    3264:	85 83       	std	Z+5, r24	; 0x05
    3266:	25 c0       	rjmp	.+74     	; 0x32b2 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3268:	40 3a       	cpi	r20, 0xA0	; 160
    326a:	89 e0       	ldi	r24, 0x09	; 9
    326c:	58 07       	cpc	r21, r24
    326e:	49 f4       	brne	.+18     	; 0x3282 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3270:	80 e6       	ldi	r24, 0x60	; 96
    3272:	96 e0       	ldi	r25, 0x06	; 6
    3274:	82 83       	std	Z+2, r24	; 0x02
    3276:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3278:	82 e0       	ldi	r24, 0x02	; 2
    327a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    327c:	83 e0       	ldi	r24, 0x03	; 3
    327e:	85 83       	std	Z+5, r24	; 0x05
    3280:	18 c0       	rjmp	.+48     	; 0x32b2 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3282:	40 3b       	cpi	r20, 0xB0	; 176
    3284:	69 e0       	ldi	r22, 0x09	; 9
    3286:	56 07       	cpc	r21, r22
    3288:	49 f4       	brne	.+18     	; 0x329c <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    328a:	80 e6       	ldi	r24, 0x60	; 96
    328c:	96 e0       	ldi	r25, 0x06	; 6
    328e:	82 83       	std	Z+2, r24	; 0x02
    3290:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3292:	86 e0       	ldi	r24, 0x06	; 6
    3294:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3296:	87 e0       	ldi	r24, 0x07	; 7
    3298:	85 83       	std	Z+5, r24	; 0x05
    329a:	0b c0       	rjmp	.+22     	; 0x32b2 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    329c:	40 3a       	cpi	r20, 0xA0	; 160
    329e:	5a 40       	sbci	r21, 0x0A	; 10
    32a0:	41 f4       	brne	.+16     	; 0x32b2 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    32a2:	80 e8       	ldi	r24, 0x80	; 128
    32a4:	96 e0       	ldi	r25, 0x06	; 6
    32a6:	82 83       	std	Z+2, r24	; 0x02
    32a8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32aa:	82 e0       	ldi	r24, 0x02	; 2
    32ac:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32ae:	83 e0       	ldi	r24, 0x03	; 3
    32b0:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    32b2:	a6 83       	std	Z+6, r26	; 0x06
    32b4:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    32b6:	cd 01       	movw	r24, r26
    32b8:	01 96       	adiw	r24, 0x01	; 1
    32ba:	80 87       	std	Z+8, r24	; 0x08
    32bc:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    32be:	03 96       	adiw	r24, 0x03	; 3
    32c0:	82 87       	std	Z+10, r24	; 0x0a
    32c2:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    32c4:	25 81       	ldd	r18, Z+5	; 0x05
    32c6:	c2 81       	ldd	r28, Z+2	; 0x02
    32c8:	d3 81       	ldd	r29, Z+3	; 0x03
    32ca:	4c 81       	ldd	r20, Y+4	; 0x04
    32cc:	81 e0       	ldi	r24, 0x01	; 1
    32ce:	90 e0       	ldi	r25, 0x00	; 0
    32d0:	bc 01       	movw	r22, r24
    32d2:	02 c0       	rjmp	.+4      	; 0x32d8 <_ZN7base232C1EjP12USART_struct+0xac>
    32d4:	66 0f       	add	r22, r22
    32d6:	77 1f       	adc	r23, r23
    32d8:	2a 95       	dec	r18
    32da:	e2 f7       	brpl	.-8      	; 0x32d4 <_ZN7base232C1EjP12USART_struct+0xa8>
    32dc:	9b 01       	movw	r18, r22
    32de:	24 2b       	or	r18, r20
    32e0:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    32e2:	25 81       	ldd	r18, Z+5	; 0x05
    32e4:	c2 81       	ldd	r28, Z+2	; 0x02
    32e6:	d3 81       	ldd	r29, Z+3	; 0x03
    32e8:	48 81       	ld	r20, Y
    32ea:	bc 01       	movw	r22, r24
    32ec:	02 c0       	rjmp	.+4      	; 0x32f2 <_ZN7base232C1EjP12USART_struct+0xc6>
    32ee:	66 0f       	add	r22, r22
    32f0:	77 1f       	adc	r23, r23
    32f2:	2a 95       	dec	r18
    32f4:	e2 f7       	brpl	.-8      	; 0x32ee <_ZN7base232C1EjP12USART_struct+0xc2>
    32f6:	9b 01       	movw	r18, r22
    32f8:	24 2b       	or	r18, r20
    32fa:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    32fc:	34 81       	ldd	r19, Z+4	; 0x04
    32fe:	c2 81       	ldd	r28, Z+2	; 0x02
    3300:	d3 81       	ldd	r29, Z+3	; 0x03
    3302:	28 81       	ld	r18, Y
    3304:	02 c0       	rjmp	.+4      	; 0x330a <_ZN7base232C1EjP12USART_struct+0xde>
    3306:	88 0f       	add	r24, r24
    3308:	99 1f       	adc	r25, r25
    330a:	3a 95       	dec	r19
    330c:	e2 f7       	brpl	.-8      	; 0x3306 <_ZN7base232C1EjP12USART_struct+0xda>
    330e:	80 95       	com	r24
    3310:	90 95       	com	r25
    3312:	82 23       	and	r24, r18
    3314:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3316:	80 e1       	ldi	r24, 0x10	; 16
    3318:	13 96       	adiw	r26, 0x03	; 3
    331a:	8c 93       	st	X, r24
    331c:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    331e:	83 e0       	ldi	r24, 0x03	; 3
    3320:	15 96       	adiw	r26, 0x05	; 5
    3322:	8c 93       	st	X, r24
    3324:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3326:	80 ef       	ldi	r24, 0xF0	; 240
    3328:	17 96       	adiw	r26, 0x07	; 7
    332a:	8c 93       	st	X, r24
    332c:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    332e:	81 e2       	ldi	r24, 0x21	; 33
    3330:	16 96       	adiw	r26, 0x06	; 6
    3332:	8c 93       	st	X, r24
    3334:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3336:	88 e1       	ldi	r24, 0x18	; 24
    3338:	14 96       	adiw	r26, 0x04	; 4
    333a:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    333c:	80 e8       	ldi	r24, 0x80	; 128
    333e:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3340:	80 e4       	ldi	r24, 0x40	; 64
    3342:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3344:	80 e2       	ldi	r24, 0x20	; 32
    3346:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3348:	06 80       	ldd	r0, Z+6	; 0x06
    334a:	f7 81       	ldd	r31, Z+7	; 0x07
    334c:	e0 2d       	mov	r30, r0
    334e:	80 81       	ld	r24, Z
    3350:	80 81       	ld	r24, Z
}
    3352:	df 91       	pop	r29
    3354:	cf 91       	pop	r28
    3356:	08 95       	ret

00003358 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3358:	81 e0       	ldi	r24, 0x01	; 1
    335a:	08 95       	ret

0000335c <_ZN8emstream7getcharEv>:
    335c:	80 e0       	ldi	r24, 0x00	; 0
    335e:	90 e0       	ldi	r25, 0x00	; 0
    3360:	08 95       	ret

00003362 <_ZN8emstream14check_for_charEv>:
    3362:	80 e0       	ldi	r24, 0x00	; 0
    3364:	08 95       	ret

00003366 <_ZN8emstream12transmit_nowEv>:
    3366:	08 95       	ret

00003368 <_ZN8emstream12clear_screenEv>:
    3368:	08 95       	ret

0000336a <_ZN8emstreamC1Ev>:
    336a:	fc 01       	movw	r30, r24
    336c:	87 e5       	ldi	r24, 0x57	; 87
    336e:	90 e2       	ldi	r25, 0x20	; 32
    3370:	80 83       	st	Z, r24
    3372:	91 83       	std	Z+1, r25	; 0x01
    3374:	8a e0       	ldi	r24, 0x0A	; 10
    3376:	82 83       	std	Z+2, r24	; 0x02
    3378:	13 82       	std	Z+3, r1	; 0x03
    337a:	83 e0       	ldi	r24, 0x03	; 3
    337c:	85 83       	std	Z+5, r24	; 0x05
    337e:	14 82       	std	Z+4, r1	; 0x04
    3380:	16 82       	std	Z+6, r1	; 0x06
    3382:	17 82       	std	Z+7, r1	; 0x07
    3384:	08 95       	ret

00003386 <_ZN8emstream4putsEPKc>:
    3386:	0f 93       	push	r16
    3388:	1f 93       	push	r17
    338a:	cf 93       	push	r28
    338c:	df 93       	push	r29
    338e:	8c 01       	movw	r16, r24
    3390:	fb 01       	movw	r30, r22
    3392:	dc 01       	movw	r26, r24
    3394:	14 96       	adiw	r26, 0x04	; 4
    3396:	8c 91       	ld	r24, X
    3398:	81 11       	cpse	r24, r1
    339a:	04 c0       	rjmp	.+8      	; 0x33a4 <_ZN8emstream4putsEPKc+0x1e>
    339c:	60 81       	ld	r22, Z
    339e:	61 11       	cpse	r22, r1
    33a0:	17 c0       	rjmp	.+46     	; 0x33d0 <_ZN8emstream4putsEPKc+0x4a>
    33a2:	23 c0       	rjmp	.+70     	; 0x33ea <_ZN8emstream4putsEPKc+0x64>
    33a4:	d8 01       	movw	r26, r16
    33a6:	14 96       	adiw	r26, 0x04	; 4
    33a8:	1c 92       	st	X, r1
    33aa:	eb 01       	movw	r28, r22
    33ac:	21 96       	adiw	r28, 0x01	; 1
    33ae:	64 91       	lpm	r22, Z
    33b0:	66 23       	and	r22, r22
    33b2:	d9 f0       	breq	.+54     	; 0x33ea <_ZN8emstream4putsEPKc+0x64>
    33b4:	d8 01       	movw	r26, r16
    33b6:	ed 91       	ld	r30, X+
    33b8:	fc 91       	ld	r31, X
    33ba:	02 80       	ldd	r0, Z+2	; 0x02
    33bc:	f3 81       	ldd	r31, Z+3	; 0x03
    33be:	e0 2d       	mov	r30, r0
    33c0:	c8 01       	movw	r24, r16
    33c2:	19 95       	eicall
    33c4:	fe 01       	movw	r30, r28
    33c6:	64 91       	lpm	r22, Z
    33c8:	21 96       	adiw	r28, 0x01	; 1
    33ca:	61 11       	cpse	r22, r1
    33cc:	f3 cf       	rjmp	.-26     	; 0x33b4 <_ZN8emstream4putsEPKc+0x2e>
    33ce:	0d c0       	rjmp	.+26     	; 0x33ea <_ZN8emstream4putsEPKc+0x64>
    33d0:	ef 01       	movw	r28, r30
    33d2:	21 96       	adiw	r28, 0x01	; 1
    33d4:	d8 01       	movw	r26, r16
    33d6:	ed 91       	ld	r30, X+
    33d8:	fc 91       	ld	r31, X
    33da:	02 80       	ldd	r0, Z+2	; 0x02
    33dc:	f3 81       	ldd	r31, Z+3	; 0x03
    33de:	e0 2d       	mov	r30, r0
    33e0:	c8 01       	movw	r24, r16
    33e2:	19 95       	eicall
    33e4:	69 91       	ld	r22, Y+
    33e6:	61 11       	cpse	r22, r1
    33e8:	f5 cf       	rjmp	.-22     	; 0x33d4 <_ZN8emstream4putsEPKc+0x4e>
    33ea:	df 91       	pop	r29
    33ec:	cf 91       	pop	r28
    33ee:	1f 91       	pop	r17
    33f0:	0f 91       	pop	r16
    33f2:	08 95       	ret

000033f4 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    33f4:	cf 93       	push	r28
    33f6:	df 93       	push	r29
    33f8:	ec 01       	movw	r28, r24
	switch (new_manip)
    33fa:	86 2f       	mov	r24, r22
    33fc:	90 e0       	ldi	r25, 0x00	; 0
    33fe:	8b 30       	cpi	r24, 0x0B	; 11
    3400:	91 05       	cpc	r25, r1
    3402:	d8 f5       	brcc	.+118    	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x86>
    3404:	fc 01       	movw	r30, r24
    3406:	88 27       	eor	r24, r24
    3408:	e2 50       	subi	r30, 0x02	; 2
    340a:	ff 4f       	sbci	r31, 0xFF	; 255
    340c:	8f 4f       	sbci	r24, 0xFF	; 255
    340e:	0c 94 ac 1f 	jmp	0x3f58	; 0x3f58 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3412:	82 e0       	ldi	r24, 0x02	; 2
    3414:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3416:	31 c0       	rjmp	.+98     	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3418:	88 e0       	ldi	r24, 0x08	; 8
    341a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    341c:	2e c0       	rjmp	.+92     	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    341e:	8a e0       	ldi	r24, 0x0A	; 10
    3420:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3422:	2b c0       	rjmp	.+86     	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3424:	80 e1       	ldi	r24, 0x10	; 16
    3426:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3428:	28 c0       	rjmp	.+80     	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    342a:	81 e0       	ldi	r24, 0x01	; 1
    342c:	8b 83       	std	Y+3, r24	; 0x03
			break;
    342e:	25 c0       	rjmp	.+74     	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3430:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3432:	23 c0       	rjmp	.+70     	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3434:	e8 81       	ld	r30, Y
    3436:	f9 81       	ldd	r31, Y+1	; 0x01
    3438:	02 80       	ldd	r0, Z+2	; 0x02
    343a:	f3 81       	ldd	r31, Z+3	; 0x03
    343c:	e0 2d       	mov	r30, r0
    343e:	6d e0       	ldi	r22, 0x0D	; 13
    3440:	ce 01       	movw	r24, r28
    3442:	19 95       	eicall
    3444:	e8 81       	ld	r30, Y
    3446:	f9 81       	ldd	r31, Y+1	; 0x01
    3448:	02 80       	ldd	r0, Z+2	; 0x02
    344a:	f3 81       	ldd	r31, Z+3	; 0x03
    344c:	e0 2d       	mov	r30, r0
    344e:	6a e0       	ldi	r22, 0x0A	; 10
    3450:	ce 01       	movw	r24, r28
    3452:	19 95       	eicall
			break;
    3454:	12 c0       	rjmp	.+36     	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3456:	e8 81       	ld	r30, Y
    3458:	f9 81       	ldd	r31, Y+1	; 0x01
    345a:	02 84       	ldd	r0, Z+10	; 0x0a
    345c:	f3 85       	ldd	r31, Z+11	; 0x0b
    345e:	e0 2d       	mov	r30, r0
    3460:	ce 01       	movw	r24, r28
    3462:	19 95       	eicall
			break;
    3464:	0a c0       	rjmp	.+20     	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3466:	e8 81       	ld	r30, Y
    3468:	f9 81       	ldd	r31, Y+1	; 0x01
    346a:	00 84       	ldd	r0, Z+8	; 0x08
    346c:	f1 85       	ldd	r31, Z+9	; 0x09
    346e:	e0 2d       	mov	r30, r0
    3470:	ce 01       	movw	r24, r28
    3472:	19 95       	eicall
			break;
    3474:	02 c0       	rjmp	.+4      	; 0x347a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3476:	81 e0       	ldi	r24, 0x01	; 1
    3478:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    347a:	ce 01       	movw	r24, r28
    347c:	df 91       	pop	r29
    347e:	cf 91       	pop	r28
    3480:	08 95       	ret

00003482 <_ZN8emstreamlsEi>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (int16_t num)
{
    3482:	0f 93       	push	r16
    3484:	1f 93       	push	r17
    3486:	cf 93       	push	r28
    3488:	df 93       	push	r29
    348a:	cd b7       	in	r28, 0x3d	; 61
    348c:	de b7       	in	r29, 0x3e	; 62
    348e:	61 97       	sbiw	r28, 0x11	; 17
    3490:	cd bf       	out	0x3d, r28	; 61
    3492:	de bf       	out	0x3e, r29	; 62
    3494:	8c 01       	movw	r16, r24
    3496:	9b 01       	movw	r18, r22
	if (base != 10)
    3498:	fc 01       	movw	r30, r24
    349a:	92 81       	ldd	r25, Z+2	; 0x02
    349c:	9a 30       	cpi	r25, 0x0A	; 10
    349e:	21 f0       	breq	.+8      	; 0x34a8 <_ZN8emstreamlsEi+0x26>
	{
		*this << (uint16_t)num;
    34a0:	c8 01       	movw	r24, r16
    34a2:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <_ZN8emstreamlsEj>
    34a6:	0d c0       	rjmp	.+26     	; 0x34c2 <_ZN8emstreamlsEi+0x40>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    34a8:	4a e0       	ldi	r20, 0x0A	; 10
    34aa:	be 01       	movw	r22, r28
    34ac:	6f 5f       	subi	r22, 0xFF	; 255
    34ae:	7f 4f       	sbci	r23, 0xFF	; 255
    34b0:	c9 01       	movw	r24, r18
    34b2:	0e 94 19 20 	call	0x4032	; 0x4032 <__itoa_ncheck>
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
		puts (out_str);
    34b6:	be 01       	movw	r22, r28
    34b8:	6f 5f       	subi	r22, 0xFF	; 255
    34ba:	7f 4f       	sbci	r23, 0xFF	; 255
    34bc:	c8 01       	movw	r24, r16
    34be:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    34c2:	c8 01       	movw	r24, r16
    34c4:	61 96       	adiw	r28, 0x11	; 17
    34c6:	cd bf       	out	0x3d, r28	; 61
    34c8:	de bf       	out	0x3e, r29	; 62
    34ca:	df 91       	pop	r29
    34cc:	cf 91       	pop	r28
    34ce:	1f 91       	pop	r17
    34d0:	0f 91       	pop	r16
    34d2:	08 95       	ret

000034d4 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    34d4:	ff 92       	push	r15
    34d6:	0f 93       	push	r16
    34d8:	1f 93       	push	r17
    34da:	cf 93       	push	r28
    34dc:	df 93       	push	r29
    34de:	cd b7       	in	r28, 0x3d	; 61
    34e0:	de b7       	in	r29, 0x3e	; 62
    34e2:	61 97       	sbiw	r28, 0x11	; 17
    34e4:	cd bf       	out	0x3d, r28	; 61
    34e6:	de bf       	out	0x3e, r29	; 62
    34e8:	8c 01       	movw	r16, r24
    34ea:	f6 2e       	mov	r15, r22
    34ec:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    34ee:	f8 01       	movw	r30, r16
    34f0:	42 81       	ldd	r20, Z+2	; 0x02
    34f2:	40 31       	cpi	r20, 0x10	; 16
    34f4:	21 f0       	breq	.+8      	; 0x34fe <_ZN8emstreamlsEj+0x2a>
    34f6:	48 30       	cpi	r20, 0x08	; 8
    34f8:	11 f0       	breq	.+4      	; 0x34fe <_ZN8emstreamlsEj+0x2a>
    34fa:	42 30       	cpi	r20, 0x02	; 2
    34fc:	41 f4       	brne	.+16     	; 0x350e <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    34fe:	69 2f       	mov	r22, r25
    3500:	c8 01       	movw	r24, r16
    3502:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <_ZN8emstreamlsEh>
    3506:	6f 2d       	mov	r22, r15
    3508:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <_ZN8emstreamlsEh>
    350c:	0d c0       	rjmp	.+26     	; 0x3528 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    350e:	50 e0       	ldi	r21, 0x00	; 0
    3510:	be 01       	movw	r22, r28
    3512:	6f 5f       	subi	r22, 0xFF	; 255
    3514:	7f 4f       	sbci	r23, 0xFF	; 255
    3516:	8f 2d       	mov	r24, r15
    3518:	0e 94 51 20 	call	0x40a2	; 0x40a2 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    351c:	be 01       	movw	r22, r28
    351e:	6f 5f       	subi	r22, 0xFF	; 255
    3520:	7f 4f       	sbci	r23, 0xFF	; 255
    3522:	c8 01       	movw	r24, r16
    3524:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3528:	c8 01       	movw	r24, r16
    352a:	61 96       	adiw	r28, 0x11	; 17
    352c:	cd bf       	out	0x3d, r28	; 61
    352e:	de bf       	out	0x3e, r29	; 62
    3530:	df 91       	pop	r29
    3532:	cf 91       	pop	r28
    3534:	1f 91       	pop	r17
    3536:	0f 91       	pop	r16
    3538:	ff 90       	pop	r15
    353a:	08 95       	ret

0000353c <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    353c:	df 92       	push	r13
    353e:	ef 92       	push	r14
    3540:	ff 92       	push	r15
    3542:	0f 93       	push	r16
    3544:	1f 93       	push	r17
    3546:	cf 93       	push	r28
    3548:	df 93       	push	r29
    354a:	cd b7       	in	r28, 0x3d	; 61
    354c:	de b7       	in	r29, 0x3e	; 62
    354e:	a1 97       	sbiw	r28, 0x21	; 33
    3550:	cd bf       	out	0x3d, r28	; 61
    3552:	de bf       	out	0x3e, r29	; 62
    3554:	8c 01       	movw	r16, r24
    3556:	d4 2e       	mov	r13, r20
    3558:	e5 2e       	mov	r14, r21
    355a:	f6 2e       	mov	r15, r22
    355c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    355e:	f8 01       	movw	r30, r16
    3560:	22 81       	ldd	r18, Z+2	; 0x02
    3562:	20 31       	cpi	r18, 0x10	; 16
    3564:	21 f0       	breq	.+8      	; 0x356e <_ZN8emstreamlsEm+0x32>
    3566:	28 30       	cpi	r18, 0x08	; 8
    3568:	11 f0       	breq	.+4      	; 0x356e <_ZN8emstreamlsEm+0x32>
    356a:	22 30       	cpi	r18, 0x02	; 2
    356c:	71 f4       	brne	.+28     	; 0x358a <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    356e:	69 2f       	mov	r22, r25
    3570:	c8 01       	movw	r24, r16
    3572:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <_ZN8emstreamlsEh>
    3576:	6f 2d       	mov	r22, r15
    3578:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <_ZN8emstreamlsEh>
    357c:	6e 2d       	mov	r22, r14
    357e:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <_ZN8emstreamlsEh>
    3582:	6d 2d       	mov	r22, r13
    3584:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <_ZN8emstreamlsEh>
    3588:	0f c0       	rjmp	.+30     	; 0x35a8 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    358a:	30 e0       	ldi	r19, 0x00	; 0
    358c:	ae 01       	movw	r20, r28
    358e:	4f 5f       	subi	r20, 0xFF	; 255
    3590:	5f 4f       	sbci	r21, 0xFF	; 255
    3592:	6d 2d       	mov	r22, r13
    3594:	7e 2d       	mov	r23, r14
    3596:	8f 2d       	mov	r24, r15
    3598:	0e 94 24 20 	call	0x4048	; 0x4048 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    359c:	be 01       	movw	r22, r28
    359e:	6f 5f       	subi	r22, 0xFF	; 255
    35a0:	7f 4f       	sbci	r23, 0xFF	; 255
    35a2:	c8 01       	movw	r24, r16
    35a4:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    35a8:	c8 01       	movw	r24, r16
    35aa:	a1 96       	adiw	r28, 0x21	; 33
    35ac:	cd bf       	out	0x3d, r28	; 61
    35ae:	de bf       	out	0x3e, r29	; 62
    35b0:	df 91       	pop	r29
    35b2:	cf 91       	pop	r28
    35b4:	1f 91       	pop	r17
    35b6:	0f 91       	pop	r16
    35b8:	ff 90       	pop	r15
    35ba:	ef 90       	pop	r14
    35bc:	df 90       	pop	r13
    35be:	08 95       	ret

000035c0 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    35c0:	cf 92       	push	r12
    35c2:	df 92       	push	r13
    35c4:	ef 92       	push	r14
    35c6:	ff 92       	push	r15
    35c8:	0f 93       	push	r16
    35ca:	1f 93       	push	r17
    35cc:	cf 93       	push	r28
    35ce:	df 93       	push	r29
    35d0:	cd b7       	in	r28, 0x3d	; 61
    35d2:	de b7       	in	r29, 0x3e	; 62
    35d4:	29 97       	sbiw	r28, 0x09	; 9
    35d6:	cd bf       	out	0x3d, r28	; 61
    35d8:	de bf       	out	0x3e, r29	; 62
    35da:	8c 01       	movw	r16, r24
    35dc:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    35de:	dc 01       	movw	r26, r24
    35e0:	13 96       	adiw	r26, 0x03	; 3
    35e2:	8c 91       	ld	r24, X
    35e4:	13 97       	sbiw	r26, 0x03	; 3
    35e6:	88 23       	and	r24, r24
    35e8:	41 f0       	breq	.+16     	; 0x35fa <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    35ea:	ed 91       	ld	r30, X+
    35ec:	fc 91       	ld	r31, X
    35ee:	02 80       	ldd	r0, Z+2	; 0x02
    35f0:	f3 81       	ldd	r31, Z+3	; 0x03
    35f2:	e0 2d       	mov	r30, r0
    35f4:	c8 01       	movw	r24, r16
    35f6:	19 95       	eicall
    35f8:	56 c0       	rjmp	.+172    	; 0x36a6 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    35fa:	f8 01       	movw	r30, r16
    35fc:	42 81       	ldd	r20, Z+2	; 0x02
    35fe:	42 30       	cpi	r20, 0x02	; 2
    3600:	19 f5       	brne	.+70     	; 0x3648 <_ZN8emstreamlsEh+0x88>
    3602:	68 94       	set
    3604:	cc 24       	eor	r12, r12
    3606:	c3 f8       	bld	r12, 3
    3608:	d1 2c       	mov	r13, r1
    360a:	68 94       	set
    360c:	ff 24       	eor	r15, r15
    360e:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3610:	8e 2d       	mov	r24, r14
    3612:	8f 21       	and	r24, r15
    3614:	51 f0       	breq	.+20     	; 0x362a <_ZN8emstreamlsEh+0x6a>
    3616:	d8 01       	movw	r26, r16
    3618:	ed 91       	ld	r30, X+
    361a:	fc 91       	ld	r31, X
    361c:	02 80       	ldd	r0, Z+2	; 0x02
    361e:	f3 81       	ldd	r31, Z+3	; 0x03
    3620:	e0 2d       	mov	r30, r0
    3622:	61 e3       	ldi	r22, 0x31	; 49
    3624:	c8 01       	movw	r24, r16
    3626:	19 95       	eicall
    3628:	09 c0       	rjmp	.+18     	; 0x363c <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    362a:	d8 01       	movw	r26, r16
    362c:	ed 91       	ld	r30, X+
    362e:	fc 91       	ld	r31, X
    3630:	02 80       	ldd	r0, Z+2	; 0x02
    3632:	f3 81       	ldd	r31, Z+3	; 0x03
    3634:	e0 2d       	mov	r30, r0
    3636:	60 e3       	ldi	r22, 0x30	; 48
    3638:	c8 01       	movw	r24, r16
    363a:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    363c:	f6 94       	lsr	r15
    363e:	b1 e0       	ldi	r27, 0x01	; 1
    3640:	cb 1a       	sub	r12, r27
    3642:	d1 08       	sbc	r13, r1
    3644:	29 f7       	brne	.-54     	; 0x3610 <_ZN8emstreamlsEh+0x50>
    3646:	2f c0       	rjmp	.+94     	; 0x36a6 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3648:	40 31       	cpi	r20, 0x10	; 16
    364a:	f9 f4       	brne	.+62     	; 0x368a <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    364c:	62 95       	swap	r22
    364e:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3650:	01 90       	ld	r0, Z+
    3652:	f0 81       	ld	r31, Z
    3654:	e0 2d       	mov	r30, r0
    3656:	02 80       	ldd	r0, Z+2	; 0x02
    3658:	f3 81       	ldd	r31, Z+3	; 0x03
    365a:	e0 2d       	mov	r30, r0
    365c:	6a 30       	cpi	r22, 0x0A	; 10
    365e:	10 f0       	brcs	.+4      	; 0x3664 <_ZN8emstreamlsEh+0xa4>
    3660:	69 5c       	subi	r22, 0xC9	; 201
    3662:	01 c0       	rjmp	.+2      	; 0x3666 <_ZN8emstreamlsEh+0xa6>
    3664:	60 5d       	subi	r22, 0xD0	; 208
    3666:	c8 01       	movw	r24, r16
    3668:	19 95       	eicall
		temp_char = num & 0x0F;
    366a:	6e 2d       	mov	r22, r14
    366c:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    366e:	d8 01       	movw	r26, r16
    3670:	ed 91       	ld	r30, X+
    3672:	fc 91       	ld	r31, X
    3674:	02 80       	ldd	r0, Z+2	; 0x02
    3676:	f3 81       	ldd	r31, Z+3	; 0x03
    3678:	e0 2d       	mov	r30, r0
    367a:	6a 30       	cpi	r22, 0x0A	; 10
    367c:	10 f0       	brcs	.+4      	; 0x3682 <_ZN8emstreamlsEh+0xc2>
    367e:	69 5c       	subi	r22, 0xC9	; 201
    3680:	01 c0       	rjmp	.+2      	; 0x3684 <_ZN8emstreamlsEh+0xc4>
    3682:	60 5d       	subi	r22, 0xD0	; 208
    3684:	c8 01       	movw	r24, r16
    3686:	19 95       	eicall
    3688:	0e c0       	rjmp	.+28     	; 0x36a6 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    368a:	50 e0       	ldi	r21, 0x00	; 0
    368c:	be 01       	movw	r22, r28
    368e:	6f 5f       	subi	r22, 0xFF	; 255
    3690:	7f 4f       	sbci	r23, 0xFF	; 255
    3692:	8e 2d       	mov	r24, r14
    3694:	90 e0       	ldi	r25, 0x00	; 0
    3696:	0e 94 51 20 	call	0x40a2	; 0x40a2 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    369a:	be 01       	movw	r22, r28
    369c:	6f 5f       	subi	r22, 0xFF	; 255
    369e:	7f 4f       	sbci	r23, 0xFF	; 255
    36a0:	c8 01       	movw	r24, r16
    36a2:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    36a6:	c8 01       	movw	r24, r16
    36a8:	29 96       	adiw	r28, 0x09	; 9
    36aa:	cd bf       	out	0x3d, r28	; 61
    36ac:	de bf       	out	0x3e, r29	; 62
    36ae:	df 91       	pop	r29
    36b0:	cf 91       	pop	r28
    36b2:	1f 91       	pop	r17
    36b4:	0f 91       	pop	r16
    36b6:	ff 90       	pop	r15
    36b8:	ef 90       	pop	r14
    36ba:	df 90       	pop	r13
    36bc:	cf 90       	pop	r12
    36be:	08 95       	ret

000036c0 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    36c0:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    36c2:	50 96       	adiw	r26, 0x10	; 16
    36c4:	ed 91       	ld	r30, X+
    36c6:	fc 91       	ld	r31, X
    36c8:	51 97       	sbiw	r26, 0x11	; 17
    36ca:	80 81       	ld	r24, Z
    36cc:	54 96       	adiw	r26, 0x14	; 20
    36ce:	4c 91       	ld	r20, X
    36d0:	54 97       	sbiw	r26, 0x14	; 20
    36d2:	84 23       	and	r24, r20
    36d4:	29 f0       	breq	.+10     	; 0x36e0 <_ZN5rs2327putcharEc+0x20>
    36d6:	09 c0       	rjmp	.+18     	; 0x36ea <_ZN5rs2327putcharEc+0x2a>
    36d8:	21 50       	subi	r18, 0x01	; 1
    36da:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    36dc:	19 f4       	brne	.+6      	; 0x36e4 <_ZN5rs2327putcharEc+0x24>
    36de:	12 c0       	rjmp	.+36     	; 0x3704 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    36e0:	21 e2       	ldi	r18, 0x21	; 33
    36e2:	3e e4       	ldi	r19, 0x4E	; 78
    36e4:	90 81       	ld	r25, Z
    36e6:	94 23       	and	r25, r20
    36e8:	b9 f3       	breq	.-18     	; 0x36d8 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    36ea:	90 81       	ld	r25, Z
    36ec:	56 96       	adiw	r26, 0x16	; 22
    36ee:	8c 91       	ld	r24, X
    36f0:	56 97       	sbiw	r26, 0x16	; 22
    36f2:	89 2b       	or	r24, r25
    36f4:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    36f6:	1e 96       	adiw	r26, 0x0e	; 14
    36f8:	ed 91       	ld	r30, X+
    36fa:	fc 91       	ld	r31, X
    36fc:	1f 97       	sbiw	r26, 0x0f	; 15
    36fe:	60 83       	st	Z, r22
	return (true);
    3700:	81 e0       	ldi	r24, 0x01	; 1
    3702:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3704:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3706:	08 95       	ret

00003708 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3708:	cf 93       	push	r28
    370a:	df 93       	push	r29
    370c:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    370e:	c1 8d       	ldd	r28, Z+25	; 0x19
    3710:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3712:	28 81       	ld	r18, Y
    3714:	39 81       	ldd	r19, Y+1	; 0x01
    3716:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3718:	b4 8d       	ldd	r27, Z+28	; 0x1c
    371a:	4d 91       	ld	r20, X+
    371c:	5c 91       	ld	r21, X
    371e:	24 17       	cp	r18, r20
    3720:	35 07       	cpc	r19, r21
    3722:	e9 f3       	breq	.-6      	; 0x371e <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3724:	a7 89       	ldd	r26, Z+23	; 0x17
    3726:	b0 8d       	ldd	r27, Z+24	; 0x18
    3728:	0d 90       	ld	r0, X+
    372a:	bc 91       	ld	r27, X
    372c:	a0 2d       	mov	r26, r0
    372e:	a2 0f       	add	r26, r18
    3730:	b3 1f       	adc	r27, r19
    3732:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3734:	2f 5f       	subi	r18, 0xFF	; 255
    3736:	3f 4f       	sbci	r19, 0xFF	; 255
    3738:	28 83       	st	Y, r18
    373a:	39 83       	std	Y+1, r19	; 0x01
    373c:	24 36       	cpi	r18, 0x64	; 100
    373e:	31 05       	cpc	r19, r1
    3740:	28 f0       	brcs	.+10     	; 0x374c <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3742:	01 8c       	ldd	r0, Z+25	; 0x19
    3744:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3746:	e0 2d       	mov	r30, r0
    3748:	10 82       	st	Z, r1
    374a:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    374c:	90 e0       	ldi	r25, 0x00	; 0
    374e:	df 91       	pop	r29
    3750:	cf 91       	pop	r28
    3752:	08 95       	ret

00003754 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3754:	cf 93       	push	r28
    3756:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3758:	ec 01       	movw	r28, r24
    375a:	a9 8d       	ldd	r26, Y+25	; 0x19
    375c:	ba 8d       	ldd	r27, Y+26	; 0x1a
    375e:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3760:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3762:	81 e0       	ldi	r24, 0x01	; 1
    3764:	4d 91       	ld	r20, X+
    3766:	5c 91       	ld	r21, X
    3768:	20 81       	ld	r18, Z
    376a:	31 81       	ldd	r19, Z+1	; 0x01
    376c:	42 17       	cp	r20, r18
    376e:	53 07       	cpc	r21, r19
    3770:	09 f4       	brne	.+2      	; 0x3774 <_ZN5rs23214check_for_charEv+0x20>
    3772:	80 e0       	ldi	r24, 0x00	; 0
}
    3774:	df 91       	pop	r29
    3776:	cf 91       	pop	r28
    3778:	08 95       	ret

0000377a <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    377a:	dc 01       	movw	r26, r24
    377c:	ed 91       	ld	r30, X+
    377e:	fc 91       	ld	r31, X
    3780:	02 80       	ldd	r0, Z+2	; 0x02
    3782:	f3 81       	ldd	r31, Z+3	; 0x03
    3784:	e0 2d       	mov	r30, r0
    3786:	6c e0       	ldi	r22, 0x0C	; 12
    3788:	19 95       	eicall
    378a:	08 95       	ret

0000378c <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    378c:	ef 92       	push	r14
    378e:	ff 92       	push	r15
    3790:	0f 93       	push	r16
    3792:	1f 93       	push	r17
    3794:	cf 93       	push	r28
    3796:	df 93       	push	r29
    3798:	ec 01       	movw	r28, r24
    379a:	7b 01       	movw	r14, r22
    379c:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    379e:	0e 94 b5 19 	call	0x336a	; 0x336a <_ZN8emstreamC1Ev>
    37a2:	a8 01       	movw	r20, r16
    37a4:	b7 01       	movw	r22, r14
    37a6:	ce 01       	movw	r24, r28
    37a8:	08 96       	adiw	r24, 0x08	; 8
    37aa:	0e 94 16 19 	call	0x322c	; 0x322c <_ZN7base232C1EjP12USART_struct>
    37ae:	87 e6       	ldi	r24, 0x67	; 103
    37b0:	90 e2       	ldi	r25, 0x20	; 32
    37b2:	88 83       	st	Y, r24
    37b4:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    37b6:	00 3a       	cpi	r16, 0xA0	; 160
    37b8:	88 e0       	ldi	r24, 0x08	; 8
    37ba:	18 07       	cpc	r17, r24
    37bc:	69 f4       	brne	.+26     	; 0x37d8 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    37be:	84 e4       	ldi	r24, 0x44	; 68
    37c0:	91 e3       	ldi	r25, 0x31	; 49
    37c2:	8f 8b       	std	Y+23, r24	; 0x17
    37c4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    37c6:	8a e3       	ldi	r24, 0x3A	; 58
    37c8:	91 e3       	ldi	r25, 0x31	; 49
    37ca:	89 8f       	std	Y+25, r24	; 0x19
    37cc:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    37ce:	80 e3       	ldi	r24, 0x30	; 48
    37d0:	91 e3       	ldi	r25, 0x31	; 49
    37d2:	8b 8f       	std	Y+27, r24	; 0x1b
    37d4:	9c 8f       	std	Y+28, r25	; 0x1c
    37d6:	42 c0       	rjmp	.+132    	; 0x385c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    37d8:	00 3b       	cpi	r16, 0xB0	; 176
    37da:	e8 e0       	ldi	r30, 0x08	; 8
    37dc:	1e 07       	cpc	r17, r30
    37de:	69 f4       	brne	.+26     	; 0x37fa <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    37e0:	82 e4       	ldi	r24, 0x42	; 66
    37e2:	91 e3       	ldi	r25, 0x31	; 49
    37e4:	8f 8b       	std	Y+23, r24	; 0x17
    37e6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    37e8:	88 e3       	ldi	r24, 0x38	; 56
    37ea:	91 e3       	ldi	r25, 0x31	; 49
    37ec:	89 8f       	std	Y+25, r24	; 0x19
    37ee:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    37f0:	8e e2       	ldi	r24, 0x2E	; 46
    37f2:	91 e3       	ldi	r25, 0x31	; 49
    37f4:	8b 8f       	std	Y+27, r24	; 0x1b
    37f6:	9c 8f       	std	Y+28, r25	; 0x1c
    37f8:	31 c0       	rjmp	.+98     	; 0x385c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    37fa:	00 3a       	cpi	r16, 0xA0	; 160
    37fc:	f9 e0       	ldi	r31, 0x09	; 9
    37fe:	1f 07       	cpc	r17, r31
    3800:	69 f4       	brne	.+26     	; 0x381c <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3802:	80 e4       	ldi	r24, 0x40	; 64
    3804:	91 e3       	ldi	r25, 0x31	; 49
    3806:	8f 8b       	std	Y+23, r24	; 0x17
    3808:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    380a:	86 e3       	ldi	r24, 0x36	; 54
    380c:	91 e3       	ldi	r25, 0x31	; 49
    380e:	89 8f       	std	Y+25, r24	; 0x19
    3810:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3812:	8c e2       	ldi	r24, 0x2C	; 44
    3814:	91 e3       	ldi	r25, 0x31	; 49
    3816:	8b 8f       	std	Y+27, r24	; 0x1b
    3818:	9c 8f       	std	Y+28, r25	; 0x1c
    381a:	20 c0       	rjmp	.+64     	; 0x385c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    381c:	00 3b       	cpi	r16, 0xB0	; 176
    381e:	89 e0       	ldi	r24, 0x09	; 9
    3820:	18 07       	cpc	r17, r24
    3822:	69 f4       	brne	.+26     	; 0x383e <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3824:	8e e3       	ldi	r24, 0x3E	; 62
    3826:	91 e3       	ldi	r25, 0x31	; 49
    3828:	8f 8b       	std	Y+23, r24	; 0x17
    382a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    382c:	84 e3       	ldi	r24, 0x34	; 52
    382e:	91 e3       	ldi	r25, 0x31	; 49
    3830:	89 8f       	std	Y+25, r24	; 0x19
    3832:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3834:	8a e2       	ldi	r24, 0x2A	; 42
    3836:	91 e3       	ldi	r25, 0x31	; 49
    3838:	8b 8f       	std	Y+27, r24	; 0x1b
    383a:	9c 8f       	std	Y+28, r25	; 0x1c
    383c:	0f c0       	rjmp	.+30     	; 0x385c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    383e:	00 3a       	cpi	r16, 0xA0	; 160
    3840:	1a 40       	sbci	r17, 0x0A	; 10
    3842:	61 f4       	brne	.+24     	; 0x385c <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3844:	8c e3       	ldi	r24, 0x3C	; 60
    3846:	91 e3       	ldi	r25, 0x31	; 49
    3848:	8f 8b       	std	Y+23, r24	; 0x17
    384a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    384c:	82 e3       	ldi	r24, 0x32	; 50
    384e:	91 e3       	ldi	r25, 0x31	; 49
    3850:	89 8f       	std	Y+25, r24	; 0x19
    3852:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3854:	88 e2       	ldi	r24, 0x28	; 40
    3856:	91 e3       	ldi	r25, 0x31	; 49
    3858:	8b 8f       	std	Y+27, r24	; 0x1b
    385a:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    385c:	0f 89       	ldd	r16, Y+23	; 0x17
    385e:	18 8d       	ldd	r17, Y+24	; 0x18
    3860:	84 e6       	ldi	r24, 0x64	; 100
    3862:	90 e0       	ldi	r25, 0x00	; 0
    3864:	0e 94 12 19 	call	0x3224	; 0x3224 <_Znaj>
    3868:	f8 01       	movw	r30, r16
    386a:	80 83       	st	Z, r24
    386c:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    386e:	e9 8d       	ldd	r30, Y+25	; 0x19
    3870:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3872:	10 82       	st	Z, r1
    3874:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3876:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3878:	fc 8d       	ldd	r31, Y+28	; 0x1c
    387a:	10 82       	st	Z, r1
    387c:	11 82       	std	Z+1, r1	; 0x01
}
    387e:	df 91       	pop	r29
    3880:	cf 91       	pop	r28
    3882:	1f 91       	pop	r17
    3884:	0f 91       	pop	r16
    3886:	ff 90       	pop	r15
    3888:	ef 90       	pop	r14
    388a:	08 95       	ret

0000388c <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    388c:	1f 92       	push	r1
    388e:	0f 92       	push	r0
    3890:	0f b6       	in	r0, 0x3f	; 63
    3892:	0f 92       	push	r0
    3894:	11 24       	eor	r1, r1
    3896:	08 b6       	in	r0, 0x38	; 56
    3898:	0f 92       	push	r0
    389a:	18 be       	out	0x38, r1	; 56
    389c:	0b b6       	in	r0, 0x3b	; 59
    389e:	0f 92       	push	r0
    38a0:	1b be       	out	0x3b, r1	; 59
    38a2:	2f 93       	push	r18
    38a4:	3f 93       	push	r19
    38a6:	8f 93       	push	r24
    38a8:	9f 93       	push	r25
    38aa:	ef 93       	push	r30
    38ac:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    38ae:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    38b2:	e0 91 44 31 	lds	r30, 0x3144	; 0x803144 <rcvC0_buffer>
    38b6:	f0 91 45 31 	lds	r31, 0x3145	; 0x803145 <rcvC0_buffer+0x1>
    38ba:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    38be:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    38c2:	e8 0f       	add	r30, r24
    38c4:	f9 1f       	adc	r31, r25
    38c6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    38c8:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    38cc:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    38d0:	01 96       	adiw	r24, 0x01	; 1
    38d2:	84 36       	cpi	r24, 0x64	; 100
    38d4:	91 05       	cpc	r25, r1
    38d6:	60 f4       	brcc	.+24     	; 0x38f0 <__vector_25+0x64>
    38d8:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <rcvC0_write_index>
    38dc:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    38e0:	20 91 3a 31 	lds	r18, 0x313A	; 0x80313a <rcvC0_read_index>
    38e4:	30 91 3b 31 	lds	r19, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    38e8:	82 17       	cp	r24, r18
    38ea:	93 07       	cpc	r25, r19
    38ec:	f1 f4       	brne	.+60     	; 0x392a <__vector_25+0x9e>
    38ee:	0c c0       	rjmp	.+24     	; 0x3908 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    38f0:	10 92 30 31 	sts	0x3130, r1	; 0x803130 <rcvC0_write_index>
    38f4:	10 92 31 31 	sts	0x3131, r1	; 0x803131 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    38f8:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC0_read_index>
    38fc:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC0_read_index+0x1>
    3900:	18 16       	cp	r1, r24
    3902:	19 06       	cpc	r1, r25
    3904:	91 f4       	brne	.+36     	; 0x392a <__vector_25+0x9e>
    3906:	0e c0       	rjmp	.+28     	; 0x3924 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3908:	01 96       	adiw	r24, 0x01	; 1
    390a:	84 36       	cpi	r24, 0x64	; 100
    390c:	91 05       	cpc	r25, r1
    390e:	28 f4       	brcc	.+10     	; 0x391a <__vector_25+0x8e>
    3910:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvC0_read_index>
    3914:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvC0_read_index+0x1>
    3918:	08 c0       	rjmp	.+16     	; 0x392a <__vector_25+0x9e>
			rcvC0_read_index = 0;
    391a:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvC0_read_index>
    391e:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvC0_read_index+0x1>
}
    3922:	03 c0       	rjmp	.+6      	; 0x392a <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3924:	81 e0       	ldi	r24, 0x01	; 1
    3926:	90 e0       	ldi	r25, 0x00	; 0
    3928:	f3 cf       	rjmp	.-26     	; 0x3910 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    392a:	ff 91       	pop	r31
    392c:	ef 91       	pop	r30
    392e:	9f 91       	pop	r25
    3930:	8f 91       	pop	r24
    3932:	3f 91       	pop	r19
    3934:	2f 91       	pop	r18
    3936:	0f 90       	pop	r0
    3938:	0b be       	out	0x3b, r0	; 59
    393a:	0f 90       	pop	r0
    393c:	08 be       	out	0x38, r0	; 56
    393e:	0f 90       	pop	r0
    3940:	0f be       	out	0x3f, r0	; 63
    3942:	0f 90       	pop	r0
    3944:	1f 90       	pop	r1
    3946:	18 95       	reti

00003948 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3948:	1f 92       	push	r1
    394a:	0f 92       	push	r0
    394c:	0f b6       	in	r0, 0x3f	; 63
    394e:	0f 92       	push	r0
    3950:	11 24       	eor	r1, r1
    3952:	08 b6       	in	r0, 0x38	; 56
    3954:	0f 92       	push	r0
    3956:	18 be       	out	0x38, r1	; 56
    3958:	0b b6       	in	r0, 0x3b	; 59
    395a:	0f 92       	push	r0
    395c:	1b be       	out	0x3b, r1	; 59
    395e:	2f 93       	push	r18
    3960:	3f 93       	push	r19
    3962:	8f 93       	push	r24
    3964:	9f 93       	push	r25
    3966:	ef 93       	push	r30
    3968:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    396a:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    396e:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <rcvC1_buffer>
    3972:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <rcvC1_buffer+0x1>
    3976:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    397a:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    397e:	e8 0f       	add	r30, r24
    3980:	f9 1f       	adc	r31, r25
    3982:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3984:	80 91 2e 31 	lds	r24, 0x312E	; 0x80312e <rcvC1_write_index>
    3988:	90 91 2f 31 	lds	r25, 0x312F	; 0x80312f <rcvC1_write_index+0x1>
    398c:	01 96       	adiw	r24, 0x01	; 1
    398e:	84 36       	cpi	r24, 0x64	; 100
    3990:	91 05       	cpc	r25, r1
    3992:	60 f4       	brcc	.+24     	; 0x39ac <__vector_28+0x64>
    3994:	80 93 2e 31 	sts	0x312E, r24	; 0x80312e <rcvC1_write_index>
    3998:	90 93 2f 31 	sts	0x312F, r25	; 0x80312f <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    399c:	20 91 38 31 	lds	r18, 0x3138	; 0x803138 <rcvC1_read_index>
    39a0:	30 91 39 31 	lds	r19, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    39a4:	82 17       	cp	r24, r18
    39a6:	93 07       	cpc	r25, r19
    39a8:	f1 f4       	brne	.+60     	; 0x39e6 <__vector_28+0x9e>
    39aa:	0c c0       	rjmp	.+24     	; 0x39c4 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    39ac:	10 92 2e 31 	sts	0x312E, r1	; 0x80312e <rcvC1_write_index>
    39b0:	10 92 2f 31 	sts	0x312F, r1	; 0x80312f <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    39b4:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvC1_read_index>
    39b8:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvC1_read_index+0x1>
    39bc:	18 16       	cp	r1, r24
    39be:	19 06       	cpc	r1, r25
    39c0:	91 f4       	brne	.+36     	; 0x39e6 <__vector_28+0x9e>
    39c2:	0e c0       	rjmp	.+28     	; 0x39e0 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    39c4:	01 96       	adiw	r24, 0x01	; 1
    39c6:	84 36       	cpi	r24, 0x64	; 100
    39c8:	91 05       	cpc	r25, r1
    39ca:	28 f4       	brcc	.+10     	; 0x39d6 <__vector_28+0x8e>
    39cc:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvC1_read_index>
    39d0:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvC1_read_index+0x1>
    39d4:	08 c0       	rjmp	.+16     	; 0x39e6 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    39d6:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvC1_read_index>
    39da:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvC1_read_index+0x1>
}
    39de:	03 c0       	rjmp	.+6      	; 0x39e6 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    39e0:	81 e0       	ldi	r24, 0x01	; 1
    39e2:	90 e0       	ldi	r25, 0x00	; 0
    39e4:	f3 cf       	rjmp	.-26     	; 0x39cc <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    39e6:	ff 91       	pop	r31
    39e8:	ef 91       	pop	r30
    39ea:	9f 91       	pop	r25
    39ec:	8f 91       	pop	r24
    39ee:	3f 91       	pop	r19
    39f0:	2f 91       	pop	r18
    39f2:	0f 90       	pop	r0
    39f4:	0b be       	out	0x3b, r0	; 59
    39f6:	0f 90       	pop	r0
    39f8:	08 be       	out	0x38, r0	; 56
    39fa:	0f 90       	pop	r0
    39fc:	0f be       	out	0x3f, r0	; 63
    39fe:	0f 90       	pop	r0
    3a00:	1f 90       	pop	r1
    3a02:	18 95       	reti

00003a04 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3a04:	1f 92       	push	r1
    3a06:	0f 92       	push	r0
    3a08:	0f b6       	in	r0, 0x3f	; 63
    3a0a:	0f 92       	push	r0
    3a0c:	11 24       	eor	r1, r1
    3a0e:	08 b6       	in	r0, 0x38	; 56
    3a10:	0f 92       	push	r0
    3a12:	18 be       	out	0x38, r1	; 56
    3a14:	0b b6       	in	r0, 0x3b	; 59
    3a16:	0f 92       	push	r0
    3a18:	1b be       	out	0x3b, r1	; 59
    3a1a:	2f 93       	push	r18
    3a1c:	3f 93       	push	r19
    3a1e:	8f 93       	push	r24
    3a20:	9f 93       	push	r25
    3a22:	ef 93       	push	r30
    3a24:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3a26:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3a2a:	e0 91 40 31 	lds	r30, 0x3140	; 0x803140 <rcvD0_buffer>
    3a2e:	f0 91 41 31 	lds	r31, 0x3141	; 0x803141 <rcvD0_buffer+0x1>
    3a32:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <rcvC0_write_index>
    3a36:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <rcvC0_write_index+0x1>
    3a3a:	e8 0f       	add	r30, r24
    3a3c:	f9 1f       	adc	r31, r25
    3a3e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3a40:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <rcvD0_write_index>
    3a44:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <rcvD0_write_index+0x1>
    3a48:	01 96       	adiw	r24, 0x01	; 1
    3a4a:	84 36       	cpi	r24, 0x64	; 100
    3a4c:	91 05       	cpc	r25, r1
    3a4e:	60 f4       	brcc	.+24     	; 0x3a68 <__vector_88+0x64>
    3a50:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <rcvD0_write_index>
    3a54:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3a58:	20 91 36 31 	lds	r18, 0x3136	; 0x803136 <rcvD0_read_index>
    3a5c:	30 91 37 31 	lds	r19, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    3a60:	82 17       	cp	r24, r18
    3a62:	93 07       	cpc	r25, r19
    3a64:	f1 f4       	brne	.+60     	; 0x3aa2 <__vector_88+0x9e>
    3a66:	0c c0       	rjmp	.+24     	; 0x3a80 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3a68:	10 92 2c 31 	sts	0x312C, r1	; 0x80312c <rcvD0_write_index>
    3a6c:	10 92 2d 31 	sts	0x312D, r1	; 0x80312d <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3a70:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD0_read_index>
    3a74:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD0_read_index+0x1>
    3a78:	18 16       	cp	r1, r24
    3a7a:	19 06       	cpc	r1, r25
    3a7c:	91 f4       	brne	.+36     	; 0x3aa2 <__vector_88+0x9e>
    3a7e:	0e c0       	rjmp	.+28     	; 0x3a9c <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3a80:	01 96       	adiw	r24, 0x01	; 1
    3a82:	84 36       	cpi	r24, 0x64	; 100
    3a84:	91 05       	cpc	r25, r1
    3a86:	28 f4       	brcc	.+10     	; 0x3a92 <__vector_88+0x8e>
    3a88:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvD0_read_index>
    3a8c:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvD0_read_index+0x1>
    3a90:	08 c0       	rjmp	.+16     	; 0x3aa2 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3a92:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvD0_read_index>
    3a96:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvD0_read_index+0x1>
}
    3a9a:	03 c0       	rjmp	.+6      	; 0x3aa2 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3a9c:	81 e0       	ldi	r24, 0x01	; 1
    3a9e:	90 e0       	ldi	r25, 0x00	; 0
    3aa0:	f3 cf       	rjmp	.-26     	; 0x3a88 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3aa2:	ff 91       	pop	r31
    3aa4:	ef 91       	pop	r30
    3aa6:	9f 91       	pop	r25
    3aa8:	8f 91       	pop	r24
    3aaa:	3f 91       	pop	r19
    3aac:	2f 91       	pop	r18
    3aae:	0f 90       	pop	r0
    3ab0:	0b be       	out	0x3b, r0	; 59
    3ab2:	0f 90       	pop	r0
    3ab4:	08 be       	out	0x38, r0	; 56
    3ab6:	0f 90       	pop	r0
    3ab8:	0f be       	out	0x3f, r0	; 63
    3aba:	0f 90       	pop	r0
    3abc:	1f 90       	pop	r1
    3abe:	18 95       	reti

00003ac0 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3ac0:	1f 92       	push	r1
    3ac2:	0f 92       	push	r0
    3ac4:	0f b6       	in	r0, 0x3f	; 63
    3ac6:	0f 92       	push	r0
    3ac8:	11 24       	eor	r1, r1
    3aca:	08 b6       	in	r0, 0x38	; 56
    3acc:	0f 92       	push	r0
    3ace:	18 be       	out	0x38, r1	; 56
    3ad0:	0b b6       	in	r0, 0x3b	; 59
    3ad2:	0f 92       	push	r0
    3ad4:	1b be       	out	0x3b, r1	; 59
    3ad6:	2f 93       	push	r18
    3ad8:	3f 93       	push	r19
    3ada:	8f 93       	push	r24
    3adc:	9f 93       	push	r25
    3ade:	ef 93       	push	r30
    3ae0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3ae2:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3ae6:	e0 91 3e 31 	lds	r30, 0x313E	; 0x80313e <rcvD1_buffer>
    3aea:	f0 91 3f 31 	lds	r31, 0x313F	; 0x80313f <rcvD1_buffer+0x1>
    3aee:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    3af2:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    3af6:	e8 0f       	add	r30, r24
    3af8:	f9 1f       	adc	r31, r25
    3afa:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3afc:	80 91 2a 31 	lds	r24, 0x312A	; 0x80312a <rcvD1_write_index>
    3b00:	90 91 2b 31 	lds	r25, 0x312B	; 0x80312b <rcvD1_write_index+0x1>
    3b04:	01 96       	adiw	r24, 0x01	; 1
    3b06:	84 36       	cpi	r24, 0x64	; 100
    3b08:	91 05       	cpc	r25, r1
    3b0a:	60 f4       	brcc	.+24     	; 0x3b24 <__vector_91+0x64>
    3b0c:	80 93 2a 31 	sts	0x312A, r24	; 0x80312a <rcvD1_write_index>
    3b10:	90 93 2b 31 	sts	0x312B, r25	; 0x80312b <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b14:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <rcvD1_read_index>
    3b18:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    3b1c:	82 17       	cp	r24, r18
    3b1e:	93 07       	cpc	r25, r19
    3b20:	f1 f4       	brne	.+60     	; 0x3b5e <__vector_91+0x9e>
    3b22:	0c c0       	rjmp	.+24     	; 0x3b3c <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3b24:	10 92 2a 31 	sts	0x312A, r1	; 0x80312a <rcvD1_write_index>
    3b28:	10 92 2b 31 	sts	0x312B, r1	; 0x80312b <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3b2c:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvD1_read_index>
    3b30:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvD1_read_index+0x1>
    3b34:	18 16       	cp	r1, r24
    3b36:	19 06       	cpc	r1, r25
    3b38:	91 f4       	brne	.+36     	; 0x3b5e <__vector_91+0x9e>
    3b3a:	0e c0       	rjmp	.+28     	; 0x3b58 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b3c:	01 96       	adiw	r24, 0x01	; 1
    3b3e:	84 36       	cpi	r24, 0x64	; 100
    3b40:	91 05       	cpc	r25, r1
    3b42:	28 f4       	brcc	.+10     	; 0x3b4e <__vector_91+0x8e>
    3b44:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvD1_read_index>
    3b48:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvD1_read_index+0x1>
    3b4c:	08 c0       	rjmp	.+16     	; 0x3b5e <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3b4e:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvD1_read_index>
    3b52:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvD1_read_index+0x1>
}
    3b56:	03 c0       	rjmp	.+6      	; 0x3b5e <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3b58:	81 e0       	ldi	r24, 0x01	; 1
    3b5a:	90 e0       	ldi	r25, 0x00	; 0
    3b5c:	f3 cf       	rjmp	.-26     	; 0x3b44 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3b5e:	ff 91       	pop	r31
    3b60:	ef 91       	pop	r30
    3b62:	9f 91       	pop	r25
    3b64:	8f 91       	pop	r24
    3b66:	3f 91       	pop	r19
    3b68:	2f 91       	pop	r18
    3b6a:	0f 90       	pop	r0
    3b6c:	0b be       	out	0x3b, r0	; 59
    3b6e:	0f 90       	pop	r0
    3b70:	08 be       	out	0x38, r0	; 56
    3b72:	0f 90       	pop	r0
    3b74:	0f be       	out	0x3f, r0	; 63
    3b76:	0f 90       	pop	r0
    3b78:	1f 90       	pop	r1
    3b7a:	18 95       	reti

00003b7c <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3b7c:	1f 92       	push	r1
    3b7e:	0f 92       	push	r0
    3b80:	0f b6       	in	r0, 0x3f	; 63
    3b82:	0f 92       	push	r0
    3b84:	11 24       	eor	r1, r1
    3b86:	08 b6       	in	r0, 0x38	; 56
    3b88:	0f 92       	push	r0
    3b8a:	18 be       	out	0x38, r1	; 56
    3b8c:	0b b6       	in	r0, 0x3b	; 59
    3b8e:	0f 92       	push	r0
    3b90:	1b be       	out	0x3b, r1	; 59
    3b92:	2f 93       	push	r18
    3b94:	3f 93       	push	r19
    3b96:	8f 93       	push	r24
    3b98:	9f 93       	push	r25
    3b9a:	ef 93       	push	r30
    3b9c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3b9e:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3ba2:	e0 91 3c 31 	lds	r30, 0x313C	; 0x80313c <rcvE0_buffer>
    3ba6:	f0 91 3d 31 	lds	r31, 0x313D	; 0x80313d <rcvE0_buffer+0x1>
    3baa:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    3bae:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    3bb2:	e8 0f       	add	r30, r24
    3bb4:	f9 1f       	adc	r31, r25
    3bb6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3bb8:	80 91 28 31 	lds	r24, 0x3128	; 0x803128 <rcvE0_write_index>
    3bbc:	90 91 29 31 	lds	r25, 0x3129	; 0x803129 <rcvE0_write_index+0x1>
    3bc0:	01 96       	adiw	r24, 0x01	; 1
    3bc2:	84 36       	cpi	r24, 0x64	; 100
    3bc4:	91 05       	cpc	r25, r1
    3bc6:	60 f4       	brcc	.+24     	; 0x3be0 <__vector_58+0x64>
    3bc8:	80 93 28 31 	sts	0x3128, r24	; 0x803128 <rcvE0_write_index>
    3bcc:	90 93 29 31 	sts	0x3129, r25	; 0x803129 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3bd0:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <rcvE0_read_index>
    3bd4:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    3bd8:	82 17       	cp	r24, r18
    3bda:	93 07       	cpc	r25, r19
    3bdc:	f1 f4       	brne	.+60     	; 0x3c1a <__vector_58+0x9e>
    3bde:	0c c0       	rjmp	.+24     	; 0x3bf8 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3be0:	10 92 28 31 	sts	0x3128, r1	; 0x803128 <rcvE0_write_index>
    3be4:	10 92 29 31 	sts	0x3129, r1	; 0x803129 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3be8:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <rcvE0_read_index>
    3bec:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <rcvE0_read_index+0x1>
    3bf0:	18 16       	cp	r1, r24
    3bf2:	19 06       	cpc	r1, r25
    3bf4:	91 f4       	brne	.+36     	; 0x3c1a <__vector_58+0x9e>
    3bf6:	0e c0       	rjmp	.+28     	; 0x3c14 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3bf8:	01 96       	adiw	r24, 0x01	; 1
    3bfa:	84 36       	cpi	r24, 0x64	; 100
    3bfc:	91 05       	cpc	r25, r1
    3bfe:	28 f4       	brcc	.+10     	; 0x3c0a <__vector_58+0x8e>
    3c00:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <rcvE0_read_index>
    3c04:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <rcvE0_read_index+0x1>
    3c08:	08 c0       	rjmp	.+16     	; 0x3c1a <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3c0a:	10 92 32 31 	sts	0x3132, r1	; 0x803132 <rcvE0_read_index>
    3c0e:	10 92 33 31 	sts	0x3133, r1	; 0x803133 <rcvE0_read_index+0x1>
}
    3c12:	03 c0       	rjmp	.+6      	; 0x3c1a <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3c14:	81 e0       	ldi	r24, 0x01	; 1
    3c16:	90 e0       	ldi	r25, 0x00	; 0
    3c18:	f3 cf       	rjmp	.-26     	; 0x3c00 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3c1a:	ff 91       	pop	r31
    3c1c:	ef 91       	pop	r30
    3c1e:	9f 91       	pop	r25
    3c20:	8f 91       	pop	r24
    3c22:	3f 91       	pop	r19
    3c24:	2f 91       	pop	r18
    3c26:	0f 90       	pop	r0
    3c28:	0b be       	out	0x3b, r0	; 59
    3c2a:	0f 90       	pop	r0
    3c2c:	08 be       	out	0x38, r0	; 56
    3c2e:	0f 90       	pop	r0
    3c30:	0f be       	out	0x3f, r0	; 63
    3c32:	0f 90       	pop	r0
    3c34:	1f 90       	pop	r1
    3c36:	18 95       	reti

00003c38 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3c38:	0f 93       	push	r16
    3c3a:	cf 93       	push	r28
    3c3c:	df 93       	push	r29
    3c3e:	1f 92       	push	r1
    3c40:	cd b7       	in	r28, 0x3d	; 61
    3c42:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3c44:	2f b7       	in	r18, 0x3f	; 63
    3c46:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3c48:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3c4a:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3c4c:	fc 01       	movw	r30, r24
    3c4e:	08 ed       	ldi	r16, 0xD8	; 216
    3c50:	04 bf       	out	0x34, r16	; 52
    3c52:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3c54:	89 81       	ldd	r24, Y+1	; 0x01
    3c56:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3c58:	0f 90       	pop	r0
    3c5a:	df 91       	pop	r29
    3c5c:	cf 91       	pop	r28
    3c5e:	0f 91       	pop	r16
    3c60:	08 95       	ret

00003c62 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3c62:	0f 93       	push	r16
    3c64:	1f 93       	push	r17
    3c66:	cf 93       	push	r28
    3c68:	df 93       	push	r29
    3c6a:	cd b7       	in	r28, 0x3d	; 61
    3c6c:	de b7       	in	r29, 0x3e	; 62
    3c6e:	6d 97       	sbiw	r28, 0x1d	; 29
    3c70:	cd bf       	out	0x3d, r28	; 61
    3c72:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN6_bm;									// set pin D4 as output LED1: turns on when power is on.
    3c74:	e0 e6       	ldi	r30, 0x60	; 96
    3c76:	f6 e0       	ldi	r31, 0x06	; 6
    3c78:	80 e4       	ldi	r24, 0x40	; 64
    3c7a:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN6_bm;									// set pin high, LED 1
    3c7c:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;									// set pin D6 as output LED3
	//PORTD.OUTSET = PIN4_bm;									// set pin high, LED 2
	//PORTD.OUTSET = PIN5_bm;									// set pin high, LED 3
	
	//Clear any interrupts
	cli();
    3c7e:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);				// 32 MHz
    3c80:	e0 e5       	ldi	r30, 0x50	; 80
    3c82:	f0 e0       	ldi	r31, 0x00	; 0
    3c84:	80 81       	ld	r24, Z
    3c86:	82 60       	ori	r24, 0x02	; 2
    3c88:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3c8a:	81 81       	ldd	r24, Z+1	; 0x01
    3c8c:	81 ff       	sbrs	r24, 1
    3c8e:	fd cf       	rjmp	.-6      	; 0x3c8a <main+0x28>

		//Enable PLL

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3c90:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3c94:	68 7f       	andi	r22, 0xF8	; 248
    3c96:	61 60       	ori	r22, 0x01	; 1
    3c98:	80 e4       	ldi	r24, 0x40	; 64
    3c9a:	90 e0       	ldi	r25, 0x00	; 0
    3c9c:	0e 94 1c 1e 	call	0x3c38	; 0x3c38 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3ca0:	e0 e5       	ldi	r30, 0x50	; 80
    3ca2:	f0 e0       	ldi	r31, 0x00	; 0
    3ca4:	80 81       	ld	r24, Z
    3ca6:	8e 7f       	andi	r24, 0xFE	; 254
    3ca8:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3caa:	9d ef       	ldi	r25, 0xFD	; 253
    3cac:	88 ed       	ldi	r24, 0xD8	; 216
    3cae:	08 b6       	in	r0, 0x38	; 56
    3cb0:	18 be       	out	0x38, r1	; 56
    3cb2:	84 bf       	out	0x34, r24	; 52
    3cb4:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3cb8:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC1); // Create a serial device on USART C0 with always baud = 115200
    3cba:	40 eb       	ldi	r20, 0xB0	; 176
    3cbc:	58 e0       	ldi	r21, 0x08	; 8
    3cbe:	60 e0       	ldi	r22, 0x00	; 0
    3cc0:	70 e0       	ldi	r23, 0x00	; 0
    3cc2:	ce 01       	movw	r24, r28
    3cc4:	01 96       	adiw	r24, 0x01	; 1
    3cc6:	0e 94 c6 1b 	call	0x378c	; 0x378c <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    3cca:	67 e0       	ldi	r22, 0x07	; 7
    3ccc:	ce 01       	movw	r24, r28
    3cce:	01 96       	adiw	r24, 0x01	; 1
    3cd0:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    3cd4:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3cd6:	63 e7       	ldi	r22, 0x73	; 115
    3cd8:	70 e2       	ldi	r23, 0x20	; 32
    3cda:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN8emstream4putsEPKc>
    3cde:	66 e0       	ldi	r22, 0x06	; 6
    3ce0:	c8 01       	movw	r24, r16
    3ce2:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
    3ce6:	66 e0       	ldi	r22, 0x06	; 6
    3ce8:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3cec:	82 e1       	ldi	r24, 0x12	; 18
    3cee:	90 e0       	ldi	r25, 0x00	; 0
    3cf0:	0e 94 0f 19 	call	0x321e	; 0x321e <_Znwj>
    3cf4:	8e 01       	movw	r16, r28
    3cf6:	0f 5f       	subi	r16, 0xFF	; 255
    3cf8:	1f 4f       	sbci	r17, 0xFF	; 255
    3cfa:	24 e0       	ldi	r18, 0x04	; 4
    3cfc:	31 e0       	ldi	r19, 0x01	; 1
    3cfe:	40 e0       	ldi	r20, 0x00	; 0
    3d00:	62 e9       	ldi	r22, 0x92	; 146
    3d02:	70 e2       	ldi	r23, 0x20	; 32
    3d04:	0e 94 d0 06 	call	0xda0	; 0xda0 <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(2), 260, &ser_dev);
    3d08:	82 e1       	ldi	r24, 0x12	; 18
    3d0a:	90 e0       	ldi	r25, 0x00	; 0
    3d0c:	0e 94 0f 19 	call	0x321e	; 0x321e <_Znwj>
    3d10:	24 e0       	ldi	r18, 0x04	; 4
    3d12:	31 e0       	ldi	r19, 0x01	; 1
    3d14:	42 e0       	ldi	r20, 0x02	; 2
    3d16:	6a e9       	ldi	r22, 0x9A	; 154
    3d18:	70 e2       	ldi	r23, 0x20	; 32
    3d1a:	0e 94 54 03 	call	0x6a8	; 0x6a8 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(3), 260, &ser_dev);
    3d1e:	82 e1       	ldi	r24, 0x12	; 18
    3d20:	90 e0       	ldi	r25, 0x00	; 0
    3d22:	0e 94 0f 19 	call	0x321e	; 0x321e <_Znwj>
    3d26:	24 e0       	ldi	r18, 0x04	; 4
    3d28:	31 e0       	ldi	r19, 0x01	; 1
    3d2a:	43 e0       	ldi	r20, 0x03	; 3
    3d2c:	61 ea       	ldi	r22, 0xA1	; 161
    3d2e:	70 e2       	ldi	r23, 0x20	; 32
    3d30:	0e 94 ad 03 	call	0x75a	; 0x75a <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(4), 260, &ser_dev);
    3d34:	82 e1       	ldi	r24, 0x12	; 18
    3d36:	90 e0       	ldi	r25, 0x00	; 0
    3d38:	0e 94 0f 19 	call	0x321e	; 0x321e <_Znwj>
    3d3c:	24 e0       	ldi	r18, 0x04	; 4
    3d3e:	31 e0       	ldi	r19, 0x01	; 1
    3d40:	44 e0       	ldi	r20, 0x04	; 4
    3d42:	68 ea       	ldi	r22, 0xA8	; 168
    3d44:	70 e2       	ldi	r23, 0x20	; 32
    3d46:	0e 94 12 04 	call	0x824	; 0x824 <_ZN13LimitSwitchesC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(3), 260, &ser_dev);
    3d4a:	8c e6       	ldi	r24, 0x6C	; 108
    3d4c:	90 e0       	ldi	r25, 0x00	; 0
    3d4e:	0e 94 0f 19 	call	0x321e	; 0x321e <_Znwj>
    3d52:	24 e0       	ldi	r18, 0x04	; 4
    3d54:	31 e0       	ldi	r19, 0x01	; 1
    3d56:	43 e0       	ldi	r20, 0x03	; 3
    3d58:	61 eb       	ldi	r22, 0xB1	; 177
    3d5a:	70 e2       	ldi	r23, 0x20	; 32
    3d5c:	0e 94 1c 06 	call	0xc38	; 0xc38 <_ZN5MotorC1EPKchjP8emstream>
	
	new PWMdriver ("PWM", task_priority(5), 260, &ser_dev);
    3d60:	82 e1       	ldi	r24, 0x12	; 18
    3d62:	90 e0       	ldi	r25, 0x00	; 0
    3d64:	0e 94 0f 19 	call	0x321e	; 0x321e <_Znwj>
    3d68:	24 e0       	ldi	r18, 0x04	; 4
    3d6a:	31 e0       	ldi	r19, 0x01	; 1
    3d6c:	44 e0       	ldi	r20, 0x04	; 4
    3d6e:	67 eb       	ldi	r22, 0xB7	; 183
    3d70:	70 e2       	ldi	r23, 0x20	; 32
    3d72:	0e 94 92 06 	call	0xd24	; 0xd24 <_ZN9PWMdriverC1EPKchjP8emstream>
	
	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3d76:	87 e0       	ldi	r24, 0x07	; 7
    3d78:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3d7c:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3d7e:	0e 94 21 10 	call	0x2042	; 0x2042 <vTaskStartScheduler>
	
	
	return 0;
    3d82:	80 e0       	ldi	r24, 0x00	; 0
    3d84:	90 e0       	ldi	r25, 0x00	; 0
    3d86:	6d 96       	adiw	r28, 0x1d	; 29
    3d88:	cd bf       	out	0x3d, r28	; 61
    3d8a:	de bf       	out	0x3e, r29	; 62
    3d8c:	df 91       	pop	r29
    3d8e:	cf 91       	pop	r28
    3d90:	1f 91       	pop	r17
    3d92:	0f 91       	pop	r16
    3d94:	08 95       	ret

00003d96 <_GLOBAL__sub_I_counter>:
    3d96:	0f 93       	push	r16
    3d98:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3d9a:	0a e0       	ldi	r16, 0x0A	; 10
    3d9c:	10 e0       	ldi	r17, 0x00	; 0
    3d9e:	20 e0       	ldi	r18, 0x00	; 0
    3da0:	30 e0       	ldi	r19, 0x00	; 0
    3da2:	40 e0       	ldi	r20, 0x00	; 0
    3da4:	50 e0       	ldi	r21, 0x00	; 0
    3da6:	60 e2       	ldi	r22, 0x20	; 32
    3da8:	70 e0       	ldi	r23, 0x00	; 0
    3daa:	80 e5       	ldi	r24, 0x50	; 80
    3dac:	91 e3       	ldi	r25, 0x31	; 49
    3dae:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <_ZN14frt_text_queueC1EjP8emstreamm>
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	
	return 0;
    3db2:	1f 91       	pop	r17
    3db4:	0f 91       	pop	r16
    3db6:	08 95       	ret

00003db8 <__cmpsf2>:
    3db8:	0e 94 1e 1f 	call	0x3e3c	; 0x3e3c <__fp_cmp>
    3dbc:	08 f4       	brcc	.+2      	; 0x3dc0 <__cmpsf2+0x8>
    3dbe:	81 e0       	ldi	r24, 0x01	; 1
    3dc0:	08 95       	ret

00003dc2 <__floatunsisf>:
    3dc2:	e8 94       	clt
    3dc4:	09 c0       	rjmp	.+18     	; 0x3dd8 <__floatsisf+0x12>

00003dc6 <__floatsisf>:
    3dc6:	97 fb       	bst	r25, 7
    3dc8:	3e f4       	brtc	.+14     	; 0x3dd8 <__floatsisf+0x12>
    3dca:	90 95       	com	r25
    3dcc:	80 95       	com	r24
    3dce:	70 95       	com	r23
    3dd0:	61 95       	neg	r22
    3dd2:	7f 4f       	sbci	r23, 0xFF	; 255
    3dd4:	8f 4f       	sbci	r24, 0xFF	; 255
    3dd6:	9f 4f       	sbci	r25, 0xFF	; 255
    3dd8:	99 23       	and	r25, r25
    3dda:	a9 f0       	breq	.+42     	; 0x3e06 <__floatsisf+0x40>
    3ddc:	f9 2f       	mov	r31, r25
    3dde:	96 e9       	ldi	r25, 0x96	; 150
    3de0:	bb 27       	eor	r27, r27
    3de2:	93 95       	inc	r25
    3de4:	f6 95       	lsr	r31
    3de6:	87 95       	ror	r24
    3de8:	77 95       	ror	r23
    3dea:	67 95       	ror	r22
    3dec:	b7 95       	ror	r27
    3dee:	f1 11       	cpse	r31, r1
    3df0:	f8 cf       	rjmp	.-16     	; 0x3de2 <__floatsisf+0x1c>
    3df2:	fa f4       	brpl	.+62     	; 0x3e32 <__floatsisf+0x6c>
    3df4:	bb 0f       	add	r27, r27
    3df6:	11 f4       	brne	.+4      	; 0x3dfc <__floatsisf+0x36>
    3df8:	60 ff       	sbrs	r22, 0
    3dfa:	1b c0       	rjmp	.+54     	; 0x3e32 <__floatsisf+0x6c>
    3dfc:	6f 5f       	subi	r22, 0xFF	; 255
    3dfe:	7f 4f       	sbci	r23, 0xFF	; 255
    3e00:	8f 4f       	sbci	r24, 0xFF	; 255
    3e02:	9f 4f       	sbci	r25, 0xFF	; 255
    3e04:	16 c0       	rjmp	.+44     	; 0x3e32 <__floatsisf+0x6c>
    3e06:	88 23       	and	r24, r24
    3e08:	11 f0       	breq	.+4      	; 0x3e0e <__floatsisf+0x48>
    3e0a:	96 e9       	ldi	r25, 0x96	; 150
    3e0c:	11 c0       	rjmp	.+34     	; 0x3e30 <__floatsisf+0x6a>
    3e0e:	77 23       	and	r23, r23
    3e10:	21 f0       	breq	.+8      	; 0x3e1a <__floatsisf+0x54>
    3e12:	9e e8       	ldi	r25, 0x8E	; 142
    3e14:	87 2f       	mov	r24, r23
    3e16:	76 2f       	mov	r23, r22
    3e18:	05 c0       	rjmp	.+10     	; 0x3e24 <__floatsisf+0x5e>
    3e1a:	66 23       	and	r22, r22
    3e1c:	71 f0       	breq	.+28     	; 0x3e3a <__floatsisf+0x74>
    3e1e:	96 e8       	ldi	r25, 0x86	; 134
    3e20:	86 2f       	mov	r24, r22
    3e22:	70 e0       	ldi	r23, 0x00	; 0
    3e24:	60 e0       	ldi	r22, 0x00	; 0
    3e26:	2a f0       	brmi	.+10     	; 0x3e32 <__floatsisf+0x6c>
    3e28:	9a 95       	dec	r25
    3e2a:	66 0f       	add	r22, r22
    3e2c:	77 1f       	adc	r23, r23
    3e2e:	88 1f       	adc	r24, r24
    3e30:	da f7       	brpl	.-10     	; 0x3e28 <__floatsisf+0x62>
    3e32:	88 0f       	add	r24, r24
    3e34:	96 95       	lsr	r25
    3e36:	87 95       	ror	r24
    3e38:	97 f9       	bld	r25, 7
    3e3a:	08 95       	ret

00003e3c <__fp_cmp>:
    3e3c:	99 0f       	add	r25, r25
    3e3e:	00 08       	sbc	r0, r0
    3e40:	55 0f       	add	r21, r21
    3e42:	aa 0b       	sbc	r26, r26
    3e44:	e0 e8       	ldi	r30, 0x80	; 128
    3e46:	fe ef       	ldi	r31, 0xFE	; 254
    3e48:	16 16       	cp	r1, r22
    3e4a:	17 06       	cpc	r1, r23
    3e4c:	e8 07       	cpc	r30, r24
    3e4e:	f9 07       	cpc	r31, r25
    3e50:	c0 f0       	brcs	.+48     	; 0x3e82 <__fp_cmp+0x46>
    3e52:	12 16       	cp	r1, r18
    3e54:	13 06       	cpc	r1, r19
    3e56:	e4 07       	cpc	r30, r20
    3e58:	f5 07       	cpc	r31, r21
    3e5a:	98 f0       	brcs	.+38     	; 0x3e82 <__fp_cmp+0x46>
    3e5c:	62 1b       	sub	r22, r18
    3e5e:	73 0b       	sbc	r23, r19
    3e60:	84 0b       	sbc	r24, r20
    3e62:	95 0b       	sbc	r25, r21
    3e64:	39 f4       	brne	.+14     	; 0x3e74 <__fp_cmp+0x38>
    3e66:	0a 26       	eor	r0, r26
    3e68:	61 f0       	breq	.+24     	; 0x3e82 <__fp_cmp+0x46>
    3e6a:	23 2b       	or	r18, r19
    3e6c:	24 2b       	or	r18, r20
    3e6e:	25 2b       	or	r18, r21
    3e70:	21 f4       	brne	.+8      	; 0x3e7a <__fp_cmp+0x3e>
    3e72:	08 95       	ret
    3e74:	0a 26       	eor	r0, r26
    3e76:	09 f4       	brne	.+2      	; 0x3e7a <__fp_cmp+0x3e>
    3e78:	a1 40       	sbci	r26, 0x01	; 1
    3e7a:	a6 95       	lsr	r26
    3e7c:	8f ef       	ldi	r24, 0xFF	; 255
    3e7e:	81 1d       	adc	r24, r1
    3e80:	81 1d       	adc	r24, r1
    3e82:	08 95       	ret

00003e84 <__gesf2>:
    3e84:	0e 94 1e 1f 	call	0x3e3c	; 0x3e3c <__fp_cmp>
    3e88:	08 f4       	brcc	.+2      	; 0x3e8c <__gesf2+0x8>
    3e8a:	8f ef       	ldi	r24, 0xFF	; 255
    3e8c:	08 95       	ret

00003e8e <__mulsi3>:
    3e8e:	db 01       	movw	r26, r22
    3e90:	8f 93       	push	r24
    3e92:	9f 93       	push	r25
    3e94:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <__muluhisi3>
    3e98:	bf 91       	pop	r27
    3e9a:	af 91       	pop	r26
    3e9c:	a2 9f       	mul	r26, r18
    3e9e:	80 0d       	add	r24, r0
    3ea0:	91 1d       	adc	r25, r1
    3ea2:	a3 9f       	mul	r26, r19
    3ea4:	90 0d       	add	r25, r0
    3ea6:	b2 9f       	mul	r27, r18
    3ea8:	90 0d       	add	r25, r0
    3eaa:	11 24       	eor	r1, r1
    3eac:	08 95       	ret

00003eae <__divmodhi4>:
    3eae:	97 fb       	bst	r25, 7
    3eb0:	07 2e       	mov	r0, r23
    3eb2:	16 f4       	brtc	.+4      	; 0x3eb8 <__divmodhi4+0xa>
    3eb4:	00 94       	com	r0
    3eb6:	07 d0       	rcall	.+14     	; 0x3ec6 <__divmodhi4_neg1>
    3eb8:	77 fd       	sbrc	r23, 7
    3eba:	09 d0       	rcall	.+18     	; 0x3ece <__divmodhi4_neg2>
    3ebc:	0e 94 e6 1f 	call	0x3fcc	; 0x3fcc <__udivmodhi4>
    3ec0:	07 fc       	sbrc	r0, 7
    3ec2:	05 d0       	rcall	.+10     	; 0x3ece <__divmodhi4_neg2>
    3ec4:	3e f4       	brtc	.+14     	; 0x3ed4 <__divmodhi4_exit>

00003ec6 <__divmodhi4_neg1>:
    3ec6:	90 95       	com	r25
    3ec8:	81 95       	neg	r24
    3eca:	9f 4f       	sbci	r25, 0xFF	; 255
    3ecc:	08 95       	ret

00003ece <__divmodhi4_neg2>:
    3ece:	70 95       	com	r23
    3ed0:	61 95       	neg	r22
    3ed2:	7f 4f       	sbci	r23, 0xFF	; 255

00003ed4 <__divmodhi4_exit>:
    3ed4:	08 95       	ret

00003ed6 <__udivmodsi4>:
    3ed6:	a1 e2       	ldi	r26, 0x21	; 33
    3ed8:	1a 2e       	mov	r1, r26
    3eda:	aa 1b       	sub	r26, r26
    3edc:	bb 1b       	sub	r27, r27
    3ede:	fd 01       	movw	r30, r26
    3ee0:	0d c0       	rjmp	.+26     	; 0x3efc <__udivmodsi4_ep>

00003ee2 <__udivmodsi4_loop>:
    3ee2:	aa 1f       	adc	r26, r26
    3ee4:	bb 1f       	adc	r27, r27
    3ee6:	ee 1f       	adc	r30, r30
    3ee8:	ff 1f       	adc	r31, r31
    3eea:	a2 17       	cp	r26, r18
    3eec:	b3 07       	cpc	r27, r19
    3eee:	e4 07       	cpc	r30, r20
    3ef0:	f5 07       	cpc	r31, r21
    3ef2:	20 f0       	brcs	.+8      	; 0x3efc <__udivmodsi4_ep>
    3ef4:	a2 1b       	sub	r26, r18
    3ef6:	b3 0b       	sbc	r27, r19
    3ef8:	e4 0b       	sbc	r30, r20
    3efa:	f5 0b       	sbc	r31, r21

00003efc <__udivmodsi4_ep>:
    3efc:	66 1f       	adc	r22, r22
    3efe:	77 1f       	adc	r23, r23
    3f00:	88 1f       	adc	r24, r24
    3f02:	99 1f       	adc	r25, r25
    3f04:	1a 94       	dec	r1
    3f06:	69 f7       	brne	.-38     	; 0x3ee2 <__udivmodsi4_loop>
    3f08:	60 95       	com	r22
    3f0a:	70 95       	com	r23
    3f0c:	80 95       	com	r24
    3f0e:	90 95       	com	r25
    3f10:	9b 01       	movw	r18, r22
    3f12:	ac 01       	movw	r20, r24
    3f14:	bd 01       	movw	r22, r26
    3f16:	cf 01       	movw	r24, r30
    3f18:	08 95       	ret

00003f1a <__divmodsi4>:
    3f1a:	05 2e       	mov	r0, r21
    3f1c:	97 fb       	bst	r25, 7
    3f1e:	1e f4       	brtc	.+6      	; 0x3f26 <__divmodsi4+0xc>
    3f20:	00 94       	com	r0
    3f22:	0e 94 a4 1f 	call	0x3f48	; 0x3f48 <__negsi2>
    3f26:	57 fd       	sbrc	r21, 7
    3f28:	07 d0       	rcall	.+14     	; 0x3f38 <__divmodsi4_neg2>
    3f2a:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <__udivmodsi4>
    3f2e:	07 fc       	sbrc	r0, 7
    3f30:	03 d0       	rcall	.+6      	; 0x3f38 <__divmodsi4_neg2>
    3f32:	4e f4       	brtc	.+18     	; 0x3f46 <__divmodsi4_exit>
    3f34:	0c 94 a4 1f 	jmp	0x3f48	; 0x3f48 <__negsi2>

00003f38 <__divmodsi4_neg2>:
    3f38:	50 95       	com	r21
    3f3a:	40 95       	com	r20
    3f3c:	30 95       	com	r19
    3f3e:	21 95       	neg	r18
    3f40:	3f 4f       	sbci	r19, 0xFF	; 255
    3f42:	4f 4f       	sbci	r20, 0xFF	; 255
    3f44:	5f 4f       	sbci	r21, 0xFF	; 255

00003f46 <__divmodsi4_exit>:
    3f46:	08 95       	ret

00003f48 <__negsi2>:
    3f48:	90 95       	com	r25
    3f4a:	80 95       	com	r24
    3f4c:	70 95       	com	r23
    3f4e:	61 95       	neg	r22
    3f50:	7f 4f       	sbci	r23, 0xFF	; 255
    3f52:	8f 4f       	sbci	r24, 0xFF	; 255
    3f54:	9f 4f       	sbci	r25, 0xFF	; 255
    3f56:	08 95       	ret

00003f58 <__tablejump2__>:
    3f58:	ee 0f       	add	r30, r30
    3f5a:	ff 1f       	adc	r31, r31
    3f5c:	88 1f       	adc	r24, r24
    3f5e:	8b bf       	out	0x3b, r24	; 59
    3f60:	07 90       	elpm	r0, Z+
    3f62:	f6 91       	elpm	r31, Z
    3f64:	e0 2d       	mov	r30, r0
    3f66:	1b be       	out	0x3b, r1	; 59
    3f68:	19 94       	eijmp

00003f6a <__mulhisi3>:
    3f6a:	0e 94 bd 1f 	call	0x3f7a	; 0x3f7a <__umulhisi3>
    3f6e:	33 23       	and	r19, r19
    3f70:	12 f4       	brpl	.+4      	; 0x3f76 <__mulhisi3+0xc>
    3f72:	8a 1b       	sub	r24, r26
    3f74:	9b 0b       	sbc	r25, r27
    3f76:	0c 94 ce 1f 	jmp	0x3f9c	; 0x3f9c <__usmulhisi3_tail>

00003f7a <__umulhisi3>:
    3f7a:	a2 9f       	mul	r26, r18
    3f7c:	b0 01       	movw	r22, r0
    3f7e:	b3 9f       	mul	r27, r19
    3f80:	c0 01       	movw	r24, r0
    3f82:	a3 9f       	mul	r26, r19
    3f84:	70 0d       	add	r23, r0
    3f86:	81 1d       	adc	r24, r1
    3f88:	11 24       	eor	r1, r1
    3f8a:	91 1d       	adc	r25, r1
    3f8c:	b2 9f       	mul	r27, r18
    3f8e:	70 0d       	add	r23, r0
    3f90:	81 1d       	adc	r24, r1
    3f92:	11 24       	eor	r1, r1
    3f94:	91 1d       	adc	r25, r1
    3f96:	08 95       	ret

00003f98 <__usmulhisi3>:
    3f98:	0e 94 bd 1f 	call	0x3f7a	; 0x3f7a <__umulhisi3>

00003f9c <__usmulhisi3_tail>:
    3f9c:	b7 ff       	sbrs	r27, 7
    3f9e:	08 95       	ret
    3fa0:	82 1b       	sub	r24, r18
    3fa2:	93 0b       	sbc	r25, r19
    3fa4:	08 95       	ret

00003fa6 <__muluhisi3>:
    3fa6:	0e 94 bd 1f 	call	0x3f7a	; 0x3f7a <__umulhisi3>
    3faa:	a5 9f       	mul	r26, r21
    3fac:	90 0d       	add	r25, r0
    3fae:	b4 9f       	mul	r27, r20
    3fb0:	90 0d       	add	r25, r0
    3fb2:	a4 9f       	mul	r26, r20
    3fb4:	80 0d       	add	r24, r0
    3fb6:	91 1d       	adc	r25, r1
    3fb8:	11 24       	eor	r1, r1
    3fba:	08 95       	ret

00003fbc <__mulshisi3>:
    3fbc:	b7 ff       	sbrs	r27, 7
    3fbe:	0c 94 d3 1f 	jmp	0x3fa6	; 0x3fa6 <__muluhisi3>

00003fc2 <__mulohisi3>:
    3fc2:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <__muluhisi3>
    3fc6:	82 1b       	sub	r24, r18
    3fc8:	93 0b       	sbc	r25, r19
    3fca:	08 95       	ret

00003fcc <__udivmodhi4>:
    3fcc:	aa 1b       	sub	r26, r26
    3fce:	bb 1b       	sub	r27, r27
    3fd0:	51 e1       	ldi	r21, 0x11	; 17
    3fd2:	07 c0       	rjmp	.+14     	; 0x3fe2 <__udivmodhi4_ep>

00003fd4 <__udivmodhi4_loop>:
    3fd4:	aa 1f       	adc	r26, r26
    3fd6:	bb 1f       	adc	r27, r27
    3fd8:	a6 17       	cp	r26, r22
    3fda:	b7 07       	cpc	r27, r23
    3fdc:	10 f0       	brcs	.+4      	; 0x3fe2 <__udivmodhi4_ep>
    3fde:	a6 1b       	sub	r26, r22
    3fe0:	b7 0b       	sbc	r27, r23

00003fe2 <__udivmodhi4_ep>:
    3fe2:	88 1f       	adc	r24, r24
    3fe4:	99 1f       	adc	r25, r25
    3fe6:	5a 95       	dec	r21
    3fe8:	a9 f7       	brne	.-22     	; 0x3fd4 <__udivmodhi4_loop>
    3fea:	80 95       	com	r24
    3fec:	90 95       	com	r25
    3fee:	bc 01       	movw	r22, r24
    3ff0:	cd 01       	movw	r24, r26
    3ff2:	08 95       	ret

00003ff4 <memcpy>:
    3ff4:	fb 01       	movw	r30, r22
    3ff6:	dc 01       	movw	r26, r24
    3ff8:	02 c0       	rjmp	.+4      	; 0x3ffe <memcpy+0xa>
    3ffa:	01 90       	ld	r0, Z+
    3ffc:	0d 92       	st	X+, r0
    3ffe:	41 50       	subi	r20, 0x01	; 1
    4000:	50 40       	sbci	r21, 0x00	; 0
    4002:	d8 f7       	brcc	.-10     	; 0x3ffa <memcpy+0x6>
    4004:	08 95       	ret

00004006 <memset>:
    4006:	dc 01       	movw	r26, r24
    4008:	01 c0       	rjmp	.+2      	; 0x400c <memset+0x6>
    400a:	6d 93       	st	X+, r22
    400c:	41 50       	subi	r20, 0x01	; 1
    400e:	50 40       	sbci	r21, 0x00	; 0
    4010:	e0 f7       	brcc	.-8      	; 0x400a <memset+0x4>
    4012:	08 95       	ret

00004014 <strncpy>:
    4014:	fb 01       	movw	r30, r22
    4016:	dc 01       	movw	r26, r24
    4018:	41 50       	subi	r20, 0x01	; 1
    401a:	50 40       	sbci	r21, 0x00	; 0
    401c:	48 f0       	brcs	.+18     	; 0x4030 <strncpy+0x1c>
    401e:	01 90       	ld	r0, Z+
    4020:	0d 92       	st	X+, r0
    4022:	00 20       	and	r0, r0
    4024:	c9 f7       	brne	.-14     	; 0x4018 <strncpy+0x4>
    4026:	01 c0       	rjmp	.+2      	; 0x402a <strncpy+0x16>
    4028:	1d 92       	st	X+, r1
    402a:	41 50       	subi	r20, 0x01	; 1
    402c:	50 40       	sbci	r21, 0x00	; 0
    402e:	e0 f7       	brcc	.-8      	; 0x4028 <strncpy+0x14>
    4030:	08 95       	ret

00004032 <__itoa_ncheck>:
    4032:	bb 27       	eor	r27, r27
    4034:	4a 30       	cpi	r20, 0x0A	; 10
    4036:	31 f4       	brne	.+12     	; 0x4044 <__itoa_ncheck+0x12>
    4038:	99 23       	and	r25, r25
    403a:	22 f4       	brpl	.+8      	; 0x4044 <__itoa_ncheck+0x12>
    403c:	bd e2       	ldi	r27, 0x2D	; 45
    403e:	90 95       	com	r25
    4040:	81 95       	neg	r24
    4042:	9f 4f       	sbci	r25, 0xFF	; 255
    4044:	0c 94 5d 20 	jmp	0x40ba	; 0x40ba <__utoa_common>

00004048 <ultoa>:
    4048:	25 32       	cpi	r18, 0x25	; 37
    404a:	31 05       	cpc	r19, r1
    404c:	20 f4       	brcc	.+8      	; 0x4056 <ultoa+0xe>
    404e:	22 30       	cpi	r18, 0x02	; 2
    4050:	10 f0       	brcs	.+4      	; 0x4056 <ultoa+0xe>
    4052:	0c 94 2f 20 	jmp	0x405e	; 0x405e <__ultoa_ncheck>
    4056:	fa 01       	movw	r30, r20
    4058:	10 82       	st	Z, r1
    405a:	ca 01       	movw	r24, r20
    405c:	08 95       	ret

0000405e <__ultoa_ncheck>:
    405e:	bb 27       	eor	r27, r27

00004060 <__ultoa_common>:
    4060:	fa 01       	movw	r30, r20
    4062:	a6 2f       	mov	r26, r22
    4064:	62 17       	cp	r22, r18
    4066:	71 05       	cpc	r23, r1
    4068:	81 05       	cpc	r24, r1
    406a:	91 05       	cpc	r25, r1
    406c:	33 0b       	sbc	r19, r19
    406e:	30 fb       	bst	r19, 0
    4070:	66 f0       	brts	.+24     	; 0x408a <__ultoa_common+0x2a>
    4072:	aa 27       	eor	r26, r26
    4074:	66 0f       	add	r22, r22
    4076:	77 1f       	adc	r23, r23
    4078:	88 1f       	adc	r24, r24
    407a:	99 1f       	adc	r25, r25
    407c:	aa 1f       	adc	r26, r26
    407e:	a2 17       	cp	r26, r18
    4080:	10 f0       	brcs	.+4      	; 0x4086 <__ultoa_common+0x26>
    4082:	a2 1b       	sub	r26, r18
    4084:	63 95       	inc	r22
    4086:	38 50       	subi	r19, 0x08	; 8
    4088:	a9 f7       	brne	.-22     	; 0x4074 <__ultoa_common+0x14>
    408a:	a0 5d       	subi	r26, 0xD0	; 208
    408c:	aa 33       	cpi	r26, 0x3A	; 58
    408e:	08 f0       	brcs	.+2      	; 0x4092 <__ultoa_common+0x32>
    4090:	a9 5d       	subi	r26, 0xD9	; 217
    4092:	a1 93       	st	Z+, r26
    4094:	36 f7       	brtc	.-52     	; 0x4062 <__ultoa_common+0x2>
    4096:	b1 11       	cpse	r27, r1
    4098:	b1 93       	st	Z+, r27
    409a:	10 82       	st	Z, r1
    409c:	ca 01       	movw	r24, r20
    409e:	0c 94 76 20 	jmp	0x40ec	; 0x40ec <strrev>

000040a2 <utoa>:
    40a2:	45 32       	cpi	r20, 0x25	; 37
    40a4:	51 05       	cpc	r21, r1
    40a6:	20 f4       	brcc	.+8      	; 0x40b0 <utoa+0xe>
    40a8:	42 30       	cpi	r20, 0x02	; 2
    40aa:	10 f0       	brcs	.+4      	; 0x40b0 <utoa+0xe>
    40ac:	0c 94 5c 20 	jmp	0x40b8	; 0x40b8 <__utoa_ncheck>
    40b0:	fb 01       	movw	r30, r22
    40b2:	10 82       	st	Z, r1
    40b4:	cb 01       	movw	r24, r22
    40b6:	08 95       	ret

000040b8 <__utoa_ncheck>:
    40b8:	bb 27       	eor	r27, r27

000040ba <__utoa_common>:
    40ba:	fb 01       	movw	r30, r22
    40bc:	55 27       	eor	r21, r21
    40be:	aa 27       	eor	r26, r26
    40c0:	88 0f       	add	r24, r24
    40c2:	99 1f       	adc	r25, r25
    40c4:	aa 1f       	adc	r26, r26
    40c6:	a4 17       	cp	r26, r20
    40c8:	10 f0       	brcs	.+4      	; 0x40ce <__utoa_common+0x14>
    40ca:	a4 1b       	sub	r26, r20
    40cc:	83 95       	inc	r24
    40ce:	50 51       	subi	r21, 0x10	; 16
    40d0:	b9 f7       	brne	.-18     	; 0x40c0 <__utoa_common+0x6>
    40d2:	a0 5d       	subi	r26, 0xD0	; 208
    40d4:	aa 33       	cpi	r26, 0x3A	; 58
    40d6:	08 f0       	brcs	.+2      	; 0x40da <__utoa_common+0x20>
    40d8:	a9 5d       	subi	r26, 0xD9	; 217
    40da:	a1 93       	st	Z+, r26
    40dc:	00 97       	sbiw	r24, 0x00	; 0
    40de:	79 f7       	brne	.-34     	; 0x40be <__utoa_common+0x4>
    40e0:	b1 11       	cpse	r27, r1
    40e2:	b1 93       	st	Z+, r27
    40e4:	11 92       	st	Z+, r1
    40e6:	cb 01       	movw	r24, r22
    40e8:	0c 94 76 20 	jmp	0x40ec	; 0x40ec <strrev>

000040ec <strrev>:
    40ec:	dc 01       	movw	r26, r24
    40ee:	fc 01       	movw	r30, r24
    40f0:	67 2f       	mov	r22, r23
    40f2:	71 91       	ld	r23, Z+
    40f4:	77 23       	and	r23, r23
    40f6:	e1 f7       	brne	.-8      	; 0x40f0 <strrev+0x4>
    40f8:	32 97       	sbiw	r30, 0x02	; 2
    40fa:	04 c0       	rjmp	.+8      	; 0x4104 <strrev+0x18>
    40fc:	7c 91       	ld	r23, X
    40fe:	6d 93       	st	X+, r22
    4100:	70 83       	st	Z, r23
    4102:	62 91       	ld	r22, -Z
    4104:	ae 17       	cp	r26, r30
    4106:	bf 07       	cpc	r27, r31
    4108:	c8 f3       	brcs	.-14     	; 0x40fc <strrev+0x10>
    410a:	08 95       	ret

0000410c <_exit>:
    410c:	f8 94       	cli

0000410e <__stop_program>:
    410e:	ff cf       	rjmp	.-2      	; 0x410e <__stop_program>
