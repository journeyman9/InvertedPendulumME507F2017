
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003cce  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ca  00802000  00003cce  00003d62  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010aa  008020ca  008020ca  00003e2c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003e2c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003e5c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006c0  00000000  00000000  00003e9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00011c30  00000000  00000000  0000455c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000076b8  00000000  00000000  0001618c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004fdc  00000000  00000000  0001d844  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001300  00000000  00000000  00022820  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006cd0  00000000  00000000  00023b20  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005c10  00000000  00000000  0002a7f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000578  00000000  00000000  00030400  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ab 02 	jmp	0x556	; 0x556 <__ctors_end>
       4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
       8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
       c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      10:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      14:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      18:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      1c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      20:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      24:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      28:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      2c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      30:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      34:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      38:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      3c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      40:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      44:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      48:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      4c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      50:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      54:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      58:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      5c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      60:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      64:	0c 94 f0 19 	jmp	0x33e0	; 0x33e0 <__vector_25>
      68:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      6c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      70:	0c 94 4e 1a 	jmp	0x349c	; 0x349c <__vector_28>
      74:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      78:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      7c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      80:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      84:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      88:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      8c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      90:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      94:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      98:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      9c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      a0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      a4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      a8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      ac:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      b0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      b4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      b8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      bc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      c0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      c4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      c8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      cc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      d0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      d4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      d8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      dc:	0c 94 ce 09 	jmp	0x139c	; 0x139c <__vector_55>
      e0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      e4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      e8:	0c 94 68 1b 	jmp	0x36d0	; 0x36d0 <__vector_58>
      ec:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      f0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      f4:	0c 94 c6 1b 	jmp	0x378c	; 0x378c <__vector_61>
      f8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
      fc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     100:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     104:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     108:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     10c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     110:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     114:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     118:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     11c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     120:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     124:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     128:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     12c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     130:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     134:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     138:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     13c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     140:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     144:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     148:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     14c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     150:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     154:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     158:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     15c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     160:	0c 94 ac 1a 	jmp	0x3558	; 0x3558 <__vector_88>
     164:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     168:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     16c:	0c 94 0a 1b 	jmp	0x3614	; 0x3614 <__vector_91>
     170:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     174:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     178:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     17c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     180:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     184:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     188:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     18c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     190:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     194:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     198:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     19c:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1a0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1a4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1a8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1ac:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1b0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1b4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1b8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1bc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1c0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1c4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1c8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1cc:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1d0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1d4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1d8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1dc:	0c 94 24 1c 	jmp	0x3848	; 0x3848 <__vector_119>
     1e0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1e4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1e8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1ec:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1f0:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1f4:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1f8:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <__bad_interrupt>
     1fc:	ba 17       	cp	r27, r26
     1fe:	bd 17       	cp	r27, r29
     200:	c0 17       	cp	r28, r16
     202:	c3 17       	cp	r28, r19
     204:	c6 17       	cp	r28, r22
     206:	c9 17       	cp	r28, r25
     208:	cb 17       	cp	r28, r27
     20a:	dc 17       	cp	r29, r28
     20c:	e4 17       	cp	r30, r20
     20e:	ee 17       	cp	r30, r30
     210:	ec 17       	cp	r30, r28

00000212 <__trampolines_start>:
     212:	0c 94 01 04 	jmp	0x802	; 0x802 <_ZN3pid3runEv>
     216:	0c 94 37 1d 	jmp	0x3a6e	; 0x3a6e <_GLOBAL__sub_I_counter>
     21a:	0c 94 f4 14 	jmp	0x29e8	; 0x29e8 <_ZN14frt_text_queue7putcharEc>
     21e:	0c 94 ee 17 	jmp	0x2fdc	; 0x2fdc <_ZN8emstreamlsE15ser_manipulator+0x86>
     222:	0c 94 c0 17 	jmp	0x2f80	; 0x2f80 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     226:	0c 94 5d 17 	jmp	0x2eba	; 0x2eba <_ZN8emstream13ready_to_sendEv>
     22a:	0c 94 c6 17 	jmp	0x2f8c	; 0x2f8c <_ZN8emstreamlsE15ser_manipulator+0x36>
     22e:	0c 94 5f 17 	jmp	0x2ebe	; 0x2ebe <_ZN8emstream7getcharEv>
     232:	0c 94 a8 02 	jmp	0x550	; 0x550 <_call_static_run_method>
     236:	0c 94 64 17 	jmp	0x2ec8	; 0x2ec8 <_ZN8emstream12transmit_nowEv>
     23a:	0c 94 c3 17 	jmp	0x2f86	; 0x2f86 <_ZN8emstreamlsE15ser_manipulator+0x30>
     23e:	0c 94 cb 17 	jmp	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator+0x40>
     242:	0c 94 65 17 	jmp	0x2eca	; 0x2eca <_ZN8emstream12clear_screenEv>
     246:	0c 94 e9 14 	jmp	0x29d2	; 0x29d2 <_ZN14frt_text_queue14check_for_charEv>
     24a:	0c 94 cf 03 	jmp	0x79e	; 0x79e <_ZN5Motor3runEv>
     24e:	0c 94 33 04 	jmp	0x866	; 0x866 <_ZN9PWMdriver3runEv>
     252:	0c 94 dc 17 	jmp	0x2fb8	; 0x2fb8 <_ZN8emstreamlsE15ser_manipulator+0x62>
     256:	0c 94 9d 03 	jmp	0x73a	; 0x73a <_ZN13LimitSwitches3runEv>
     25a:	0c 94 81 13 	jmp	0x2702	; 0x2702 <_ZN8frt_task12print_statusER8emstream>
     25e:	0c 94 ac 16 	jmp	0x2d58	; 0x2d58 <__cxa_pure_virtual>
     262:	0c 94 ba 17 	jmp	0x2f74	; 0x2f74 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     266:	0c 94 4c 03 	jmp	0x698	; 0x698 <_ZN15EncoderPendulum3runEv>
     26a:	0c 94 52 0c 	jmp	0x18a4	; 0x18a4 <prvIdleTask>
     26e:	0c 94 c9 17 	jmp	0x2f92	; 0x2f92 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     272:	0c 94 62 17 	jmp	0x2ec4	; 0x2ec4 <_ZN8emstream14check_for_charEv>
     276:	0c 94 e8 18 	jmp	0x31d0	; 0x31d0 <_ZN5rs2327putcharEc>
     27a:	0c 94 e3 02 	jmp	0x5c6	; 0x5c6 <_ZN12EncoderMotor3runEv>
     27e:	0c 94 32 19 	jmp	0x3264	; 0x3264 <_ZN5rs23214check_for_charEv>
     282:	0c 94 cb 14 	jmp	0x2996	; 0x2996 <_ZN14frt_text_queue7getcharEv>
     286:	0c 94 a8 05 	jmp	0xb50	; 0xb50 <_ZN9task_user3runEv>
     28a:	0c 94 bd 17 	jmp	0x2f7a	; 0x2f7a <_ZN8emstreamlsE15ser_manipulator+0x24>
     28e:	0c 94 ec 17 	jmp	0x2fd8	; 0x2fd8 <_ZN8emstreamlsE15ser_manipulator+0x82>
     292:	0c 94 e4 17 	jmp	0x2fc8	; 0x2fc8 <_ZN8emstreamlsE15ser_manipulator+0x72>
     296:	0c 94 45 19 	jmp	0x328a	; 0x328a <_ZN5rs23212clear_screenEv>
     29a:	0c 94 0c 19 	jmp	0x3218	; 0x3218 <_ZN5rs2327getcharEv>

0000029e <__trampolines_end>:
     29e:	2c 20       	and	r2, r12
     2a0:	54 43       	sbci	r21, 0x34	; 52
     2a2:	43 30       	cpi	r20, 0x03	; 3
     2a4:	43 43       	sbci	r20, 0x33	; 51
     2a6:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a9 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a9:	2f 00                                               /.

000002ab <_ZZN9task_user11show_statusEvE3__c_2>:
     2ab:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b9 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b9:	54 69 6d 65 3a 20 00                                Time: .

000002c0 <_ZZN9task_user11show_statusEvE3__c_0>:
     2c0:	4e 6f 76 20 32 35 20 32 30 31 37 00                 Nov 25 2017.

000002cc <_ZZN9task_user11show_statusEvE3__c>:
     2cc:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2dc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002eb <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2eb:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002fa <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2fa:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     30a:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000315 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     315:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     325:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000333 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     333:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     343:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     353:	6d 61 74 69 6f 6e 00                                mation.

0000035a <_ZZN9task_user18print_help_messageEvE3__c_6>:
     35a:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     36a:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000037b <_ZZN9task_user18print_help_messageEvE3__c_5>:
     37b:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     38b:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000393 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     393:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     3a3:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003af <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3af:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3bf:	68 65 20 41 56 52 00                                he AVR.

000003c6 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3c6:	20 68 65 6c 70 00                                    help.

000003cc <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3cc:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3dc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003eb <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3eb:	1b 5b 33 30 6d 00                                   .[30m.

000003f1 <_ZZN9task_user18print_help_messageEvE3__c>:
     3f1:	1b 5b 34 36 6d 00                                   .[46m.

000003f7 <_ZZN9task_user3runEvE3__c_3>:
     3f7:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     407:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000414 <_ZZN9task_user3runEvE3__c_2>:
     414:	3a 57 54 46 3f 00                                   :WTF?.

0000041a <_ZZN9task_user3runEvE3__c_1>:
     41a:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     42a:	65 00                                               e.

0000042c <_ZZN9task_user3runEvE3__c_0>:
     42c:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000043a <_ZZN9task_user3runEvE3__c>:
     43a:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     44a:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000458 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     458:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000462 <_ZZN8frt_task15emergency_resetEvE3__c>:
     462:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000471 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     471:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     481:	61 73 6b 20 00                                      ask .

00000486 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     486:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000494 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     494:	20 63 72 65 61 74 65 64 00                           created.

0000049d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     49d:	54 61 73 6b 20 00                                   Task .

000004a3 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     4a3:	1b 5b 32 32 6d 00                                   .[22m.

000004a9 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a9:	54 61 73 6b 3a 20 00                                Task: .

000004b0 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4b0:	1b 5b 31 6d 00                                      .[1m.

000004b5 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4b5:	1b 5b 32 32 6d 00                                   .[22m.

000004bb <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4bb:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004c6 <_ZZ17print_task_stacksP8emstreamE3__c>:
     4c6:	1b 5b 31 6d 00                                      .[1m.

000004cb <_ZZ15print_task_listP8emstreamE3__c_9>:
     4cb:	09 09 00                                            ...

000004ce <_ZZ15print_task_listP8emstreamE3__c_8>:
     4ce:	2f 00                                               /.

000004d0 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4d0:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004db <_ZZ15print_task_listP8emstreamE3__c_6>:
     4db:	09 2d 2d 2d 2d 00                                   .----.

000004e1 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4e1:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004ed <_ZZ15print_task_listP8emstreamE3__c_4>:
     4ed:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004fe <_ZZ15print_task_listP8emstreamE3__c_3>:
     4fe:	09 52 75 6e 73 00                                   .Runs.

00000504 <_ZZ15print_task_listP8emstreamE3__c_2>:
     504:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000510 <_ZZ15print_task_listP8emstreamE3__c_1>:
     510:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000521 <_ZZ15print_task_listP8emstreamE3__c_0>:
     521:	09 53 74 61 63 6b 00                                .Stack.

00000528 <_ZZ15print_task_listP8emstreamE3__c>:
     528:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     533:	09 00                                               ..

00000535 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     535:	09 00                                               ..

00000537 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     537:	2f 00                                               /.

00000539 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     539:	09 00                                               ..

0000053b <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     53b:	09 00                                               ..

0000053d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     53d:	1b 5b 32 32 6d 00                                   .[22m.

00000543 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     543:	1b 5b 31 6d 00                                      .[1m.

00000548 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     548:	1b 5b 31 6d 00                                      .[1m.

0000054d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     54d:	20 20 00                                              .

00000550 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     550:	0e 94 19 12 	call	0x2432	; 0x2432 <_ZN8frt_task22_call_users_run_methodEPS_>

00000554 <__ctors_start>:
     554:	37 1d       	adc	r19, r7

00000556 <__ctors_end>:
     556:	11 24       	eor	r1, r1
     558:	1f be       	out	0x3f, r1	; 63
     55a:	cf ef       	ldi	r28, 0xFF	; 255
     55c:	cd bf       	out	0x3d, r28	; 61
     55e:	df e3       	ldi	r29, 0x3F	; 63
     560:	de bf       	out	0x3e, r29	; 62
     562:	00 e0       	ldi	r16, 0x00	; 0
     564:	0c bf       	out	0x3c, r16	; 60
     566:	18 be       	out	0x38, r1	; 56
     568:	19 be       	out	0x39, r1	; 57
     56a:	1a be       	out	0x3a, r1	; 58
     56c:	1b be       	out	0x3b, r1	; 59

0000056e <__do_copy_data>:
     56e:	10 e2       	ldi	r17, 0x20	; 32
     570:	a0 e0       	ldi	r26, 0x00	; 0
     572:	b0 e2       	ldi	r27, 0x20	; 32
     574:	ee ec       	ldi	r30, 0xCE	; 206
     576:	fc e3       	ldi	r31, 0x3C	; 60
     578:	00 e0       	ldi	r16, 0x00	; 0
     57a:	0b bf       	out	0x3b, r16	; 59
     57c:	02 c0       	rjmp	.+4      	; 0x582 <__do_copy_data+0x14>
     57e:	07 90       	elpm	r0, Z+
     580:	0d 92       	st	X+, r0
     582:	aa 3c       	cpi	r26, 0xCA	; 202
     584:	b1 07       	cpc	r27, r17
     586:	d9 f7       	brne	.-10     	; 0x57e <__do_copy_data+0x10>
     588:	1b be       	out	0x3b, r1	; 59

0000058a <__do_clear_bss>:
     58a:	21 e3       	ldi	r18, 0x31	; 49
     58c:	aa ec       	ldi	r26, 0xCA	; 202
     58e:	b0 e2       	ldi	r27, 0x20	; 32
     590:	01 c0       	rjmp	.+2      	; 0x594 <.do_clear_bss_start>

00000592 <.do_clear_bss_loop>:
     592:	1d 92       	st	X+, r1

00000594 <.do_clear_bss_start>:
     594:	a4 37       	cpi	r26, 0x74	; 116
     596:	b2 07       	cpc	r27, r18
     598:	e1 f7       	brne	.-8      	; 0x592 <.do_clear_bss_loop>

0000059a <__do_global_ctors>:
     59a:	12 e0       	ldi	r17, 0x02	; 2
     59c:	cb ea       	ldi	r28, 0xAB	; 171
     59e:	d2 e0       	ldi	r29, 0x02	; 2
     5a0:	00 e0       	ldi	r16, 0x00	; 0
     5a2:	06 c0       	rjmp	.+12     	; 0x5b0 <__do_global_ctors+0x16>
     5a4:	21 97       	sbiw	r28, 0x01	; 1
     5a6:	01 09       	sbc	r16, r1
     5a8:	80 2f       	mov	r24, r16
     5aa:	fe 01       	movw	r30, r28
     5ac:	0e 94 ad 1d 	call	0x3b5a	; 0x3b5a <__tablejump2__>
     5b0:	ca 3a       	cpi	r28, 0xAA	; 170
     5b2:	d1 07       	cpc	r29, r17
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	08 07       	cpc	r16, r24
     5b8:	a9 f7       	brne	.-22     	; 0x5a4 <__do_global_ctors+0xa>
     5ba:	0e 94 97 1c 	call	0x392e	; 0x392e <main>
     5be:	0c 94 65 1e 	jmp	0x3cca	; 0x3cca <_exit>

000005c2 <__bad_interrupt>:
     5c2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005c6 <_ZN12EncoderMotor3runEv>:
	// Nothing to do in this constructor other than call the parent constructor
}


void EncoderMotor::run (void)
{ 
     5c6:	cf 93       	push	r28
     5c8:	df 93       	push	r29
     5ca:	00 d0       	rcall	.+0      	; 0x5cc <_ZN12EncoderMotor3runEv+0x6>
     5cc:	1f 92       	push	r1
     5ce:	cd b7       	in	r28, 0x3d	; 61
     5d0:	de b7       	in	r29, 0x3e	; 62
     5d2:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5d4:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <xTaskGetTickCount>
     5d8:	69 83       	std	Y+1, r22	; 0x01
     5da:	7a 83       	std	Y+2, r23	; 0x02
     5dc:	8b 83       	std	Y+3, r24	; 0x03
     5de:	9c 83       	std	Y+4, r25	; 0x04
	
	PORTC.DIRCLR = PIN0_bm | PIN1_bm;										// Set both CHa and CHb for input
     5e0:	e0 e4       	ldi	r30, 0x40	; 64
     5e2:	f6 e0       	ldi	r31, 0x06	; 6
     5e4:	83 e0       	ldi	r24, 0x03	; 3
     5e6:	82 83       	std	Z+2, r24	; 0x02
	PORTC.PIN0CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Cha
     5e8:	80 89       	ldd	r24, Z+16	; 0x10
     5ea:	83 60       	ori	r24, 0x03	; 3
     5ec:	80 8b       	std	Z+16, r24	; 0x10
	PORTC.PIN1CTRL |= PORT_ISC_LEVEL_gc;									// Set low level sense for Chb
     5ee:	81 89       	ldd	r24, Z+17	; 0x11
     5f0:	83 60       	ori	r24, 0x03	; 3
     5f2:	81 8b       	std	Z+17, r24	; 0x11
	
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTC_PIN0_gc;								// Configure CHa as a multiplexer input for event channel 0
     5f4:	e0 e8       	ldi	r30, 0x80	; 128
     5f6:	f1 e0       	ldi	r31, 0x01	; 1
     5f8:	80 e6       	ldi	r24, 0x60	; 96
     5fa:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;				// Enable the quadrature encoder
     5fc:	89 e0       	ldi	r24, 0x09	; 9
     5fe:	80 87       	std	Z+8, r24	; 0x08
	
	TCC0.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH0_gc;						// Set the quadrature decoding as the event action for the timer
     600:	e0 e0       	ldi	r30, 0x00	; 0
     602:	f8 e0       	ldi	r31, 0x08	; 8
     604:	88 e6       	ldi	r24, 0x68	; 104
     606:	83 83       	std	Z+3, r24	; 0x03
	TCC0.PER = 0xFFFF;														// Set the timer counter period 1000 cpr, = 1000*4-1 F9F
     608:	8f ef       	ldi	r24, 0xFF	; 255
     60a:	9f ef       	ldi	r25, 0xFF	; 255
     60c:	86 a3       	std	Z+38, r24	; 0x26
     60e:	97 a3       	std	Z+39, r25	; 0x27
	TCC0.CTRLA = TC_CLKSEL_DIV1_gc;											// Start the timer
     610:	81 e0       	ldi	r24, 0x01	; 1
     612:	80 83       	st	Z, r24
	int16_t AngularVelocity;
	float x_calc;
	int16_t x;

	while(1){
		encoder_count = TCC0.CNT;											// get count
     614:	c1 2c       	mov	r12, r1
     616:	68 94       	set
     618:	dd 24       	eor	r13, r13
     61a:	d3 f8       	bld	r13, 3
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
			the_data = new_data;
     61c:	0f 2e       	mov	r0, r31
     61e:	f4 e6       	ldi	r31, 0x64	; 100
     620:	ef 2e       	mov	r14, r31
     622:	f1 2c       	mov	r15, r1
     624:	f0 2d       	mov	r31, r0
     626:	f6 01       	movw	r30, r12
     628:	80 a1       	ldd	r24, Z+32	; 0x20
     62a:	91 a1       	ldd	r25, Z+33	; 0x21
		*  stack, jumping, jumping back and popping the program counter, yawn, zzz...
		*  @param new_data The data which is to be written
		*/
		void put (data_type new_data)
		{
			portENTER_CRITICAL ();
     62c:	0f b6       	in	r0, 0x3f	; 63
     62e:	f8 94       	cli
     630:	0f 92       	push	r0
			the_data = new_data;
     632:	9c 01       	movw	r18, r24
     634:	22 0f       	add	r18, r18
     636:	33 1f       	adc	r19, r19
     638:	82 0f       	add	r24, r18
     63a:	93 1f       	adc	r25, r19
     63c:	b7 01       	movw	r22, r14
     63e:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <__divmodhi4>
     642:	60 93 60 31 	sts	0x3160, r22	; 0x803160 <linear_position>
     646:	70 93 61 31 	sts	0x3161, r23	; 0x803161 <linear_position+0x1>
			portEXIT_CRITICAL ();
     64a:	0f 90       	pop	r0
     64c:	0f be       	out	0x3f, r0	; 63
			motor_enc_zero = false;
		}
		*/
		
		// Increment counter for debugging
		runs++;
     64e:	f8 01       	movw	r30, r16
     650:	86 85       	ldd	r24, Z+14	; 0x0e
     652:	97 85       	ldd	r25, Z+15	; 0x0f
     654:	a0 89       	ldd	r26, Z+16	; 0x10
     656:	b1 89       	ldd	r27, Z+17	; 0x11
     658:	01 96       	adiw	r24, 0x01	; 1
     65a:	a1 1d       	adc	r26, r1
     65c:	b1 1d       	adc	r27, r1
     65e:	86 87       	std	Z+14, r24	; 0x0e
     660:	97 87       	std	Z+15, r25	; 0x0f
     662:	a0 8b       	std	Z+16, r26	; 0x10
     664:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     666:	41 e0       	ldi	r20, 0x01	; 1
     668:	50 e0       	ldi	r21, 0x00	; 0
     66a:	60 e0       	ldi	r22, 0x00	; 0
     66c:	70 e0       	ldi	r23, 0x00	; 0
     66e:	ce 01       	movw	r24, r28
     670:	01 96       	adiw	r24, 0x01	; 1
     672:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <vTaskDelayUntil>
     676:	d7 cf       	rjmp	.-82     	; 0x626 <_ZN12EncoderMotor3runEv+0x60>

00000678 <_ZN12EncoderMotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderMotor::EncoderMotor(const char* a_name,
     678:	0f 93       	push	r16
     67a:	1f 93       	push	r17
     67c:	cf 93       	push	r28
     67e:	df 93       	push	r29
     680:	ec 01       	movw	r28, r24
							size_t a_stack_size,
							emstream* p_ser_dev
							)
							
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     682:	0e 94 2c 12 	call	0x2458	; 0x2458 <_ZN8frt_taskC1EPKchjP8emstream>
     686:	8a e0       	ldi	r24, 0x0A	; 10
     688:	90 e2       	ldi	r25, 0x20	; 32
     68a:	88 83       	st	Y, r24
     68c:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing to do in this constructor other than call the parent constructor
}
     68e:	df 91       	pop	r29
     690:	cf 91       	pop	r28
     692:	1f 91       	pop	r17
     694:	0f 91       	pop	r16
     696:	08 95       	ret

00000698 <_ZN15EncoderPendulum3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void EncoderPendulum::run(void){
     698:	cf 93       	push	r28
     69a:	df 93       	push	r29
     69c:	00 d0       	rcall	.+0      	; 0x69e <_ZN15EncoderPendulum3runEv+0x6>
     69e:	1f 92       	push	r1
     6a0:	cd b7       	in	r28, 0x3d	; 61
     6a2:	de b7       	in	r29, 0x3e	; 62
     6a4:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     6a6:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <xTaskGetTickCount>
     6aa:	69 83       	std	Y+1, r22	; 0x01
     6ac:	7a 83       	std	Y+2, r23	; 0x02
     6ae:	8b 83       	std	Y+3, r24	; 0x03
     6b0:	9c 83       	std	Y+4, r25	; 0x04
	
	// INIT:
	// Setup quad encoder on pins C4 & C5
	PORTC.DIRCLR = (PIN4_bm | PIN5_bm);							// set C4 & C5 as inputs
     6b2:	e0 e4       	ldi	r30, 0x40	; 64
     6b4:	f6 e0       	ldi	r31, 0x06	; 6
     6b6:	80 e3       	ldi	r24, 0x30	; 48
     6b8:	82 83       	std	Z+2, r24	; 0x02
	PORTC.PIN4CTRL = PORT_ISC_LEVEL_gc;							// set C4 for level sensing
     6ba:	83 e0       	ldi	r24, 0x03	; 3
     6bc:	84 8b       	std	Z+20, r24	; 0x14
	PORTC.PIN5CTRL = PORT_ISC_LEVEL_gc;							// set C5 for level sensing
     6be:	85 8b       	std	Z+21, r24	; 0x15
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTC_PIN4_gc;					// set PC4 as Multiplexer for Event Chan 0
     6c0:	e0 e8       	ldi	r30, 0x80	; 128
     6c2:	f1 e0       	ldi	r31, 0x01	; 1
     6c4:	84 e6       	ldi	r24, 0x64	; 100
     6c6:	80 83       	st	Z, r24
	EVSYS.CH0CTRL = EVSYS_QDEN_bm | EVSYS_DIGFILT_2SAMPLES_gc;	// enable quad encoder mode with 2-sample filtering
     6c8:	89 e0       	ldi	r24, 0x09	; 9
     6ca:	80 87       	std	Z+8, r24	; 0x08
	TCC1.CTRLD = TC_EVACT_QDEC_gc | TC_EVSEL_CH1_gc;			// set TCC1 event action to quad decoding, and event source as Event Chan 1
     6cc:	e0 e4       	ldi	r30, 0x40	; 64
     6ce:	f8 e0       	ldi	r31, 0x08	; 8
     6d0:	89 e6       	ldi	r24, 0x69	; 105
     6d2:	83 83       	std	Z+3, r24	; 0x03
	TCC1.PER = 0xFFFF;											// usually ticks/rev, but this doesn't matter since we're converting to linear anyway
     6d4:	8f ef       	ldi	r24, 0xFF	; 255
     6d6:	9f ef       	ldi	r25, 0xFF	; 255
     6d8:	86 a3       	std	Z+38, r24	; 0x26
     6da:	97 a3       	std	Z+39, r25	; 0x27
	TCC1.CTRLA = TC_CLKSEL_DIV1_gc;								// start TCC1 with prescaler = 1
     6dc:	81 e0       	ldi	r24, 0x01	; 1
     6de:	80 83       	st	Z, r24
	
	uint16_t count;												// contains the current encoder value
	
	while(1){
		// Read value from hardware counter
		count = TCC1.CNT;
     6e0:	68 94       	set
     6e2:	ee 24       	eor	r14, r14
     6e4:	e6 f8       	bld	r14, 6
     6e6:	ff 24       	eor	r15, r15
     6e8:	f3 f8       	bld	r15, 3
     6ea:	f7 01       	movw	r30, r14
     6ec:	80 a1       	ldd	r24, Z+32	; 0x20
     6ee:	91 a1       	ldd	r25, Z+33	; 0x21
			pendulum_enc_zero = false;
			}
		*/
		
		// Increment counter for debugging
		runs++;
     6f0:	f8 01       	movw	r30, r16
     6f2:	86 85       	ldd	r24, Z+14	; 0x0e
     6f4:	97 85       	ldd	r25, Z+15	; 0x0f
     6f6:	a0 89       	ldd	r26, Z+16	; 0x10
     6f8:	b1 89       	ldd	r27, Z+17	; 0x11
     6fa:	01 96       	adiw	r24, 0x01	; 1
     6fc:	a1 1d       	adc	r26, r1
     6fe:	b1 1d       	adc	r27, r1
     700:	86 87       	std	Z+14, r24	; 0x0e
     702:	97 87       	std	Z+15, r25	; 0x0f
     704:	a0 8b       	std	Z+16, r26	; 0x10
     706:	b1 8b       	std	Z+17, r27	; 0x11
     708:	41 e0       	ldi	r20, 0x01	; 1
     70a:	50 e0       	ldi	r21, 0x00	; 0
     70c:	60 e0       	ldi	r22, 0x00	; 0
     70e:	70 e0       	ldi	r23, 0x00	; 0
     710:	ce 01       	movw	r24, r28
     712:	01 96       	adiw	r24, 0x01	; 1
     714:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <vTaskDelayUntil>
     718:	e8 cf       	rjmp	.-48     	; 0x6ea <_ZN15EncoderPendulum3runEv+0x52>

0000071a <_ZN15EncoderPendulumC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


EncoderPendulum::EncoderPendulum(const char* a_name,
     71a:	0f 93       	push	r16
     71c:	1f 93       	push	r17
     71e:	cf 93       	push	r28
     720:	df 93       	push	r29
     722:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     724:	0e 94 2c 12 	call	0x2458	; 0x2458 <_ZN8frt_taskC1EPKchjP8emstream>
     728:	82 e1       	ldi	r24, 0x12	; 18
     72a:	90 e2       	ldi	r25, 0x20	; 32
     72c:	88 83       	st	Y, r24
     72e:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     730:	df 91       	pop	r29
     732:	cf 91       	pop	r28
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	08 95       	ret

0000073a <_ZN13LimitSwitches3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void LimitSwitches::run(void){
     73a:	cf 93       	push	r28
     73c:	df 93       	push	r29
     73e:	00 d0       	rcall	.+0      	; 0x740 <_ZN13LimitSwitches3runEv+0x6>
     740:	1f 92       	push	r1
     742:	cd b7       	in	r28, 0x3d	; 61
     744:	de b7       	in	r29, 0x3e	; 62
     746:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     748:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <xTaskGetTickCount>
     74c:	69 83       	std	Y+1, r22	; 0x01
     74e:	7a 83       	std	Y+2, r23	; 0x02
     750:	8b 83       	std	Y+3, r24	; 0x03
     752:	9c 83       	std	Y+4, r25	; 0x04

	while(1){
		// Increment counter for debugging
		runs++;
     754:	f8 01       	movw	r30, r16
     756:	86 85       	ldd	r24, Z+14	; 0x0e
     758:	97 85       	ldd	r25, Z+15	; 0x0f
     75a:	a0 89       	ldd	r26, Z+16	; 0x10
     75c:	b1 89       	ldd	r27, Z+17	; 0x11
     75e:	01 96       	adiw	r24, 0x01	; 1
     760:	a1 1d       	adc	r26, r1
     762:	b1 1d       	adc	r27, r1
     764:	86 87       	std	Z+14, r24	; 0x0e
     766:	97 87       	std	Z+15, r25	; 0x0f
     768:	a0 8b       	std	Z+16, r26	; 0x10
     76a:	b1 8b       	std	Z+17, r27	; 0x11
     76c:	41 e0       	ldi	r20, 0x01	; 1
     76e:	50 e0       	ldi	r21, 0x00	; 0
     770:	60 e0       	ldi	r22, 0x00	; 0
     772:	70 e0       	ldi	r23, 0x00	; 0
     774:	ce 01       	movw	r24, r28
     776:	01 96       	adiw	r24, 0x01	; 1
     778:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <vTaskDelayUntil>
     77c:	eb cf       	rjmp	.-42     	; 0x754 <_ZN13LimitSwitches3runEv+0x1a>

0000077e <_ZN13LimitSwitchesC1EPKchjP8emstream>:
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

LimitSwitches::LimitSwitches(const char* a_name,
     77e:	0f 93       	push	r16
     780:	1f 93       	push	r17
     782:	cf 93       	push	r28
     784:	df 93       	push	r29
     786:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     788:	0e 94 2c 12 	call	0x2458	; 0x2458 <_ZN8frt_taskC1EPKchjP8emstream>
     78c:	8a e1       	ldi	r24, 0x1A	; 26
     78e:	90 e2       	ldi	r25, 0x20	; 32
     790:	88 83       	st	Y, r24
     792:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     794:	df 91       	pop	r29
     796:	cf 91       	pop	r28
     798:	1f 91       	pop	r17
     79a:	0f 91       	pop	r16
     79c:	08 95       	ret

0000079e <_ZN5Motor3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void Motor::run(void){
     79e:	cf 93       	push	r28
     7a0:	df 93       	push	r29
     7a2:	00 d0       	rcall	.+0      	; 0x7a4 <_ZN5Motor3runEv+0x6>
     7a4:	1f 92       	push	r1
     7a6:	cd b7       	in	r28, 0x3d	; 61
     7a8:	de b7       	in	r29, 0x3e	; 62
     7aa:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7ac:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <xTaskGetTickCount>
     7b0:	69 83       	std	Y+1, r22	; 0x01
     7b2:	7a 83       	std	Y+2, r23	; 0x02
     7b4:	8b 83       	std	Y+3, r24	; 0x03
     7b6:	9c 83       	std	Y+4, r25	; 0x04

	while(1){
		// Increment counter for debugging
		runs++;
     7b8:	f8 01       	movw	r30, r16
     7ba:	86 85       	ldd	r24, Z+14	; 0x0e
     7bc:	97 85       	ldd	r25, Z+15	; 0x0f
     7be:	a0 89       	ldd	r26, Z+16	; 0x10
     7c0:	b1 89       	ldd	r27, Z+17	; 0x11
     7c2:	01 96       	adiw	r24, 0x01	; 1
     7c4:	a1 1d       	adc	r26, r1
     7c6:	b1 1d       	adc	r27, r1
     7c8:	86 87       	std	Z+14, r24	; 0x0e
     7ca:	97 87       	std	Z+15, r25	; 0x0f
     7cc:	a0 8b       	std	Z+16, r26	; 0x10
     7ce:	b1 8b       	std	Z+17, r27	; 0x11
     7d0:	41 e0       	ldi	r20, 0x01	; 1
     7d2:	50 e0       	ldi	r21, 0x00	; 0
     7d4:	60 e0       	ldi	r22, 0x00	; 0
     7d6:	70 e0       	ldi	r23, 0x00	; 0
     7d8:	ce 01       	movw	r24, r28
     7da:	01 96       	adiw	r24, 0x01	; 1
     7dc:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <vTaskDelayUntil>
     7e0:	eb cf       	rjmp	.-42     	; 0x7b8 <_ZN5Motor3runEv+0x1a>

000007e2 <_ZN5MotorC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


Motor::Motor(const char* a_name,
     7e2:	0f 93       	push	r16
     7e4:	1f 93       	push	r17
     7e6:	cf 93       	push	r28
     7e8:	df 93       	push	r29
     7ea:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     7ec:	0e 94 2c 12 	call	0x2458	; 0x2458 <_ZN8frt_taskC1EPKchjP8emstream>
     7f0:	82 e2       	ldi	r24, 0x22	; 34
     7f2:	90 e2       	ldi	r25, 0x20	; 32
     7f4:	88 83       	st	Y, r24
     7f6:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     7f8:	df 91       	pop	r29
     7fa:	cf 91       	pop	r28
     7fc:	1f 91       	pop	r17
     7fe:	0f 91       	pop	r16
     800:	08 95       	ret

00000802 <_ZN3pid3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void pid::run(void){
     802:	cf 93       	push	r28
     804:	df 93       	push	r29
     806:	00 d0       	rcall	.+0      	; 0x808 <_ZN3pid3runEv+0x6>
     808:	1f 92       	push	r1
     80a:	cd b7       	in	r28, 0x3d	; 61
     80c:	de b7       	in	r29, 0x3e	; 62
     80e:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     810:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <xTaskGetTickCount>
     814:	69 83       	std	Y+1, r22	; 0x01
     816:	7a 83       	std	Y+2, r23	; 0x02
     818:	8b 83       	std	Y+3, r24	; 0x03
     81a:	9c 83       	std	Y+4, r25	; 0x04

	while(1){
		// Increment counter for debugging
		runs++;
     81c:	f8 01       	movw	r30, r16
     81e:	86 85       	ldd	r24, Z+14	; 0x0e
     820:	97 85       	ldd	r25, Z+15	; 0x0f
     822:	a0 89       	ldd	r26, Z+16	; 0x10
     824:	b1 89       	ldd	r27, Z+17	; 0x11
     826:	01 96       	adiw	r24, 0x01	; 1
     828:	a1 1d       	adc	r26, r1
     82a:	b1 1d       	adc	r27, r1
     82c:	86 87       	std	Z+14, r24	; 0x0e
     82e:	97 87       	std	Z+15, r25	; 0x0f
     830:	a0 8b       	std	Z+16, r26	; 0x10
     832:	b1 8b       	std	Z+17, r27	; 0x11
     834:	41 e0       	ldi	r20, 0x01	; 1
     836:	50 e0       	ldi	r21, 0x00	; 0
     838:	60 e0       	ldi	r22, 0x00	; 0
     83a:	70 e0       	ldi	r23, 0x00	; 0
     83c:	ce 01       	movw	r24, r28
     83e:	01 96       	adiw	r24, 0x01	; 1
     840:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <vTaskDelayUntil>
     844:	eb cf       	rjmp	.-42     	; 0x81c <_ZN3pid3runEv+0x1a>

00000846 <_ZN3pidC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


pid::pid (const char* a_name,
     846:	0f 93       	push	r16
     848:	1f 93       	push	r17
     84a:	cf 93       	push	r28
     84c:	df 93       	push	r29
     84e:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     850:	0e 94 2c 12 	call	0x2458	; 0x2458 <_ZN8frt_taskC1EPKchjP8emstream>
     854:	8a e2       	ldi	r24, 0x2A	; 42
     856:	90 e2       	ldi	r25, 0x20	; 32
     858:	88 83       	st	Y, r24
     85a:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     85c:	df 91       	pop	r29
     85e:	cf 91       	pop	r28
     860:	1f 91       	pop	r17
     862:	0f 91       	pop	r16
     864:	08 95       	ret

00000866 <_ZN9PWMdriver3runEv>:
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
	{
		// Nothing to do in this constructor other than call the parent constructor
	}

void PWMdriver::run(void){
     866:	cf 93       	push	r28
     868:	df 93       	push	r29
     86a:	00 d0       	rcall	.+0      	; 0x86c <_ZN9PWMdriver3runEv+0x6>
     86c:	1f 92       	push	r1
     86e:	cd b7       	in	r28, 0x3d	; 61
     870:	de b7       	in	r29, 0x3e	; 62
     872:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     874:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <xTaskGetTickCount>
     878:	69 83       	std	Y+1, r22	; 0x01
     87a:	7a 83       	std	Y+2, r23	; 0x02
     87c:	8b 83       	std	Y+3, r24	; 0x03
     87e:	9c 83       	std	Y+4, r25	; 0x04

	while(1){
		// Increment counter for debugging
		runs++;
     880:	f8 01       	movw	r30, r16
     882:	86 85       	ldd	r24, Z+14	; 0x0e
     884:	97 85       	ldd	r25, Z+15	; 0x0f
     886:	a0 89       	ldd	r26, Z+16	; 0x10
     888:	b1 89       	ldd	r27, Z+17	; 0x11
     88a:	01 96       	adiw	r24, 0x01	; 1
     88c:	a1 1d       	adc	r26, r1
     88e:	b1 1d       	adc	r27, r1
     890:	86 87       	std	Z+14, r24	; 0x0e
     892:	97 87       	std	Z+15, r25	; 0x0f
     894:	a0 8b       	std	Z+16, r26	; 0x10
     896:	b1 8b       	std	Z+17, r27	; 0x11
     898:	41 e0       	ldi	r20, 0x01	; 1
     89a:	50 e0       	ldi	r21, 0x00	; 0
     89c:	60 e0       	ldi	r22, 0x00	; 0
     89e:	70 e0       	ldi	r23, 0x00	; 0
     8a0:	ce 01       	movw	r24, r28
     8a2:	01 96       	adiw	r24, 0x01	; 1
     8a4:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <vTaskDelayUntil>
     8a8:	eb cf       	rjmp	.-42     	; 0x880 <_ZN9PWMdriver3runEv+0x1a>

000008aa <_ZN9PWMdriverC1EPKchjP8emstream>:
#include "LimitSwitches.h"					// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file


PWMdriver::PWMdriver(const char* a_name,
     8aa:	0f 93       	push	r16
     8ac:	1f 93       	push	r17
     8ae:	cf 93       	push	r28
     8b0:	df 93       	push	r29
     8b2:	ec 01       	movw	r28, r24
								size_t a_stack_size,
								emstream* p_ser_dev
								)
								
	// Call the parent (task base) constructor
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8b4:	0e 94 2c 12 	call	0x2458	; 0x2458 <_ZN8frt_taskC1EPKchjP8emstream>
     8b8:	82 e3       	ldi	r24, 0x32	; 50
     8ba:	90 e2       	ldi	r25, 0x20	; 32
     8bc:	88 83       	st	Y, r24
     8be:	99 83       	std	Y+1, r25	; 0x01
	{
		// Nothing to do in this constructor other than call the parent constructor
	}
     8c0:	df 91       	pop	r29
     8c2:	cf 91       	pop	r28
     8c4:	1f 91       	pop	r17
     8c6:	0f 91       	pop	r16
     8c8:	08 95       	ret

000008ca <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     8ca:	0f 93       	push	r16
     8cc:	1f 93       	push	r17
     8ce:	cf 93       	push	r28
     8d0:	df 93       	push	r29
     8d2:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     8d4:	0e 94 2c 12 	call	0x2458	; 0x2458 <_ZN8frt_taskC1EPKchjP8emstream>
     8d8:	8a e3       	ldi	r24, 0x3A	; 58
     8da:	90 e2       	ldi	r25, 0x20	; 32
     8dc:	88 83       	st	Y, r24
     8de:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     8e0:	df 91       	pop	r29
     8e2:	cf 91       	pop	r28
     8e4:	1f 91       	pop	r17
     8e6:	0f 91       	pop	r16
     8e8:	08 95       	ret

000008ea <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     8ea:	0f 93       	push	r16
     8ec:	1f 93       	push	r17
     8ee:	cf 93       	push	r28
     8f0:	df 93       	push	r29
     8f2:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     8f4:	6a e0       	ldi	r22, 0x0A	; 10
     8f6:	8e 81       	ldd	r24, Y+6	; 0x06
     8f8:	9f 81       	ldd	r25, Y+7	; 0x07
     8fa:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     8fe:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     900:	61 ef       	ldi	r22, 0xF1	; 241
     902:	73 e0       	ldi	r23, 0x03	; 3
     904:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     908:	6a e0       	ldi	r22, 0x0A	; 10
     90a:	c8 01       	movw	r24, r16
     90c:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     910:	8c 01       	movw	r16, r24
     912:	6b ee       	ldi	r22, 0xEB	; 235
     914:	73 e0       	ldi	r23, 0x03	; 3
     916:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     91a:	67 e0       	ldi	r22, 0x07	; 7
     91c:	c8 01       	movw	r24, r16
     91e:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     922:	6a e0       	ldi	r22, 0x0A	; 10
     924:	8e 81       	ldd	r24, Y+6	; 0x06
     926:	9f 81       	ldd	r25, Y+7	; 0x07
     928:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     92c:	8c 01       	movw	r16, r24
     92e:	6c ec       	ldi	r22, 0xCC	; 204
     930:	73 e0       	ldi	r23, 0x03	; 3
     932:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     936:	6a e0       	ldi	r22, 0x0A	; 10
     938:	c8 01       	movw	r24, r16
     93a:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     93e:	8c 01       	movw	r16, r24
     940:	66 ec       	ldi	r22, 0xC6	; 198
     942:	73 e0       	ldi	r23, 0x03	; 3
     944:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     948:	66 e0       	ldi	r22, 0x06	; 6
     94a:	c8 01       	movw	r24, r16
     94c:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     950:	6a e0       	ldi	r22, 0x0A	; 10
     952:	8e 81       	ldd	r24, Y+6	; 0x06
     954:	9f 81       	ldd	r25, Y+7	; 0x07
     956:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     95a:	8c 01       	movw	r16, r24
     95c:	6f ea       	ldi	r22, 0xAF	; 175
     95e:	73 e0       	ldi	r23, 0x03	; 3
     960:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     964:	66 e0       	ldi	r22, 0x06	; 6
     966:	c8 01       	movw	r24, r16
     968:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     96c:	6a e0       	ldi	r22, 0x0A	; 10
     96e:	8e 81       	ldd	r24, Y+6	; 0x06
     970:	9f 81       	ldd	r25, Y+7	; 0x07
     972:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     976:	8c 01       	movw	r16, r24
     978:	63 e9       	ldi	r22, 0x93	; 147
     97a:	73 e0       	ldi	r23, 0x03	; 3
     97c:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     980:	66 e0       	ldi	r22, 0x06	; 6
     982:	c8 01       	movw	r24, r16
     984:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     988:	6a e0       	ldi	r22, 0x0A	; 10
     98a:	8e 81       	ldd	r24, Y+6	; 0x06
     98c:	9f 81       	ldd	r25, Y+7	; 0x07
     98e:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     992:	8c 01       	movw	r16, r24
     994:	6b e7       	ldi	r22, 0x7B	; 123
     996:	73 e0       	ldi	r23, 0x03	; 3
     998:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     99c:	66 e0       	ldi	r22, 0x06	; 6
     99e:	c8 01       	movw	r24, r16
     9a0:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     9a4:	6a e0       	ldi	r22, 0x0A	; 10
     9a6:	8e 81       	ldd	r24, Y+6	; 0x06
     9a8:	9f 81       	ldd	r25, Y+7	; 0x07
     9aa:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     9ae:	8c 01       	movw	r16, r24
     9b0:	6a e5       	ldi	r22, 0x5A	; 90
     9b2:	73 e0       	ldi	r23, 0x03	; 3
     9b4:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     9b8:	66 e0       	ldi	r22, 0x06	; 6
     9ba:	c8 01       	movw	r24, r16
     9bc:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     9c0:	6a e0       	ldi	r22, 0x0A	; 10
     9c2:	8e 81       	ldd	r24, Y+6	; 0x06
     9c4:	9f 81       	ldd	r25, Y+7	; 0x07
     9c6:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     9ca:	8c 01       	movw	r16, r24
     9cc:	63 e3       	ldi	r22, 0x33	; 51
     9ce:	73 e0       	ldi	r23, 0x03	; 3
     9d0:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     9d4:	66 e0       	ldi	r22, 0x06	; 6
     9d6:	c8 01       	movw	r24, r16
     9d8:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     9dc:	6a e0       	ldi	r22, 0x0A	; 10
     9de:	8e 81       	ldd	r24, Y+6	; 0x06
     9e0:	9f 81       	ldd	r25, Y+7	; 0x07
     9e2:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     9e6:	8c 01       	movw	r16, r24
     9e8:	65 e1       	ldi	r22, 0x15	; 21
     9ea:	73 e0       	ldi	r23, 0x03	; 3
     9ec:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     9f0:	66 e0       	ldi	r22, 0x06	; 6
     9f2:	c8 01       	movw	r24, r16
     9f4:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     9f8:	6a e0       	ldi	r22, 0x0A	; 10
     9fa:	8e 81       	ldd	r24, Y+6	; 0x06
     9fc:	9f 81       	ldd	r25, Y+7	; 0x07
     9fe:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     a02:	8c 01       	movw	r16, r24
     a04:	6a ef       	ldi	r22, 0xFA	; 250
     a06:	72 e0       	ldi	r23, 0x02	; 2
     a08:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     a0c:	66 e0       	ldi	r22, 0x06	; 6
     a0e:	c8 01       	movw	r24, r16
     a10:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     a14:	6a e0       	ldi	r22, 0x0A	; 10
     a16:	8e 81       	ldd	r24, Y+6	; 0x06
     a18:	9f 81       	ldd	r25, Y+7	; 0x07
     a1a:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     a1e:	ec 01       	movw	r28, r24
     a20:	6b ee       	ldi	r22, 0xEB	; 235
     a22:	72 e0       	ldi	r23, 0x02	; 2
     a24:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     a28:	66 e0       	ldi	r22, 0x06	; 6
     a2a:	ce 01       	movw	r24, r28
     a2c:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
}
     a30:	df 91       	pop	r29
     a32:	cf 91       	pop	r28
     a34:	1f 91       	pop	r17
     a36:	0f 91       	pop	r16
     a38:	08 95       	ret

00000a3a <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     a3a:	af 92       	push	r10
     a3c:	bf 92       	push	r11
     a3e:	cf 92       	push	r12
     a40:	df 92       	push	r13
     a42:	ef 92       	push	r14
     a44:	ff 92       	push	r15
     a46:	0f 93       	push	r16
     a48:	1f 93       	push	r17
     a4a:	cf 93       	push	r28
     a4c:	df 93       	push	r29
     a4e:	00 d0       	rcall	.+0      	; 0xa50 <_ZN9task_user11show_statusEv+0x16>
     a50:	00 d0       	rcall	.+0      	; 0xa52 <_ZN9task_user11show_statusEv+0x18>
     a52:	cd b7       	in	r28, 0x3d	; 61
     a54:	de b7       	in	r29, 0x3e	; 62
     a56:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     a58:	19 82       	std	Y+1, r1	; 0x01
     a5a:	1a 82       	std	Y+2, r1	; 0x02
     a5c:	1b 82       	std	Y+3, r1	; 0x03
     a5e:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     a60:	1d 82       	std	Y+5, r1	; 0x05
     a62:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     a64:	0e 94 a2 07 	call	0xf44	; 0xf44 <xPortGetFreeHeapSize>
     a68:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     a6a:	ce 01       	movw	r24, r28
     a6c:	01 96       	adiw	r24, 0x01	; 1
     a6e:	0e 94 dd 15 	call	0x2bba	; 0x2bba <_ZN10time_stamp10set_to_nowEv>
     a72:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     a74:	66 e0       	ldi	r22, 0x06	; 6
     a76:	f8 01       	movw	r30, r16
     a78:	86 81       	ldd	r24, Z+6	; 0x06
     a7a:	97 81       	ldd	r25, Z+7	; 0x07
     a7c:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     a80:	6a e0       	ldi	r22, 0x0A	; 10
     a82:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     a86:	7c 01       	movw	r14, r24
     a88:	6c ec       	ldi	r22, 0xCC	; 204
     a8a:	72 e0       	ldi	r23, 0x02	; 2
     a8c:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     a90:	6a e0       	ldi	r22, 0x0A	; 10
     a92:	c7 01       	movw	r24, r14
     a94:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     a98:	7c 01       	movw	r14, r24
     a9a:	60 ec       	ldi	r22, 0xC0	; 192
     a9c:	72 e0       	ldi	r23, 0x02	; 2
     a9e:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     aa2:	66 e0       	ldi	r22, 0x06	; 6
     aa4:	c7 01       	movw	r24, r14
     aa6:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     aaa:	6a e0       	ldi	r22, 0x0A	; 10
     aac:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     ab0:	7c 01       	movw	r14, r24
     ab2:	69 eb       	ldi	r22, 0xB9	; 185
     ab4:	72 e0       	ldi	r23, 0x02	; 2
     ab6:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     aba:	b5 01       	movw	r22, r10
     abc:	c7 01       	movw	r24, r14
     abe:	0e 94 81 15 	call	0x2b02	; 0x2b02 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     ac2:	6a e0       	ldi	r22, 0x0A	; 10
     ac4:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     ac8:	7c 01       	movw	r14, r24
     aca:	6b ea       	ldi	r22, 0xAB	; 171
     acc:	72 e0       	ldi	r23, 0x02	; 2
     ace:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     ad2:	b6 01       	movw	r22, r12
     ad4:	c7 01       	movw	r24, r14
     ad6:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <_ZN8emstreamlsEj>
     ada:	6a e0       	ldi	r22, 0x0A	; 10
     adc:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     ae0:	7c 01       	movw	r14, r24
     ae2:	69 ea       	ldi	r22, 0xA9	; 169
     ae4:	72 e0       	ldi	r23, 0x02	; 2
     ae6:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     aea:	4f ef       	ldi	r20, 0xFF	; 255
     aec:	5f e0       	ldi	r21, 0x0F	; 15
     aee:	60 e0       	ldi	r22, 0x00	; 0
     af0:	70 e0       	ldi	r23, 0x00	; 0
     af2:	c7 01       	movw	r24, r14
     af4:	0e 94 26 18 	call	0x304c	; 0x304c <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     af8:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     afc:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     b00:	6a e0       	ldi	r22, 0x0A	; 10
     b02:	f8 01       	movw	r30, r16
     b04:	86 81       	ldd	r24, Z+6	; 0x06
     b06:	97 81       	ldd	r25, Z+7	; 0x07
     b08:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     b0c:	7c 01       	movw	r14, r24
     b0e:	6e e9       	ldi	r22, 0x9E	; 158
     b10:	72 e0       	ldi	r23, 0x02	; 2
     b12:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     b16:	b6 01       	movw	r22, r12
     b18:	c7 01       	movw	r24, r14
     b1a:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <_ZN8emstreamlsEj>
     b1e:	66 e0       	ldi	r22, 0x06	; 6
     b20:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     b24:	66 e0       	ldi	r22, 0x06	; 6
     b26:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     b2a:	f8 01       	movw	r30, r16
     b2c:	86 81       	ldd	r24, Z+6	; 0x06
     b2e:	97 81       	ldd	r25, Z+7	; 0x07
     b30:	0e 94 3a 14 	call	0x2874	; 0x2874 <_Z15print_task_listP8emstream>
}
     b34:	26 96       	adiw	r28, 0x06	; 6
     b36:	cd bf       	out	0x3d, r28	; 61
     b38:	de bf       	out	0x3e, r29	; 62
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	1f 91       	pop	r17
     b40:	0f 91       	pop	r16
     b42:	ff 90       	pop	r15
     b44:	ef 90       	pop	r14
     b46:	df 90       	pop	r13
     b48:	cf 90       	pop	r12
     b4a:	bf 90       	pop	r11
     b4c:	af 90       	pop	r10
     b4e:	08 95       	ret

00000b50 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     b50:	cf 93       	push	r28
     b52:	df 93       	push	r29
     b54:	00 d0       	rcall	.+0      	; 0xb56 <_ZN9task_user3runEv+0x6>
     b56:	00 d0       	rcall	.+0      	; 0xb58 <_ZN9task_user3runEv+0x8>
     b58:	cd b7       	in	r28, 0x3d	; 61
     b5a:	de b7       	in	r29, 0x3e	; 62
     b5c:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     b5e:	19 82       	std	Y+1, r1	; 0x01
     b60:	1a 82       	std	Y+2, r1	; 0x02
     b62:	1b 82       	std	Y+3, r1	; 0x03
     b64:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     b66:	1d 82       	std	Y+5, r1	; 0x05
     b68:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     b6a:	6a e0       	ldi	r22, 0x0A	; 10
     b6c:	dc 01       	movw	r26, r24
     b6e:	16 96       	adiw	r26, 0x06	; 6
     b70:	8d 91       	ld	r24, X+
     b72:	9c 91       	ld	r25, X
     b74:	17 97       	sbiw	r26, 0x07	; 7
     b76:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     b7a:	7c 01       	movw	r14, r24
     b7c:	6a e3       	ldi	r22, 0x3A	; 58
     b7e:	74 e0       	ldi	r23, 0x04	; 4
     b80:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     b84:	66 e0       	ldi	r22, 0x06	; 6
     b86:	c7 01       	movw	r24, r14
     b88:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     b8c:	f8 01       	movw	r30, r16
     b8e:	84 85       	ldd	r24, Z+12	; 0x0c
     b90:	88 23       	and	r24, r24
     b92:	21 f0       	breq	.+8      	; 0xb9c <_ZN9task_user3runEv+0x4c>
     b94:	81 30       	cpi	r24, 0x01	; 1
     b96:	09 f4       	brne	.+2      	; 0xb9a <_ZN9task_user3runEv+0x4a>
     b98:	5d c0       	rjmp	.+186    	; 0xc54 <_ZN9task_user3runEv+0x104>
     b9a:	d8 c0       	rjmp	.+432    	; 0xd4c <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     b9c:	86 81       	ldd	r24, Z+6	; 0x06
     b9e:	97 81       	ldd	r25, Z+7	; 0x07
     ba0:	dc 01       	movw	r26, r24
     ba2:	ed 91       	ld	r30, X+
     ba4:	fc 91       	ld	r31, X
     ba6:	04 80       	ldd	r0, Z+4	; 0x04
     ba8:	f5 81       	ldd	r31, Z+5	; 0x05
     baa:	e0 2d       	mov	r30, r0
     bac:	19 95       	eicall
     bae:	88 23       	and	r24, r24
     bb0:	a9 f1       	breq	.+106    	; 0xc1c <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     bb2:	f8 01       	movw	r30, r16
     bb4:	86 81       	ldd	r24, Z+6	; 0x06
     bb6:	97 81       	ldd	r25, Z+7	; 0x07
     bb8:	dc 01       	movw	r26, r24
     bba:	ed 91       	ld	r30, X+
     bbc:	fc 91       	ld	r31, X
     bbe:	06 80       	ldd	r0, Z+6	; 0x06
     bc0:	f7 81       	ldd	r31, Z+7	; 0x07
     bc2:	e0 2d       	mov	r30, r0
     bc4:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     bc6:	99 27       	eor	r25, r25
     bc8:	81 30       	cpi	r24, 0x01	; 1
     bca:	91 05       	cpc	r25, r1
     bcc:	f9 f0       	breq	.+62     	; 0xc0c <_ZN9task_user3runEv+0xbc>
     bce:	03 97       	sbiw	r24, 0x03	; 3
     bd0:	09 f0       	breq	.+2      	; 0xbd4 <_ZN9task_user3runEv+0x84>
     bd2:	d8 c0       	rjmp	.+432    	; 0xd84 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     bd4:	6a e0       	ldi	r22, 0x0A	; 10
     bd6:	f8 01       	movw	r30, r16
     bd8:	86 81       	ldd	r24, Z+6	; 0x06
     bda:	97 81       	ldd	r25, Z+7	; 0x07
     bdc:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     be0:	8c 01       	movw	r16, r24
     be2:	6c e2       	ldi	r22, 0x2C	; 44
     be4:	74 e0       	ldi	r23, 0x04	; 4
     be6:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     bea:	66 e0       	ldi	r22, 0x06	; 6
     bec:	c8 01       	movw	r24, r16
     bee:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     bf2:	93 e0       	ldi	r25, 0x03	; 3
     bf4:	88 ed       	ldi	r24, 0xD8	; 216
     bf6:	08 b6       	in	r0, 0x38	; 56
     bf8:	18 be       	out	0x38, r1	; 56
     bfa:	84 bf       	out	0x34, r24	; 52
     bfc:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     c00:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     c04:	81 fd       	sbrc	r24, 1
     c06:	fc cf       	rjmp	.-8      	; 0xc00 <_ZN9task_user3runEv+0xb0>
     c08:	08 be       	out	0x38, r0	; 56
     c0a:	ff cf       	rjmp	.-2      	; 0xc0a <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     c0c:	c8 01       	movw	r24, r16
     c0e:	0e 94 75 04 	call	0x8ea	; 0x8ea <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     c12:	61 e0       	ldi	r22, 0x01	; 1
     c14:	c8 01       	movw	r24, r16
     c16:	0e 94 28 12 	call	0x2450	; 0x2450 <_ZN8frt_task13transition_toEh>
							break;
     c1a:	b4 c0       	rjmp	.+360    	; 0xd84 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     c1c:	82 e6       	ldi	r24, 0x62	; 98
     c1e:	91 e3       	ldi	r25, 0x31	; 49
     c20:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <_ZN14frt_text_queue14check_for_charEv>
     c24:	88 23       	and	r24, r24
     c26:	09 f4       	brne	.+2      	; 0xc2a <_ZN9task_user3runEv+0xda>
     c28:	ad c0       	rjmp	.+346    	; 0xd84 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     c2a:	d8 01       	movw	r26, r16
     c2c:	16 96       	adiw	r26, 0x06	; 6
     c2e:	ed 91       	ld	r30, X+
     c30:	fc 91       	ld	r31, X
     c32:	17 97       	sbiw	r26, 0x07	; 7
     c34:	01 90       	ld	r0, Z+
     c36:	f0 81       	ld	r31, Z
     c38:	e0 2d       	mov	r30, r0
     c3a:	e2 80       	ldd	r14, Z+2	; 0x02
     c3c:	f3 80       	ldd	r15, Z+3	; 0x03
     c3e:	82 e6       	ldi	r24, 0x62	; 98
     c40:	91 e3       	ldi	r25, 0x31	; 49
     c42:	0e 94 cb 14 	call	0x2996	; 0x2996 <_ZN14frt_text_queue7getcharEv>
     c46:	68 2f       	mov	r22, r24
     c48:	f8 01       	movw	r30, r16
     c4a:	86 81       	ldd	r24, Z+6	; 0x06
     c4c:	97 81       	ldd	r25, Z+7	; 0x07
     c4e:	f7 01       	movw	r30, r14
     c50:	19 95       	eicall
     c52:	98 c0       	rjmp	.+304    	; 0xd84 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     c54:	86 81       	ldd	r24, Z+6	; 0x06
     c56:	97 81       	ldd	r25, Z+7	; 0x07
     c58:	dc 01       	movw	r26, r24
     c5a:	ed 91       	ld	r30, X+
     c5c:	fc 91       	ld	r31, X
     c5e:	04 80       	ldd	r0, Z+4	; 0x04
     c60:	f5 81       	ldd	r31, Z+5	; 0x05
     c62:	e0 2d       	mov	r30, r0
     c64:	19 95       	eicall
     c66:	88 23       	and	r24, r24
     c68:	09 f4       	brne	.+2      	; 0xc6c <_ZN9task_user3runEv+0x11c>
     c6a:	8c c0       	rjmp	.+280    	; 0xd84 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     c6c:	f8 01       	movw	r30, r16
     c6e:	86 81       	ldd	r24, Z+6	; 0x06
     c70:	97 81       	ldd	r25, Z+7	; 0x07
     c72:	dc 01       	movw	r26, r24
     c74:	ed 91       	ld	r30, X+
     c76:	fc 91       	ld	r31, X
     c78:	06 80       	ldd	r0, Z+6	; 0x06
     c7a:	f7 81       	ldd	r31, Z+7	; 0x07
     c7c:	e0 2d       	mov	r30, r0
     c7e:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     c80:	9c 01       	movw	r18, r24
     c82:	33 27       	eor	r19, r19
     c84:	28 36       	cpi	r18, 0x68	; 104
     c86:	31 05       	cpc	r19, r1
     c88:	59 f1       	breq	.+86     	; 0xce0 <_ZN9task_user3runEv+0x190>
     c8a:	3c f4       	brge	.+14     	; 0xc9a <_ZN9task_user3runEv+0x14a>
     c8c:	2b 31       	cpi	r18, 0x1B	; 27
     c8e:	31 05       	cpc	r19, r1
     c90:	59 f1       	breq	.+86     	; 0xce8 <_ZN9task_user3runEv+0x198>
     c92:	25 36       	cpi	r18, 0x65	; 101
     c94:	31 05       	cpc	r19, r1
     c96:	41 f1       	breq	.+80     	; 0xce8 <_ZN9task_user3runEv+0x198>
     c98:	3b c0       	rjmp	.+118    	; 0xd10 <_ZN9task_user3runEv+0x1c0>
     c9a:	23 37       	cpi	r18, 0x73	; 115
     c9c:	31 05       	cpc	r19, r1
     c9e:	c1 f0       	breq	.+48     	; 0xcd0 <_ZN9task_user3runEv+0x180>
     ca0:	26 37       	cpi	r18, 0x76	; 118
     ca2:	31 05       	cpc	r19, r1
     ca4:	89 f0       	breq	.+34     	; 0xcc8 <_ZN9task_user3runEv+0x178>
     ca6:	2e 36       	cpi	r18, 0x6E	; 110
     ca8:	31 05       	cpc	r19, r1
     caa:	91 f5       	brne	.+100    	; 0xd10 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     cac:	ce 01       	movw	r24, r28
     cae:	01 96       	adiw	r24, 0x01	; 1
     cb0:	0e 94 dd 15 	call	0x2bba	; 0x2bba <_ZN10time_stamp10set_to_nowEv>
     cb4:	bc 01       	movw	r22, r24
     cb6:	f8 01       	movw	r30, r16
     cb8:	86 81       	ldd	r24, Z+6	; 0x06
     cba:	97 81       	ldd	r25, Z+7	; 0x07
     cbc:	0e 94 81 15 	call	0x2b02	; 0x2b02 <_ZlsR8emstreamR10time_stamp>
     cc0:	66 e0       	ldi	r22, 0x06	; 6
     cc2:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
							break;
     cc6:	5e c0       	rjmp	.+188    	; 0xd84 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     cc8:	c8 01       	movw	r24, r16
     cca:	0e 94 1d 05 	call	0xa3a	; 0xa3a <_ZN9task_user11show_statusEv>
							break;
     cce:	5a c0       	rjmp	.+180    	; 0xd84 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     cd0:	d8 01       	movw	r26, r16
     cd2:	16 96       	adiw	r26, 0x06	; 6
     cd4:	8d 91       	ld	r24, X+
     cd6:	9c 91       	ld	r25, X
     cd8:	17 97       	sbiw	r26, 0x07	; 7
     cda:	0e 94 41 13 	call	0x2682	; 0x2682 <_Z17print_task_stacksP8emstream>
							break;
     cde:	52 c0       	rjmp	.+164    	; 0xd84 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     ce0:	c8 01       	movw	r24, r16
     ce2:	0e 94 75 04 	call	0x8ea	; 0x8ea <_ZN9task_user18print_help_messageEv>
							break;
     ce6:	4e c0       	rjmp	.+156    	; 0xd84 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     ce8:	6a e0       	ldi	r22, 0x0A	; 10
     cea:	f8 01       	movw	r30, r16
     cec:	86 81       	ldd	r24, Z+6	; 0x06
     cee:	97 81       	ldd	r25, Z+7	; 0x07
     cf0:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     cf4:	7c 01       	movw	r14, r24
     cf6:	6a e1       	ldi	r22, 0x1A	; 26
     cf8:	74 e0       	ldi	r23, 0x04	; 4
     cfa:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     cfe:	66 e0       	ldi	r22, 0x06	; 6
     d00:	c7 01       	movw	r24, r14
     d02:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     d06:	60 e0       	ldi	r22, 0x00	; 0
     d08:	c8 01       	movw	r24, r16
     d0a:	0e 94 28 12 	call	0x2450	; 0x2450 <_ZN8frt_task13transition_toEh>
							break;
     d0e:	3a c0       	rjmp	.+116    	; 0xd84 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     d10:	f8 01       	movw	r30, r16
     d12:	a6 81       	ldd	r26, Z+6	; 0x06
     d14:	b7 81       	ldd	r27, Z+7	; 0x07
     d16:	ed 91       	ld	r30, X+
     d18:	fc 91       	ld	r31, X
     d1a:	11 97       	sbiw	r26, 0x01	; 1
     d1c:	02 80       	ldd	r0, Z+2	; 0x02
     d1e:	f3 81       	ldd	r31, Z+3	; 0x03
     d20:	e0 2d       	mov	r30, r0
     d22:	68 2f       	mov	r22, r24
     d24:	cd 01       	movw	r24, r26
     d26:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     d28:	6a e0       	ldi	r22, 0x0A	; 10
     d2a:	d8 01       	movw	r26, r16
     d2c:	16 96       	adiw	r26, 0x06	; 6
     d2e:	8d 91       	ld	r24, X+
     d30:	9c 91       	ld	r25, X
     d32:	17 97       	sbiw	r26, 0x07	; 7
     d34:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     d38:	7c 01       	movw	r14, r24
     d3a:	64 e1       	ldi	r22, 0x14	; 20
     d3c:	74 e0       	ldi	r23, 0x04	; 4
     d3e:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     d42:	66 e0       	ldi	r22, 0x06	; 6
     d44:	c7 01       	movw	r24, r14
     d46:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
							break;
     d4a:	1c c0       	rjmp	.+56     	; 0xd84 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     d4c:	6a e0       	ldi	r22, 0x0A	; 10
     d4e:	f8 01       	movw	r30, r16
     d50:	86 81       	ldd	r24, Z+6	; 0x06
     d52:	97 81       	ldd	r25, Z+7	; 0x07
     d54:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
     d58:	8c 01       	movw	r16, r24
     d5a:	67 ef       	ldi	r22, 0xF7	; 247
     d5c:	73 e0       	ldi	r23, 0x03	; 3
     d5e:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
     d62:	66 e0       	ldi	r22, 0x06	; 6
     d64:	c8 01       	movw	r24, r16
     d66:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     d6a:	93 e0       	ldi	r25, 0x03	; 3
     d6c:	88 ed       	ldi	r24, 0xD8	; 216
     d6e:	08 b6       	in	r0, 0x38	; 56
     d70:	18 be       	out	0x38, r1	; 56
     d72:	84 bf       	out	0x34, r24	; 52
     d74:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     d78:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     d7c:	81 fd       	sbrc	r24, 1
     d7e:	fc cf       	rjmp	.-8      	; 0xd78 <_ZN9task_user3runEv+0x228>
     d80:	08 be       	out	0x38, r0	; 56
     d82:	ff cf       	rjmp	.-2      	; 0xd82 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     d84:	f8 01       	movw	r30, r16
     d86:	86 85       	ldd	r24, Z+14	; 0x0e
     d88:	97 85       	ldd	r25, Z+15	; 0x0f
     d8a:	a0 89       	ldd	r26, Z+16	; 0x10
     d8c:	b1 89       	ldd	r27, Z+17	; 0x11
     d8e:	01 96       	adiw	r24, 0x01	; 1
     d90:	a1 1d       	adc	r26, r1
     d92:	b1 1d       	adc	r27, r1
     d94:	86 87       	std	Z+14, r24	; 0x0e
     d96:	97 87       	std	Z+15, r25	; 0x0f
     d98:	a0 8b       	std	Z+16, r26	; 0x10
     d9a:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     d9c:	61 e0       	ldi	r22, 0x01	; 1
     d9e:	70 e0       	ldi	r23, 0x00	; 0
     da0:	80 e0       	ldi	r24, 0x00	; 0
     da2:	90 e0       	ldi	r25, 0x00	; 0
     da4:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     da8:	f1 ce       	rjmp	.-542    	; 0xb8c <_ZN9task_user3runEv+0x3c>

00000daa <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     daa:	0f 93       	push	r16
     dac:	1f 93       	push	r17
     dae:	cf 93       	push	r28
     db0:	df 93       	push	r29
     db2:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     db4:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     db8:	80 91 ca 20 	lds	r24, 0x20CA	; 0x8020ca <__data_end>
     dbc:	81 11       	cpse	r24, r1
     dbe:	1d c0       	rjmp	.+58     	; 0xdfa <pvPortMalloc+0x50>
		{
			prvHeapInit();
     dc0:	af ec       	ldi	r26, 0xCF	; 207
     dc2:	b0 e2       	ldi	r27, 0x20	; 32
     dc4:	e3 ed       	ldi	r30, 0xD3	; 211
     dc6:	f0 e2       	ldi	r31, 0x20	; 32
     dc8:	ed 93       	st	X+, r30
     dca:	fc 93       	st	X, r31
     dcc:	11 97       	sbiw	r26, 0x01	; 1
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	1d 92       	st	X+, r1
     dd2:	1c 92       	st	X, r1
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	ab ec       	ldi	r26, 0xCB	; 203
     dd8:	b0 e2       	ldi	r27, 0x20	; 32
     dda:	8f ef       	ldi	r24, 0xFF	; 255
     ddc:	9f e0       	ldi	r25, 0x0F	; 15
     dde:	12 96       	adiw	r26, 0x02	; 2
     de0:	8d 93       	st	X+, r24
     de2:	9c 93       	st	X, r25
     de4:	13 97       	sbiw	r26, 0x03	; 3
     de6:	1d 92       	st	X+, r1
     de8:	1c 92       	st	X, r1
     dea:	11 97       	sbiw	r26, 0x01	; 1
     dec:	82 83       	std	Z+2, r24	; 0x02
     dee:	93 83       	std	Z+3, r25	; 0x03
     df0:	a0 83       	st	Z, r26
     df2:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
     df4:	81 e0       	ldi	r24, 0x01	; 1
     df6:	80 93 ca 20 	sts	0x20CA, r24	; 0x8020ca <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     dfa:	20 97       	sbiw	r28, 0x00	; 0
     dfc:	09 f4       	brne	.+2      	; 0xe00 <pvPortMalloc+0x56>
     dfe:	5f c0       	rjmp	.+190    	; 0xebe <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     e00:	9e 01       	movw	r18, r28
     e02:	2b 5f       	subi	r18, 0xFB	; 251
     e04:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
     e06:	24 96       	adiw	r28, 0x04	; 4
     e08:	ce 3f       	cpi	r28, 0xFE	; 254
     e0a:	df 40       	sbci	r29, 0x0F	; 15
     e0c:	08 f0       	brcs	.+2      	; 0xe10 <pvPortMalloc+0x66>
     e0e:	5a c0       	rjmp	.+180    	; 0xec4 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     e10:	e0 91 cf 20 	lds	r30, 0x20CF	; 0x8020cf <xStart>
     e14:	f0 91 d0 20 	lds	r31, 0x20D0	; 0x8020d0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     e18:	af ec       	ldi	r26, 0xCF	; 207
     e1a:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     e1c:	02 c0       	rjmp	.+4      	; 0xe22 <pvPortMalloc+0x78>
     e1e:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     e20:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     e22:	82 81       	ldd	r24, Z+2	; 0x02
     e24:	93 81       	ldd	r25, Z+3	; 0x03
     e26:	82 17       	cp	r24, r18
     e28:	93 07       	cpc	r25, r19
     e2a:	20 f4       	brcc	.+8      	; 0xe34 <pvPortMalloc+0x8a>
     e2c:	80 81       	ld	r24, Z
     e2e:	91 81       	ldd	r25, Z+1	; 0x01
     e30:	00 97       	sbiw	r24, 0x00	; 0
     e32:	a9 f7       	brne	.-22     	; 0xe1e <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     e34:	c0 e2       	ldi	r28, 0x20	; 32
     e36:	eb 3c       	cpi	r30, 0xCB	; 203
     e38:	fc 07       	cpc	r31, r28
     e3a:	09 f4       	brne	.+2      	; 0xe3e <pvPortMalloc+0x94>
     e3c:	46 c0       	rjmp	.+140    	; 0xeca <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     e3e:	cd 91       	ld	r28, X+
     e40:	dc 91       	ld	r29, X
     e42:	11 97       	sbiw	r26, 0x01	; 1
     e44:	8e 01       	movw	r16, r28
     e46:	0b 5f       	subi	r16, 0xFB	; 251
     e48:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     e4a:	80 81       	ld	r24, Z
     e4c:	91 81       	ldd	r25, Z+1	; 0x01
     e4e:	8d 93       	st	X+, r24
     e50:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     e52:	82 81       	ldd	r24, Z+2	; 0x02
     e54:	93 81       	ldd	r25, Z+3	; 0x03
     e56:	82 1b       	sub	r24, r18
     e58:	93 0b       	sbc	r25, r19
     e5a:	8b 30       	cpi	r24, 0x0B	; 11
     e5c:	91 05       	cpc	r25, r1
     e5e:	10 f1       	brcs	.+68     	; 0xea4 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
     e60:	bf 01       	movw	r22, r30
     e62:	62 0f       	add	r22, r18
     e64:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     e66:	db 01       	movw	r26, r22
     e68:	12 96       	adiw	r26, 0x02	; 2
     e6a:	8d 93       	st	X+, r24
     e6c:	9c 93       	st	X, r25
     e6e:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
     e70:	22 83       	std	Z+2, r18	; 0x02
     e72:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     e74:	12 96       	adiw	r26, 0x02	; 2
     e76:	4d 91       	ld	r20, X+
     e78:	5c 91       	ld	r21, X
     e7a:	13 97       	sbiw	r26, 0x03	; 3
     e7c:	8f ec       	ldi	r24, 0xCF	; 207
     e7e:	90 e2       	ldi	r25, 0x20	; 32
     e80:	01 c0       	rjmp	.+2      	; 0xe84 <pvPortMalloc+0xda>
     e82:	cd 01       	movw	r24, r26
     e84:	ec 01       	movw	r28, r24
     e86:	a8 81       	ld	r26, Y
     e88:	b9 81       	ldd	r27, Y+1	; 0x01
     e8a:	12 96       	adiw	r26, 0x02	; 2
     e8c:	2d 91       	ld	r18, X+
     e8e:	3c 91       	ld	r19, X
     e90:	13 97       	sbiw	r26, 0x03	; 3
     e92:	24 17       	cp	r18, r20
     e94:	35 07       	cpc	r19, r21
     e96:	a8 f3       	brcs	.-22     	; 0xe82 <pvPortMalloc+0xd8>
     e98:	eb 01       	movw	r28, r22
     e9a:	a8 83       	st	Y, r26
     e9c:	b9 83       	std	Y+1, r27	; 0x01
     e9e:	dc 01       	movw	r26, r24
     ea0:	6d 93       	st	X+, r22
     ea2:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     ea4:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     ea8:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     eac:	22 81       	ldd	r18, Z+2	; 0x02
     eae:	33 81       	ldd	r19, Z+3	; 0x03
     eb0:	82 1b       	sub	r24, r18
     eb2:	93 0b       	sbc	r25, r19
     eb4:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     eb8:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
     ebc:	08 c0       	rjmp	.+16     	; 0xece <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     ebe:	00 e0       	ldi	r16, 0x00	; 0
     ec0:	10 e0       	ldi	r17, 0x00	; 0
     ec2:	05 c0       	rjmp	.+10     	; 0xece <pvPortMalloc+0x124>
     ec4:	00 e0       	ldi	r16, 0x00	; 0
     ec6:	10 e0       	ldi	r17, 0x00	; 0
     ec8:	02 c0       	rjmp	.+4      	; 0xece <pvPortMalloc+0x124>
     eca:	00 e0       	ldi	r16, 0x00	; 0
     ecc:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
     ece:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     ed2:	c8 01       	movw	r24, r16
     ed4:	df 91       	pop	r29
     ed6:	cf 91       	pop	r28
     ed8:	1f 91       	pop	r17
     eda:	0f 91       	pop	r16
     edc:	08 95       	ret

00000ede <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     ede:	0f 93       	push	r16
     ee0:	1f 93       	push	r17
     ee2:	cf 93       	push	r28
     ee4:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
     ee6:	00 97       	sbiw	r24, 0x00	; 0
     ee8:	41 f1       	breq	.+80     	; 0xf3a <vPortFree+0x5c>
     eea:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     eec:	8c 01       	movw	r16, r24
     eee:	05 50       	subi	r16, 0x05	; 5
     ef0:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     ef2:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
     ef6:	f8 01       	movw	r30, r16
     ef8:	42 81       	ldd	r20, Z+2	; 0x02
     efa:	53 81       	ldd	r21, Z+3	; 0x03
     efc:	af ec       	ldi	r26, 0xCF	; 207
     efe:	b0 e2       	ldi	r27, 0x20	; 32
     f00:	01 c0       	rjmp	.+2      	; 0xf04 <vPortFree+0x26>
     f02:	df 01       	movw	r26, r30
     f04:	ed 91       	ld	r30, X+
     f06:	fc 91       	ld	r31, X
     f08:	11 97       	sbiw	r26, 0x01	; 1
     f0a:	22 81       	ldd	r18, Z+2	; 0x02
     f0c:	33 81       	ldd	r19, Z+3	; 0x03
     f0e:	24 17       	cp	r18, r20
     f10:	35 07       	cpc	r19, r21
     f12:	b8 f3       	brcs	.-18     	; 0xf02 <vPortFree+0x24>
     f14:	25 97       	sbiw	r28, 0x05	; 5
     f16:	e8 83       	st	Y, r30
     f18:	f9 83       	std	Y+1, r31	; 0x01
     f1a:	0d 93       	st	X+, r16
     f1c:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     f1e:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
     f22:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
     f26:	8a 81       	ldd	r24, Y+2	; 0x02
     f28:	9b 81       	ldd	r25, Y+3	; 0x03
     f2a:	82 0f       	add	r24, r18
     f2c:	93 1f       	adc	r25, r19
     f2e:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     f32:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
     f36:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <xTaskResumeAll>
	}
}
     f3a:	df 91       	pop	r29
     f3c:	cf 91       	pop	r28
     f3e:	1f 91       	pop	r17
     f40:	0f 91       	pop	r16
     f42:	08 95       	ret

00000f44 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     f44:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     f48:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     f4c:	08 95       	ret

00000f4e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     f4e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     f50:	03 96       	adiw	r24, 0x03	; 3
     f52:	81 83       	std	Z+1, r24	; 0x01
     f54:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     f56:	4f ef       	ldi	r20, 0xFF	; 255
     f58:	5f ef       	ldi	r21, 0xFF	; 255
     f5a:	ba 01       	movw	r22, r20
     f5c:	43 83       	std	Z+3, r20	; 0x03
     f5e:	54 83       	std	Z+4, r21	; 0x04
     f60:	65 83       	std	Z+5, r22	; 0x05
     f62:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     f64:	87 83       	std	Z+7, r24	; 0x07
     f66:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     f68:	81 87       	std	Z+9, r24	; 0x09
     f6a:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     f6c:	10 82       	st	Z, r1
     f6e:	08 95       	ret

00000f70 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     f70:	fc 01       	movw	r30, r24
     f72:	12 86       	std	Z+10, r1	; 0x0a
     f74:	13 86       	std	Z+11, r1	; 0x0b
     f76:	08 95       	ret

00000f78 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     f78:	cf 93       	push	r28
     f7a:	df 93       	push	r29
     f7c:	fc 01       	movw	r30, r24
     f7e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     f80:	21 81       	ldd	r18, Z+1	; 0x01
     f82:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     f84:	e9 01       	movw	r28, r18
     f86:	8c 81       	ldd	r24, Y+4	; 0x04
     f88:	9d 81       	ldd	r25, Y+5	; 0x05
     f8a:	14 96       	adiw	r26, 0x04	; 4
     f8c:	8d 93       	st	X+, r24
     f8e:	9c 93       	st	X, r25
     f90:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
     f92:	81 81       	ldd	r24, Z+1	; 0x01
     f94:	92 81       	ldd	r25, Z+2	; 0x02
     f96:	16 96       	adiw	r26, 0x06	; 6
     f98:	8d 93       	st	X+, r24
     f9a:	9c 93       	st	X, r25
     f9c:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     f9e:	8c 81       	ldd	r24, Y+4	; 0x04
     fa0:	9d 81       	ldd	r25, Y+5	; 0x05
     fa2:	ec 01       	movw	r28, r24
     fa4:	6e 83       	std	Y+6, r22	; 0x06
     fa6:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     fa8:	e9 01       	movw	r28, r18
     faa:	6c 83       	std	Y+4, r22	; 0x04
     fac:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     fae:	61 83       	std	Z+1, r22	; 0x01
     fb0:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     fb2:	1a 96       	adiw	r26, 0x0a	; 10
     fb4:	ed 93       	st	X+, r30
     fb6:	fc 93       	st	X, r31
     fb8:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
     fba:	80 81       	ld	r24, Z
     fbc:	8f 5f       	subi	r24, 0xFF	; 255
     fbe:	80 83       	st	Z, r24
}
     fc0:	df 91       	pop	r29
     fc2:	cf 91       	pop	r28
     fc4:	08 95       	ret

00000fc6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     fc6:	0f 93       	push	r16
     fc8:	1f 93       	push	r17
     fca:	cf 93       	push	r28
     fcc:	df 93       	push	r29
     fce:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     fd0:	08 81       	ld	r16, Y
     fd2:	19 81       	ldd	r17, Y+1	; 0x01
     fd4:	2a 81       	ldd	r18, Y+2	; 0x02
     fd6:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     fd8:	0f 3f       	cpi	r16, 0xFF	; 255
     fda:	4f ef       	ldi	r20, 0xFF	; 255
     fdc:	14 07       	cpc	r17, r20
     fde:	24 07       	cpc	r18, r20
     fe0:	34 07       	cpc	r19, r20
     fe2:	31 f4       	brne	.+12     	; 0xff0 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     fe4:	dc 01       	movw	r26, r24
     fe6:	19 96       	adiw	r26, 0x09	; 9
     fe8:	ed 91       	ld	r30, X+
     fea:	fc 91       	ld	r31, X
     fec:	1a 97       	sbiw	r26, 0x0a	; 10
     fee:	1f c0       	rjmp	.+62     	; 0x102e <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     ff0:	fc 01       	movw	r30, r24
     ff2:	33 96       	adiw	r30, 0x03	; 3
     ff4:	dc 01       	movw	r26, r24
     ff6:	17 96       	adiw	r26, 0x07	; 7
     ff8:	4d 91       	ld	r20, X+
     ffa:	5c 91       	ld	r21, X
     ffc:	18 97       	sbiw	r26, 0x08	; 8
     ffe:	da 01       	movw	r26, r20
    1000:	4d 91       	ld	r20, X+
    1002:	5d 91       	ld	r21, X+
    1004:	6d 91       	ld	r22, X+
    1006:	7c 91       	ld	r23, X
    1008:	04 17       	cp	r16, r20
    100a:	15 07       	cpc	r17, r21
    100c:	26 07       	cpc	r18, r22
    100e:	37 07       	cpc	r19, r23
    1010:	70 f0       	brcs	.+28     	; 0x102e <vListInsert+0x68>
    1012:	04 80       	ldd	r0, Z+4	; 0x04
    1014:	f5 81       	ldd	r31, Z+5	; 0x05
    1016:	e0 2d       	mov	r30, r0
    1018:	a4 81       	ldd	r26, Z+4	; 0x04
    101a:	b5 81       	ldd	r27, Z+5	; 0x05
    101c:	4d 91       	ld	r20, X+
    101e:	5d 91       	ld	r21, X+
    1020:	6d 91       	ld	r22, X+
    1022:	7c 91       	ld	r23, X
    1024:	04 17       	cp	r16, r20
    1026:	15 07       	cpc	r17, r21
    1028:	26 07       	cpc	r18, r22
    102a:	37 07       	cpc	r19, r23
    102c:	90 f7       	brcc	.-28     	; 0x1012 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    102e:	a4 81       	ldd	r26, Z+4	; 0x04
    1030:	b5 81       	ldd	r27, Z+5	; 0x05
    1032:	ac 83       	std	Y+4, r26	; 0x04
    1034:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1036:	16 96       	adiw	r26, 0x06	; 6
    1038:	cd 93       	st	X+, r28
    103a:	dc 93       	st	X, r29
    103c:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    103e:	ee 83       	std	Y+6, r30	; 0x06
    1040:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1042:	c4 83       	std	Z+4, r28	; 0x04
    1044:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1046:	8a 87       	std	Y+10, r24	; 0x0a
    1048:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    104a:	fc 01       	movw	r30, r24
    104c:	20 81       	ld	r18, Z
    104e:	2f 5f       	subi	r18, 0xFF	; 255
    1050:	20 83       	st	Z, r18
}
    1052:	df 91       	pop	r29
    1054:	cf 91       	pop	r28
    1056:	1f 91       	pop	r17
    1058:	0f 91       	pop	r16
    105a:	08 95       	ret

0000105c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    105c:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    105e:	a4 81       	ldd	r26, Z+4	; 0x04
    1060:	b5 81       	ldd	r27, Z+5	; 0x05
    1062:	86 81       	ldd	r24, Z+6	; 0x06
    1064:	97 81       	ldd	r25, Z+7	; 0x07
    1066:	16 96       	adiw	r26, 0x06	; 6
    1068:	8d 93       	st	X+, r24
    106a:	9c 93       	st	X, r25
    106c:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    106e:	a6 81       	ldd	r26, Z+6	; 0x06
    1070:	b7 81       	ldd	r27, Z+7	; 0x07
    1072:	84 81       	ldd	r24, Z+4	; 0x04
    1074:	95 81       	ldd	r25, Z+5	; 0x05
    1076:	14 96       	adiw	r26, 0x04	; 4
    1078:	8d 93       	st	X+, r24
    107a:	9c 93       	st	X, r25
    107c:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    107e:	a2 85       	ldd	r26, Z+10	; 0x0a
    1080:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1082:	11 96       	adiw	r26, 0x01	; 1
    1084:	8d 91       	ld	r24, X+
    1086:	9c 91       	ld	r25, X
    1088:	12 97       	sbiw	r26, 0x02	; 2
    108a:	e8 17       	cp	r30, r24
    108c:	f9 07       	cpc	r31, r25
    108e:	31 f4       	brne	.+12     	; 0x109c <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1090:	86 81       	ldd	r24, Z+6	; 0x06
    1092:	97 81       	ldd	r25, Z+7	; 0x07
    1094:	11 96       	adiw	r26, 0x01	; 1
    1096:	8d 93       	st	X+, r24
    1098:	9c 93       	st	X, r25
    109a:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    109c:	12 86       	std	Z+10, r1	; 0x0a
    109e:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    10a0:	8c 91       	ld	r24, X
    10a2:	81 50       	subi	r24, 0x01	; 1
    10a4:	8c 93       	st	X, r24
    10a6:	08 95       	ret

000010a8 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    10a8:	80 93 72 31 	sts	0x3172, r24	; 0x803172 <portStackTopForTask>
    10ac:	90 93 73 31 	sts	0x3173, r25	; 0x803173 <portStackTopForTask+0x1>
    10b0:	31 e1       	ldi	r19, 0x11	; 17
    10b2:	fc 01       	movw	r30, r24
    10b4:	30 83       	st	Z, r19
    10b6:	31 97       	sbiw	r30, 0x01	; 1
    10b8:	22 e2       	ldi	r18, 0x22	; 34
    10ba:	20 83       	st	Z, r18
    10bc:	31 97       	sbiw	r30, 0x01	; 1
    10be:	a3 e3       	ldi	r26, 0x33	; 51
    10c0:	a0 83       	st	Z, r26
    10c2:	31 97       	sbiw	r30, 0x01	; 1
    10c4:	60 83       	st	Z, r22
    10c6:	31 97       	sbiw	r30, 0x01	; 1
    10c8:	70 83       	st	Z, r23
    10ca:	31 97       	sbiw	r30, 0x01	; 1
    10cc:	10 82       	st	Z, r1
    10ce:	31 97       	sbiw	r30, 0x01	; 1
    10d0:	10 82       	st	Z, r1
    10d2:	31 97       	sbiw	r30, 0x01	; 1
    10d4:	60 e8       	ldi	r22, 0x80	; 128
    10d6:	60 83       	st	Z, r22
    10d8:	31 97       	sbiw	r30, 0x01	; 1
    10da:	10 82       	st	Z, r1
    10dc:	31 97       	sbiw	r30, 0x01	; 1
    10de:	10 82       	st	Z, r1
    10e0:	31 97       	sbiw	r30, 0x01	; 1
    10e2:	10 82       	st	Z, r1
    10e4:	31 97       	sbiw	r30, 0x01	; 1
    10e6:	62 e0       	ldi	r22, 0x02	; 2
    10e8:	60 83       	st	Z, r22
    10ea:	31 97       	sbiw	r30, 0x01	; 1
    10ec:	63 e0       	ldi	r22, 0x03	; 3
    10ee:	60 83       	st	Z, r22
    10f0:	31 97       	sbiw	r30, 0x01	; 1
    10f2:	64 e0       	ldi	r22, 0x04	; 4
    10f4:	60 83       	st	Z, r22
    10f6:	31 97       	sbiw	r30, 0x01	; 1
    10f8:	65 e0       	ldi	r22, 0x05	; 5
    10fa:	60 83       	st	Z, r22
    10fc:	31 97       	sbiw	r30, 0x01	; 1
    10fe:	66 e0       	ldi	r22, 0x06	; 6
    1100:	60 83       	st	Z, r22
    1102:	31 97       	sbiw	r30, 0x01	; 1
    1104:	67 e0       	ldi	r22, 0x07	; 7
    1106:	60 83       	st	Z, r22
    1108:	31 97       	sbiw	r30, 0x01	; 1
    110a:	68 e0       	ldi	r22, 0x08	; 8
    110c:	60 83       	st	Z, r22
    110e:	31 97       	sbiw	r30, 0x01	; 1
    1110:	69 e0       	ldi	r22, 0x09	; 9
    1112:	60 83       	st	Z, r22
    1114:	31 97       	sbiw	r30, 0x01	; 1
    1116:	60 e1       	ldi	r22, 0x10	; 16
    1118:	60 83       	st	Z, r22
    111a:	31 97       	sbiw	r30, 0x01	; 1
    111c:	30 83       	st	Z, r19
    111e:	31 97       	sbiw	r30, 0x01	; 1
    1120:	32 e1       	ldi	r19, 0x12	; 18
    1122:	30 83       	st	Z, r19
    1124:	31 97       	sbiw	r30, 0x01	; 1
    1126:	33 e1       	ldi	r19, 0x13	; 19
    1128:	30 83       	st	Z, r19
    112a:	31 97       	sbiw	r30, 0x01	; 1
    112c:	34 e1       	ldi	r19, 0x14	; 20
    112e:	30 83       	st	Z, r19
    1130:	31 97       	sbiw	r30, 0x01	; 1
    1132:	35 e1       	ldi	r19, 0x15	; 21
    1134:	30 83       	st	Z, r19
    1136:	31 97       	sbiw	r30, 0x01	; 1
    1138:	36 e1       	ldi	r19, 0x16	; 22
    113a:	30 83       	st	Z, r19
    113c:	31 97       	sbiw	r30, 0x01	; 1
    113e:	37 e1       	ldi	r19, 0x17	; 23
    1140:	30 83       	st	Z, r19
    1142:	31 97       	sbiw	r30, 0x01	; 1
    1144:	38 e1       	ldi	r19, 0x18	; 24
    1146:	30 83       	st	Z, r19
    1148:	31 97       	sbiw	r30, 0x01	; 1
    114a:	39 e1       	ldi	r19, 0x19	; 25
    114c:	30 83       	st	Z, r19
    114e:	31 97       	sbiw	r30, 0x01	; 1
    1150:	30 e2       	ldi	r19, 0x20	; 32
    1152:	30 83       	st	Z, r19
    1154:	31 97       	sbiw	r30, 0x01	; 1
    1156:	31 e2       	ldi	r19, 0x21	; 33
    1158:	30 83       	st	Z, r19
    115a:	31 97       	sbiw	r30, 0x01	; 1
    115c:	20 83       	st	Z, r18
    115e:	31 97       	sbiw	r30, 0x01	; 1
    1160:	23 e2       	ldi	r18, 0x23	; 35
    1162:	20 83       	st	Z, r18
    1164:	31 97       	sbiw	r30, 0x01	; 1
    1166:	40 83       	st	Z, r20
    1168:	31 97       	sbiw	r30, 0x01	; 1
    116a:	50 83       	st	Z, r21
    116c:	31 97       	sbiw	r30, 0x01	; 1
    116e:	26 e2       	ldi	r18, 0x26	; 38
    1170:	20 83       	st	Z, r18
    1172:	31 97       	sbiw	r30, 0x01	; 1
    1174:	27 e2       	ldi	r18, 0x27	; 39
    1176:	20 83       	st	Z, r18
    1178:	31 97       	sbiw	r30, 0x01	; 1
    117a:	28 e2       	ldi	r18, 0x28	; 40
    117c:	20 83       	st	Z, r18
    117e:	31 97       	sbiw	r30, 0x01	; 1
    1180:	29 e2       	ldi	r18, 0x29	; 41
    1182:	20 83       	st	Z, r18
    1184:	31 97       	sbiw	r30, 0x01	; 1
    1186:	20 e3       	ldi	r18, 0x30	; 48
    1188:	20 83       	st	Z, r18
    118a:	31 97       	sbiw	r30, 0x01	; 1
    118c:	21 e3       	ldi	r18, 0x31	; 49
    118e:	20 83       	st	Z, r18
    1190:	89 97       	sbiw	r24, 0x29	; 41
    1192:	08 95       	ret

00001194 <xPortStartScheduler>:
    1194:	8c e7       	ldi	r24, 0x7C	; 124
    1196:	80 93 69 0a 	sts	0x0A69, r24	; 0x800a69 <__TEXT_REGION_LENGTH__+0x700a69>
    119a:	8f ef       	ldi	r24, 0xFF	; 255
    119c:	80 93 68 0a 	sts	0x0A68, r24	; 0x800a68 <__TEXT_REGION_LENGTH__+0x700a68>
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <__TEXT_REGION_LENGTH__+0x700a40>
    11a6:	81 e1       	ldi	r24, 0x11	; 17
    11a8:	80 93 41 0a 	sts	0x0A41, r24	; 0x800a41 <__TEXT_REGION_LENGTH__+0x700a41>
    11ac:	83 e0       	ldi	r24, 0x03	; 3
    11ae:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <__TEXT_REGION_LENGTH__+0x700a47>
    11b2:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    11b6:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    11ba:	cd 91       	ld	r28, X+
    11bc:	cd bf       	out	0x3d, r28	; 61
    11be:	dd 91       	ld	r29, X+
    11c0:	de bf       	out	0x3e, r29	; 62
    11c2:	ff 91       	pop	r31
    11c4:	ef 91       	pop	r30
    11c6:	df 91       	pop	r29
    11c8:	cf 91       	pop	r28
    11ca:	bf 91       	pop	r27
    11cc:	af 91       	pop	r26
    11ce:	9f 91       	pop	r25
    11d0:	8f 91       	pop	r24
    11d2:	7f 91       	pop	r23
    11d4:	6f 91       	pop	r22
    11d6:	5f 91       	pop	r21
    11d8:	4f 91       	pop	r20
    11da:	3f 91       	pop	r19
    11dc:	2f 91       	pop	r18
    11de:	1f 91       	pop	r17
    11e0:	0f 91       	pop	r16
    11e2:	ff 90       	pop	r15
    11e4:	ef 90       	pop	r14
    11e6:	df 90       	pop	r13
    11e8:	cf 90       	pop	r12
    11ea:	bf 90       	pop	r11
    11ec:	af 90       	pop	r10
    11ee:	9f 90       	pop	r9
    11f0:	8f 90       	pop	r8
    11f2:	7f 90       	pop	r7
    11f4:	6f 90       	pop	r6
    11f6:	5f 90       	pop	r5
    11f8:	4f 90       	pop	r4
    11fa:	3f 90       	pop	r3
    11fc:	2f 90       	pop	r2
    11fe:	1f 90       	pop	r1
    1200:	0f 90       	pop	r0
    1202:	0c be       	out	0x3c, r0	; 60
    1204:	0f 90       	pop	r0
    1206:	0b be       	out	0x3b, r0	; 59
    1208:	0f 90       	pop	r0
    120a:	0f be       	out	0x3f, r0	; 63
    120c:	0f 90       	pop	r0
    120e:	08 95       	ret
    1210:	81 e0       	ldi	r24, 0x01	; 1
    1212:	08 95       	ret

00001214 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1214:	0f 92       	push	r0
    1216:	0f b6       	in	r0, 0x3f	; 63
    1218:	f8 94       	cli
    121a:	0f 92       	push	r0
    121c:	0b b6       	in	r0, 0x3b	; 59
    121e:	0f 92       	push	r0
    1220:	0c b6       	in	r0, 0x3c	; 60
    1222:	0f 92       	push	r0
    1224:	1f 92       	push	r1
    1226:	11 24       	eor	r1, r1
    1228:	2f 92       	push	r2
    122a:	3f 92       	push	r3
    122c:	4f 92       	push	r4
    122e:	5f 92       	push	r5
    1230:	6f 92       	push	r6
    1232:	7f 92       	push	r7
    1234:	8f 92       	push	r8
    1236:	9f 92       	push	r9
    1238:	af 92       	push	r10
    123a:	bf 92       	push	r11
    123c:	cf 92       	push	r12
    123e:	df 92       	push	r13
    1240:	ef 92       	push	r14
    1242:	ff 92       	push	r15
    1244:	0f 93       	push	r16
    1246:	1f 93       	push	r17
    1248:	2f 93       	push	r18
    124a:	3f 93       	push	r19
    124c:	4f 93       	push	r20
    124e:	5f 93       	push	r21
    1250:	6f 93       	push	r22
    1252:	7f 93       	push	r23
    1254:	8f 93       	push	r24
    1256:	9f 93       	push	r25
    1258:	af 93       	push	r26
    125a:	bf 93       	push	r27
    125c:	cf 93       	push	r28
    125e:	df 93       	push	r29
    1260:	ef 93       	push	r30
    1262:	ff 93       	push	r31
    1264:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    1268:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    126c:	0d b6       	in	r0, 0x3d	; 61
    126e:	0d 92       	st	X+, r0
    1270:	0e b6       	in	r0, 0x3e	; 62
    1272:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1274:	0e 94 2a 10 	call	0x2054	; 0x2054 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1278:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    127c:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1280:	cd 91       	ld	r28, X+
    1282:	cd bf       	out	0x3d, r28	; 61
    1284:	dd 91       	ld	r29, X+
    1286:	de bf       	out	0x3e, r29	; 62
    1288:	ff 91       	pop	r31
    128a:	ef 91       	pop	r30
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	bf 91       	pop	r27
    1292:	af 91       	pop	r26
    1294:	9f 91       	pop	r25
    1296:	8f 91       	pop	r24
    1298:	7f 91       	pop	r23
    129a:	6f 91       	pop	r22
    129c:	5f 91       	pop	r21
    129e:	4f 91       	pop	r20
    12a0:	3f 91       	pop	r19
    12a2:	2f 91       	pop	r18
    12a4:	1f 91       	pop	r17
    12a6:	0f 91       	pop	r16
    12a8:	ff 90       	pop	r15
    12aa:	ef 90       	pop	r14
    12ac:	df 90       	pop	r13
    12ae:	cf 90       	pop	r12
    12b0:	bf 90       	pop	r11
    12b2:	af 90       	pop	r10
    12b4:	9f 90       	pop	r9
    12b6:	8f 90       	pop	r8
    12b8:	7f 90       	pop	r7
    12ba:	6f 90       	pop	r6
    12bc:	5f 90       	pop	r5
    12be:	4f 90       	pop	r4
    12c0:	3f 90       	pop	r3
    12c2:	2f 90       	pop	r2
    12c4:	1f 90       	pop	r1
    12c6:	0f 90       	pop	r0
    12c8:	0c be       	out	0x3c, r0	; 60
    12ca:	0f 90       	pop	r0
    12cc:	0b be       	out	0x3b, r0	; 59
    12ce:	0f 90       	pop	r0
    12d0:	0f be       	out	0x3f, r0	; 63
    12d2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12d4:	08 95       	ret

000012d6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    12d6:	0f 92       	push	r0
    12d8:	0f b6       	in	r0, 0x3f	; 63
    12da:	f8 94       	cli
    12dc:	0f 92       	push	r0
    12de:	0b b6       	in	r0, 0x3b	; 59
    12e0:	0f 92       	push	r0
    12e2:	0c b6       	in	r0, 0x3c	; 60
    12e4:	0f 92       	push	r0
    12e6:	1f 92       	push	r1
    12e8:	11 24       	eor	r1, r1
    12ea:	2f 92       	push	r2
    12ec:	3f 92       	push	r3
    12ee:	4f 92       	push	r4
    12f0:	5f 92       	push	r5
    12f2:	6f 92       	push	r6
    12f4:	7f 92       	push	r7
    12f6:	8f 92       	push	r8
    12f8:	9f 92       	push	r9
    12fa:	af 92       	push	r10
    12fc:	bf 92       	push	r11
    12fe:	cf 92       	push	r12
    1300:	df 92       	push	r13
    1302:	ef 92       	push	r14
    1304:	ff 92       	push	r15
    1306:	0f 93       	push	r16
    1308:	1f 93       	push	r17
    130a:	2f 93       	push	r18
    130c:	3f 93       	push	r19
    130e:	4f 93       	push	r20
    1310:	5f 93       	push	r21
    1312:	6f 93       	push	r22
    1314:	7f 93       	push	r23
    1316:	8f 93       	push	r24
    1318:	9f 93       	push	r25
    131a:	af 93       	push	r26
    131c:	bf 93       	push	r27
    131e:	cf 93       	push	r28
    1320:	df 93       	push	r29
    1322:	ef 93       	push	r30
    1324:	ff 93       	push	r31
    1326:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    132a:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    132e:	0d b6       	in	r0, 0x3d	; 61
    1330:	0d 92       	st	X+, r0
    1332:	0e b6       	in	r0, 0x3e	; 62
    1334:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1336:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <vTaskIncrementTick>
	vTaskSwitchContext();
    133a:	0e 94 2a 10 	call	0x2054	; 0x2054 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    133e:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    1342:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1346:	cd 91       	ld	r28, X+
    1348:	cd bf       	out	0x3d, r28	; 61
    134a:	dd 91       	ld	r29, X+
    134c:	de bf       	out	0x3e, r29	; 62
    134e:	ff 91       	pop	r31
    1350:	ef 91       	pop	r30
    1352:	df 91       	pop	r29
    1354:	cf 91       	pop	r28
    1356:	bf 91       	pop	r27
    1358:	af 91       	pop	r26
    135a:	9f 91       	pop	r25
    135c:	8f 91       	pop	r24
    135e:	7f 91       	pop	r23
    1360:	6f 91       	pop	r22
    1362:	5f 91       	pop	r21
    1364:	4f 91       	pop	r20
    1366:	3f 91       	pop	r19
    1368:	2f 91       	pop	r18
    136a:	1f 91       	pop	r17
    136c:	0f 91       	pop	r16
    136e:	ff 90       	pop	r15
    1370:	ef 90       	pop	r14
    1372:	df 90       	pop	r13
    1374:	cf 90       	pop	r12
    1376:	bf 90       	pop	r11
    1378:	af 90       	pop	r10
    137a:	9f 90       	pop	r9
    137c:	8f 90       	pop	r8
    137e:	7f 90       	pop	r7
    1380:	6f 90       	pop	r6
    1382:	5f 90       	pop	r5
    1384:	4f 90       	pop	r4
    1386:	3f 90       	pop	r3
    1388:	2f 90       	pop	r2
    138a:	1f 90       	pop	r1
    138c:	0f 90       	pop	r0
    138e:	0c be       	out	0x3c, r0	; 60
    1390:	0f 90       	pop	r0
    1392:	0b be       	out	0x3b, r0	; 59
    1394:	0f 90       	pop	r0
    1396:	0f be       	out	0x3f, r0	; 63
    1398:	0f 90       	pop	r0

	asm volatile ( "ret" );
    139a:	08 95       	ret

0000139c <__vector_55>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    139c:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    13a0:	18 95       	reti

000013a2 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    13a2:	cf 93       	push	r28
    13a4:	df 93       	push	r29
    13a6:	ec 01       	movw	r28, r24
    13a8:	88 a1       	ldd	r24, Y+32	; 0x20
    13aa:	81 11       	cpse	r24, r1
    13ac:	0b c0       	rjmp	.+22     	; 0x13c4 <prvCopyDataToQueue+0x22>
    13ae:	88 81       	ld	r24, Y
    13b0:	99 81       	ldd	r25, Y+1	; 0x01
    13b2:	89 2b       	or	r24, r25
    13b4:	e1 f5       	brne	.+120    	; 0x142e <prvCopyDataToQueue+0x8c>
    13b6:	8a 81       	ldd	r24, Y+2	; 0x02
    13b8:	9b 81       	ldd	r25, Y+3	; 0x03
    13ba:	0e 94 e5 11 	call	0x23ca	; 0x23ca <vTaskPriorityDisinherit>
    13be:	1a 82       	std	Y+2, r1	; 0x02
    13c0:	1b 82       	std	Y+3, r1	; 0x03
    13c2:	35 c0       	rjmp	.+106    	; 0x142e <prvCopyDataToQueue+0x8c>
    13c4:	41 11       	cpse	r20, r1
    13c6:	17 c0       	rjmp	.+46     	; 0x13f6 <prvCopyDataToQueue+0x54>
    13c8:	48 2f       	mov	r20, r24
    13ca:	50 e0       	ldi	r21, 0x00	; 0
    13cc:	8c 81       	ldd	r24, Y+4	; 0x04
    13ce:	9d 81       	ldd	r25, Y+5	; 0x05
    13d0:	0e 94 e4 1d 	call	0x3bc8	; 0x3bc8 <memcpy>
    13d4:	28 a1       	ldd	r18, Y+32	; 0x20
    13d6:	8c 81       	ldd	r24, Y+4	; 0x04
    13d8:	9d 81       	ldd	r25, Y+5	; 0x05
    13da:	82 0f       	add	r24, r18
    13dc:	91 1d       	adc	r25, r1
    13de:	8c 83       	std	Y+4, r24	; 0x04
    13e0:	9d 83       	std	Y+5, r25	; 0x05
    13e2:	2a 81       	ldd	r18, Y+2	; 0x02
    13e4:	3b 81       	ldd	r19, Y+3	; 0x03
    13e6:	82 17       	cp	r24, r18
    13e8:	93 07       	cpc	r25, r19
    13ea:	08 f1       	brcs	.+66     	; 0x142e <prvCopyDataToQueue+0x8c>
    13ec:	88 81       	ld	r24, Y
    13ee:	99 81       	ldd	r25, Y+1	; 0x01
    13f0:	8c 83       	std	Y+4, r24	; 0x04
    13f2:	9d 83       	std	Y+5, r25	; 0x05
    13f4:	1c c0       	rjmp	.+56     	; 0x142e <prvCopyDataToQueue+0x8c>
    13f6:	48 2f       	mov	r20, r24
    13f8:	50 e0       	ldi	r21, 0x00	; 0
    13fa:	8e 81       	ldd	r24, Y+6	; 0x06
    13fc:	9f 81       	ldd	r25, Y+7	; 0x07
    13fe:	0e 94 e4 1d 	call	0x3bc8	; 0x3bc8 <memcpy>
    1402:	88 a1       	ldd	r24, Y+32	; 0x20
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	91 95       	neg	r25
    1408:	81 95       	neg	r24
    140a:	91 09       	sbc	r25, r1
    140c:	2e 81       	ldd	r18, Y+6	; 0x06
    140e:	3f 81       	ldd	r19, Y+7	; 0x07
    1410:	28 0f       	add	r18, r24
    1412:	39 1f       	adc	r19, r25
    1414:	2e 83       	std	Y+6, r18	; 0x06
    1416:	3f 83       	std	Y+7, r19	; 0x07
    1418:	48 81       	ld	r20, Y
    141a:	59 81       	ldd	r21, Y+1	; 0x01
    141c:	24 17       	cp	r18, r20
    141e:	35 07       	cpc	r19, r21
    1420:	30 f4       	brcc	.+12     	; 0x142e <prvCopyDataToQueue+0x8c>
    1422:	2a 81       	ldd	r18, Y+2	; 0x02
    1424:	3b 81       	ldd	r19, Y+3	; 0x03
    1426:	82 0f       	add	r24, r18
    1428:	93 1f       	adc	r25, r19
    142a:	8e 83       	std	Y+6, r24	; 0x06
    142c:	9f 83       	std	Y+7, r25	; 0x07
    142e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1430:	8f 5f       	subi	r24, 0xFF	; 255
    1432:	8e 8f       	std	Y+30, r24	; 0x1e
    1434:	df 91       	pop	r29
    1436:	cf 91       	pop	r28
    1438:	08 95       	ret

0000143a <prvCopyDataFromQueue>:
    143a:	fc 01       	movw	r30, r24
    143c:	80 81       	ld	r24, Z
    143e:	91 81       	ldd	r25, Z+1	; 0x01
    1440:	00 97       	sbiw	r24, 0x00	; 0
    1442:	a1 f0       	breq	.+40     	; 0x146c <prvCopyDataFromQueue+0x32>
    1444:	40 a1       	ldd	r20, Z+32	; 0x20
    1446:	50 e0       	ldi	r21, 0x00	; 0
    1448:	26 81       	ldd	r18, Z+6	; 0x06
    144a:	37 81       	ldd	r19, Z+7	; 0x07
    144c:	24 0f       	add	r18, r20
    144e:	35 1f       	adc	r19, r21
    1450:	26 83       	std	Z+6, r18	; 0x06
    1452:	37 83       	std	Z+7, r19	; 0x07
    1454:	a2 81       	ldd	r26, Z+2	; 0x02
    1456:	b3 81       	ldd	r27, Z+3	; 0x03
    1458:	2a 17       	cp	r18, r26
    145a:	3b 07       	cpc	r19, r27
    145c:	10 f0       	brcs	.+4      	; 0x1462 <prvCopyDataFromQueue+0x28>
    145e:	86 83       	std	Z+6, r24	; 0x06
    1460:	97 83       	std	Z+7, r25	; 0x07
    1462:	cb 01       	movw	r24, r22
    1464:	66 81       	ldd	r22, Z+6	; 0x06
    1466:	77 81       	ldd	r23, Z+7	; 0x07
    1468:	0e 94 e4 1d 	call	0x3bc8	; 0x3bc8 <memcpy>
    146c:	08 95       	ret

0000146e <prvUnlockQueue>:
    146e:	0f 93       	push	r16
    1470:	1f 93       	push	r17
    1472:	cf 93       	push	r28
    1474:	df 93       	push	r29
    1476:	ec 01       	movw	r28, r24
    1478:	0f b6       	in	r0, 0x3f	; 63
    147a:	f8 94       	cli
    147c:	0f 92       	push	r0
    147e:	8a a1       	ldd	r24, Y+34	; 0x22
    1480:	18 16       	cp	r1, r24
    1482:	b4 f4       	brge	.+44     	; 0x14b0 <prvUnlockQueue+0x42>
    1484:	8b 89       	ldd	r24, Y+19	; 0x13
    1486:	81 11       	cpse	r24, r1
    1488:	05 c0       	rjmp	.+10     	; 0x1494 <prvUnlockQueue+0x26>
    148a:	12 c0       	rjmp	.+36     	; 0x14b0 <prvUnlockQueue+0x42>
    148c:	8b 89       	ldd	r24, Y+19	; 0x13
    148e:	81 11       	cpse	r24, r1
    1490:	04 c0       	rjmp	.+8      	; 0x149a <prvUnlockQueue+0x2c>
    1492:	0e c0       	rjmp	.+28     	; 0x14b0 <prvUnlockQueue+0x42>
    1494:	8e 01       	movw	r16, r28
    1496:	0d 5e       	subi	r16, 0xED	; 237
    1498:	1f 4f       	sbci	r17, 0xFF	; 255
    149a:	c8 01       	movw	r24, r16
    149c:	0e 94 b1 10 	call	0x2162	; 0x2162 <xTaskRemoveFromEventList>
    14a0:	81 11       	cpse	r24, r1
    14a2:	0e 94 6e 11 	call	0x22dc	; 0x22dc <vTaskMissedYield>
    14a6:	8a a1       	ldd	r24, Y+34	; 0x22
    14a8:	81 50       	subi	r24, 0x01	; 1
    14aa:	8a a3       	std	Y+34, r24	; 0x22
    14ac:	18 16       	cp	r1, r24
    14ae:	74 f3       	brlt	.-36     	; 0x148c <prvUnlockQueue+0x1e>
    14b0:	8f ef       	ldi	r24, 0xFF	; 255
    14b2:	8a a3       	std	Y+34, r24	; 0x22
    14b4:	0f 90       	pop	r0
    14b6:	0f be       	out	0x3f, r0	; 63
    14b8:	0f b6       	in	r0, 0x3f	; 63
    14ba:	f8 94       	cli
    14bc:	0f 92       	push	r0
    14be:	89 a1       	ldd	r24, Y+33	; 0x21
    14c0:	18 16       	cp	r1, r24
    14c2:	b4 f4       	brge	.+44     	; 0x14f0 <prvUnlockQueue+0x82>
    14c4:	88 85       	ldd	r24, Y+8	; 0x08
    14c6:	81 11       	cpse	r24, r1
    14c8:	05 c0       	rjmp	.+10     	; 0x14d4 <prvUnlockQueue+0x66>
    14ca:	12 c0       	rjmp	.+36     	; 0x14f0 <prvUnlockQueue+0x82>
    14cc:	88 85       	ldd	r24, Y+8	; 0x08
    14ce:	81 11       	cpse	r24, r1
    14d0:	04 c0       	rjmp	.+8      	; 0x14da <prvUnlockQueue+0x6c>
    14d2:	0e c0       	rjmp	.+28     	; 0x14f0 <prvUnlockQueue+0x82>
    14d4:	8e 01       	movw	r16, r28
    14d6:	08 5f       	subi	r16, 0xF8	; 248
    14d8:	1f 4f       	sbci	r17, 0xFF	; 255
    14da:	c8 01       	movw	r24, r16
    14dc:	0e 94 b1 10 	call	0x2162	; 0x2162 <xTaskRemoveFromEventList>
    14e0:	81 11       	cpse	r24, r1
    14e2:	0e 94 6e 11 	call	0x22dc	; 0x22dc <vTaskMissedYield>
    14e6:	89 a1       	ldd	r24, Y+33	; 0x21
    14e8:	81 50       	subi	r24, 0x01	; 1
    14ea:	89 a3       	std	Y+33, r24	; 0x21
    14ec:	18 16       	cp	r1, r24
    14ee:	74 f3       	brlt	.-36     	; 0x14cc <prvUnlockQueue+0x5e>
    14f0:	8f ef       	ldi	r24, 0xFF	; 255
    14f2:	89 a3       	std	Y+33, r24	; 0x21
    14f4:	0f 90       	pop	r0
    14f6:	0f be       	out	0x3f, r0	; 63
    14f8:	df 91       	pop	r29
    14fa:	cf 91       	pop	r28
    14fc:	1f 91       	pop	r17
    14fe:	0f 91       	pop	r16
    1500:	08 95       	ret

00001502 <xQueueGenericReset>:
    1502:	1f 93       	push	r17
    1504:	cf 93       	push	r28
    1506:	df 93       	push	r29
    1508:	61 30       	cpi	r22, 0x01	; 1
    150a:	59 f0       	breq	.+22     	; 0x1522 <xQueueGenericReset+0x20>
    150c:	fc 01       	movw	r30, r24
    150e:	23 89       	ldd	r18, Z+19	; 0x13
    1510:	30 85       	ldd	r19, Z+8	; 0x08
    1512:	31 11       	cpse	r19, r1
    1514:	2c c0       	rjmp	.+88     	; 0x156e <xQueueGenericReset+0x6c>
    1516:	11 e0       	ldi	r17, 0x01	; 1
    1518:	21 11       	cpse	r18, r1
    151a:	10 e0       	ldi	r17, 0x00	; 0
    151c:	21 11       	cpse	r18, r1
    151e:	28 c0       	rjmp	.+80     	; 0x1570 <xQueueGenericReset+0x6e>
    1520:	01 c0       	rjmp	.+2      	; 0x1524 <xQueueGenericReset+0x22>
    1522:	11 e0       	ldi	r17, 0x01	; 1
    1524:	ec 01       	movw	r28, r24
    1526:	48 81       	ld	r20, Y
    1528:	59 81       	ldd	r21, Y+1	; 0x01
    152a:	28 a1       	ldd	r18, Y+32	; 0x20
    152c:	30 e0       	ldi	r19, 0x00	; 0
    152e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1530:	62 9f       	mul	r22, r18
    1532:	c0 01       	movw	r24, r0
    1534:	63 9f       	mul	r22, r19
    1536:	90 0d       	add	r25, r0
    1538:	11 24       	eor	r1, r1
    153a:	ba 01       	movw	r22, r20
    153c:	68 0f       	add	r22, r24
    153e:	79 1f       	adc	r23, r25
    1540:	6a 83       	std	Y+2, r22	; 0x02
    1542:	7b 83       	std	Y+3, r23	; 0x03
    1544:	1e 8e       	std	Y+30, r1	; 0x1e
    1546:	4c 83       	std	Y+4, r20	; 0x04
    1548:	5d 83       	std	Y+5, r21	; 0x05
    154a:	82 1b       	sub	r24, r18
    154c:	93 0b       	sbc	r25, r19
    154e:	84 0f       	add	r24, r20
    1550:	95 1f       	adc	r25, r21
    1552:	8e 83       	std	Y+6, r24	; 0x06
    1554:	9f 83       	std	Y+7, r25	; 0x07
    1556:	8f ef       	ldi	r24, 0xFF	; 255
    1558:	89 a3       	std	Y+33, r24	; 0x21
    155a:	8a a3       	std	Y+34, r24	; 0x22
    155c:	ce 01       	movw	r24, r28
    155e:	08 96       	adiw	r24, 0x08	; 8
    1560:	0e 94 a7 07 	call	0xf4e	; 0xf4e <vListInitialise>
    1564:	ce 01       	movw	r24, r28
    1566:	43 96       	adiw	r24, 0x13	; 19
    1568:	0e 94 a7 07 	call	0xf4e	; 0xf4e <vListInitialise>
    156c:	01 c0       	rjmp	.+2      	; 0x1570 <xQueueGenericReset+0x6e>
    156e:	10 e0       	ldi	r17, 0x00	; 0
    1570:	81 2f       	mov	r24, r17
    1572:	df 91       	pop	r29
    1574:	cf 91       	pop	r28
    1576:	1f 91       	pop	r17
    1578:	08 95       	ret

0000157a <xQueueGenericCreate>:
    157a:	0f 93       	push	r16
    157c:	1f 93       	push	r17
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	88 23       	and	r24, r24
    1584:	01 f1       	breq	.+64     	; 0x15c6 <xQueueGenericCreate+0x4c>
    1586:	06 2f       	mov	r16, r22
    1588:	18 2f       	mov	r17, r24
    158a:	83 e2       	ldi	r24, 0x23	; 35
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	0e 94 d5 06 	call	0xdaa	; 0xdaa <pvPortMalloc>
    1592:	ec 01       	movw	r28, r24
    1594:	89 2b       	or	r24, r25
    1596:	c9 f0       	breq	.+50     	; 0x15ca <xQueueGenericCreate+0x50>
    1598:	10 9f       	mul	r17, r16
    159a:	c0 01       	movw	r24, r0
    159c:	11 24       	eor	r1, r1
    159e:	01 96       	adiw	r24, 0x01	; 1
    15a0:	0e 94 d5 06 	call	0xdaa	; 0xdaa <pvPortMalloc>
    15a4:	88 83       	st	Y, r24
    15a6:	99 83       	std	Y+1, r25	; 0x01
    15a8:	89 2b       	or	r24, r25
    15aa:	39 f0       	breq	.+14     	; 0x15ba <xQueueGenericCreate+0x40>
    15ac:	1f 8f       	std	Y+31, r17	; 0x1f
    15ae:	08 a3       	std	Y+32, r16	; 0x20
    15b0:	61 e0       	ldi	r22, 0x01	; 1
    15b2:	ce 01       	movw	r24, r28
    15b4:	0e 94 81 0a 	call	0x1502	; 0x1502 <xQueueGenericReset>
    15b8:	08 c0       	rjmp	.+16     	; 0x15ca <xQueueGenericCreate+0x50>
    15ba:	ce 01       	movw	r24, r28
    15bc:	0e 94 6f 07 	call	0xede	; 0xede <vPortFree>
    15c0:	c0 e0       	ldi	r28, 0x00	; 0
    15c2:	d0 e0       	ldi	r29, 0x00	; 0
    15c4:	02 c0       	rjmp	.+4      	; 0x15ca <xQueueGenericCreate+0x50>
    15c6:	c0 e0       	ldi	r28, 0x00	; 0
    15c8:	d0 e0       	ldi	r29, 0x00	; 0
    15ca:	ce 01       	movw	r24, r28
    15cc:	df 91       	pop	r29
    15ce:	cf 91       	pop	r28
    15d0:	1f 91       	pop	r17
    15d2:	0f 91       	pop	r16
    15d4:	08 95       	ret

000015d6 <xQueueGenericSend>:
    15d6:	af 92       	push	r10
    15d8:	bf 92       	push	r11
    15da:	cf 92       	push	r12
    15dc:	df 92       	push	r13
    15de:	ef 92       	push	r14
    15e0:	ff 92       	push	r15
    15e2:	0f 93       	push	r16
    15e4:	1f 93       	push	r17
    15e6:	cf 93       	push	r28
    15e8:	df 93       	push	r29
    15ea:	cd b7       	in	r28, 0x3d	; 61
    15ec:	de b7       	in	r29, 0x3e	; 62
    15ee:	29 97       	sbiw	r28, 0x09	; 9
    15f0:	cd bf       	out	0x3d, r28	; 61
    15f2:	de bf       	out	0x3e, r29	; 62
    15f4:	7c 01       	movw	r14, r24
    15f6:	5b 01       	movw	r10, r22
    15f8:	2e 83       	std	Y+6, r18	; 0x06
    15fa:	3f 83       	std	Y+7, r19	; 0x07
    15fc:	48 87       	std	Y+8, r20	; 0x08
    15fe:	59 87       	std	Y+9, r21	; 0x09
    1600:	10 e0       	ldi	r17, 0x00	; 0
    1602:	6c 01       	movw	r12, r24
    1604:	88 e0       	ldi	r24, 0x08	; 8
    1606:	c8 0e       	add	r12, r24
    1608:	d1 1c       	adc	r13, r1
    160a:	0f b6       	in	r0, 0x3f	; 63
    160c:	f8 94       	cli
    160e:	0f 92       	push	r0
    1610:	f7 01       	movw	r30, r14
    1612:	96 8d       	ldd	r25, Z+30	; 0x1e
    1614:	87 8d       	ldd	r24, Z+31	; 0x1f
    1616:	98 17       	cp	r25, r24
    1618:	a8 f4       	brcc	.+42     	; 0x1644 <xQueueGenericSend+0x6e>
    161a:	40 2f       	mov	r20, r16
    161c:	b5 01       	movw	r22, r10
    161e:	c7 01       	movw	r24, r14
    1620:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <prvCopyDataToQueue>
    1624:	f7 01       	movw	r30, r14
    1626:	83 89       	ldd	r24, Z+19	; 0x13
    1628:	88 23       	and	r24, r24
    162a:	41 f0       	breq	.+16     	; 0x163c <xQueueGenericSend+0x66>
    162c:	c7 01       	movw	r24, r14
    162e:	43 96       	adiw	r24, 0x13	; 19
    1630:	0e 94 b1 10 	call	0x2162	; 0x2162 <xTaskRemoveFromEventList>
    1634:	81 30       	cpi	r24, 0x01	; 1
    1636:	11 f4       	brne	.+4      	; 0x163c <xQueueGenericSend+0x66>
    1638:	0e 94 0a 09 	call	0x1214	; 0x1214 <vPortYield>
    163c:	0f 90       	pop	r0
    163e:	0f be       	out	0x3f, r0	; 63
    1640:	81 e0       	ldi	r24, 0x01	; 1
    1642:	56 c0       	rjmp	.+172    	; 0x16f0 <xQueueGenericSend+0x11a>
    1644:	8e 81       	ldd	r24, Y+6	; 0x06
    1646:	9f 81       	ldd	r25, Y+7	; 0x07
    1648:	a8 85       	ldd	r26, Y+8	; 0x08
    164a:	b9 85       	ldd	r27, Y+9	; 0x09
    164c:	89 2b       	or	r24, r25
    164e:	8a 2b       	or	r24, r26
    1650:	8b 2b       	or	r24, r27
    1652:	21 f4       	brne	.+8      	; 0x165c <xQueueGenericSend+0x86>
    1654:	0f 90       	pop	r0
    1656:	0f be       	out	0x3f, r0	; 63
    1658:	80 e0       	ldi	r24, 0x00	; 0
    165a:	4a c0       	rjmp	.+148    	; 0x16f0 <xQueueGenericSend+0x11a>
    165c:	11 11       	cpse	r17, r1
    165e:	05 c0       	rjmp	.+10     	; 0x166a <xQueueGenericSend+0x94>
    1660:	ce 01       	movw	r24, r28
    1662:	01 96       	adiw	r24, 0x01	; 1
    1664:	0e 94 f0 10 	call	0x21e0	; 0x21e0 <vTaskSetTimeOutState>
    1668:	11 e0       	ldi	r17, 0x01	; 1
    166a:	0f 90       	pop	r0
    166c:	0f be       	out	0x3f, r0	; 63
    166e:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <vTaskSuspendAll>
    1672:	0f b6       	in	r0, 0x3f	; 63
    1674:	f8 94       	cli
    1676:	0f 92       	push	r0
    1678:	f7 01       	movw	r30, r14
    167a:	81 a1       	ldd	r24, Z+33	; 0x21
    167c:	8f 3f       	cpi	r24, 0xFF	; 255
    167e:	09 f4       	brne	.+2      	; 0x1682 <xQueueGenericSend+0xac>
    1680:	11 a2       	std	Z+33, r1	; 0x21
    1682:	f7 01       	movw	r30, r14
    1684:	82 a1       	ldd	r24, Z+34	; 0x22
    1686:	8f 3f       	cpi	r24, 0xFF	; 255
    1688:	09 f4       	brne	.+2      	; 0x168c <xQueueGenericSend+0xb6>
    168a:	12 a2       	std	Z+34, r1	; 0x22
    168c:	0f 90       	pop	r0
    168e:	0f be       	out	0x3f, r0	; 63
    1690:	be 01       	movw	r22, r28
    1692:	6a 5f       	subi	r22, 0xFA	; 250
    1694:	7f 4f       	sbci	r23, 0xFF	; 255
    1696:	ce 01       	movw	r24, r28
    1698:	01 96       	adiw	r24, 0x01	; 1
    169a:	0e 94 01 11 	call	0x2202	; 0x2202 <xTaskCheckForTimeOut>
    169e:	81 11       	cpse	r24, r1
    16a0:	21 c0       	rjmp	.+66     	; 0x16e4 <xQueueGenericSend+0x10e>
    16a2:	0f b6       	in	r0, 0x3f	; 63
    16a4:	f8 94       	cli
    16a6:	0f 92       	push	r0
    16a8:	f7 01       	movw	r30, r14
    16aa:	96 8d       	ldd	r25, Z+30	; 0x1e
    16ac:	0f 90       	pop	r0
    16ae:	0f be       	out	0x3f, r0	; 63
    16b0:	87 8d       	ldd	r24, Z+31	; 0x1f
    16b2:	98 13       	cpse	r25, r24
    16b4:	11 c0       	rjmp	.+34     	; 0x16d8 <xQueueGenericSend+0x102>
    16b6:	4e 81       	ldd	r20, Y+6	; 0x06
    16b8:	5f 81       	ldd	r21, Y+7	; 0x07
    16ba:	68 85       	ldd	r22, Y+8	; 0x08
    16bc:	79 85       	ldd	r23, Y+9	; 0x09
    16be:	c6 01       	movw	r24, r12
    16c0:	0e 94 87 10 	call	0x210e	; 0x210e <vTaskPlaceOnEventList>
    16c4:	c7 01       	movw	r24, r14
    16c6:	0e 94 37 0a 	call	0x146e	; 0x146e <prvUnlockQueue>
    16ca:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <xTaskResumeAll>
    16ce:	81 11       	cpse	r24, r1
    16d0:	9c cf       	rjmp	.-200    	; 0x160a <xQueueGenericSend+0x34>
    16d2:	0e 94 0a 09 	call	0x1214	; 0x1214 <vPortYield>
    16d6:	99 cf       	rjmp	.-206    	; 0x160a <xQueueGenericSend+0x34>
    16d8:	c7 01       	movw	r24, r14
    16da:	0e 94 37 0a 	call	0x146e	; 0x146e <prvUnlockQueue>
    16de:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <xTaskResumeAll>
    16e2:	93 cf       	rjmp	.-218    	; 0x160a <xQueueGenericSend+0x34>
    16e4:	c7 01       	movw	r24, r14
    16e6:	0e 94 37 0a 	call	0x146e	; 0x146e <prvUnlockQueue>
    16ea:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <xTaskResumeAll>
    16ee:	80 e0       	ldi	r24, 0x00	; 0
    16f0:	29 96       	adiw	r28, 0x09	; 9
    16f2:	cd bf       	out	0x3d, r28	; 61
    16f4:	de bf       	out	0x3e, r29	; 62
    16f6:	df 91       	pop	r29
    16f8:	cf 91       	pop	r28
    16fa:	1f 91       	pop	r17
    16fc:	0f 91       	pop	r16
    16fe:	ff 90       	pop	r15
    1700:	ef 90       	pop	r14
    1702:	df 90       	pop	r13
    1704:	cf 90       	pop	r12
    1706:	bf 90       	pop	r11
    1708:	af 90       	pop	r10
    170a:	08 95       	ret

0000170c <xQueueGenericReceive>:
    170c:	af 92       	push	r10
    170e:	bf 92       	push	r11
    1710:	cf 92       	push	r12
    1712:	df 92       	push	r13
    1714:	ef 92       	push	r14
    1716:	ff 92       	push	r15
    1718:	0f 93       	push	r16
    171a:	1f 93       	push	r17
    171c:	cf 93       	push	r28
    171e:	df 93       	push	r29
    1720:	cd b7       	in	r28, 0x3d	; 61
    1722:	de b7       	in	r29, 0x3e	; 62
    1724:	29 97       	sbiw	r28, 0x09	; 9
    1726:	cd bf       	out	0x3d, r28	; 61
    1728:	de bf       	out	0x3e, r29	; 62
    172a:	7c 01       	movw	r14, r24
    172c:	5b 01       	movw	r10, r22
    172e:	2e 83       	std	Y+6, r18	; 0x06
    1730:	3f 83       	std	Y+7, r19	; 0x07
    1732:	48 87       	std	Y+8, r20	; 0x08
    1734:	59 87       	std	Y+9, r21	; 0x09
    1736:	10 e0       	ldi	r17, 0x00	; 0
    1738:	6c 01       	movw	r12, r24
    173a:	83 e1       	ldi	r24, 0x13	; 19
    173c:	c8 0e       	add	r12, r24
    173e:	d1 1c       	adc	r13, r1
    1740:	0f b6       	in	r0, 0x3f	; 63
    1742:	f8 94       	cli
    1744:	0f 92       	push	r0
    1746:	f7 01       	movw	r30, r14
    1748:	86 8d       	ldd	r24, Z+30	; 0x1e
    174a:	88 23       	and	r24, r24
    174c:	99 f1       	breq	.+102    	; 0x17b4 <xQueueGenericReceive+0xa8>
    174e:	c6 80       	ldd	r12, Z+6	; 0x06
    1750:	d7 80       	ldd	r13, Z+7	; 0x07
    1752:	b5 01       	movw	r22, r10
    1754:	c7 01       	movw	r24, r14
    1756:	0e 94 1d 0a 	call	0x143a	; 0x143a <prvCopyDataFromQueue>
    175a:	01 11       	cpse	r16, r1
    175c:	1a c0       	rjmp	.+52     	; 0x1792 <xQueueGenericReceive+0x86>
    175e:	f7 01       	movw	r30, r14
    1760:	86 8d       	ldd	r24, Z+30	; 0x1e
    1762:	81 50       	subi	r24, 0x01	; 1
    1764:	86 8f       	std	Z+30, r24	; 0x1e
    1766:	80 81       	ld	r24, Z
    1768:	91 81       	ldd	r25, Z+1	; 0x01
    176a:	89 2b       	or	r24, r25
    176c:	29 f4       	brne	.+10     	; 0x1778 <xQueueGenericReceive+0x6c>
    176e:	0e 94 8b 11 	call	0x2316	; 0x2316 <xTaskGetCurrentTaskHandle>
    1772:	f7 01       	movw	r30, r14
    1774:	82 83       	std	Z+2, r24	; 0x02
    1776:	93 83       	std	Z+3, r25	; 0x03
    1778:	f7 01       	movw	r30, r14
    177a:	80 85       	ldd	r24, Z+8	; 0x08
    177c:	88 23       	and	r24, r24
    177e:	b1 f0       	breq	.+44     	; 0x17ac <xQueueGenericReceive+0xa0>
    1780:	c7 01       	movw	r24, r14
    1782:	08 96       	adiw	r24, 0x08	; 8
    1784:	0e 94 b1 10 	call	0x2162	; 0x2162 <xTaskRemoveFromEventList>
    1788:	81 30       	cpi	r24, 0x01	; 1
    178a:	81 f4       	brne	.+32     	; 0x17ac <xQueueGenericReceive+0xa0>
    178c:	0e 94 0a 09 	call	0x1214	; 0x1214 <vPortYield>
    1790:	0d c0       	rjmp	.+26     	; 0x17ac <xQueueGenericReceive+0xa0>
    1792:	f7 01       	movw	r30, r14
    1794:	c6 82       	std	Z+6, r12	; 0x06
    1796:	d7 82       	std	Z+7, r13	; 0x07
    1798:	83 89       	ldd	r24, Z+19	; 0x13
    179a:	88 23       	and	r24, r24
    179c:	39 f0       	breq	.+14     	; 0x17ac <xQueueGenericReceive+0xa0>
    179e:	c7 01       	movw	r24, r14
    17a0:	43 96       	adiw	r24, 0x13	; 19
    17a2:	0e 94 b1 10 	call	0x2162	; 0x2162 <xTaskRemoveFromEventList>
    17a6:	81 11       	cpse	r24, r1
    17a8:	0e 94 0a 09 	call	0x1214	; 0x1214 <vPortYield>
    17ac:	0f 90       	pop	r0
    17ae:	0f be       	out	0x3f, r0	; 63
    17b0:	81 e0       	ldi	r24, 0x01	; 1
    17b2:	62 c0       	rjmp	.+196    	; 0x1878 <xQueueGenericReceive+0x16c>
    17b4:	8e 81       	ldd	r24, Y+6	; 0x06
    17b6:	9f 81       	ldd	r25, Y+7	; 0x07
    17b8:	a8 85       	ldd	r26, Y+8	; 0x08
    17ba:	b9 85       	ldd	r27, Y+9	; 0x09
    17bc:	89 2b       	or	r24, r25
    17be:	8a 2b       	or	r24, r26
    17c0:	8b 2b       	or	r24, r27
    17c2:	21 f4       	brne	.+8      	; 0x17cc <xQueueGenericReceive+0xc0>
    17c4:	0f 90       	pop	r0
    17c6:	0f be       	out	0x3f, r0	; 63
    17c8:	80 e0       	ldi	r24, 0x00	; 0
    17ca:	56 c0       	rjmp	.+172    	; 0x1878 <xQueueGenericReceive+0x16c>
    17cc:	11 11       	cpse	r17, r1
    17ce:	05 c0       	rjmp	.+10     	; 0x17da <xQueueGenericReceive+0xce>
    17d0:	ce 01       	movw	r24, r28
    17d2:	01 96       	adiw	r24, 0x01	; 1
    17d4:	0e 94 f0 10 	call	0x21e0	; 0x21e0 <vTaskSetTimeOutState>
    17d8:	11 e0       	ldi	r17, 0x01	; 1
    17da:	0f 90       	pop	r0
    17dc:	0f be       	out	0x3f, r0	; 63
    17de:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <vTaskSuspendAll>
    17e2:	0f b6       	in	r0, 0x3f	; 63
    17e4:	f8 94       	cli
    17e6:	0f 92       	push	r0
    17e8:	f7 01       	movw	r30, r14
    17ea:	81 a1       	ldd	r24, Z+33	; 0x21
    17ec:	8f 3f       	cpi	r24, 0xFF	; 255
    17ee:	09 f4       	brne	.+2      	; 0x17f2 <xQueueGenericReceive+0xe6>
    17f0:	11 a2       	std	Z+33, r1	; 0x21
    17f2:	f7 01       	movw	r30, r14
    17f4:	82 a1       	ldd	r24, Z+34	; 0x22
    17f6:	8f 3f       	cpi	r24, 0xFF	; 255
    17f8:	09 f4       	brne	.+2      	; 0x17fc <xQueueGenericReceive+0xf0>
    17fa:	12 a2       	std	Z+34, r1	; 0x22
    17fc:	0f 90       	pop	r0
    17fe:	0f be       	out	0x3f, r0	; 63
    1800:	be 01       	movw	r22, r28
    1802:	6a 5f       	subi	r22, 0xFA	; 250
    1804:	7f 4f       	sbci	r23, 0xFF	; 255
    1806:	ce 01       	movw	r24, r28
    1808:	01 96       	adiw	r24, 0x01	; 1
    180a:	0e 94 01 11 	call	0x2202	; 0x2202 <xTaskCheckForTimeOut>
    180e:	81 11       	cpse	r24, r1
    1810:	2d c0       	rjmp	.+90     	; 0x186c <xQueueGenericReceive+0x160>
    1812:	0f b6       	in	r0, 0x3f	; 63
    1814:	f8 94       	cli
    1816:	0f 92       	push	r0
    1818:	f7 01       	movw	r30, r14
    181a:	86 8d       	ldd	r24, Z+30	; 0x1e
    181c:	0f 90       	pop	r0
    181e:	0f be       	out	0x3f, r0	; 63
    1820:	81 11       	cpse	r24, r1
    1822:	1e c0       	rjmp	.+60     	; 0x1860 <xQueueGenericReceive+0x154>
    1824:	80 81       	ld	r24, Z
    1826:	91 81       	ldd	r25, Z+1	; 0x01
    1828:	89 2b       	or	r24, r25
    182a:	49 f4       	brne	.+18     	; 0x183e <xQueueGenericReceive+0x132>
    182c:	0f b6       	in	r0, 0x3f	; 63
    182e:	f8 94       	cli
    1830:	0f 92       	push	r0
    1832:	82 81       	ldd	r24, Z+2	; 0x02
    1834:	93 81       	ldd	r25, Z+3	; 0x03
    1836:	0e 94 90 11 	call	0x2320	; 0x2320 <vTaskPriorityInherit>
    183a:	0f 90       	pop	r0
    183c:	0f be       	out	0x3f, r0	; 63
    183e:	4e 81       	ldd	r20, Y+6	; 0x06
    1840:	5f 81       	ldd	r21, Y+7	; 0x07
    1842:	68 85       	ldd	r22, Y+8	; 0x08
    1844:	79 85       	ldd	r23, Y+9	; 0x09
    1846:	c6 01       	movw	r24, r12
    1848:	0e 94 87 10 	call	0x210e	; 0x210e <vTaskPlaceOnEventList>
    184c:	c7 01       	movw	r24, r14
    184e:	0e 94 37 0a 	call	0x146e	; 0x146e <prvUnlockQueue>
    1852:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <xTaskResumeAll>
    1856:	81 11       	cpse	r24, r1
    1858:	73 cf       	rjmp	.-282    	; 0x1740 <xQueueGenericReceive+0x34>
    185a:	0e 94 0a 09 	call	0x1214	; 0x1214 <vPortYield>
    185e:	70 cf       	rjmp	.-288    	; 0x1740 <xQueueGenericReceive+0x34>
    1860:	c7 01       	movw	r24, r14
    1862:	0e 94 37 0a 	call	0x146e	; 0x146e <prvUnlockQueue>
    1866:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <xTaskResumeAll>
    186a:	6a cf       	rjmp	.-300    	; 0x1740 <xQueueGenericReceive+0x34>
    186c:	c7 01       	movw	r24, r14
    186e:	0e 94 37 0a 	call	0x146e	; 0x146e <prvUnlockQueue>
    1872:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <xTaskResumeAll>
    1876:	80 e0       	ldi	r24, 0x00	; 0
    1878:	29 96       	adiw	r28, 0x09	; 9
    187a:	cd bf       	out	0x3d, r28	; 61
    187c:	de bf       	out	0x3e, r29	; 62
    187e:	df 91       	pop	r29
    1880:	cf 91       	pop	r28
    1882:	1f 91       	pop	r17
    1884:	0f 91       	pop	r16
    1886:	ff 90       	pop	r15
    1888:	ef 90       	pop	r14
    188a:	df 90       	pop	r13
    188c:	cf 90       	pop	r12
    188e:	bf 90       	pop	r11
    1890:	af 90       	pop	r10
    1892:	08 95       	ret

00001894 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1894:	0f b6       	in	r0, 0x3f	; 63
    1896:	f8 94       	cli
    1898:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    189a:	fc 01       	movw	r30, r24
    189c:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    189e:	0f 90       	pop	r0
    18a0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    18a2:	08 95       	ret

000018a4 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    18a4:	c6 e0       	ldi	r28, 0x06	; 6
    18a6:	d1 e3       	ldi	r29, 0x31	; 49
    18a8:	88 81       	ld	r24, Y
    18aa:	82 30       	cpi	r24, 0x02	; 2
    18ac:	e8 f3       	brcs	.-6      	; 0x18a8 <prvIdleTask+0x4>
    18ae:	0e 94 0a 09 	call	0x1214	; 0x1214 <vPortYield>
    18b2:	fa cf       	rjmp	.-12     	; 0x18a8 <prvIdleTask+0x4>

000018b4 <prvAddCurrentTaskToDelayedList>:
    18b4:	cf 92       	push	r12
    18b6:	df 92       	push	r13
    18b8:	ef 92       	push	r14
    18ba:	ff 92       	push	r15
    18bc:	6b 01       	movw	r12, r22
    18be:	7c 01       	movw	r14, r24
    18c0:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    18c4:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    18c8:	62 83       	std	Z+2, r22	; 0x02
    18ca:	73 83       	std	Z+3, r23	; 0x03
    18cc:	84 83       	std	Z+4, r24	; 0x04
    18ce:	95 83       	std	Z+5, r25	; 0x05
    18d0:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    18d4:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    18d8:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    18dc:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    18e0:	c8 16       	cp	r12, r24
    18e2:	d9 06       	cpc	r13, r25
    18e4:	ea 06       	cpc	r14, r26
    18e6:	fb 06       	cpc	r15, r27
    18e8:	68 f4       	brcc	.+26     	; 0x1904 <prvAddCurrentTaskToDelayedList+0x50>
    18ea:	60 91 32 31 	lds	r22, 0x3132	; 0x803132 <pxCurrentTCB>
    18ee:	70 91 33 31 	lds	r23, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    18f2:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <pxOverflowDelayedTaskList>
    18f6:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
    18fa:	6e 5f       	subi	r22, 0xFE	; 254
    18fc:	7f 4f       	sbci	r23, 0xFF	; 255
    18fe:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <vListInsert>
    1902:	21 c0       	rjmp	.+66     	; 0x1946 <prvAddCurrentTaskToDelayedList+0x92>
    1904:	60 91 32 31 	lds	r22, 0x3132	; 0x803132 <pxCurrentTCB>
    1908:	70 91 33 31 	lds	r23, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    190c:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1910:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1914:	6e 5f       	subi	r22, 0xFE	; 254
    1916:	7f 4f       	sbci	r23, 0xFF	; 255
    1918:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <vListInsert>
    191c:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1920:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1924:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1928:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    192c:	c8 16       	cp	r12, r24
    192e:	d9 06       	cpc	r13, r25
    1930:	ea 06       	cpc	r14, r26
    1932:	fb 06       	cpc	r15, r27
    1934:	40 f4       	brcc	.+16     	; 0x1946 <prvAddCurrentTaskToDelayedList+0x92>
    1936:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    193a:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    193e:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1942:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1946:	ff 90       	pop	r15
    1948:	ef 90       	pop	r14
    194a:	df 90       	pop	r13
    194c:	cf 90       	pop	r12
    194e:	08 95       	ret

00001950 <xTaskGenericCreate>:
    1950:	4f 92       	push	r4
    1952:	5f 92       	push	r5
    1954:	6f 92       	push	r6
    1956:	7f 92       	push	r7
    1958:	8f 92       	push	r8
    195a:	9f 92       	push	r9
    195c:	af 92       	push	r10
    195e:	bf 92       	push	r11
    1960:	cf 92       	push	r12
    1962:	df 92       	push	r13
    1964:	ef 92       	push	r14
    1966:	ff 92       	push	r15
    1968:	0f 93       	push	r16
    196a:	1f 93       	push	r17
    196c:	cf 93       	push	r28
    196e:	df 93       	push	r29
    1970:	5c 01       	movw	r10, r24
    1972:	4b 01       	movw	r8, r22
    1974:	3a 01       	movw	r6, r20
    1976:	29 01       	movw	r4, r18
    1978:	88 e2       	ldi	r24, 0x28	; 40
    197a:	90 e0       	ldi	r25, 0x00	; 0
    197c:	0e 94 d5 06 	call	0xdaa	; 0xdaa <pvPortMalloc>
    1980:	ec 01       	movw	r28, r24
    1982:	89 2b       	or	r24, r25
    1984:	09 f4       	brne	.+2      	; 0x1988 <xTaskGenericCreate+0x38>
    1986:	d4 c0       	rjmp	.+424    	; 0x1b30 <xTaskGenericCreate+0x1e0>
    1988:	c1 14       	cp	r12, r1
    198a:	d1 04       	cpc	r13, r1
    198c:	09 f0       	breq	.+2      	; 0x1990 <xTaskGenericCreate+0x40>
    198e:	cc c0       	rjmp	.+408    	; 0x1b28 <xTaskGenericCreate+0x1d8>
    1990:	c3 01       	movw	r24, r6
    1992:	0e 94 d5 06 	call	0xdaa	; 0xdaa <pvPortMalloc>
    1996:	8b 8f       	std	Y+27, r24	; 0x1b
    1998:	9c 8f       	std	Y+28, r25	; 0x1c
    199a:	00 97       	sbiw	r24, 0x00	; 0
    199c:	21 f4       	brne	.+8      	; 0x19a6 <xTaskGenericCreate+0x56>
    199e:	ce 01       	movw	r24, r28
    19a0:	0e 94 6f 07 	call	0xede	; 0xede <vPortFree>
    19a4:	c5 c0       	rjmp	.+394    	; 0x1b30 <xTaskGenericCreate+0x1e0>
    19a6:	a3 01       	movw	r20, r6
    19a8:	61 e1       	ldi	r22, 0x11	; 17
    19aa:	70 e0       	ldi	r23, 0x00	; 0
    19ac:	0e 94 ed 1d 	call	0x3bda	; 0x3bda <memset>
    19b0:	93 01       	movw	r18, r6
    19b2:	21 50       	subi	r18, 0x01	; 1
    19b4:	31 09       	sbc	r19, r1
    19b6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    19b8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    19ba:	3c 01       	movw	r6, r24
    19bc:	62 0e       	add	r6, r18
    19be:	73 1e       	adc	r7, r19
    19c0:	4a e0       	ldi	r20, 0x0A	; 10
    19c2:	50 e0       	ldi	r21, 0x00	; 0
    19c4:	b4 01       	movw	r22, r8
    19c6:	ce 01       	movw	r24, r28
    19c8:	4d 96       	adiw	r24, 0x1d	; 29
    19ca:	0e 94 f4 1d 	call	0x3be8	; 0x3be8 <strncpy>
    19ce:	1e a2       	std	Y+38, r1	; 0x26
    19d0:	10 2f       	mov	r17, r16
    19d2:	04 30       	cpi	r16, 0x04	; 4
    19d4:	08 f0       	brcs	.+2      	; 0x19d8 <xTaskGenericCreate+0x88>
    19d6:	13 e0       	ldi	r17, 0x03	; 3
    19d8:	1a 8f       	std	Y+26, r17	; 0x1a
    19da:	1f a3       	std	Y+39, r17	; 0x27
    19dc:	6e 01       	movw	r12, r28
    19de:	22 e0       	ldi	r18, 0x02	; 2
    19e0:	c2 0e       	add	r12, r18
    19e2:	d1 1c       	adc	r13, r1
    19e4:	c6 01       	movw	r24, r12
    19e6:	0e 94 b8 07 	call	0xf70	; 0xf70 <vListInitialiseItem>
    19ea:	ce 01       	movw	r24, r28
    19ec:	0e 96       	adiw	r24, 0x0e	; 14
    19ee:	0e 94 b8 07 	call	0xf70	; 0xf70 <vListInitialiseItem>
    19f2:	ca 87       	std	Y+10, r28	; 0x0a
    19f4:	db 87       	std	Y+11, r29	; 0x0b
    19f6:	84 e0       	ldi	r24, 0x04	; 4
    19f8:	90 e0       	ldi	r25, 0x00	; 0
    19fa:	a0 e0       	ldi	r26, 0x00	; 0
    19fc:	b0 e0       	ldi	r27, 0x00	; 0
    19fe:	81 1b       	sub	r24, r17
    1a00:	91 09       	sbc	r25, r1
    1a02:	a1 09       	sbc	r26, r1
    1a04:	b1 09       	sbc	r27, r1
    1a06:	8e 87       	std	Y+14, r24	; 0x0e
    1a08:	9f 87       	std	Y+15, r25	; 0x0f
    1a0a:	a8 8b       	std	Y+16, r26	; 0x10
    1a0c:	b9 8b       	std	Y+17, r27	; 0x11
    1a0e:	ce 8b       	std	Y+22, r28	; 0x16
    1a10:	df 8b       	std	Y+23, r29	; 0x17
    1a12:	a2 01       	movw	r20, r4
    1a14:	b5 01       	movw	r22, r10
    1a16:	c3 01       	movw	r24, r6
    1a18:	0e 94 54 08 	call	0x10a8	; 0x10a8 <pxPortInitialiseStack>
    1a1c:	88 83       	st	Y, r24
    1a1e:	99 83       	std	Y+1, r25	; 0x01
    1a20:	e1 14       	cp	r14, r1
    1a22:	f1 04       	cpc	r15, r1
    1a24:	19 f0       	breq	.+6      	; 0x1a2c <xTaskGenericCreate+0xdc>
    1a26:	f7 01       	movw	r30, r14
    1a28:	c0 83       	st	Z, r28
    1a2a:	d1 83       	std	Z+1, r29	; 0x01
    1a2c:	0f b6       	in	r0, 0x3f	; 63
    1a2e:	f8 94       	cli
    1a30:	0f 92       	push	r0
    1a32:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <uxCurrentNumberOfTasks>
    1a36:	8f 5f       	subi	r24, 0xFF	; 255
    1a38:	80 93 de 30 	sts	0x30DE, r24	; 0x8030de <uxCurrentNumberOfTasks>
    1a3c:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    1a40:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1a44:	89 2b       	or	r24, r25
    1a46:	89 f5       	brne	.+98     	; 0x1aaa <xTaskGenericCreate+0x15a>
    1a48:	c0 93 32 31 	sts	0x3132, r28	; 0x803132 <pxCurrentTCB>
    1a4c:	d0 93 33 31 	sts	0x3133, r29	; 0x803133 <pxCurrentTCB+0x1>
    1a50:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <uxCurrentNumberOfTasks>
    1a54:	81 30       	cpi	r24, 0x01	; 1
    1a56:	c1 f5       	brne	.+112    	; 0x1ac8 <xTaskGenericCreate+0x178>
    1a58:	86 e0       	ldi	r24, 0x06	; 6
    1a5a:	91 e3       	ldi	r25, 0x31	; 49
    1a5c:	0e 94 a7 07 	call	0xf4e	; 0xf4e <vListInitialise>
    1a60:	81 e1       	ldi	r24, 0x11	; 17
    1a62:	91 e3       	ldi	r25, 0x31	; 49
    1a64:	0e 94 a7 07 	call	0xf4e	; 0xf4e <vListInitialise>
    1a68:	8c e1       	ldi	r24, 0x1C	; 28
    1a6a:	91 e3       	ldi	r25, 0x31	; 49
    1a6c:	0e 94 a7 07 	call	0xf4e	; 0xf4e <vListInitialise>
    1a70:	87 e2       	ldi	r24, 0x27	; 39
    1a72:	91 e3       	ldi	r25, 0x31	; 49
    1a74:	0e 94 a7 07 	call	0xf4e	; 0xf4e <vListInitialise>
    1a78:	8b ef       	ldi	r24, 0xFB	; 251
    1a7a:	90 e3       	ldi	r25, 0x30	; 48
    1a7c:	0e 94 a7 07 	call	0xf4e	; 0xf4e <vListInitialise>
    1a80:	80 ef       	ldi	r24, 0xF0	; 240
    1a82:	90 e3       	ldi	r25, 0x30	; 48
    1a84:	0e 94 a7 07 	call	0xf4e	; 0xf4e <vListInitialise>
    1a88:	81 ee       	ldi	r24, 0xE1	; 225
    1a8a:	90 e3       	ldi	r25, 0x30	; 48
    1a8c:	0e 94 a7 07 	call	0xf4e	; 0xf4e <vListInitialise>
    1a90:	8b ef       	ldi	r24, 0xFB	; 251
    1a92:	90 e3       	ldi	r25, 0x30	; 48
    1a94:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <pxDelayedTaskList>
    1a98:	90 93 ef 30 	sts	0x30EF, r25	; 0x8030ef <pxDelayedTaskList+0x1>
    1a9c:	80 ef       	ldi	r24, 0xF0	; 240
    1a9e:	90 e3       	ldi	r25, 0x30	; 48
    1aa0:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <pxOverflowDelayedTaskList>
    1aa4:	90 93 ed 30 	sts	0x30ED, r25	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
    1aa8:	0f c0       	rjmp	.+30     	; 0x1ac8 <xTaskGenericCreate+0x178>
    1aaa:	80 91 d7 30 	lds	r24, 0x30D7	; 0x8030d7 <xSchedulerRunning>
    1aae:	81 11       	cpse	r24, r1
    1ab0:	0b c0       	rjmp	.+22     	; 0x1ac8 <xTaskGenericCreate+0x178>
    1ab2:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1ab6:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1aba:	82 8d       	ldd	r24, Z+26	; 0x1a
    1abc:	08 17       	cp	r16, r24
    1abe:	20 f0       	brcs	.+8      	; 0x1ac8 <xTaskGenericCreate+0x178>
    1ac0:	c0 93 32 31 	sts	0x3132, r28	; 0x803132 <pxCurrentTCB>
    1ac4:	d0 93 33 31 	sts	0x3133, r29	; 0x803133 <pxCurrentTCB+0x1>
    1ac8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1aca:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <uxTopUsedPriority>
    1ace:	98 17       	cp	r25, r24
    1ad0:	10 f4       	brcc	.+4      	; 0x1ad6 <xTaskGenericCreate+0x186>
    1ad2:	80 93 d9 30 	sts	0x30D9, r24	; 0x8030d9 <uxTopUsedPriority>
    1ad6:	90 91 d2 30 	lds	r25, 0x30D2	; 0x8030d2 <uxTaskNumber>
    1ada:	9f 5f       	subi	r25, 0xFF	; 255
    1adc:	90 93 d2 30 	sts	0x30D2, r25	; 0x8030d2 <uxTaskNumber>
    1ae0:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    1ae4:	98 17       	cp	r25, r24
    1ae6:	10 f4       	brcc	.+4      	; 0x1aec <xTaskGenericCreate+0x19c>
    1ae8:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    1aec:	fb e0       	ldi	r31, 0x0B	; 11
    1aee:	8f 9f       	mul	r24, r31
    1af0:	c0 01       	movw	r24, r0
    1af2:	11 24       	eor	r1, r1
    1af4:	b6 01       	movw	r22, r12
    1af6:	8a 5f       	subi	r24, 0xFA	; 250
    1af8:	9e 4c       	sbci	r25, 0xCE	; 206
    1afa:	0e 94 bc 07 	call	0xf78	; 0xf78 <vListInsertEnd>
    1afe:	0f 90       	pop	r0
    1b00:	0f be       	out	0x3f, r0	; 63
    1b02:	80 91 d7 30 	lds	r24, 0x30D7	; 0x8030d7 <xSchedulerRunning>
    1b06:	88 23       	and	r24, r24
    1b08:	59 f0       	breq	.+22     	; 0x1b20 <xTaskGenericCreate+0x1d0>
    1b0a:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1b0e:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1b12:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b14:	80 17       	cp	r24, r16
    1b16:	30 f4       	brcc	.+12     	; 0x1b24 <xTaskGenericCreate+0x1d4>
    1b18:	0e 94 0a 09 	call	0x1214	; 0x1214 <vPortYield>
    1b1c:	81 e0       	ldi	r24, 0x01	; 1
    1b1e:	09 c0       	rjmp	.+18     	; 0x1b32 <xTaskGenericCreate+0x1e2>
    1b20:	81 e0       	ldi	r24, 0x01	; 1
    1b22:	07 c0       	rjmp	.+14     	; 0x1b32 <xTaskGenericCreate+0x1e2>
    1b24:	81 e0       	ldi	r24, 0x01	; 1
    1b26:	05 c0       	rjmp	.+10     	; 0x1b32 <xTaskGenericCreate+0x1e2>
    1b28:	cb 8e       	std	Y+27, r12	; 0x1b
    1b2a:	dc 8e       	std	Y+28, r13	; 0x1c
    1b2c:	c6 01       	movw	r24, r12
    1b2e:	3b cf       	rjmp	.-394    	; 0x19a6 <xTaskGenericCreate+0x56>
    1b30:	8f ef       	ldi	r24, 0xFF	; 255
    1b32:	df 91       	pop	r29
    1b34:	cf 91       	pop	r28
    1b36:	1f 91       	pop	r17
    1b38:	0f 91       	pop	r16
    1b3a:	ff 90       	pop	r15
    1b3c:	ef 90       	pop	r14
    1b3e:	df 90       	pop	r13
    1b40:	cf 90       	pop	r12
    1b42:	bf 90       	pop	r11
    1b44:	af 90       	pop	r10
    1b46:	9f 90       	pop	r9
    1b48:	8f 90       	pop	r8
    1b4a:	7f 90       	pop	r7
    1b4c:	6f 90       	pop	r6
    1b4e:	5f 90       	pop	r5
    1b50:	4f 90       	pop	r4
    1b52:	08 95       	ret

00001b54 <uxTaskPriorityGet>:
    1b54:	0f b6       	in	r0, 0x3f	; 63
    1b56:	f8 94       	cli
    1b58:	0f 92       	push	r0
    1b5a:	00 97       	sbiw	r24, 0x00	; 0
    1b5c:	21 f4       	brne	.+8      	; 0x1b66 <uxTaskPriorityGet+0x12>
    1b5e:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    1b62:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1b66:	0f 90       	pop	r0
    1b68:	0f be       	out	0x3f, r0	; 63
    1b6a:	fc 01       	movw	r30, r24
    1b6c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b6e:	08 95       	ret

00001b70 <vTaskStartScheduler>:
    1b70:	af 92       	push	r10
    1b72:	bf 92       	push	r11
    1b74:	cf 92       	push	r12
    1b76:	df 92       	push	r13
    1b78:	ef 92       	push	r14
    1b7a:	ff 92       	push	r15
    1b7c:	0f 93       	push	r16
    1b7e:	a1 2c       	mov	r10, r1
    1b80:	b1 2c       	mov	r11, r1
    1b82:	c1 2c       	mov	r12, r1
    1b84:	d1 2c       	mov	r13, r1
    1b86:	0f 2e       	mov	r0, r31
    1b88:	ff ed       	ldi	r31, 0xDF	; 223
    1b8a:	ef 2e       	mov	r14, r31
    1b8c:	f0 e3       	ldi	r31, 0x30	; 48
    1b8e:	ff 2e       	mov	r15, r31
    1b90:	f0 2d       	mov	r31, r0
    1b92:	00 e0       	ldi	r16, 0x00	; 0
    1b94:	20 e0       	ldi	r18, 0x00	; 0
    1b96:	30 e0       	ldi	r19, 0x00	; 0
    1b98:	44 e6       	ldi	r20, 0x64	; 100
    1b9a:	50 e0       	ldi	r21, 0x00	; 0
    1b9c:	6e e3       	ldi	r22, 0x3E	; 62
    1b9e:	70 e2       	ldi	r23, 0x20	; 32
    1ba0:	82 e5       	ldi	r24, 0x52	; 82
    1ba2:	9c e0       	ldi	r25, 0x0C	; 12
    1ba4:	0e 94 a8 0c 	call	0x1950	; 0x1950 <xTaskGenericCreate>
    1ba8:	81 30       	cpi	r24, 0x01	; 1
    1baa:	69 f4       	brne	.+26     	; 0x1bc6 <vTaskStartScheduler+0x56>
    1bac:	f8 94       	cli
    1bae:	80 93 d7 30 	sts	0x30D7, r24	; 0x8030d7 <xSchedulerRunning>
    1bb2:	10 92 da 30 	sts	0x30DA, r1	; 0x8030da <xTickCount>
    1bb6:	10 92 db 30 	sts	0x30DB, r1	; 0x8030db <xTickCount+0x1>
    1bba:	10 92 dc 30 	sts	0x30DC, r1	; 0x8030dc <xTickCount+0x2>
    1bbe:	10 92 dd 30 	sts	0x30DD, r1	; 0x8030dd <xTickCount+0x3>
    1bc2:	0e 94 ca 08 	call	0x1194	; 0x1194 <xPortStartScheduler>
    1bc6:	0f 91       	pop	r16
    1bc8:	ff 90       	pop	r15
    1bca:	ef 90       	pop	r14
    1bcc:	df 90       	pop	r13
    1bce:	cf 90       	pop	r12
    1bd0:	bf 90       	pop	r11
    1bd2:	af 90       	pop	r10
    1bd4:	08 95       	ret

00001bd6 <vTaskSuspendAll>:
    1bd6:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    1bda:	8f 5f       	subi	r24, 0xFF	; 255
    1bdc:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxSchedulerSuspended>
    1be0:	08 95       	ret

00001be2 <xTaskGetTickCount>:
    1be2:	0f b6       	in	r0, 0x3f	; 63
    1be4:	f8 94       	cli
    1be6:	0f 92       	push	r0
    1be8:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount>
    1bec:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x1>
    1bf0:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1bf4:	90 91 dd 30 	lds	r25, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1bf8:	0f 90       	pop	r0
    1bfa:	0f be       	out	0x3f, r0	; 63
    1bfc:	08 95       	ret

00001bfe <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1bfe:	00 97       	sbiw	r24, 0x00	; 0
    1c00:	21 f4       	brne	.+8      	; 0x1c0a <pcTaskGetTaskName+0xc>
    1c02:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    1c06:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    1c0a:	4d 96       	adiw	r24, 0x1d	; 29
    1c0c:	08 95       	ret

00001c0e <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    1c0e:	80 91 df 30 	lds	r24, 0x30DF	; 0x8030df <xIdleTaskHandle>
    1c12:	90 91 e0 30 	lds	r25, 0x30E0	; 0x8030e0 <xIdleTaskHandle+0x1>
    1c16:	08 95       	ret

00001c18 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1c18:	ff 92       	push	r15
    1c1a:	0f 93       	push	r16
    1c1c:	1f 93       	push	r17
    1c1e:	cf 93       	push	r28
    1c20:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1c22:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    1c26:	81 11       	cpse	r24, r1
    1c28:	ed c0       	rjmp	.+474    	; 0x1e04 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    1c2a:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    1c2e:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    1c32:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1c36:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1c3a:	01 96       	adiw	r24, 0x01	; 1
    1c3c:	a1 1d       	adc	r26, r1
    1c3e:	b1 1d       	adc	r27, r1
    1c40:	80 93 da 30 	sts	0x30DA, r24	; 0x8030da <xTickCount>
    1c44:	90 93 db 30 	sts	0x30DB, r25	; 0x8030db <xTickCount+0x1>
    1c48:	a0 93 dc 30 	sts	0x30DC, r26	; 0x8030dc <xTickCount+0x2>
    1c4c:	b0 93 dd 30 	sts	0x30DD, r27	; 0x8030dd <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    1c50:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    1c54:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    1c58:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1c5c:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1c60:	89 2b       	or	r24, r25
    1c62:	8a 2b       	or	r24, r26
    1c64:	8b 2b       	or	r24, r27
    1c66:	f1 f5       	brne	.+124    	; 0x1ce4 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1c68:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1c6c:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1c70:	20 91 ec 30 	lds	r18, 0x30EC	; 0x8030ec <pxOverflowDelayedTaskList>
    1c74:	30 91 ed 30 	lds	r19, 0x30ED	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
    1c78:	20 93 ee 30 	sts	0x30EE, r18	; 0x8030ee <pxDelayedTaskList>
    1c7c:	30 93 ef 30 	sts	0x30EF, r19	; 0x8030ef <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    1c80:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <pxOverflowDelayedTaskList>
    1c84:	90 93 ed 30 	sts	0x30ED, r25	; 0x8030ed <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    1c88:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <xNumOfOverflows>
    1c8c:	8f 5f       	subi	r24, 0xFF	; 255
    1c8e:	80 93 d3 30 	sts	0x30D3, r24	; 0x8030d3 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1c92:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1c96:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1c9a:	80 81       	ld	r24, Z
    1c9c:	81 11       	cpse	r24, r1
    1c9e:	0c c0       	rjmp	.+24     	; 0x1cb8 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1ca0:	8f ef       	ldi	r24, 0xFF	; 255
    1ca2:	9f ef       	ldi	r25, 0xFF	; 255
    1ca4:	dc 01       	movw	r26, r24
    1ca6:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1caa:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1cae:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1cb2:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1cb6:	16 c0       	rjmp	.+44     	; 0x1ce4 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1cb8:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1cbc:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1cc0:	07 80       	ldd	r0, Z+7	; 0x07
    1cc2:	f0 85       	ldd	r31, Z+8	; 0x08
    1cc4:	e0 2d       	mov	r30, r0
    1cc6:	00 84       	ldd	r0, Z+8	; 0x08
    1cc8:	f1 85       	ldd	r31, Z+9	; 0x09
    1cca:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1ccc:	82 81       	ldd	r24, Z+2	; 0x02
    1cce:	93 81       	ldd	r25, Z+3	; 0x03
    1cd0:	a4 81       	ldd	r26, Z+4	; 0x04
    1cd2:	b5 81       	ldd	r27, Z+5	; 0x05
    1cd4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1cd8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1cdc:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1ce0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1ce4:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    1ce8:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    1cec:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1cf0:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1cf4:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1cf8:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1cfc:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1d00:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1d04:	48 17       	cp	r20, r24
    1d06:	59 07       	cpc	r21, r25
    1d08:	6a 07       	cpc	r22, r26
    1d0a:	7b 07       	cpc	r23, r27
    1d0c:	08 f4       	brcc	.+2      	; 0x1d10 <vTaskIncrementTick+0xf8>
    1d0e:	7f c0       	rjmp	.+254    	; 0x1e0e <vTaskIncrementTick+0x1f6>
    1d10:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1d14:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1d18:	80 81       	ld	r24, Z
    1d1a:	88 23       	and	r24, r24
    1d1c:	f9 f0       	breq	.+62     	; 0x1d5c <vTaskIncrementTick+0x144>
    1d1e:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1d22:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1d26:	07 80       	ldd	r0, Z+7	; 0x07
    1d28:	f0 85       	ldd	r31, Z+8	; 0x08
    1d2a:	e0 2d       	mov	r30, r0
    1d2c:	c0 85       	ldd	r28, Z+8	; 0x08
    1d2e:	d1 85       	ldd	r29, Z+9	; 0x09
    1d30:	8a 81       	ldd	r24, Y+2	; 0x02
    1d32:	9b 81       	ldd	r25, Y+3	; 0x03
    1d34:	ac 81       	ldd	r26, Y+4	; 0x04
    1d36:	bd 81       	ldd	r27, Y+5	; 0x05
    1d38:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    1d3c:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    1d40:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1d44:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1d48:	48 17       	cp	r20, r24
    1d4a:	59 07       	cpc	r21, r25
    1d4c:	6a 07       	cpc	r22, r26
    1d4e:	7b 07       	cpc	r23, r27
    1d50:	58 f1       	brcs	.+86     	; 0x1da8 <vTaskIncrementTick+0x190>
    1d52:	0f 2e       	mov	r0, r31
    1d54:	fb e0       	ldi	r31, 0x0B	; 11
    1d56:	ff 2e       	mov	r15, r31
    1d58:	f0 2d       	mov	r31, r0
    1d5a:	2f c0       	rjmp	.+94     	; 0x1dba <vTaskIncrementTick+0x1a2>
    1d5c:	8f ef       	ldi	r24, 0xFF	; 255
    1d5e:	9f ef       	ldi	r25, 0xFF	; 255
    1d60:	dc 01       	movw	r26, r24
    1d62:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1d66:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1d6a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1d6e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1d72:	4d c0       	rjmp	.+154    	; 0x1e0e <vTaskIncrementTick+0x1f6>
    1d74:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1d78:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1d7c:	07 80       	ldd	r0, Z+7	; 0x07
    1d7e:	f0 85       	ldd	r31, Z+8	; 0x08
    1d80:	e0 2d       	mov	r30, r0
    1d82:	c0 85       	ldd	r28, Z+8	; 0x08
    1d84:	d1 85       	ldd	r29, Z+9	; 0x09
    1d86:	8a 81       	ldd	r24, Y+2	; 0x02
    1d88:	9b 81       	ldd	r25, Y+3	; 0x03
    1d8a:	ac 81       	ldd	r26, Y+4	; 0x04
    1d8c:	bd 81       	ldd	r27, Y+5	; 0x05
    1d8e:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    1d92:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    1d96:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1d9a:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1d9e:	48 17       	cp	r20, r24
    1da0:	59 07       	cpc	r21, r25
    1da2:	6a 07       	cpc	r22, r26
    1da4:	7b 07       	cpc	r23, r27
    1da6:	48 f4       	brcc	.+18     	; 0x1dba <vTaskIncrementTick+0x1a2>
    1da8:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1dac:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1db0:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1db4:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1db8:	2a c0       	rjmp	.+84     	; 0x1e0e <vTaskIncrementTick+0x1f6>
    1dba:	8e 01       	movw	r16, r28
    1dbc:	0e 5f       	subi	r16, 0xFE	; 254
    1dbe:	1f 4f       	sbci	r17, 0xFF	; 255
    1dc0:	c8 01       	movw	r24, r16
    1dc2:	0e 94 2e 08 	call	0x105c	; 0x105c <vListRemove>
    1dc6:	88 8d       	ldd	r24, Y+24	; 0x18
    1dc8:	99 8d       	ldd	r25, Y+25	; 0x19
    1dca:	89 2b       	or	r24, r25
    1dcc:	21 f0       	breq	.+8      	; 0x1dd6 <vTaskIncrementTick+0x1be>
    1dce:	ce 01       	movw	r24, r28
    1dd0:	0e 96       	adiw	r24, 0x0e	; 14
    1dd2:	0e 94 2e 08 	call	0x105c	; 0x105c <vListRemove>
    1dd6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1dd8:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    1ddc:	98 17       	cp	r25, r24
    1dde:	10 f4       	brcc	.+4      	; 0x1de4 <vTaskIncrementTick+0x1cc>
    1de0:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    1de4:	f8 9e       	mul	r15, r24
    1de6:	c0 01       	movw	r24, r0
    1de8:	11 24       	eor	r1, r1
    1dea:	b8 01       	movw	r22, r16
    1dec:	8a 5f       	subi	r24, 0xFA	; 250
    1dee:	9e 4c       	sbci	r25, 0xCE	; 206
    1df0:	0e 94 bc 07 	call	0xf78	; 0xf78 <vListInsertEnd>
    1df4:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <pxDelayedTaskList>
    1df8:	f0 91 ef 30 	lds	r31, 0x30EF	; 0x8030ef <pxDelayedTaskList+0x1>
    1dfc:	80 81       	ld	r24, Z
    1dfe:	81 11       	cpse	r24, r1
    1e00:	b9 cf       	rjmp	.-142    	; 0x1d74 <vTaskIncrementTick+0x15c>
    1e02:	ac cf       	rjmp	.-168    	; 0x1d5c <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    1e04:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    1e08:	8f 5f       	subi	r24, 0xFF	; 255
    1e0a:	80 93 d5 30 	sts	0x30D5, r24	; 0x8030d5 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1e0e:	df 91       	pop	r29
    1e10:	cf 91       	pop	r28
    1e12:	1f 91       	pop	r17
    1e14:	0f 91       	pop	r16
    1e16:	ff 90       	pop	r15
    1e18:	08 95       	ret

00001e1a <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1e1a:	cf 92       	push	r12
    1e1c:	df 92       	push	r13
    1e1e:	ef 92       	push	r14
    1e20:	ff 92       	push	r15
    1e22:	0f 93       	push	r16
    1e24:	1f 93       	push	r17
    1e26:	cf 93       	push	r28
    1e28:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1e2a:	0f b6       	in	r0, 0x3f	; 63
    1e2c:	f8 94       	cli
    1e2e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1e30:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    1e34:	81 50       	subi	r24, 0x01	; 1
    1e36:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e3a:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    1e3e:	81 11       	cpse	r24, r1
    1e40:	60 c0       	rjmp	.+192    	; 0x1f02 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1e42:	80 91 de 30 	lds	r24, 0x30DE	; 0x8030de <uxCurrentNumberOfTasks>
    1e46:	81 11       	cpse	r24, r1
    1e48:	2c c0       	rjmp	.+88     	; 0x1ea2 <xTaskResumeAll+0x88>
    1e4a:	5e c0       	rjmp	.+188    	; 0x1f08 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1e4c:	d7 01       	movw	r26, r14
    1e4e:	17 96       	adiw	r26, 0x07	; 7
    1e50:	ed 91       	ld	r30, X+
    1e52:	fc 91       	ld	r31, X
    1e54:	18 97       	sbiw	r26, 0x08	; 8
    1e56:	c0 85       	ldd	r28, Z+8	; 0x08
    1e58:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    1e5a:	ce 01       	movw	r24, r28
    1e5c:	0e 96       	adiw	r24, 0x0e	; 14
    1e5e:	0e 94 2e 08 	call	0x105c	; 0x105c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1e62:	8e 01       	movw	r16, r28
    1e64:	0e 5f       	subi	r16, 0xFE	; 254
    1e66:	1f 4f       	sbci	r17, 0xFF	; 255
    1e68:	c8 01       	movw	r24, r16
    1e6a:	0e 94 2e 08 	call	0x105c	; 0x105c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1e6e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e70:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    1e74:	98 17       	cp	r25, r24
    1e76:	10 f4       	brcc	.+4      	; 0x1e7c <xTaskResumeAll+0x62>
    1e78:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    1e7c:	d8 9e       	mul	r13, r24
    1e7e:	c0 01       	movw	r24, r0
    1e80:	11 24       	eor	r1, r1
    1e82:	b8 01       	movw	r22, r16
    1e84:	8a 5f       	subi	r24, 0xFA	; 250
    1e86:	9e 4c       	sbci	r25, 0xCE	; 206
    1e88:	0e 94 bc 07 	call	0xf78	; 0xf78 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1e8c:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    1e90:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1e94:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1e96:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e98:	98 17       	cp	r25, r24
    1e9a:	70 f0       	brcs	.+28     	; 0x1eb8 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    1e9c:	cc 24       	eor	r12, r12
    1e9e:	c3 94       	inc	r12
    1ea0:	0b c0       	rjmp	.+22     	; 0x1eb8 <xTaskResumeAll+0x9e>
    1ea2:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1ea4:	0f 2e       	mov	r0, r31
    1ea6:	f1 ee       	ldi	r31, 0xE1	; 225
    1ea8:	ef 2e       	mov	r14, r31
    1eaa:	f0 e3       	ldi	r31, 0x30	; 48
    1eac:	ff 2e       	mov	r15, r31
    1eae:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    1eb0:	0f 2e       	mov	r0, r31
    1eb2:	fb e0       	ldi	r31, 0x0B	; 11
    1eb4:	df 2e       	mov	r13, r31
    1eb6:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1eb8:	f7 01       	movw	r30, r14
    1eba:	80 81       	ld	r24, Z
    1ebc:	81 11       	cpse	r24, r1
    1ebe:	c6 cf       	rjmp	.-116    	; 0x1e4c <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ec0:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    1ec4:	88 23       	and	r24, r24
    1ec6:	81 f0       	breq	.+32     	; 0x1ee8 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ec8:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    1ecc:	88 23       	and	r24, r24
    1ece:	99 f0       	breq	.+38     	; 0x1ef6 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    1ed0:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <vTaskIncrementTick>
						--uxMissedTicks;
    1ed4:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    1ed8:	81 50       	subi	r24, 0x01	; 1
    1eda:	80 93 d5 30 	sts	0x30D5, r24	; 0x8030d5 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ede:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <uxMissedTicks>
    1ee2:	81 11       	cpse	r24, r1
    1ee4:	f5 cf       	rjmp	.-22     	; 0x1ed0 <xTaskResumeAll+0xb6>
    1ee6:	07 c0       	rjmp	.+14     	; 0x1ef6 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1ee8:	f1 e0       	ldi	r31, 0x01	; 1
    1eea:	cf 16       	cp	r12, r31
    1eec:	21 f0       	breq	.+8      	; 0x1ef6 <xTaskResumeAll+0xdc>
    1eee:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <xMissedYield>
    1ef2:	81 30       	cpi	r24, 0x01	; 1
    1ef4:	41 f4       	brne	.+16     	; 0x1f06 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1ef6:	10 92 d4 30 	sts	0x30D4, r1	; 0x8030d4 <xMissedYield>
					portYIELD_WITHIN_API();
    1efa:	0e 94 0a 09 	call	0x1214	; 0x1214 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    1efe:	81 e0       	ldi	r24, 0x01	; 1
    1f00:	03 c0       	rjmp	.+6      	; 0x1f08 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1f02:	80 e0       	ldi	r24, 0x00	; 0
    1f04:	01 c0       	rjmp	.+2      	; 0x1f08 <xTaskResumeAll+0xee>
    1f06:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1f08:	0f 90       	pop	r0
    1f0a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1f0c:	df 91       	pop	r29
    1f0e:	cf 91       	pop	r28
    1f10:	1f 91       	pop	r17
    1f12:	0f 91       	pop	r16
    1f14:	ff 90       	pop	r15
    1f16:	ef 90       	pop	r14
    1f18:	df 90       	pop	r13
    1f1a:	cf 90       	pop	r12
    1f1c:	08 95       	ret

00001f1e <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1f1e:	cf 92       	push	r12
    1f20:	df 92       	push	r13
    1f22:	ef 92       	push	r14
    1f24:	ff 92       	push	r15
    1f26:	cf 93       	push	r28
    1f28:	df 93       	push	r29
    1f2a:	ec 01       	movw	r28, r24
    1f2c:	6a 01       	movw	r12, r20
    1f2e:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1f30:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1f34:	88 81       	ld	r24, Y
    1f36:	99 81       	ldd	r25, Y+1	; 0x01
    1f38:	aa 81       	ldd	r26, Y+2	; 0x02
    1f3a:	bb 81       	ldd	r27, Y+3	; 0x03
    1f3c:	c8 0e       	add	r12, r24
    1f3e:	d9 1e       	adc	r13, r25
    1f40:	ea 1e       	adc	r14, r26
    1f42:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    1f44:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    1f48:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    1f4c:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1f50:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1f54:	48 17       	cp	r20, r24
    1f56:	59 07       	cpc	r21, r25
    1f58:	6a 07       	cpc	r22, r26
    1f5a:	7b 07       	cpc	r23, r27
    1f5c:	b8 f4       	brcc	.+46     	; 0x1f8c <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1f5e:	c8 16       	cp	r12, r24
    1f60:	d9 06       	cpc	r13, r25
    1f62:	ea 06       	cpc	r14, r26
    1f64:	fb 06       	cpc	r15, r27
    1f66:	e0 f5       	brcc	.+120    	; 0x1fe0 <vTaskDelayUntil+0xc2>
    1f68:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    1f6c:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    1f70:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1f74:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1f78:	c8 82       	st	Y, r12
    1f7a:	d9 82       	std	Y+1, r13	; 0x01
    1f7c:	ea 82       	std	Y+2, r14	; 0x02
    1f7e:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    1f80:	8c 15       	cp	r24, r12
    1f82:	9d 05       	cpc	r25, r13
    1f84:	ae 05       	cpc	r26, r14
    1f86:	bf 05       	cpc	r27, r15
    1f88:	f8 f4       	brcc	.+62     	; 0x1fc8 <vTaskDelayUntil+0xaa>
    1f8a:	13 c0       	rjmp	.+38     	; 0x1fb2 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1f8c:	c8 16       	cp	r12, r24
    1f8e:	d9 06       	cpc	r13, r25
    1f90:	ea 06       	cpc	r14, r26
    1f92:	fb 06       	cpc	r15, r27
    1f94:	00 f1       	brcs	.+64     	; 0x1fd6 <vTaskDelayUntil+0xb8>
    1f96:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    1f9a:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    1f9e:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    1fa2:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    1fa6:	8c 15       	cp	r24, r12
    1fa8:	9d 05       	cpc	r25, r13
    1faa:	ae 05       	cpc	r26, r14
    1fac:	bf 05       	cpc	r27, r15
    1fae:	98 f0       	brcs	.+38     	; 0x1fd6 <vTaskDelayUntil+0xb8>
    1fb0:	17 c0       	rjmp	.+46     	; 0x1fe0 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1fb2:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    1fb6:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    1fba:	02 96       	adiw	r24, 0x02	; 2
    1fbc:	0e 94 2e 08 	call	0x105c	; 0x105c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1fc0:	c7 01       	movw	r24, r14
    1fc2:	b6 01       	movw	r22, r12
    1fc4:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1fc8:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1fcc:	81 11       	cpse	r24, r1
    1fce:	0d c0       	rjmp	.+26     	; 0x1fea <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    1fd0:	0e 94 0a 09 	call	0x1214	; 0x1214 <vPortYield>
		}
	}
    1fd4:	0a c0       	rjmp	.+20     	; 0x1fea <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1fd6:	c8 82       	st	Y, r12
    1fd8:	d9 82       	std	Y+1, r13	; 0x01
    1fda:	ea 82       	std	Y+2, r14	; 0x02
    1fdc:	fb 82       	std	Y+3, r15	; 0x03
    1fde:	e9 cf       	rjmp	.-46     	; 0x1fb2 <vTaskDelayUntil+0x94>
    1fe0:	c8 82       	st	Y, r12
    1fe2:	d9 82       	std	Y+1, r13	; 0x01
    1fe4:	ea 82       	std	Y+2, r14	; 0x02
    1fe6:	fb 82       	std	Y+3, r15	; 0x03
    1fe8:	ef cf       	rjmp	.-34     	; 0x1fc8 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1fea:	df 91       	pop	r29
    1fec:	cf 91       	pop	r28
    1fee:	ff 90       	pop	r15
    1ff0:	ef 90       	pop	r14
    1ff2:	df 90       	pop	r13
    1ff4:	cf 90       	pop	r12
    1ff6:	08 95       	ret

00001ff8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1ff8:	cf 92       	push	r12
    1ffa:	df 92       	push	r13
    1ffc:	ef 92       	push	r14
    1ffe:	ff 92       	push	r15
    2000:	6b 01       	movw	r12, r22
    2002:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2004:	67 2b       	or	r22, r23
    2006:	68 2b       	or	r22, r24
    2008:	69 2b       	or	r22, r25
    200a:	e9 f0       	breq	.+58     	; 0x2046 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    200c:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2010:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    2014:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    2018:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    201c:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    2020:	c8 0e       	add	r12, r24
    2022:	d9 1e       	adc	r13, r25
    2024:	ea 1e       	adc	r14, r26
    2026:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2028:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    202c:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    2030:	02 96       	adiw	r24, 0x02	; 2
    2032:	0e 94 2e 08 	call	0x105c	; 0x105c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2036:	c7 01       	movw	r24, r14
    2038:	b6 01       	movw	r22, r12
    203a:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    203e:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2042:	81 11       	cpse	r24, r1
    2044:	02 c0       	rjmp	.+4      	; 0x204a <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2046:	0e 94 0a 09 	call	0x1214	; 0x1214 <vPortYield>
		}
	}
    204a:	ff 90       	pop	r15
    204c:	ef 90       	pop	r14
    204e:	df 90       	pop	r13
    2050:	cf 90       	pop	r12
    2052:	08 95       	ret

00002054 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2054:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    2058:	81 11       	cpse	r24, r1
    205a:	0c c0       	rjmp	.+24     	; 0x2074 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    205c:	e0 91 d8 30 	lds	r30, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2060:	4b e0       	ldi	r20, 0x0B	; 11
    2062:	e4 9f       	mul	r30, r20
    2064:	f0 01       	movw	r30, r0
    2066:	11 24       	eor	r1, r1
    2068:	ea 5f       	subi	r30, 0xFA	; 250
    206a:	fe 4c       	sbci	r31, 0xCE	; 206
    206c:	80 81       	ld	r24, Z
    206e:	88 23       	and	r24, r24
    2070:	29 f0       	breq	.+10     	; 0x207c <vTaskSwitchContext+0x28>
    2072:	14 c0       	rjmp	.+40     	; 0x209c <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2074:	81 e0       	ldi	r24, 0x01	; 1
    2076:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <xMissedYield>
    207a:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    207c:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    207e:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2082:	81 50       	subi	r24, 0x01	; 1
    2084:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2088:	e0 91 d8 30 	lds	r30, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    208c:	9e 9f       	mul	r25, r30
    208e:	f0 01       	movw	r30, r0
    2090:	11 24       	eor	r1, r1
    2092:	ea 5f       	subi	r30, 0xFA	; 250
    2094:	fe 4c       	sbci	r31, 0xCE	; 206
    2096:	80 81       	ld	r24, Z
    2098:	88 23       	and	r24, r24
    209a:	89 f3       	breq	.-30     	; 0x207e <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    209c:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    20a0:	28 2f       	mov	r18, r24
    20a2:	30 e0       	ldi	r19, 0x00	; 0
    20a4:	4b e0       	ldi	r20, 0x0B	; 11
    20a6:	84 9f       	mul	r24, r20
    20a8:	c0 01       	movw	r24, r0
    20aa:	11 24       	eor	r1, r1
    20ac:	dc 01       	movw	r26, r24
    20ae:	aa 5f       	subi	r26, 0xFA	; 250
    20b0:	be 4c       	sbci	r27, 0xCE	; 206
    20b2:	11 96       	adiw	r26, 0x01	; 1
    20b4:	ed 91       	ld	r30, X+
    20b6:	fc 91       	ld	r31, X
    20b8:	12 97       	sbiw	r26, 0x02	; 2
    20ba:	04 80       	ldd	r0, Z+4	; 0x04
    20bc:	f5 81       	ldd	r31, Z+5	; 0x05
    20be:	e0 2d       	mov	r30, r0
    20c0:	11 96       	adiw	r26, 0x01	; 1
    20c2:	ed 93       	st	X+, r30
    20c4:	fc 93       	st	X, r31
    20c6:	12 97       	sbiw	r26, 0x02	; 2
    20c8:	87 5f       	subi	r24, 0xF7	; 247
    20ca:	9e 4c       	sbci	r25, 0xCE	; 206
    20cc:	e8 17       	cp	r30, r24
    20ce:	f9 07       	cpc	r31, r25
    20d0:	61 f4       	brne	.+24     	; 0x20ea <vTaskSwitchContext+0x96>
    20d2:	84 81       	ldd	r24, Z+4	; 0x04
    20d4:	95 81       	ldd	r25, Z+5	; 0x05
    20d6:	4b e0       	ldi	r20, 0x0B	; 11
    20d8:	42 9f       	mul	r20, r18
    20da:	f0 01       	movw	r30, r0
    20dc:	43 9f       	mul	r20, r19
    20de:	f0 0d       	add	r31, r0
    20e0:	11 24       	eor	r1, r1
    20e2:	ea 5f       	subi	r30, 0xFA	; 250
    20e4:	fe 4c       	sbci	r31, 0xCE	; 206
    20e6:	81 83       	std	Z+1, r24	; 0x01
    20e8:	92 83       	std	Z+2, r25	; 0x02
    20ea:	8b e0       	ldi	r24, 0x0B	; 11
    20ec:	82 9f       	mul	r24, r18
    20ee:	f0 01       	movw	r30, r0
    20f0:	83 9f       	mul	r24, r19
    20f2:	f0 0d       	add	r31, r0
    20f4:	11 24       	eor	r1, r1
    20f6:	ea 5f       	subi	r30, 0xFA	; 250
    20f8:	fe 4c       	sbci	r31, 0xCE	; 206
    20fa:	01 80       	ldd	r0, Z+1	; 0x01
    20fc:	f2 81       	ldd	r31, Z+2	; 0x02
    20fe:	e0 2d       	mov	r30, r0
    2100:	80 85       	ldd	r24, Z+8	; 0x08
    2102:	91 85       	ldd	r25, Z+9	; 0x09
    2104:	80 93 32 31 	sts	0x3132, r24	; 0x803132 <pxCurrentTCB>
    2108:	90 93 33 31 	sts	0x3133, r25	; 0x803133 <pxCurrentTCB+0x1>
    210c:	08 95       	ret

0000210e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    210e:	cf 92       	push	r12
    2110:	df 92       	push	r13
    2112:	ef 92       	push	r14
    2114:	ff 92       	push	r15
    2116:	6a 01       	movw	r12, r20
    2118:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    211a:	60 91 32 31 	lds	r22, 0x3132	; 0x803132 <pxCurrentTCB>
    211e:	70 91 33 31 	lds	r23, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    2122:	62 5f       	subi	r22, 0xF2	; 242
    2124:	7f 4f       	sbci	r23, 0xFF	; 255
    2126:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    212a:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    212e:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    2132:	02 96       	adiw	r24, 0x02	; 2
    2134:	0e 94 2e 08 	call	0x105c	; 0x105c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2138:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    213c:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    2140:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2144:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2148:	bc 01       	movw	r22, r24
    214a:	cd 01       	movw	r24, r26
    214c:	6c 0d       	add	r22, r12
    214e:	7d 1d       	adc	r23, r13
    2150:	8e 1d       	adc	r24, r14
    2152:	9f 1d       	adc	r25, r15
    2154:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2158:	ff 90       	pop	r15
    215a:	ef 90       	pop	r14
    215c:	df 90       	pop	r13
    215e:	cf 90       	pop	r12
    2160:	08 95       	ret

00002162 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2162:	0f 93       	push	r16
    2164:	1f 93       	push	r17
    2166:	cf 93       	push	r28
    2168:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    216a:	dc 01       	movw	r26, r24
    216c:	17 96       	adiw	r26, 0x07	; 7
    216e:	ed 91       	ld	r30, X+
    2170:	fc 91       	ld	r31, X
    2172:	18 97       	sbiw	r26, 0x08	; 8
    2174:	c0 85       	ldd	r28, Z+8	; 0x08
    2176:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2178:	8e 01       	movw	r16, r28
    217a:	02 5f       	subi	r16, 0xF2	; 242
    217c:	1f 4f       	sbci	r17, 0xFF	; 255
    217e:	c8 01       	movw	r24, r16
    2180:	0e 94 2e 08 	call	0x105c	; 0x105c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2184:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxSchedulerSuspended>
    2188:	81 11       	cpse	r24, r1
    218a:	16 c0       	rjmp	.+44     	; 0x21b8 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    218c:	0c 50       	subi	r16, 0x0C	; 12
    218e:	11 09       	sbc	r17, r1
    2190:	c8 01       	movw	r24, r16
    2192:	0e 94 2e 08 	call	0x105c	; 0x105c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2196:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2198:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    219c:	98 17       	cp	r25, r24
    219e:	10 f4       	brcc	.+4      	; 0x21a4 <xTaskRemoveFromEventList+0x42>
    21a0:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    21a4:	bb e0       	ldi	r27, 0x0B	; 11
    21a6:	8b 9f       	mul	r24, r27
    21a8:	c0 01       	movw	r24, r0
    21aa:	11 24       	eor	r1, r1
    21ac:	b8 01       	movw	r22, r16
    21ae:	8a 5f       	subi	r24, 0xFA	; 250
    21b0:	9e 4c       	sbci	r25, 0xCE	; 206
    21b2:	0e 94 bc 07 	call	0xf78	; 0xf78 <vListInsertEnd>
    21b6:	05 c0       	rjmp	.+10     	; 0x21c2 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    21b8:	b8 01       	movw	r22, r16
    21ba:	81 ee       	ldi	r24, 0xE1	; 225
    21bc:	90 e3       	ldi	r25, 0x30	; 48
    21be:	0e 94 bc 07 	call	0xf78	; 0xf78 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    21c2:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    21c6:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    21ca:	81 e0       	ldi	r24, 0x01	; 1
    21cc:	2a 8d       	ldd	r18, Y+26	; 0x1a
    21ce:	92 8d       	ldd	r25, Z+26	; 0x1a
    21d0:	29 17       	cp	r18, r25
    21d2:	08 f4       	brcc	.+2      	; 0x21d6 <xTaskRemoveFromEventList+0x74>
    21d4:	80 e0       	ldi	r24, 0x00	; 0
}
    21d6:	df 91       	pop	r29
    21d8:	cf 91       	pop	r28
    21da:	1f 91       	pop	r17
    21dc:	0f 91       	pop	r16
    21de:	08 95       	ret

000021e0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    21e0:	20 91 d3 30 	lds	r18, 0x30D3	; 0x8030d3 <xNumOfOverflows>
    21e4:	fc 01       	movw	r30, r24
    21e6:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    21e8:	40 91 da 30 	lds	r20, 0x30DA	; 0x8030da <xTickCount>
    21ec:	50 91 db 30 	lds	r21, 0x30DB	; 0x8030db <xTickCount+0x1>
    21f0:	60 91 dc 30 	lds	r22, 0x30DC	; 0x8030dc <xTickCount+0x2>
    21f4:	70 91 dd 30 	lds	r23, 0x30DD	; 0x8030dd <xTickCount+0x3>
    21f8:	41 83       	std	Z+1, r20	; 0x01
    21fa:	52 83       	std	Z+2, r21	; 0x02
    21fc:	63 83       	std	Z+3, r22	; 0x03
    21fe:	74 83       	std	Z+4, r23	; 0x04
    2200:	08 95       	ret

00002202 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2202:	8f 92       	push	r8
    2204:	9f 92       	push	r9
    2206:	af 92       	push	r10
    2208:	bf 92       	push	r11
    220a:	cf 92       	push	r12
    220c:	df 92       	push	r13
    220e:	ef 92       	push	r14
    2210:	ff 92       	push	r15
    2212:	0f 93       	push	r16
    2214:	1f 93       	push	r17
    2216:	cf 93       	push	r28
    2218:	df 93       	push	r29
    221a:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    221c:	0f b6       	in	r0, 0x3f	; 63
    221e:	f8 94       	cli
    2220:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2222:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <xNumOfOverflows>
    2226:	90 81       	ld	r25, Z
    2228:	98 17       	cp	r25, r24
    222a:	89 f0       	breq	.+34     	; 0x224e <xTaskCheckForTimeOut+0x4c>
    222c:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    2230:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    2234:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2238:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    223c:	01 81       	ldd	r16, Z+1	; 0x01
    223e:	12 81       	ldd	r17, Z+2	; 0x02
    2240:	23 81       	ldd	r18, Z+3	; 0x03
    2242:	34 81       	ldd	r19, Z+4	; 0x04
    2244:	80 17       	cp	r24, r16
    2246:	91 07       	cpc	r25, r17
    2248:	a2 07       	cpc	r26, r18
    224a:	b3 07       	cpc	r27, r19
    224c:	a8 f5       	brcc	.+106    	; 0x22b8 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    224e:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount>
    2252:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x1>
    2256:	a0 91 dc 30 	lds	r26, 0x30DC	; 0x8030dc <xTickCount+0x2>
    225a:	b0 91 dd 30 	lds	r27, 0x30DD	; 0x8030dd <xTickCount+0x3>
    225e:	c1 80       	ldd	r12, Z+1	; 0x01
    2260:	d2 80       	ldd	r13, Z+2	; 0x02
    2262:	e3 80       	ldd	r14, Z+3	; 0x03
    2264:	f4 80       	ldd	r15, Z+4	; 0x04
    2266:	eb 01       	movw	r28, r22
    2268:	08 81       	ld	r16, Y
    226a:	19 81       	ldd	r17, Y+1	; 0x01
    226c:	2a 81       	ldd	r18, Y+2	; 0x02
    226e:	3b 81       	ldd	r19, Y+3	; 0x03
    2270:	8c 19       	sub	r24, r12
    2272:	9d 09       	sbc	r25, r13
    2274:	ae 09       	sbc	r26, r14
    2276:	bf 09       	sbc	r27, r15
    2278:	80 17       	cp	r24, r16
    227a:	91 07       	cpc	r25, r17
    227c:	a2 07       	cpc	r26, r18
    227e:	b3 07       	cpc	r27, r19
    2280:	e8 f4       	brcc	.+58     	; 0x22bc <xTaskCheckForTimeOut+0xba>
    2282:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2284:	80 90 da 30 	lds	r8, 0x30DA	; 0x8030da <xTickCount>
    2288:	90 90 db 30 	lds	r9, 0x30DB	; 0x8030db <xTickCount+0x1>
    228c:	a0 90 dc 30 	lds	r10, 0x30DC	; 0x8030dc <xTickCount+0x2>
    2290:	b0 90 dd 30 	lds	r11, 0x30DD	; 0x8030dd <xTickCount+0x3>
    2294:	b5 01       	movw	r22, r10
    2296:	a4 01       	movw	r20, r8
    2298:	4c 19       	sub	r20, r12
    229a:	5d 09       	sbc	r21, r13
    229c:	6e 09       	sbc	r22, r14
    229e:	7f 09       	sbc	r23, r15
    22a0:	04 1b       	sub	r16, r20
    22a2:	15 0b       	sbc	r17, r21
    22a4:	26 0b       	sbc	r18, r22
    22a6:	37 0b       	sbc	r19, r23
    22a8:	08 83       	st	Y, r16
    22aa:	19 83       	std	Y+1, r17	; 0x01
    22ac:	2a 83       	std	Y+2, r18	; 0x02
    22ae:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    22b0:	0e 94 f0 10 	call	0x21e0	; 0x21e0 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    22b4:	80 e0       	ldi	r24, 0x00	; 0
    22b6:	03 c0       	rjmp	.+6      	; 0x22be <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    22b8:	81 e0       	ldi	r24, 0x01	; 1
    22ba:	01 c0       	rjmp	.+2      	; 0x22be <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    22bc:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    22be:	0f 90       	pop	r0
    22c0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    22c2:	df 91       	pop	r29
    22c4:	cf 91       	pop	r28
    22c6:	1f 91       	pop	r17
    22c8:	0f 91       	pop	r16
    22ca:	ff 90       	pop	r15
    22cc:	ef 90       	pop	r14
    22ce:	df 90       	pop	r13
    22d0:	cf 90       	pop	r12
    22d2:	bf 90       	pop	r11
    22d4:	af 90       	pop	r10
    22d6:	9f 90       	pop	r9
    22d8:	8f 90       	pop	r8
    22da:	08 95       	ret

000022dc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    22dc:	81 e0       	ldi	r24, 0x01	; 1
    22de:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <xMissedYield>
    22e2:	08 95       	ret

000022e4 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    22e4:	00 97       	sbiw	r24, 0x00	; 0
    22e6:	21 f4       	brne	.+8      	; 0x22f0 <uxTaskGetStackHighWaterMark+0xc>
    22e8:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    22ec:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    22f0:	dc 01       	movw	r26, r24
    22f2:	5b 96       	adiw	r26, 0x1b	; 27
    22f4:	ed 91       	ld	r30, X+
    22f6:	fc 91       	ld	r31, X
    22f8:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    22fa:	80 81       	ld	r24, Z
    22fc:	81 31       	cpi	r24, 0x11	; 17
    22fe:	41 f4       	brne	.+16     	; 0x2310 <uxTaskGetStackHighWaterMark+0x2c>
    2300:	31 96       	adiw	r30, 0x01	; 1
    2302:	80 e0       	ldi	r24, 0x00	; 0
    2304:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2306:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2308:	21 91       	ld	r18, Z+
    230a:	21 31       	cpi	r18, 0x11	; 17
    230c:	e1 f3       	breq	.-8      	; 0x2306 <uxTaskGetStackHighWaterMark+0x22>
    230e:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2310:	80 e0       	ldi	r24, 0x00	; 0
    2312:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2314:	08 95       	ret

00002316 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2316:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <pxCurrentTCB>
    231a:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <pxCurrentTCB+0x1>

		return xReturn;
	}
    231e:	08 95       	ret

00002320 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2320:	0f 93       	push	r16
    2322:	1f 93       	push	r17
    2324:	cf 93       	push	r28
    2326:	df 93       	push	r29
    2328:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    232a:	22 8d       	ldd	r18, Z+26	; 0x1a
    232c:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    2330:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    2334:	5a 96       	adiw	r26, 0x1a	; 26
    2336:	8c 91       	ld	r24, X
    2338:	28 17       	cp	r18, r24
    233a:	08 f0       	brcs	.+2      	; 0x233e <vTaskPriorityInherit+0x1e>
    233c:	41 c0       	rjmp	.+130    	; 0x23c0 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    233e:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    2342:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    2346:	5a 96       	adiw	r26, 0x1a	; 26
    2348:	3c 91       	ld	r19, X
    234a:	84 e0       	ldi	r24, 0x04	; 4
    234c:	90 e0       	ldi	r25, 0x00	; 0
    234e:	a0 e0       	ldi	r26, 0x00	; 0
    2350:	b0 e0       	ldi	r27, 0x00	; 0
    2352:	83 1b       	sub	r24, r19
    2354:	91 09       	sbc	r25, r1
    2356:	a1 09       	sbc	r26, r1
    2358:	b1 09       	sbc	r27, r1
    235a:	86 87       	std	Z+14, r24	; 0x0e
    235c:	97 87       	std	Z+15, r25	; 0x0f
    235e:	a0 8b       	std	Z+16, r26	; 0x10
    2360:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2362:	8b e0       	ldi	r24, 0x0B	; 11
    2364:	28 9f       	mul	r18, r24
    2366:	90 01       	movw	r18, r0
    2368:	11 24       	eor	r1, r1
    236a:	2a 5f       	subi	r18, 0xFA	; 250
    236c:	3e 4c       	sbci	r19, 0xCE	; 206
    236e:	84 85       	ldd	r24, Z+12	; 0x0c
    2370:	95 85       	ldd	r25, Z+13	; 0x0d
    2372:	82 17       	cp	r24, r18
    2374:	93 07       	cpc	r25, r19
    2376:	e9 f4       	brne	.+58     	; 0x23b2 <vTaskPriorityInherit+0x92>
    2378:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    237a:	ef 01       	movw	r28, r30
    237c:	22 96       	adiw	r28, 0x02	; 2
    237e:	ce 01       	movw	r24, r28
    2380:	0e 94 2e 08 	call	0x105c	; 0x105c <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2384:	e0 91 32 31 	lds	r30, 0x3132	; 0x803132 <pxCurrentTCB>
    2388:	f0 91 33 31 	lds	r31, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    238c:	82 8d       	ldd	r24, Z+26	; 0x1a
    238e:	f8 01       	movw	r30, r16
    2390:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2392:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    2396:	98 17       	cp	r25, r24
    2398:	10 f4       	brcc	.+4      	; 0x239e <vTaskPriorityInherit+0x7e>
    239a:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    239e:	fb e0       	ldi	r31, 0x0B	; 11
    23a0:	8f 9f       	mul	r24, r31
    23a2:	c0 01       	movw	r24, r0
    23a4:	11 24       	eor	r1, r1
    23a6:	be 01       	movw	r22, r28
    23a8:	8a 5f       	subi	r24, 0xFA	; 250
    23aa:	9e 4c       	sbci	r25, 0xCE	; 206
    23ac:	0e 94 bc 07 	call	0xf78	; 0xf78 <vListInsertEnd>
    23b0:	07 c0       	rjmp	.+14     	; 0x23c0 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    23b2:	a0 91 32 31 	lds	r26, 0x3132	; 0x803132 <pxCurrentTCB>
    23b6:	b0 91 33 31 	lds	r27, 0x3133	; 0x803133 <pxCurrentTCB+0x1>
    23ba:	5a 96       	adiw	r26, 0x1a	; 26
    23bc:	8c 91       	ld	r24, X
    23be:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    23c0:	df 91       	pop	r29
    23c2:	cf 91       	pop	r28
    23c4:	1f 91       	pop	r17
    23c6:	0f 91       	pop	r16
    23c8:	08 95       	ret

000023ca <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    23ca:	0f 93       	push	r16
    23cc:	1f 93       	push	r17
    23ce:	cf 93       	push	r28
    23d0:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    23d2:	00 97       	sbiw	r24, 0x00	; 0
    23d4:	49 f1       	breq	.+82     	; 0x2428 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    23d6:	fc 01       	movw	r30, r24
    23d8:	32 8d       	ldd	r19, Z+26	; 0x1a
    23da:	27 a1       	ldd	r18, Z+39	; 0x27
    23dc:	32 17       	cp	r19, r18
    23de:	21 f1       	breq	.+72     	; 0x2428 <vTaskPriorityDisinherit+0x5e>
    23e0:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    23e2:	8c 01       	movw	r16, r24
    23e4:	0e 5f       	subi	r16, 0xFE	; 254
    23e6:	1f 4f       	sbci	r17, 0xFF	; 255
    23e8:	c8 01       	movw	r24, r16
    23ea:	0e 94 2e 08 	call	0x105c	; 0x105c <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    23ee:	8f a1       	ldd	r24, Y+39	; 0x27
    23f0:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    23f2:	44 e0       	ldi	r20, 0x04	; 4
    23f4:	50 e0       	ldi	r21, 0x00	; 0
    23f6:	60 e0       	ldi	r22, 0x00	; 0
    23f8:	70 e0       	ldi	r23, 0x00	; 0
    23fa:	48 1b       	sub	r20, r24
    23fc:	51 09       	sbc	r21, r1
    23fe:	61 09       	sbc	r22, r1
    2400:	71 09       	sbc	r23, r1
    2402:	4e 87       	std	Y+14, r20	; 0x0e
    2404:	5f 87       	std	Y+15, r21	; 0x0f
    2406:	68 8b       	std	Y+16, r22	; 0x10
    2408:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    240a:	90 91 d8 30 	lds	r25, 0x30D8	; 0x8030d8 <uxTopReadyPriority>
    240e:	98 17       	cp	r25, r24
    2410:	10 f4       	brcc	.+4      	; 0x2416 <vTaskPriorityDisinherit+0x4c>
    2412:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <uxTopReadyPriority>
    2416:	fb e0       	ldi	r31, 0x0B	; 11
    2418:	8f 9f       	mul	r24, r31
    241a:	c0 01       	movw	r24, r0
    241c:	11 24       	eor	r1, r1
    241e:	b8 01       	movw	r22, r16
    2420:	8a 5f       	subi	r24, 0xFA	; 250
    2422:	9e 4c       	sbci	r25, 0xCE	; 206
    2424:	0e 94 bc 07 	call	0xf78	; 0xf78 <vListInsertEnd>
			}
		}
	}
    2428:	df 91       	pop	r29
    242a:	cf 91       	pop	r28
    242c:	1f 91       	pop	r17
    242e:	0f 91       	pop	r16
    2430:	08 95       	ret

00002432 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2432:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2434:	e8 81       	ld	r30, Y
    2436:	f9 81       	ldd	r31, Y+1	; 0x01
    2438:	01 90       	ld	r0, Z+
    243a:	f0 81       	ld	r31, Z
    243c:	e0 2d       	mov	r30, r0
    243e:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2440:	1a 82       	std	Y+2, r1	; 0x02
    2442:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2444:	6f ef       	ldi	r22, 0xFF	; 255
    2446:	7f ef       	ldi	r23, 0xFF	; 255
    2448:	cb 01       	movw	r24, r22
    244a:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <vTaskDelay>
    244e:	fa cf       	rjmp	.-12     	; 0x2444 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002450 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2450:	fc 01       	movw	r30, r24
    2452:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2454:	65 87       	std	Z+13, r22	; 0x0d
    2456:	08 95       	ret

00002458 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2458:	4f 92       	push	r4
    245a:	5f 92       	push	r5
    245c:	6f 92       	push	r6
    245e:	7f 92       	push	r7
    2460:	8f 92       	push	r8
    2462:	9f 92       	push	r9
    2464:	af 92       	push	r10
    2466:	bf 92       	push	r11
    2468:	cf 92       	push	r12
    246a:	df 92       	push	r13
    246c:	ef 92       	push	r14
    246e:	ff 92       	push	r15
    2470:	0f 93       	push	r16
    2472:	1f 93       	push	r17
    2474:	cf 93       	push	r28
    2476:	df 93       	push	r29
    2478:	cd b7       	in	r28, 0x3d	; 61
    247a:	de b7       	in	r29, 0x3e	; 62
    247c:	2a 97       	sbiw	r28, 0x0a	; 10
    247e:	cd bf       	out	0x3d, r28	; 61
    2480:	de bf       	out	0x3e, r29	; 62
    2482:	4c 01       	movw	r8, r24
    2484:	29 01       	movw	r4, r18
    2486:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2488:	87 e4       	ldi	r24, 0x47	; 71
    248a:	90 e2       	ldi	r25, 0x20	; 32
    248c:	f4 01       	movw	r30, r8
    248e:	80 83       	st	Z, r24
    2490:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2492:	fb 01       	movw	r30, r22
    2494:	80 81       	ld	r24, Z
    2496:	88 23       	and	r24, r24
    2498:	69 f0       	breq	.+26     	; 0x24b4 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    249a:	de 01       	movw	r26, r28
    249c:	11 96       	adiw	r26, 0x01	; 1
    249e:	31 96       	adiw	r30, 0x01	; 1
    24a0:	90 e0       	ldi	r25, 0x00	; 0
    24a2:	02 c0       	rjmp	.+4      	; 0x24a8 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    24a4:	99 30       	cpi	r25, 0x09	; 9
    24a6:	39 f0       	breq	.+14     	; 0x24b6 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    24a8:	9f 5f       	subi	r25, 0xFF	; 255
    24aa:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    24ac:	81 91       	ld	r24, Z+
    24ae:	81 11       	cpse	r24, r1
    24b0:	f9 cf       	rjmp	.-14     	; 0x24a4 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    24b2:	01 c0       	rjmp	.+2      	; 0x24b6 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    24b4:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    24b6:	e1 e0       	ldi	r30, 0x01	; 1
    24b8:	f0 e0       	ldi	r31, 0x00	; 0
    24ba:	ec 0f       	add	r30, r28
    24bc:	fd 1f       	adc	r31, r29
    24be:	e9 0f       	add	r30, r25
    24c0:	f1 1d       	adc	r31, r1
    24c2:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    24c4:	74 01       	movw	r14, r8
    24c6:	f2 e0       	ldi	r31, 0x02	; 2
    24c8:	ef 0e       	add	r14, r31
    24ca:	f1 1c       	adc	r15, r1
    24cc:	a1 2c       	mov	r10, r1
    24ce:	b1 2c       	mov	r11, r1
    24d0:	c1 2c       	mov	r12, r1
    24d2:	d1 2c       	mov	r13, r1
    24d4:	04 2f       	mov	r16, r20
    24d6:	94 01       	movw	r18, r8
    24d8:	a2 01       	movw	r20, r4
    24da:	be 01       	movw	r22, r28
    24dc:	6f 5f       	subi	r22, 0xFF	; 255
    24de:	7f 4f       	sbci	r23, 0xFF	; 255
    24e0:	88 ea       	ldi	r24, 0xA8	; 168
    24e2:	92 e0       	ldi	r25, 0x02	; 2
    24e4:	0e 94 a8 0c 	call	0x1950	; 0x1950 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    24e8:	f4 01       	movw	r30, r8
    24ea:	66 82       	std	Z+6, r6	; 0x06
    24ec:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    24ee:	40 86       	std	Z+8, r4	; 0x08
    24f0:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    24f2:	20 91 34 31 	lds	r18, 0x3134	; 0x803134 <last_created_task_pointer>
    24f6:	30 91 35 31 	lds	r19, 0x3135	; 0x803135 <last_created_task_pointer+0x1>
    24fa:	24 83       	std	Z+4, r18	; 0x04
    24fc:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    24fe:	80 92 34 31 	sts	0x3134, r8	; 0x803134 <last_created_task_pointer>
    2502:	90 92 35 31 	sts	0x3135, r9	; 0x803135 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2506:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2508:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    250a:	40 90 72 31 	lds	r4, 0x3172	; 0x803172 <portStackTopForTask>
    250e:	50 90 73 31 	lds	r5, 0x3173	; 0x803173 <portStackTopForTask+0x1>
    2512:	ff ef       	ldi	r31, 0xFF	; 255
    2514:	4f 1a       	sub	r4, r31
    2516:	5f 0a       	sbc	r5, r31
    2518:	40 92 72 31 	sts	0x3172, r4	; 0x803172 <portStackTopForTask>
    251c:	50 92 73 31 	sts	0x3173, r5	; 0x803173 <portStackTopForTask+0x1>
    2520:	f4 01       	movw	r30, r8
    2522:	42 86       	std	Z+10, r4	; 0x0a
    2524:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2526:	16 86       	std	Z+14, r1	; 0x0e
    2528:	17 86       	std	Z+15, r1	; 0x0f
    252a:	10 8a       	std	Z+16, r1	; 0x10
    252c:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    252e:	61 14       	cp	r6, r1
    2530:	71 04       	cpc	r7, r1
    2532:	09 f4       	brne	.+2      	; 0x2536 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2534:	44 c0       	rjmp	.+136    	; 0x25be <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2536:	81 30       	cpi	r24, 0x01	; 1
    2538:	79 f5       	brne	.+94     	; 0x2598 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    253a:	6a e0       	ldi	r22, 0x0A	; 10
    253c:	c3 01       	movw	r24, r6
    253e:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2542:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2544:	6d e9       	ldi	r22, 0x9D	; 157
    2546:	74 e0       	ldi	r23, 0x04	; 4
    2548:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    254c:	be 01       	movw	r22, r28
    254e:	6f 5f       	subi	r22, 0xFF	; 255
    2550:	7f 4f       	sbci	r23, 0xFF	; 255
    2552:	c7 01       	movw	r24, r14
    2554:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    2558:	6a e0       	ldi	r22, 0x0A	; 10
    255a:	c7 01       	movw	r24, r14
    255c:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2560:	7c 01       	movw	r14, r24
    2562:	64 e9       	ldi	r22, 0x94	; 148
    2564:	74 e0       	ldi	r23, 0x04	; 4
    2566:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    256a:	6a e0       	ldi	r22, 0x0A	; 10
    256c:	c7 01       	movw	r24, r14
    256e:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2572:	7c 01       	movw	r14, r24
    2574:	66 e8       	ldi	r22, 0x86	; 134
    2576:	74 e0       	ldi	r23, 0x04	; 4
    2578:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    257c:	63 e0       	ldi	r22, 0x03	; 3
    257e:	c7 01       	movw	r24, r14
    2580:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2584:	b2 01       	movw	r22, r4
    2586:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <_ZN8emstreamlsEj>
    258a:	62 e0       	ldi	r22, 0x02	; 2
    258c:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2590:	66 e0       	ldi	r22, 0x06	; 6
    2592:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2596:	13 c0       	rjmp	.+38     	; 0x25be <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2598:	6a e0       	ldi	r22, 0x0A	; 10
    259a:	c3 01       	movw	r24, r6
    259c:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    25a0:	4c 01       	movw	r8, r24
    25a2:	61 e7       	ldi	r22, 0x71	; 113
    25a4:	74 e0       	ldi	r23, 0x04	; 4
    25a6:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    25aa:	be 01       	movw	r22, r28
    25ac:	6f 5f       	subi	r22, 0xFF	; 255
    25ae:	7f 4f       	sbci	r23, 0xFF	; 255
    25b0:	c4 01       	movw	r24, r8
    25b2:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    25b6:	66 e0       	ldi	r22, 0x06	; 6
    25b8:	c4 01       	movw	r24, r8
    25ba:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    25be:	2a 96       	adiw	r28, 0x0a	; 10
    25c0:	cd bf       	out	0x3d, r28	; 61
    25c2:	de bf       	out	0x3e, r29	; 62
    25c4:	df 91       	pop	r29
    25c6:	cf 91       	pop	r28
    25c8:	1f 91       	pop	r17
    25ca:	0f 91       	pop	r16
    25cc:	ff 90       	pop	r15
    25ce:	ef 90       	pop	r14
    25d0:	df 90       	pop	r13
    25d2:	cf 90       	pop	r12
    25d4:	bf 90       	pop	r11
    25d6:	af 90       	pop	r10
    25d8:	9f 90       	pop	r9
    25da:	8f 90       	pop	r8
    25dc:	7f 90       	pop	r7
    25de:	6f 90       	pop	r6
    25e0:	5f 90       	pop	r5
    25e2:	4f 90       	pop	r4
    25e4:	08 95       	ret

000025e6 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    25e6:	cf 92       	push	r12
    25e8:	df 92       	push	r13
    25ea:	ef 92       	push	r14
    25ec:	ff 92       	push	r15
    25ee:	0f 93       	push	r16
    25f0:	1f 93       	push	r17
    25f2:	cf 93       	push	r28
    25f4:	df 93       	push	r29
    25f6:	ec 01       	movw	r28, r24
    25f8:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    25fa:	8a 81       	ldd	r24, Y+2	; 0x02
    25fc:	9b 81       	ldd	r25, Y+3	; 0x03
    25fe:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <pcTaskGetTaskName>
    2602:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2604:	6a e0       	ldi	r22, 0x0A	; 10
    2606:	c7 01       	movw	r24, r14
    2608:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    260c:	8c 01       	movw	r16, r24
    260e:	60 eb       	ldi	r22, 0xB0	; 176
    2610:	74 e0       	ldi	r23, 0x04	; 4
    2612:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    2616:	6a e0       	ldi	r22, 0x0A	; 10
    2618:	c8 01       	movw	r24, r16
    261a:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    261e:	8c 01       	movw	r16, r24
    2620:	69 ea       	ldi	r22, 0xA9	; 169
    2622:	74 e0       	ldi	r23, 0x04	; 4
    2624:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    2628:	b6 01       	movw	r22, r12
    262a:	c8 01       	movw	r24, r16
    262c:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2630:	6a e0       	ldi	r22, 0x0A	; 10
    2632:	c8 01       	movw	r24, r16
    2634:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2638:	8c 01       	movw	r16, r24
    263a:	63 ea       	ldi	r22, 0xA3	; 163
    263c:	74 e0       	ldi	r23, 0x04	; 4
    263e:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    2642:	66 e0       	ldi	r22, 0x06	; 6
    2644:	c8 01       	movw	r24, r16
    2646:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    264a:	8a 85       	ldd	r24, Y+10	; 0x0a
    264c:	9b 85       	ldd	r25, Y+11	; 0x0b
    264e:	e8 85       	ldd	r30, Y+8	; 0x08
    2650:	f9 85       	ldd	r31, Y+9	; 0x09
    2652:	01 e1       	ldi	r16, 0x11	; 17
    2654:	21 e0       	ldi	r18, 0x01	; 1
    2656:	a7 01       	movw	r20, r14
    2658:	bc 01       	movw	r22, r24
    265a:	8e 1b       	sub	r24, r30
    265c:	9f 0b       	sbc	r25, r31
    265e:	0e 94 f5 15 	call	0x2bea	; 0x2bea <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2662:	8c 81       	ldd	r24, Y+4	; 0x04
    2664:	9d 81       	ldd	r25, Y+5	; 0x05
    2666:	00 97       	sbiw	r24, 0x00	; 0
    2668:	19 f0       	breq	.+6      	; 0x2670 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    266a:	b7 01       	movw	r22, r14
    266c:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2670:	df 91       	pop	r29
    2672:	cf 91       	pop	r28
    2674:	1f 91       	pop	r17
    2676:	0f 91       	pop	r16
    2678:	ff 90       	pop	r15
    267a:	ef 90       	pop	r14
    267c:	df 90       	pop	r13
    267e:	cf 90       	pop	r12
    2680:	08 95       	ret

00002682 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2682:	0f 93       	push	r16
    2684:	1f 93       	push	r17
    2686:	cf 93       	push	r28
    2688:	df 93       	push	r29
    268a:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    268c:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <last_created_task_pointer>
    2690:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <last_created_task_pointer+0x1>
    2694:	00 97       	sbiw	r24, 0x00	; 0
    2696:	19 f0       	breq	.+6      	; 0x269e <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2698:	be 01       	movw	r22, r28
    269a:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    269e:	6a e0       	ldi	r22, 0x0A	; 10
    26a0:	ce 01       	movw	r24, r28
    26a2:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    26a6:	8c 01       	movw	r16, r24
    26a8:	66 ec       	ldi	r22, 0xC6	; 198
    26aa:	74 e0       	ldi	r23, 0x04	; 4
    26ac:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    26b0:	6a e0       	ldi	r22, 0x0A	; 10
    26b2:	c8 01       	movw	r24, r16
    26b4:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    26b8:	8c 01       	movw	r16, r24
    26ba:	6b eb       	ldi	r22, 0xBB	; 187
    26bc:	74 e0       	ldi	r23, 0x04	; 4
    26be:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    26c2:	6a e0       	ldi	r22, 0x0A	; 10
    26c4:	c8 01       	movw	r24, r16
    26c6:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    26ca:	8c 01       	movw	r16, r24
    26cc:	65 eb       	ldi	r22, 0xB5	; 181
    26ce:	74 e0       	ldi	r23, 0x04	; 4
    26d0:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    26d4:	66 e0       	ldi	r22, 0x06	; 6
    26d6:	c8 01       	movw	r24, r16
    26d8:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    26dc:	80 91 72 31 	lds	r24, 0x3172	; 0x803172 <portStackTopForTask>
    26e0:	90 91 73 31 	lds	r25, 0x3173	; 0x803173 <portStackTopForTask+0x1>
    26e4:	bc 01       	movw	r22, r24
    26e6:	6f 5f       	subi	r22, 0xFF	; 255
    26e8:	7f 4f       	sbci	r23, 0xFF	; 255
    26ea:	01 e1       	ldi	r16, 0x11	; 17
    26ec:	21 e0       	ldi	r18, 0x01	; 1
    26ee:	ae 01       	movw	r20, r28
    26f0:	83 56       	subi	r24, 0x63	; 99
    26f2:	91 09       	sbc	r25, r1
    26f4:	0e 94 f5 15 	call	0x2bea	; 0x2bea <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    26f8:	df 91       	pop	r29
    26fa:	cf 91       	pop	r28
    26fc:	1f 91       	pop	r17
    26fe:	0f 91       	pop	r16
    2700:	08 95       	ret

00002702 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2702:	8f 92       	push	r8
    2704:	9f 92       	push	r9
    2706:	af 92       	push	r10
    2708:	bf 92       	push	r11
    270a:	cf 92       	push	r12
    270c:	df 92       	push	r13
    270e:	ef 92       	push	r14
    2710:	ff 92       	push	r15
    2712:	0f 93       	push	r16
    2714:	1f 93       	push	r17
    2716:	cf 93       	push	r28
    2718:	df 93       	push	r29
    271a:	ec 01       	movw	r28, r24
    271c:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    271e:	8a 81       	ldd	r24, Y+2	; 0x02
    2720:	9b 81       	ldd	r25, Y+3	; 0x03
    2722:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <pcTaskGetTaskName>
    2726:	bc 01       	movw	r22, r24
    2728:	c8 01       	movw	r24, r16
    272a:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    272e:	d8 01       	movw	r26, r16
    2730:	ed 91       	ld	r30, X+
    2732:	fc 91       	ld	r31, X
    2734:	02 80       	ldd	r0, Z+2	; 0x02
    2736:	f3 81       	ldd	r31, Z+3	; 0x03
    2738:	e0 2d       	mov	r30, r0
    273a:	69 e0       	ldi	r22, 0x09	; 9
    273c:	c8 01       	movw	r24, r16
    273e:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2740:	8a 81       	ldd	r24, Y+2	; 0x02
    2742:	9b 81       	ldd	r25, Y+3	; 0x03
    2744:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <pcTaskGetTaskName>
    2748:	fc 01       	movw	r30, r24
    274a:	01 90       	ld	r0, Z+
    274c:	00 20       	and	r0, r0
    274e:	e9 f7       	brne	.-6      	; 0x274a <_ZN8frt_task12print_statusER8emstream+0x48>
    2750:	31 97       	sbiw	r30, 0x01	; 1
    2752:	e8 1b       	sub	r30, r24
    2754:	f9 0b       	sbc	r31, r25
    2756:	38 97       	sbiw	r30, 0x08	; 8
    2758:	48 f4       	brcc	.+18     	; 0x276c <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    275a:	d8 01       	movw	r26, r16
    275c:	ed 91       	ld	r30, X+
    275e:	fc 91       	ld	r31, X
    2760:	02 80       	ldd	r0, Z+2	; 0x02
    2762:	f3 81       	ldd	r31, Z+3	; 0x03
    2764:	e0 2d       	mov	r30, r0
    2766:	69 e0       	ldi	r22, 0x09	; 9
    2768:	c8 01       	movw	r24, r16
    276a:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    276c:	ce 84       	ldd	r12, Y+14	; 0x0e
    276e:	df 84       	ldd	r13, Y+15	; 0x0f
    2770:	e8 88       	ldd	r14, Y+16	; 0x10
    2772:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2774:	a8 84       	ldd	r10, Y+8	; 0x08
    2776:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2778:	8a 81       	ldd	r24, Y+2	; 0x02
    277a:	9b 81       	ldd	r25, Y+3	; 0x03
    277c:	0e 94 72 11 	call	0x22e4	; 0x22e4 <uxTaskGetStackHighWaterMark>
    2780:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2782:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2784:	8a 81       	ldd	r24, Y+2	; 0x02
    2786:	9b 81       	ldd	r25, Y+3	; 0x03
    2788:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <uxTaskPriorityGet>
    278c:	68 2f       	mov	r22, r24
    278e:	c8 01       	movw	r24, r16
    2790:	0e 94 68 18 	call	0x30d0	; 0x30d0 <_ZN8emstreamlsEh>
    2794:	6a e0       	ldi	r22, 0x0A	; 10
    2796:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    279a:	ec 01       	movw	r28, r24
    279c:	6b e3       	ldi	r22, 0x3B	; 59
    279e:	75 e0       	ldi	r23, 0x05	; 5
    27a0:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
			<< get_state ()
    27a4:	68 2d       	mov	r22, r8
    27a6:	ce 01       	movw	r24, r28
    27a8:	0e 94 68 18 	call	0x30d0	; 0x30d0 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    27ac:	6a e0       	ldi	r22, 0x0A	; 10
    27ae:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    27b2:	ec 01       	movw	r28, r24
    27b4:	69 e3       	ldi	r22, 0x39	; 57
    27b6:	75 e0       	ldi	r23, 0x05	; 5
    27b8:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    27bc:	69 2d       	mov	r22, r9
    27be:	ce 01       	movw	r24, r28
    27c0:	0e 94 68 18 	call	0x30d0	; 0x30d0 <_ZN8emstreamlsEh>
    27c4:	6a e0       	ldi	r22, 0x0A	; 10
    27c6:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    27ca:	ec 01       	movw	r28, r24
    27cc:	67 e3       	ldi	r22, 0x37	; 55
    27ce:	75 e0       	ldi	r23, 0x05	; 5
    27d0:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    27d4:	b5 01       	movw	r22, r10
    27d6:	ce 01       	movw	r24, r28
    27d8:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <_ZN8emstreamlsEj>
    27dc:	6a e0       	ldi	r22, 0x0A	; 10
    27de:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    27e2:	ec 01       	movw	r28, r24
    27e4:	65 e3       	ldi	r22, 0x35	; 53
    27e6:	75 e0       	ldi	r23, 0x05	; 5
    27e8:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    27ec:	6a e0       	ldi	r22, 0x0A	; 10
    27ee:	ce 01       	movw	r24, r28
    27f0:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    27f4:	ec 01       	movw	r28, r24
    27f6:	63 e3       	ldi	r22, 0x33	; 51
    27f8:	75 e0       	ldi	r23, 0x05	; 5
    27fa:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    27fe:	b7 01       	movw	r22, r14
    2800:	a6 01       	movw	r20, r12
    2802:	ce 01       	movw	r24, r28
    2804:	0e 94 26 18 	call	0x304c	; 0x304c <_ZN8emstreamlsEm>
}
    2808:	df 91       	pop	r29
    280a:	cf 91       	pop	r28
    280c:	1f 91       	pop	r17
    280e:	0f 91       	pop	r16
    2810:	ff 90       	pop	r15
    2812:	ef 90       	pop	r14
    2814:	df 90       	pop	r13
    2816:	cf 90       	pop	r12
    2818:	bf 90       	pop	r11
    281a:	af 90       	pop	r10
    281c:	9f 90       	pop	r9
    281e:	8f 90       	pop	r8
    2820:	08 95       	ret

00002822 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2822:	cf 93       	push	r28
    2824:	df 93       	push	r29
    2826:	ec 01       	movw	r28, r24
    2828:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    282a:	db 01       	movw	r26, r22
    282c:	ed 91       	ld	r30, X+
    282e:	fc 91       	ld	r31, X
    2830:	02 80       	ldd	r0, Z+2	; 0x02
    2832:	f3 81       	ldd	r31, Z+3	; 0x03
    2834:	e0 2d       	mov	r30, r0
    2836:	be 01       	movw	r22, r28
    2838:	19 95       	eicall
	return (ser_dev);
}
    283a:	ce 01       	movw	r24, r28
    283c:	df 91       	pop	r29
    283e:	cf 91       	pop	r28
    2840:	08 95       	ret

00002842 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2842:	0f 93       	push	r16
    2844:	1f 93       	push	r17
    2846:	cf 93       	push	r28
    2848:	df 93       	push	r29
    284a:	ec 01       	movw	r28, r24
    284c:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    284e:	bc 01       	movw	r22, r24
    2850:	c8 01       	movw	r24, r16
    2852:	0e 94 11 14 	call	0x2822	; 0x2822 <_ZlsR8emstreamR8frt_task>
    2856:	66 e0       	ldi	r22, 0x06	; 6
    2858:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    285c:	8c 81       	ldd	r24, Y+4	; 0x04
    285e:	9d 81       	ldd	r25, Y+5	; 0x05
    2860:	00 97       	sbiw	r24, 0x00	; 0
    2862:	19 f0       	breq	.+6      	; 0x286a <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2864:	b8 01       	movw	r22, r16
    2866:	0e 94 21 14 	call	0x2842	; 0x2842 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    286a:	df 91       	pop	r29
    286c:	cf 91       	pop	r28
    286e:	1f 91       	pop	r17
    2870:	0f 91       	pop	r16
    2872:	08 95       	ret

00002874 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2874:	0f 93       	push	r16
    2876:	1f 93       	push	r17
    2878:	cf 93       	push	r28
    287a:	df 93       	push	r29
    287c:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    287e:	6a e0       	ldi	r22, 0x0A	; 10
    2880:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2884:	8c 01       	movw	r16, r24
    2886:	68 e2       	ldi	r22, 0x28	; 40
    2888:	75 e0       	ldi	r23, 0x05	; 5
    288a:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    288e:	6a e0       	ldi	r22, 0x0A	; 10
    2890:	c8 01       	movw	r24, r16
    2892:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2896:	8c 01       	movw	r16, r24
    2898:	61 e2       	ldi	r22, 0x21	; 33
    289a:	75 e0       	ldi	r23, 0x05	; 5
    289c:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    28a0:	66 e0       	ldi	r22, 0x06	; 6
    28a2:	c8 01       	movw	r24, r16
    28a4:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    28a8:	6a e0       	ldi	r22, 0x0A	; 10
    28aa:	ce 01       	movw	r24, r28
    28ac:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    28b0:	8c 01       	movw	r16, r24
    28b2:	60 e1       	ldi	r22, 0x10	; 16
    28b4:	75 e0       	ldi	r23, 0x05	; 5
    28b6:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    28ba:	6a e0       	ldi	r22, 0x0A	; 10
    28bc:	c8 01       	movw	r24, r16
    28be:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    28c2:	8c 01       	movw	r16, r24
    28c4:	64 e0       	ldi	r22, 0x04	; 4
    28c6:	75 e0       	ldi	r23, 0x05	; 5
    28c8:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    28cc:	6a e0       	ldi	r22, 0x0A	; 10
    28ce:	c8 01       	movw	r24, r16
    28d0:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    28d4:	8c 01       	movw	r16, r24
    28d6:	6e ef       	ldi	r22, 0xFE	; 254
    28d8:	74 e0       	ldi	r23, 0x04	; 4
    28da:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    28de:	66 e0       	ldi	r22, 0x06	; 6
    28e0:	c8 01       	movw	r24, r16
    28e2:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    28e6:	6a e0       	ldi	r22, 0x0A	; 10
    28e8:	ce 01       	movw	r24, r28
    28ea:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    28ee:	8c 01       	movw	r16, r24
    28f0:	6d ee       	ldi	r22, 0xED	; 237
    28f2:	74 e0       	ldi	r23, 0x04	; 4
    28f4:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    28f8:	6a e0       	ldi	r22, 0x0A	; 10
    28fa:	c8 01       	movw	r24, r16
    28fc:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2900:	8c 01       	movw	r16, r24
    2902:	61 ee       	ldi	r22, 0xE1	; 225
    2904:	74 e0       	ldi	r23, 0x04	; 4
    2906:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    290a:	6a e0       	ldi	r22, 0x0A	; 10
    290c:	c8 01       	movw	r24, r16
    290e:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2912:	8c 01       	movw	r16, r24
    2914:	6b ed       	ldi	r22, 0xDB	; 219
    2916:	74 e0       	ldi	r23, 0x04	; 4
    2918:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    291c:	66 e0       	ldi	r22, 0x06	; 6
    291e:	c8 01       	movw	r24, r16
    2920:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2924:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <last_created_task_pointer>
    2928:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <last_created_task_pointer+0x1>
    292c:	00 97       	sbiw	r24, 0x00	; 0
    292e:	19 f0       	breq	.+6      	; 0x2936 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2930:	be 01       	movw	r22, r28
    2932:	0e 94 21 14 	call	0x2842	; 0x2842 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2936:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <xTaskGetIdleTaskHandle>
    293a:	0e 94 72 11 	call	0x22e4	; 0x22e4 <uxTaskGetStackHighWaterMark>
    293e:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2940:	6a e0       	ldi	r22, 0x0A	; 10
    2942:	ce 01       	movw	r24, r28
    2944:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2948:	ec 01       	movw	r28, r24
    294a:	60 ed       	ldi	r22, 0xD0	; 208
    294c:	74 e0       	ldi	r23, 0x04	; 4
    294e:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2952:	61 2f       	mov	r22, r17
    2954:	ce 01       	movw	r24, r28
    2956:	0e 94 68 18 	call	0x30d0	; 0x30d0 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    295a:	6a e0       	ldi	r22, 0x0A	; 10
    295c:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2960:	ec 01       	movw	r28, r24
    2962:	6e ec       	ldi	r22, 0xCE	; 206
    2964:	74 e0       	ldi	r23, 0x04	; 4
    2966:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    296a:	64 e6       	ldi	r22, 0x64	; 100
    296c:	70 e0       	ldi	r23, 0x00	; 0
    296e:	ce 01       	movw	r24, r28
    2970:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <_ZN8emstreamlsEj>
    2974:	6a e0       	ldi	r22, 0x0A	; 10
    2976:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    297a:	ec 01       	movw	r28, r24
    297c:	6b ec       	ldi	r22, 0xCB	; 203
    297e:	74 e0       	ldi	r23, 0x04	; 4
    2980:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2984:	66 e0       	ldi	r22, 0x06	; 6
    2986:	ce 01       	movw	r24, r28
    2988:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
}
    298c:	df 91       	pop	r29
    298e:	cf 91       	pop	r28
    2990:	1f 91       	pop	r17
    2992:	0f 91       	pop	r16
    2994:	08 95       	ret

00002996 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2996:	0f 93       	push	r16
    2998:	cf 93       	push	r28
    299a:	df 93       	push	r29
    299c:	1f 92       	push	r1
    299e:	cd b7       	in	r28, 0x3d	; 61
    29a0:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    29a2:	00 e0       	ldi	r16, 0x00	; 0
    29a4:	2f ef       	ldi	r18, 0xFF	; 255
    29a6:	3f ef       	ldi	r19, 0xFF	; 255
    29a8:	a9 01       	movw	r20, r18
    29aa:	be 01       	movw	r22, r28
    29ac:	6f 5f       	subi	r22, 0xFF	; 255
    29ae:	7f 4f       	sbci	r23, 0xFF	; 255
    29b0:	fc 01       	movw	r30, r24
    29b2:	80 85       	ldd	r24, Z+8	; 0x08
    29b4:	91 85       	ldd	r25, Z+9	; 0x09
    29b6:	0e 94 86 0b 	call	0x170c	; 0x170c <xQueueGenericReceive>
    29ba:	81 30       	cpi	r24, 0x01	; 1
    29bc:	19 f4       	brne	.+6      	; 0x29c4 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    29be:	89 81       	ldd	r24, Y+1	; 0x01
    29c0:	90 e0       	ldi	r25, 0x00	; 0
    29c2:	02 c0       	rjmp	.+4      	; 0x29c8 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    29c4:	8f ef       	ldi	r24, 0xFF	; 255
    29c6:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    29c8:	0f 90       	pop	r0
    29ca:	df 91       	pop	r29
    29cc:	cf 91       	pop	r28
    29ce:	0f 91       	pop	r16
    29d0:	08 95       	ret

000029d2 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    29d2:	fc 01       	movw	r30, r24
    29d4:	80 85       	ldd	r24, Z+8	; 0x08
    29d6:	91 85       	ldd	r25, Z+9	; 0x09
    29d8:	0e 94 4a 0c 	call	0x1894	; 0x1894 <uxQueueMessagesWaiting>
    29dc:	91 e0       	ldi	r25, 0x01	; 1
    29de:	81 11       	cpse	r24, r1
    29e0:	01 c0       	rjmp	.+2      	; 0x29e4 <_ZN14frt_text_queue14check_for_charEv+0x12>
    29e2:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    29e4:	89 2f       	mov	r24, r25
    29e6:	08 95       	ret

000029e8 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    29e8:	0f 93       	push	r16
    29ea:	cf 93       	push	r28
    29ec:	df 93       	push	r29
    29ee:	1f 92       	push	r1
    29f0:	cd b7       	in	r28, 0x3d	; 61
    29f2:	de b7       	in	r29, 0x3e	; 62
    29f4:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    29f6:	fc 01       	movw	r30, r24
    29f8:	22 85       	ldd	r18, Z+10	; 0x0a
    29fa:	33 85       	ldd	r19, Z+11	; 0x0b
    29fc:	44 85       	ldd	r20, Z+12	; 0x0c
    29fe:	55 85       	ldd	r21, Z+13	; 0x0d
    2a00:	00 e0       	ldi	r16, 0x00	; 0
    2a02:	be 01       	movw	r22, r28
    2a04:	6f 5f       	subi	r22, 0xFF	; 255
    2a06:	7f 4f       	sbci	r23, 0xFF	; 255
    2a08:	80 85       	ldd	r24, Z+8	; 0x08
    2a0a:	91 85       	ldd	r25, Z+9	; 0x09
    2a0c:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <xQueueGenericSend>
    2a10:	91 e0       	ldi	r25, 0x01	; 1
    2a12:	81 11       	cpse	r24, r1
    2a14:	01 c0       	rjmp	.+2      	; 0x2a18 <_ZN14frt_text_queue7putcharEc+0x30>
    2a16:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2a18:	89 2f       	mov	r24, r25
    2a1a:	0f 90       	pop	r0
    2a1c:	df 91       	pop	r29
    2a1e:	cf 91       	pop	r28
    2a20:	0f 91       	pop	r16
    2a22:	08 95       	ret

00002a24 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2a24:	8f 92       	push	r8
    2a26:	9f 92       	push	r9
    2a28:	bf 92       	push	r11
    2a2a:	cf 92       	push	r12
    2a2c:	df 92       	push	r13
    2a2e:	ef 92       	push	r14
    2a30:	ff 92       	push	r15
    2a32:	0f 93       	push	r16
    2a34:	1f 93       	push	r17
    2a36:	cf 93       	push	r28
    2a38:	df 93       	push	r29
    2a3a:	ec 01       	movw	r28, r24
    2a3c:	b6 2e       	mov	r11, r22
    2a3e:	4a 01       	movw	r8, r20
    2a40:	68 01       	movw	r12, r16
    2a42:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2a44:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <_ZN8emstreamC1Ev>
    2a48:	8f e4       	ldi	r24, 0x4F	; 79
    2a4a:	90 e2       	ldi	r25, 0x20	; 32
    2a4c:	88 83       	st	Y, r24
    2a4e:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2a50:	8e 86       	std	Y+14, r8	; 0x0e
    2a52:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2a54:	40 e0       	ldi	r20, 0x00	; 0
    2a56:	61 e0       	ldi	r22, 0x01	; 1
    2a58:	8b 2d       	mov	r24, r11
    2a5a:	0e 94 bd 0a 	call	0x157a	; 0x157a <xQueueGenericCreate>
    2a5e:	88 87       	std	Y+8, r24	; 0x08
    2a60:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2a62:	ca 86       	std	Y+10, r12	; 0x0a
    2a64:	db 86       	std	Y+11, r13	; 0x0b
    2a66:	ec 86       	std	Y+12, r14	; 0x0c
    2a68:	fd 86       	std	Y+13, r15	; 0x0d
}
    2a6a:	df 91       	pop	r29
    2a6c:	cf 91       	pop	r28
    2a6e:	1f 91       	pop	r17
    2a70:	0f 91       	pop	r16
    2a72:	ff 90       	pop	r15
    2a74:	ef 90       	pop	r14
    2a76:	df 90       	pop	r13
    2a78:	cf 90       	pop	r12
    2a7a:	bf 90       	pop	r11
    2a7c:	9f 90       	pop	r9
    2a7e:	8f 90       	pop	r8
    2a80:	08 95       	ret

00002a82 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2a82:	cf 92       	push	r12
    2a84:	df 92       	push	r13
    2a86:	ef 92       	push	r14
    2a88:	ff 92       	push	r15
    2a8a:	cf 93       	push	r28
    2a8c:	df 93       	push	r29
    2a8e:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2a90:	68 81       	ld	r22, Y
    2a92:	79 81       	ldd	r23, Y+1	; 0x01
    2a94:	8a 81       	ldd	r24, Y+2	; 0x02
    2a96:	9b 81       	ldd	r25, Y+3	; 0x03
    2a98:	0f 2e       	mov	r0, r31
    2a9a:	f8 ee       	ldi	r31, 0xE8	; 232
    2a9c:	cf 2e       	mov	r12, r31
    2a9e:	f3 e0       	ldi	r31, 0x03	; 3
    2aa0:	df 2e       	mov	r13, r31
    2aa2:	e1 2c       	mov	r14, r1
    2aa4:	f1 2c       	mov	r15, r1
    2aa6:	f0 2d       	mov	r31, r0
    2aa8:	a7 01       	movw	r20, r14
    2aaa:	96 01       	movw	r18, r12
    2aac:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <__udivmodsi4>
    2ab0:	9b 01       	movw	r18, r22
    2ab2:	ac 01       	movw	r20, r24
    2ab4:	60 e4       	ldi	r22, 0x40	; 64
    2ab6:	72 e4       	ldi	r23, 0x42	; 66
    2ab8:	8f e0       	ldi	r24, 0x0F	; 15
    2aba:	90 e0       	ldi	r25, 0x00	; 0
    2abc:	0e 94 48 1d 	call	0x3a90	; 0x3a90 <__mulsi3>
    2ac0:	a7 01       	movw	r20, r14
    2ac2:	96 01       	movw	r18, r12
    2ac4:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <__udivmodsi4>
    2ac8:	69 01       	movw	r12, r18
    2aca:	7a 01       	movw	r14, r20
    2acc:	ac 81       	ldd	r26, Y+4	; 0x04
    2ace:	bd 81       	ldd	r27, Y+5	; 0x05
    2ad0:	20 e4       	ldi	r18, 0x40	; 64
    2ad2:	32 e4       	ldi	r19, 0x42	; 66
    2ad4:	4f e0       	ldi	r20, 0x0F	; 15
    2ad6:	50 e0       	ldi	r21, 0x00	; 0
    2ad8:	0e 94 b6 1d 	call	0x3b6c	; 0x3b6c <__muluhisi3>
    2adc:	20 e0       	ldi	r18, 0x00	; 0
    2ade:	38 e4       	ldi	r19, 0x48	; 72
    2ae0:	48 ee       	ldi	r20, 0xE8	; 232
    2ae2:	51 e0       	ldi	r21, 0x01	; 1
    2ae4:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <__udivmodsi4>
    2ae8:	c7 01       	movw	r24, r14
    2aea:	b6 01       	movw	r22, r12
    2aec:	62 0f       	add	r22, r18
    2aee:	73 1f       	adc	r23, r19
    2af0:	84 1f       	adc	r24, r20
    2af2:	95 1f       	adc	r25, r21
}
    2af4:	df 91       	pop	r29
    2af6:	cf 91       	pop	r28
    2af8:	ff 90       	pop	r15
    2afa:	ef 90       	pop	r14
    2afc:	df 90       	pop	r13
    2afe:	cf 90       	pop	r12
    2b00:	08 95       	ret

00002b02 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2b02:	cf 92       	push	r12
    2b04:	df 92       	push	r13
    2b06:	ef 92       	push	r14
    2b08:	ff 92       	push	r15
    2b0a:	0f 93       	push	r16
    2b0c:	1f 93       	push	r17
    2b0e:	cf 93       	push	r28
    2b10:	df 93       	push	r29
    2b12:	cd b7       	in	r28, 0x3d	; 61
    2b14:	de b7       	in	r29, 0x3e	; 62
    2b16:	2f 97       	sbiw	r28, 0x0f	; 15
    2b18:	cd bf       	out	0x3d, r28	; 61
    2b1a:	de bf       	out	0x3e, r29	; 62
    2b1c:	6c 01       	movw	r12, r24
    2b1e:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2b20:	db 01       	movw	r26, r22
    2b22:	6d 91       	ld	r22, X+
    2b24:	7d 91       	ld	r23, X+
    2b26:	8d 91       	ld	r24, X+
    2b28:	9c 91       	ld	r25, X
    2b2a:	28 ee       	ldi	r18, 0xE8	; 232
    2b2c:	33 e0       	ldi	r19, 0x03	; 3
    2b2e:	40 e0       	ldi	r20, 0x00	; 0
    2b30:	50 e0       	ldi	r21, 0x00	; 0
    2b32:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <__udivmodsi4>
    2b36:	ba 01       	movw	r22, r20
    2b38:	a9 01       	movw	r20, r18
    2b3a:	c6 01       	movw	r24, r12
    2b3c:	0e 94 26 18 	call	0x304c	; 0x304c <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2b40:	d6 01       	movw	r26, r12
    2b42:	ed 91       	ld	r30, X+
    2b44:	fc 91       	ld	r31, X
    2b46:	02 80       	ldd	r0, Z+2	; 0x02
    2b48:	f3 81       	ldd	r31, Z+3	; 0x03
    2b4a:	e0 2d       	mov	r30, r0
    2b4c:	6e e2       	ldi	r22, 0x2E	; 46
    2b4e:	c6 01       	movw	r24, r12
    2b50:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2b52:	c8 01       	movw	r24, r16
    2b54:	0e 94 41 15 	call	0x2a82	; 0x2a82 <_ZN10time_stamp12get_microsecEv>
    2b58:	8e 01       	movw	r16, r28
    2b5a:	09 5f       	subi	r16, 0xF9	; 249
    2b5c:	1f 4f       	sbci	r17, 0xFF	; 255
    2b5e:	fe 01       	movw	r30, r28
    2b60:	31 96       	adiw	r30, 0x01	; 1
    2b62:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2b64:	2a e0       	ldi	r18, 0x0A	; 10
    2b66:	30 e0       	ldi	r19, 0x00	; 0
    2b68:	40 e0       	ldi	r20, 0x00	; 0
    2b6a:	50 e0       	ldi	r21, 0x00	; 0
    2b6c:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <__divmodsi4>
    2b70:	e6 2f       	mov	r30, r22
    2b72:	28 87       	std	Y+8, r18	; 0x08
    2b74:	39 87       	std	Y+9, r19	; 0x09
    2b76:	4a 87       	std	Y+10, r20	; 0x0a
    2b78:	5b 87       	std	Y+11, r21	; 0x0b
    2b7a:	68 85       	ldd	r22, Y+8	; 0x08
    2b7c:	79 85       	ldd	r23, Y+9	; 0x09
    2b7e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b80:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2b82:	20 e3       	ldi	r18, 0x30	; 48
    2b84:	2e 0f       	add	r18, r30
    2b86:	d8 01       	movw	r26, r16
    2b88:	2e 93       	st	-X, r18
    2b8a:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2b8c:	ae 15       	cp	r26, r14
    2b8e:	bf 05       	cpc	r27, r15
    2b90:	49 f7       	brne	.-46     	; 0x2b64 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2b92:	1f 82       	std	Y+7, r1	; 0x07
    2b94:	be 01       	movw	r22, r28
    2b96:	6f 5f       	subi	r22, 0xFF	; 255
    2b98:	7f 4f       	sbci	r23, 0xFF	; 255
    2b9a:	c6 01       	movw	r24, r12
    2b9c:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2ba0:	c6 01       	movw	r24, r12
    2ba2:	2f 96       	adiw	r28, 0x0f	; 15
    2ba4:	cd bf       	out	0x3d, r28	; 61
    2ba6:	de bf       	out	0x3e, r29	; 62
    2ba8:	df 91       	pop	r29
    2baa:	cf 91       	pop	r28
    2bac:	1f 91       	pop	r17
    2bae:	0f 91       	pop	r16
    2bb0:	ff 90       	pop	r15
    2bb2:	ef 90       	pop	r14
    2bb4:	df 90       	pop	r13
    2bb6:	cf 90       	pop	r12
    2bb8:	08 95       	ret

00002bba <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2bba:	cf 93       	push	r28
    2bbc:	df 93       	push	r29
    2bbe:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2bc0:	0f b6       	in	r0, 0x3f	; 63
    2bc2:	f8 94       	cli
    2bc4:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2bc6:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2bca:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2bce:	8c 83       	std	Y+4, r24	; 0x04
    2bd0:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2bd2:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <xTaskGetTickCount>
    2bd6:	68 83       	st	Y, r22
    2bd8:	79 83       	std	Y+1, r23	; 0x01
    2bda:	8a 83       	std	Y+2, r24	; 0x02
    2bdc:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2bde:	0f 90       	pop	r0
    2be0:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2be2:	ce 01       	movw	r24, r28
    2be4:	df 91       	pop	r29
    2be6:	cf 91       	pop	r28
    2be8:	08 95       	ret

00002bea <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2bea:	5f 92       	push	r5
    2bec:	6f 92       	push	r6
    2bee:	7f 92       	push	r7
    2bf0:	8f 92       	push	r8
    2bf2:	9f 92       	push	r9
    2bf4:	af 92       	push	r10
    2bf6:	bf 92       	push	r11
    2bf8:	cf 92       	push	r12
    2bfa:	df 92       	push	r13
    2bfc:	ef 92       	push	r14
    2bfe:	ff 92       	push	r15
    2c00:	0f 93       	push	r16
    2c02:	1f 93       	push	r17
    2c04:	cf 93       	push	r28
    2c06:	df 93       	push	r29
    2c08:	5c 01       	movw	r10, r24
    2c0a:	4b 01       	movw	r8, r22
    2c0c:	7a 01       	movw	r14, r20
    2c0e:	12 2f       	mov	r17, r18
    2c10:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2c12:	63 e0       	ldi	r22, 0x03	; 3
    2c14:	ca 01       	movw	r24, r20
    2c16:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2c1a:	a8 14       	cp	r10, r8
    2c1c:	b9 04       	cpc	r11, r9
    2c1e:	08 f0       	brcs	.+2      	; 0x2c22 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2c20:	7d c0       	rjmp	.+250    	; 0x2d1c <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2c22:	65 01       	movw	r12, r10
    2c24:	84 e1       	ldi	r24, 0x14	; 20
    2c26:	c8 0e       	add	r12, r24
    2c28:	d1 1c       	adc	r13, r1
    2c2a:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2c2c:	6a 2c       	mov	r6, r10
    2c2e:	5b 2c       	mov	r5, r11
    2c30:	b5 01       	movw	r22, r10
    2c32:	c7 01       	movw	r24, r14
    2c34:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <_ZN8emstreamlsEj>
    2c38:	6a e0       	ldi	r22, 0x0A	; 10
    2c3a:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2c3e:	6d e4       	ldi	r22, 0x4D	; 77
    2c40:	75 e0       	ldi	r23, 0x05	; 5
    2c42:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2c46:	11 23       	and	r17, r17
    2c48:	09 f4       	brne	.+2      	; 0x2c4c <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2c4a:	6d c0       	rjmp	.+218    	; 0x2d26 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2c4c:	00 23       	and	r16, r16
    2c4e:	09 f4       	brne	.+2      	; 0x2c52 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2c50:	6a c0       	rjmp	.+212    	; 0x2d26 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2c52:	6a e0       	ldi	r22, 0x0A	; 10
    2c54:	c7 01       	movw	r24, r14
    2c56:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2c5a:	68 e4       	ldi	r22, 0x48	; 72
    2c5c:	75 e0       	ldi	r23, 0x05	; 5
    2c5e:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    2c62:	61 c0       	rjmp	.+194    	; 0x2d26 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2c64:	11 23       	and	r17, r17
    2c66:	71 f0       	breq	.+28     	; 0x2c84 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2c68:	01 11       	cpse	r16, r1
    2c6a:	0c c0       	rjmp	.+24     	; 0x2c84 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2c6c:	88 81       	ld	r24, Y
    2c6e:	87 15       	cp	r24, r7
    2c70:	49 f0       	breq	.+18     	; 0x2c84 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2c72:	6a e0       	ldi	r22, 0x0A	; 10
    2c74:	c7 01       	movw	r24, r14
    2c76:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2c7a:	63 e4       	ldi	r22, 0x43	; 67
    2c7c:	75 e0       	ldi	r23, 0x05	; 5
    2c7e:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2c82:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2c84:	69 91       	ld	r22, Y+
    2c86:	c7 01       	movw	r24, r14
    2c88:	0e 94 68 18 	call	0x30d0	; 0x30d0 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2c8c:	dc 01       	movw	r26, r24
    2c8e:	ed 91       	ld	r30, X+
    2c90:	fc 91       	ld	r31, X
    2c92:	02 80       	ldd	r0, Z+2	; 0x02
    2c94:	f3 81       	ldd	r31, Z+3	; 0x03
    2c96:	e0 2d       	mov	r30, r0
    2c98:	60 e2       	ldi	r22, 0x20	; 32
    2c9a:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2c9c:	cc 16       	cp	r12, r28
    2c9e:	dd 06       	cpc	r13, r29
    2ca0:	09 f7       	brne	.-62     	; 0x2c64 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2ca2:	11 23       	and	r17, r17
    2ca4:	89 f0       	breq	.+34     	; 0x2cc8 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2ca6:	6a e0       	ldi	r22, 0x0A	; 10
    2ca8:	c7 01       	movw	r24, r14
    2caa:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2cae:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2cb0:	6d e3       	ldi	r22, 0x3D	; 61
    2cb2:	75 e0       	ldi	r23, 0x05	; 5
    2cb4:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2cb8:	e8 81       	ld	r30, Y
    2cba:	f9 81       	ldd	r31, Y+1	; 0x01
    2cbc:	02 80       	ldd	r0, Z+2	; 0x02
    2cbe:	f3 81       	ldd	r31, Z+3	; 0x03
    2cc0:	e0 2d       	mov	r30, r0
    2cc2:	60 e2       	ldi	r22, 0x20	; 32
    2cc4:	ce 01       	movw	r24, r28
    2cc6:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2cc8:	c6 2d       	mov	r28, r6
    2cca:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2ccc:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2cce:	80 ee       	ldi	r24, 0xE0	; 224
    2cd0:	86 0f       	add	r24, r22
    2cd2:	8f 35       	cpi	r24, 0x5F	; 95
    2cd4:	48 f4       	brcc	.+18     	; 0x2ce8 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2cd6:	d7 01       	movw	r26, r14
    2cd8:	ed 91       	ld	r30, X+
    2cda:	fc 91       	ld	r31, X
    2cdc:	02 80       	ldd	r0, Z+2	; 0x02
    2cde:	f3 81       	ldd	r31, Z+3	; 0x03
    2ce0:	e0 2d       	mov	r30, r0
    2ce2:	c7 01       	movw	r24, r14
    2ce4:	19 95       	eicall
    2ce6:	09 c0       	rjmp	.+18     	; 0x2cfa <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2ce8:	d7 01       	movw	r26, r14
    2cea:	ed 91       	ld	r30, X+
    2cec:	fc 91       	ld	r31, X
    2cee:	02 80       	ldd	r0, Z+2	; 0x02
    2cf0:	f3 81       	ldd	r31, Z+3	; 0x03
    2cf2:	e0 2d       	mov	r30, r0
    2cf4:	6e e2       	ldi	r22, 0x2E	; 46
    2cf6:	c7 01       	movw	r24, r14
    2cf8:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2cfa:	cc 16       	cp	r12, r28
    2cfc:	dd 06       	cpc	r13, r29
    2cfe:	31 f7       	brne	.-52     	; 0x2ccc <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2d00:	b4 e1       	ldi	r27, 0x14	; 20
    2d02:	ab 0e       	add	r10, r27
    2d04:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2d06:	66 e0       	ldi	r22, 0x06	; 6
    2d08:	c7 01       	movw	r24, r14
    2d0a:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    2d0e:	84 e1       	ldi	r24, 0x14	; 20
    2d10:	c8 0e       	add	r12, r24
    2d12:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2d14:	a8 14       	cp	r10, r8
    2d16:	b9 04       	cpc	r11, r9
    2d18:	08 f4       	brcc	.+2      	; 0x2d1c <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2d1a:	88 cf       	rjmp	.-240    	; 0x2c2c <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2d1c:	62 e0       	ldi	r22, 0x02	; 2
    2d1e:	c7 01       	movw	r24, r14
    2d20:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
}
    2d24:	03 c0       	rjmp	.+6      	; 0x2d2c <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2d26:	c6 2d       	mov	r28, r6
    2d28:	d5 2d       	mov	r29, r5
    2d2a:	9c cf       	rjmp	.-200    	; 0x2c64 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2d2c:	df 91       	pop	r29
    2d2e:	cf 91       	pop	r28
    2d30:	1f 91       	pop	r17
    2d32:	0f 91       	pop	r16
    2d34:	ff 90       	pop	r15
    2d36:	ef 90       	pop	r14
    2d38:	df 90       	pop	r13
    2d3a:	cf 90       	pop	r12
    2d3c:	bf 90       	pop	r11
    2d3e:	af 90       	pop	r10
    2d40:	9f 90       	pop	r9
    2d42:	8f 90       	pop	r8
    2d44:	7f 90       	pop	r7
    2d46:	6f 90       	pop	r6
    2d48:	5f 90       	pop	r5
    2d4a:	08 95       	ret

00002d4c <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2d4c:	0e 94 d5 06 	call	0xdaa	; 0xdaa <pvPortMalloc>
    2d50:	08 95       	ret

00002d52 <_Znaj>:
    2d52:	0e 94 d5 06 	call	0xdaa	; 0xdaa <pvPortMalloc>
    2d56:	08 95       	ret

00002d58 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2d58:	08 95       	ret

00002d5a <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2d5a:	cf 93       	push	r28
    2d5c:	df 93       	push	r29
    2d5e:	fc 01       	movw	r30, r24
    2d60:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2d62:	40 3a       	cpi	r20, 0xA0	; 160
    2d64:	68 e0       	ldi	r22, 0x08	; 8
    2d66:	56 07       	cpc	r21, r22
    2d68:	49 f4       	brne	.+18     	; 0x2d7c <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2d6a:	80 e4       	ldi	r24, 0x40	; 64
    2d6c:	96 e0       	ldi	r25, 0x06	; 6
    2d6e:	82 83       	std	Z+2, r24	; 0x02
    2d70:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2d72:	82 e0       	ldi	r24, 0x02	; 2
    2d74:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2d76:	83 e0       	ldi	r24, 0x03	; 3
    2d78:	85 83       	std	Z+5, r24	; 0x05
    2d7a:	4c c0       	rjmp	.+152    	; 0x2e14 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2d7c:	40 3b       	cpi	r20, 0xB0	; 176
    2d7e:	78 e0       	ldi	r23, 0x08	; 8
    2d80:	57 07       	cpc	r21, r23
    2d82:	49 f4       	brne	.+18     	; 0x2d96 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2d84:	80 e4       	ldi	r24, 0x40	; 64
    2d86:	96 e0       	ldi	r25, 0x06	; 6
    2d88:	82 83       	std	Z+2, r24	; 0x02
    2d8a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2d8c:	86 e0       	ldi	r24, 0x06	; 6
    2d8e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2d90:	87 e0       	ldi	r24, 0x07	; 7
    2d92:	85 83       	std	Z+5, r24	; 0x05
    2d94:	3f c0       	rjmp	.+126    	; 0x2e14 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    2d96:	40 3a       	cpi	r20, 0xA0	; 160
    2d98:	89 e0       	ldi	r24, 0x09	; 9
    2d9a:	58 07       	cpc	r21, r24
    2d9c:	49 f4       	brne	.+18     	; 0x2db0 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    2d9e:	80 e6       	ldi	r24, 0x60	; 96
    2da0:	96 e0       	ldi	r25, 0x06	; 6
    2da2:	82 83       	std	Z+2, r24	; 0x02
    2da4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2da6:	82 e0       	ldi	r24, 0x02	; 2
    2da8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2daa:	83 e0       	ldi	r24, 0x03	; 3
    2dac:	85 83       	std	Z+5, r24	; 0x05
    2dae:	32 c0       	rjmp	.+100    	; 0x2e14 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    2db0:	40 3b       	cpi	r20, 0xB0	; 176
    2db2:	69 e0       	ldi	r22, 0x09	; 9
    2db4:	56 07       	cpc	r21, r22
    2db6:	49 f4       	brne	.+18     	; 0x2dca <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    2db8:	80 e6       	ldi	r24, 0x60	; 96
    2dba:	96 e0       	ldi	r25, 0x06	; 6
    2dbc:	82 83       	std	Z+2, r24	; 0x02
    2dbe:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2dc0:	86 e0       	ldi	r24, 0x06	; 6
    2dc2:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2dc4:	87 e0       	ldi	r24, 0x07	; 7
    2dc6:	85 83       	std	Z+5, r24	; 0x05
    2dc8:	25 c0       	rjmp	.+74     	; 0x2e14 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    2dca:	40 3a       	cpi	r20, 0xA0	; 160
    2dcc:	7a e0       	ldi	r23, 0x0A	; 10
    2dce:	57 07       	cpc	r21, r23
    2dd0:	49 f4       	brne	.+18     	; 0x2de4 <_ZN7base232C1EjP12USART_struct+0x8a>
	{
		p_port = &PORTE;
    2dd2:	80 e8       	ldi	r24, 0x80	; 128
    2dd4:	96 e0       	ldi	r25, 0x06	; 6
    2dd6:	82 83       	std	Z+2, r24	; 0x02
    2dd8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2dda:	82 e0       	ldi	r24, 0x02	; 2
    2ddc:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2dde:	83 e0       	ldi	r24, 0x03	; 3
    2de0:	85 83       	std	Z+5, r24	; 0x05
    2de2:	18 c0       	rjmp	.+48     	; 0x2e14 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE1 
	else if(p_usart == &USARTE1)
    2de4:	40 3b       	cpi	r20, 0xB0	; 176
    2de6:	8a e0       	ldi	r24, 0x0A	; 10
    2de8:	58 07       	cpc	r21, r24
    2dea:	49 f4       	brne	.+18     	; 0x2dfe <_ZN7base232C1EjP12USART_struct+0xa4>
	{
		p_port = &PORTE;
    2dec:	80 e8       	ldi	r24, 0x80	; 128
    2dee:	96 e0       	ldi	r25, 0x06	; 6
    2df0:	82 83       	std	Z+2, r24	; 0x02
    2df2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2df4:	86 e0       	ldi	r24, 0x06	; 6
    2df6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2df8:	87 e0       	ldi	r24, 0x07	; 7
    2dfa:	85 83       	std	Z+5, r24	; 0x05
    2dfc:	0b c0       	rjmp	.+22     	; 0x2e14 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTF0 
	else if(p_usart == &USARTF0)
    2dfe:	40 3a       	cpi	r20, 0xA0	; 160
    2e00:	5b 40       	sbci	r21, 0x0B	; 11
    2e02:	41 f4       	brne	.+16     	; 0x2e14 <_ZN7base232C1EjP12USART_struct+0xba>
	{
		p_port = &PORTF;
    2e04:	80 ea       	ldi	r24, 0xA0	; 160
    2e06:	96 e0       	ldi	r25, 0x06	; 6
    2e08:	82 83       	std	Z+2, r24	; 0x02
    2e0a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e0c:	82 e0       	ldi	r24, 0x02	; 2
    2e0e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2e10:	83 e0       	ldi	r24, 0x03	; 3
    2e12:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    2e14:	a6 83       	std	Z+6, r26	; 0x06
    2e16:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    2e18:	cd 01       	movw	r24, r26
    2e1a:	01 96       	adiw	r24, 0x01	; 1
    2e1c:	80 87       	std	Z+8, r24	; 0x08
    2e1e:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    2e20:	03 96       	adiw	r24, 0x03	; 3
    2e22:	82 87       	std	Z+10, r24	; 0x0a
    2e24:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    2e26:	25 81       	ldd	r18, Z+5	; 0x05
    2e28:	c2 81       	ldd	r28, Z+2	; 0x02
    2e2a:	d3 81       	ldd	r29, Z+3	; 0x03
    2e2c:	4c 81       	ldd	r20, Y+4	; 0x04
    2e2e:	81 e0       	ldi	r24, 0x01	; 1
    2e30:	90 e0       	ldi	r25, 0x00	; 0
    2e32:	bc 01       	movw	r22, r24
    2e34:	02 c0       	rjmp	.+4      	; 0x2e3a <_ZN7base232C1EjP12USART_struct+0xe0>
    2e36:	66 0f       	add	r22, r22
    2e38:	77 1f       	adc	r23, r23
    2e3a:	2a 95       	dec	r18
    2e3c:	e2 f7       	brpl	.-8      	; 0x2e36 <_ZN7base232C1EjP12USART_struct+0xdc>
    2e3e:	9b 01       	movw	r18, r22
    2e40:	24 2b       	or	r18, r20
    2e42:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    2e44:	25 81       	ldd	r18, Z+5	; 0x05
    2e46:	c2 81       	ldd	r28, Z+2	; 0x02
    2e48:	d3 81       	ldd	r29, Z+3	; 0x03
    2e4a:	48 81       	ld	r20, Y
    2e4c:	bc 01       	movw	r22, r24
    2e4e:	02 c0       	rjmp	.+4      	; 0x2e54 <_ZN7base232C1EjP12USART_struct+0xfa>
    2e50:	66 0f       	add	r22, r22
    2e52:	77 1f       	adc	r23, r23
    2e54:	2a 95       	dec	r18
    2e56:	e2 f7       	brpl	.-8      	; 0x2e50 <_ZN7base232C1EjP12USART_struct+0xf6>
    2e58:	9b 01       	movw	r18, r22
    2e5a:	24 2b       	or	r18, r20
    2e5c:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    2e5e:	34 81       	ldd	r19, Z+4	; 0x04
    2e60:	c2 81       	ldd	r28, Z+2	; 0x02
    2e62:	d3 81       	ldd	r29, Z+3	; 0x03
    2e64:	28 81       	ld	r18, Y
    2e66:	02 c0       	rjmp	.+4      	; 0x2e6c <_ZN7base232C1EjP12USART_struct+0x112>
    2e68:	88 0f       	add	r24, r24
    2e6a:	99 1f       	adc	r25, r25
    2e6c:	3a 95       	dec	r19
    2e6e:	e2 f7       	brpl	.-8      	; 0x2e68 <_ZN7base232C1EjP12USART_struct+0x10e>
    2e70:	80 95       	com	r24
    2e72:	90 95       	com	r25
    2e74:	82 23       	and	r24, r18
    2e76:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    2e78:	80 e1       	ldi	r24, 0x10	; 16
    2e7a:	13 96       	adiw	r26, 0x03	; 3
    2e7c:	8c 93       	st	X, r24
    2e7e:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    2e80:	83 e0       	ldi	r24, 0x03	; 3
    2e82:	15 96       	adiw	r26, 0x05	; 5
    2e84:	8c 93       	st	X, r24
    2e86:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    2e88:	80 ef       	ldi	r24, 0xF0	; 240
    2e8a:	17 96       	adiw	r26, 0x07	; 7
    2e8c:	8c 93       	st	X, r24
    2e8e:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    2e90:	81 e2       	ldi	r24, 0x21	; 33
    2e92:	16 96       	adiw	r26, 0x06	; 6
    2e94:	8c 93       	st	X, r24
    2e96:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    2e98:	88 e1       	ldi	r24, 0x18	; 24
    2e9a:	14 96       	adiw	r26, 0x04	; 4
    2e9c:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    2e9e:	80 e8       	ldi	r24, 0x80	; 128
    2ea0:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    2ea2:	80 e4       	ldi	r24, 0x40	; 64
    2ea4:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    2ea6:	80 e2       	ldi	r24, 0x20	; 32
    2ea8:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    2eaa:	06 80       	ldd	r0, Z+6	; 0x06
    2eac:	f7 81       	ldd	r31, Z+7	; 0x07
    2eae:	e0 2d       	mov	r30, r0
    2eb0:	80 81       	ld	r24, Z
    2eb2:	80 81       	ld	r24, Z
}
    2eb4:	df 91       	pop	r29
    2eb6:	cf 91       	pop	r28
    2eb8:	08 95       	ret

00002eba <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    2eba:	81 e0       	ldi	r24, 0x01	; 1
    2ebc:	08 95       	ret

00002ebe <_ZN8emstream7getcharEv>:
    2ebe:	80 e0       	ldi	r24, 0x00	; 0
    2ec0:	90 e0       	ldi	r25, 0x00	; 0
    2ec2:	08 95       	ret

00002ec4 <_ZN8emstream14check_for_charEv>:
    2ec4:	80 e0       	ldi	r24, 0x00	; 0
    2ec6:	08 95       	ret

00002ec8 <_ZN8emstream12transmit_nowEv>:
    2ec8:	08 95       	ret

00002eca <_ZN8emstream12clear_screenEv>:
    2eca:	08 95       	ret

00002ecc <_ZN8emstreamC1Ev>:
    2ecc:	fc 01       	movw	r30, r24
    2ece:	8f e5       	ldi	r24, 0x5F	; 95
    2ed0:	90 e2       	ldi	r25, 0x20	; 32
    2ed2:	80 83       	st	Z, r24
    2ed4:	91 83       	std	Z+1, r25	; 0x01
    2ed6:	8a e0       	ldi	r24, 0x0A	; 10
    2ed8:	82 83       	std	Z+2, r24	; 0x02
    2eda:	13 82       	std	Z+3, r1	; 0x03
    2edc:	83 e0       	ldi	r24, 0x03	; 3
    2ede:	85 83       	std	Z+5, r24	; 0x05
    2ee0:	14 82       	std	Z+4, r1	; 0x04
    2ee2:	16 82       	std	Z+6, r1	; 0x06
    2ee4:	17 82       	std	Z+7, r1	; 0x07
    2ee6:	08 95       	ret

00002ee8 <_ZN8emstream4putsEPKc>:
    2ee8:	0f 93       	push	r16
    2eea:	1f 93       	push	r17
    2eec:	cf 93       	push	r28
    2eee:	df 93       	push	r29
    2ef0:	8c 01       	movw	r16, r24
    2ef2:	fb 01       	movw	r30, r22
    2ef4:	dc 01       	movw	r26, r24
    2ef6:	14 96       	adiw	r26, 0x04	; 4
    2ef8:	8c 91       	ld	r24, X
    2efa:	81 11       	cpse	r24, r1
    2efc:	04 c0       	rjmp	.+8      	; 0x2f06 <_ZN8emstream4putsEPKc+0x1e>
    2efe:	60 81       	ld	r22, Z
    2f00:	61 11       	cpse	r22, r1
    2f02:	17 c0       	rjmp	.+46     	; 0x2f32 <_ZN8emstream4putsEPKc+0x4a>
    2f04:	23 c0       	rjmp	.+70     	; 0x2f4c <_ZN8emstream4putsEPKc+0x64>
    2f06:	d8 01       	movw	r26, r16
    2f08:	14 96       	adiw	r26, 0x04	; 4
    2f0a:	1c 92       	st	X, r1
    2f0c:	eb 01       	movw	r28, r22
    2f0e:	21 96       	adiw	r28, 0x01	; 1
    2f10:	64 91       	lpm	r22, Z
    2f12:	66 23       	and	r22, r22
    2f14:	d9 f0       	breq	.+54     	; 0x2f4c <_ZN8emstream4putsEPKc+0x64>
    2f16:	d8 01       	movw	r26, r16
    2f18:	ed 91       	ld	r30, X+
    2f1a:	fc 91       	ld	r31, X
    2f1c:	02 80       	ldd	r0, Z+2	; 0x02
    2f1e:	f3 81       	ldd	r31, Z+3	; 0x03
    2f20:	e0 2d       	mov	r30, r0
    2f22:	c8 01       	movw	r24, r16
    2f24:	19 95       	eicall
    2f26:	fe 01       	movw	r30, r28
    2f28:	64 91       	lpm	r22, Z
    2f2a:	21 96       	adiw	r28, 0x01	; 1
    2f2c:	61 11       	cpse	r22, r1
    2f2e:	f3 cf       	rjmp	.-26     	; 0x2f16 <_ZN8emstream4putsEPKc+0x2e>
    2f30:	0d c0       	rjmp	.+26     	; 0x2f4c <_ZN8emstream4putsEPKc+0x64>
    2f32:	ef 01       	movw	r28, r30
    2f34:	21 96       	adiw	r28, 0x01	; 1
    2f36:	d8 01       	movw	r26, r16
    2f38:	ed 91       	ld	r30, X+
    2f3a:	fc 91       	ld	r31, X
    2f3c:	02 80       	ldd	r0, Z+2	; 0x02
    2f3e:	f3 81       	ldd	r31, Z+3	; 0x03
    2f40:	e0 2d       	mov	r30, r0
    2f42:	c8 01       	movw	r24, r16
    2f44:	19 95       	eicall
    2f46:	69 91       	ld	r22, Y+
    2f48:	61 11       	cpse	r22, r1
    2f4a:	f5 cf       	rjmp	.-22     	; 0x2f36 <_ZN8emstream4putsEPKc+0x4e>
    2f4c:	df 91       	pop	r29
    2f4e:	cf 91       	pop	r28
    2f50:	1f 91       	pop	r17
    2f52:	0f 91       	pop	r16
    2f54:	08 95       	ret

00002f56 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    2f56:	cf 93       	push	r28
    2f58:	df 93       	push	r29
    2f5a:	ec 01       	movw	r28, r24
	switch (new_manip)
    2f5c:	86 2f       	mov	r24, r22
    2f5e:	90 e0       	ldi	r25, 0x00	; 0
    2f60:	8b 30       	cpi	r24, 0x0B	; 11
    2f62:	91 05       	cpc	r25, r1
    2f64:	d8 f5       	brcc	.+118    	; 0x2fdc <_ZN8emstreamlsE15ser_manipulator+0x86>
    2f66:	fc 01       	movw	r30, r24
    2f68:	88 27       	eor	r24, r24
    2f6a:	e2 50       	subi	r30, 0x02	; 2
    2f6c:	ff 4f       	sbci	r31, 0xFF	; 255
    2f6e:	8f 4f       	sbci	r24, 0xFF	; 255
    2f70:	0c 94 ad 1d 	jmp	0x3b5a	; 0x3b5a <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    2f74:	82 e0       	ldi	r24, 0x02	; 2
    2f76:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2f78:	31 c0       	rjmp	.+98     	; 0x2fdc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    2f7a:	88 e0       	ldi	r24, 0x08	; 8
    2f7c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2f7e:	2e c0       	rjmp	.+92     	; 0x2fdc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    2f80:	8a e0       	ldi	r24, 0x0A	; 10
    2f82:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2f84:	2b c0       	rjmp	.+86     	; 0x2fdc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    2f86:	80 e1       	ldi	r24, 0x10	; 16
    2f88:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2f8a:	28 c0       	rjmp	.+80     	; 0x2fdc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    2f8c:	81 e0       	ldi	r24, 0x01	; 1
    2f8e:	8b 83       	std	Y+3, r24	; 0x03
			break;
    2f90:	25 c0       	rjmp	.+74     	; 0x2fdc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    2f92:	1b 82       	std	Y+3, r1	; 0x03
			break;
    2f94:	23 c0       	rjmp	.+70     	; 0x2fdc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    2f96:	e8 81       	ld	r30, Y
    2f98:	f9 81       	ldd	r31, Y+1	; 0x01
    2f9a:	02 80       	ldd	r0, Z+2	; 0x02
    2f9c:	f3 81       	ldd	r31, Z+3	; 0x03
    2f9e:	e0 2d       	mov	r30, r0
    2fa0:	6d e0       	ldi	r22, 0x0D	; 13
    2fa2:	ce 01       	movw	r24, r28
    2fa4:	19 95       	eicall
    2fa6:	e8 81       	ld	r30, Y
    2fa8:	f9 81       	ldd	r31, Y+1	; 0x01
    2faa:	02 80       	ldd	r0, Z+2	; 0x02
    2fac:	f3 81       	ldd	r31, Z+3	; 0x03
    2fae:	e0 2d       	mov	r30, r0
    2fb0:	6a e0       	ldi	r22, 0x0A	; 10
    2fb2:	ce 01       	movw	r24, r28
    2fb4:	19 95       	eicall
			break;
    2fb6:	12 c0       	rjmp	.+36     	; 0x2fdc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    2fb8:	e8 81       	ld	r30, Y
    2fba:	f9 81       	ldd	r31, Y+1	; 0x01
    2fbc:	02 84       	ldd	r0, Z+10	; 0x0a
    2fbe:	f3 85       	ldd	r31, Z+11	; 0x0b
    2fc0:	e0 2d       	mov	r30, r0
    2fc2:	ce 01       	movw	r24, r28
    2fc4:	19 95       	eicall
			break;
    2fc6:	0a c0       	rjmp	.+20     	; 0x2fdc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    2fc8:	e8 81       	ld	r30, Y
    2fca:	f9 81       	ldd	r31, Y+1	; 0x01
    2fcc:	00 84       	ldd	r0, Z+8	; 0x08
    2fce:	f1 85       	ldd	r31, Z+9	; 0x09
    2fd0:	e0 2d       	mov	r30, r0
    2fd2:	ce 01       	movw	r24, r28
    2fd4:	19 95       	eicall
			break;
    2fd6:	02 c0       	rjmp	.+4      	; 0x2fdc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    2fd8:	81 e0       	ldi	r24, 0x01	; 1
    2fda:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    2fdc:	ce 01       	movw	r24, r28
    2fde:	df 91       	pop	r29
    2fe0:	cf 91       	pop	r28
    2fe2:	08 95       	ret

00002fe4 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    2fe4:	ff 92       	push	r15
    2fe6:	0f 93       	push	r16
    2fe8:	1f 93       	push	r17
    2fea:	cf 93       	push	r28
    2fec:	df 93       	push	r29
    2fee:	cd b7       	in	r28, 0x3d	; 61
    2ff0:	de b7       	in	r29, 0x3e	; 62
    2ff2:	61 97       	sbiw	r28, 0x11	; 17
    2ff4:	cd bf       	out	0x3d, r28	; 61
    2ff6:	de bf       	out	0x3e, r29	; 62
    2ff8:	8c 01       	movw	r16, r24
    2ffa:	f6 2e       	mov	r15, r22
    2ffc:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    2ffe:	f8 01       	movw	r30, r16
    3000:	42 81       	ldd	r20, Z+2	; 0x02
    3002:	40 31       	cpi	r20, 0x10	; 16
    3004:	21 f0       	breq	.+8      	; 0x300e <_ZN8emstreamlsEj+0x2a>
    3006:	48 30       	cpi	r20, 0x08	; 8
    3008:	11 f0       	breq	.+4      	; 0x300e <_ZN8emstreamlsEj+0x2a>
    300a:	42 30       	cpi	r20, 0x02	; 2
    300c:	41 f4       	brne	.+16     	; 0x301e <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    300e:	69 2f       	mov	r22, r25
    3010:	c8 01       	movw	r24, r16
    3012:	0e 94 68 18 	call	0x30d0	; 0x30d0 <_ZN8emstreamlsEh>
    3016:	6f 2d       	mov	r22, r15
    3018:	0e 94 68 18 	call	0x30d0	; 0x30d0 <_ZN8emstreamlsEh>
    301c:	0d c0       	rjmp	.+26     	; 0x3038 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    301e:	50 e0       	ldi	r21, 0x00	; 0
    3020:	be 01       	movw	r22, r28
    3022:	6f 5f       	subi	r22, 0xFF	; 255
    3024:	7f 4f       	sbci	r23, 0xFF	; 255
    3026:	8f 2d       	mov	r24, r15
    3028:	0e 94 30 1e 	call	0x3c60	; 0x3c60 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    302c:	be 01       	movw	r22, r28
    302e:	6f 5f       	subi	r22, 0xFF	; 255
    3030:	7f 4f       	sbci	r23, 0xFF	; 255
    3032:	c8 01       	movw	r24, r16
    3034:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3038:	c8 01       	movw	r24, r16
    303a:	61 96       	adiw	r28, 0x11	; 17
    303c:	cd bf       	out	0x3d, r28	; 61
    303e:	de bf       	out	0x3e, r29	; 62
    3040:	df 91       	pop	r29
    3042:	cf 91       	pop	r28
    3044:	1f 91       	pop	r17
    3046:	0f 91       	pop	r16
    3048:	ff 90       	pop	r15
    304a:	08 95       	ret

0000304c <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    304c:	df 92       	push	r13
    304e:	ef 92       	push	r14
    3050:	ff 92       	push	r15
    3052:	0f 93       	push	r16
    3054:	1f 93       	push	r17
    3056:	cf 93       	push	r28
    3058:	df 93       	push	r29
    305a:	cd b7       	in	r28, 0x3d	; 61
    305c:	de b7       	in	r29, 0x3e	; 62
    305e:	a1 97       	sbiw	r28, 0x21	; 33
    3060:	cd bf       	out	0x3d, r28	; 61
    3062:	de bf       	out	0x3e, r29	; 62
    3064:	8c 01       	movw	r16, r24
    3066:	d4 2e       	mov	r13, r20
    3068:	e5 2e       	mov	r14, r21
    306a:	f6 2e       	mov	r15, r22
    306c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    306e:	f8 01       	movw	r30, r16
    3070:	22 81       	ldd	r18, Z+2	; 0x02
    3072:	20 31       	cpi	r18, 0x10	; 16
    3074:	21 f0       	breq	.+8      	; 0x307e <_ZN8emstreamlsEm+0x32>
    3076:	28 30       	cpi	r18, 0x08	; 8
    3078:	11 f0       	breq	.+4      	; 0x307e <_ZN8emstreamlsEm+0x32>
    307a:	22 30       	cpi	r18, 0x02	; 2
    307c:	71 f4       	brne	.+28     	; 0x309a <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    307e:	69 2f       	mov	r22, r25
    3080:	c8 01       	movw	r24, r16
    3082:	0e 94 68 18 	call	0x30d0	; 0x30d0 <_ZN8emstreamlsEh>
    3086:	6f 2d       	mov	r22, r15
    3088:	0e 94 68 18 	call	0x30d0	; 0x30d0 <_ZN8emstreamlsEh>
    308c:	6e 2d       	mov	r22, r14
    308e:	0e 94 68 18 	call	0x30d0	; 0x30d0 <_ZN8emstreamlsEh>
    3092:	6d 2d       	mov	r22, r13
    3094:	0e 94 68 18 	call	0x30d0	; 0x30d0 <_ZN8emstreamlsEh>
    3098:	0f c0       	rjmp	.+30     	; 0x30b8 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    309a:	30 e0       	ldi	r19, 0x00	; 0
    309c:	ae 01       	movw	r20, r28
    309e:	4f 5f       	subi	r20, 0xFF	; 255
    30a0:	5f 4f       	sbci	r21, 0xFF	; 255
    30a2:	6d 2d       	mov	r22, r13
    30a4:	7e 2d       	mov	r23, r14
    30a6:	8f 2d       	mov	r24, r15
    30a8:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    30ac:	be 01       	movw	r22, r28
    30ae:	6f 5f       	subi	r22, 0xFF	; 255
    30b0:	7f 4f       	sbci	r23, 0xFF	; 255
    30b2:	c8 01       	movw	r24, r16
    30b4:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    30b8:	c8 01       	movw	r24, r16
    30ba:	a1 96       	adiw	r28, 0x21	; 33
    30bc:	cd bf       	out	0x3d, r28	; 61
    30be:	de bf       	out	0x3e, r29	; 62
    30c0:	df 91       	pop	r29
    30c2:	cf 91       	pop	r28
    30c4:	1f 91       	pop	r17
    30c6:	0f 91       	pop	r16
    30c8:	ff 90       	pop	r15
    30ca:	ef 90       	pop	r14
    30cc:	df 90       	pop	r13
    30ce:	08 95       	ret

000030d0 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    30d0:	cf 92       	push	r12
    30d2:	df 92       	push	r13
    30d4:	ef 92       	push	r14
    30d6:	ff 92       	push	r15
    30d8:	0f 93       	push	r16
    30da:	1f 93       	push	r17
    30dc:	cf 93       	push	r28
    30de:	df 93       	push	r29
    30e0:	cd b7       	in	r28, 0x3d	; 61
    30e2:	de b7       	in	r29, 0x3e	; 62
    30e4:	29 97       	sbiw	r28, 0x09	; 9
    30e6:	cd bf       	out	0x3d, r28	; 61
    30e8:	de bf       	out	0x3e, r29	; 62
    30ea:	8c 01       	movw	r16, r24
    30ec:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    30ee:	dc 01       	movw	r26, r24
    30f0:	13 96       	adiw	r26, 0x03	; 3
    30f2:	8c 91       	ld	r24, X
    30f4:	13 97       	sbiw	r26, 0x03	; 3
    30f6:	88 23       	and	r24, r24
    30f8:	41 f0       	breq	.+16     	; 0x310a <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    30fa:	ed 91       	ld	r30, X+
    30fc:	fc 91       	ld	r31, X
    30fe:	02 80       	ldd	r0, Z+2	; 0x02
    3100:	f3 81       	ldd	r31, Z+3	; 0x03
    3102:	e0 2d       	mov	r30, r0
    3104:	c8 01       	movw	r24, r16
    3106:	19 95       	eicall
    3108:	56 c0       	rjmp	.+172    	; 0x31b6 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    310a:	f8 01       	movw	r30, r16
    310c:	42 81       	ldd	r20, Z+2	; 0x02
    310e:	42 30       	cpi	r20, 0x02	; 2
    3110:	19 f5       	brne	.+70     	; 0x3158 <_ZN8emstreamlsEh+0x88>
    3112:	68 94       	set
    3114:	cc 24       	eor	r12, r12
    3116:	c3 f8       	bld	r12, 3
    3118:	d1 2c       	mov	r13, r1
    311a:	68 94       	set
    311c:	ff 24       	eor	r15, r15
    311e:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3120:	8e 2d       	mov	r24, r14
    3122:	8f 21       	and	r24, r15
    3124:	51 f0       	breq	.+20     	; 0x313a <_ZN8emstreamlsEh+0x6a>
    3126:	d8 01       	movw	r26, r16
    3128:	ed 91       	ld	r30, X+
    312a:	fc 91       	ld	r31, X
    312c:	02 80       	ldd	r0, Z+2	; 0x02
    312e:	f3 81       	ldd	r31, Z+3	; 0x03
    3130:	e0 2d       	mov	r30, r0
    3132:	61 e3       	ldi	r22, 0x31	; 49
    3134:	c8 01       	movw	r24, r16
    3136:	19 95       	eicall
    3138:	09 c0       	rjmp	.+18     	; 0x314c <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    313a:	d8 01       	movw	r26, r16
    313c:	ed 91       	ld	r30, X+
    313e:	fc 91       	ld	r31, X
    3140:	02 80       	ldd	r0, Z+2	; 0x02
    3142:	f3 81       	ldd	r31, Z+3	; 0x03
    3144:	e0 2d       	mov	r30, r0
    3146:	60 e3       	ldi	r22, 0x30	; 48
    3148:	c8 01       	movw	r24, r16
    314a:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    314c:	f6 94       	lsr	r15
    314e:	b1 e0       	ldi	r27, 0x01	; 1
    3150:	cb 1a       	sub	r12, r27
    3152:	d1 08       	sbc	r13, r1
    3154:	29 f7       	brne	.-54     	; 0x3120 <_ZN8emstreamlsEh+0x50>
    3156:	2f c0       	rjmp	.+94     	; 0x31b6 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3158:	40 31       	cpi	r20, 0x10	; 16
    315a:	f9 f4       	brne	.+62     	; 0x319a <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    315c:	62 95       	swap	r22
    315e:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3160:	01 90       	ld	r0, Z+
    3162:	f0 81       	ld	r31, Z
    3164:	e0 2d       	mov	r30, r0
    3166:	02 80       	ldd	r0, Z+2	; 0x02
    3168:	f3 81       	ldd	r31, Z+3	; 0x03
    316a:	e0 2d       	mov	r30, r0
    316c:	6a 30       	cpi	r22, 0x0A	; 10
    316e:	10 f0       	brcs	.+4      	; 0x3174 <_ZN8emstreamlsEh+0xa4>
    3170:	69 5c       	subi	r22, 0xC9	; 201
    3172:	01 c0       	rjmp	.+2      	; 0x3176 <_ZN8emstreamlsEh+0xa6>
    3174:	60 5d       	subi	r22, 0xD0	; 208
    3176:	c8 01       	movw	r24, r16
    3178:	19 95       	eicall
		temp_char = num & 0x0F;
    317a:	6e 2d       	mov	r22, r14
    317c:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    317e:	d8 01       	movw	r26, r16
    3180:	ed 91       	ld	r30, X+
    3182:	fc 91       	ld	r31, X
    3184:	02 80       	ldd	r0, Z+2	; 0x02
    3186:	f3 81       	ldd	r31, Z+3	; 0x03
    3188:	e0 2d       	mov	r30, r0
    318a:	6a 30       	cpi	r22, 0x0A	; 10
    318c:	10 f0       	brcs	.+4      	; 0x3192 <_ZN8emstreamlsEh+0xc2>
    318e:	69 5c       	subi	r22, 0xC9	; 201
    3190:	01 c0       	rjmp	.+2      	; 0x3194 <_ZN8emstreamlsEh+0xc4>
    3192:	60 5d       	subi	r22, 0xD0	; 208
    3194:	c8 01       	movw	r24, r16
    3196:	19 95       	eicall
    3198:	0e c0       	rjmp	.+28     	; 0x31b6 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    319a:	50 e0       	ldi	r21, 0x00	; 0
    319c:	be 01       	movw	r22, r28
    319e:	6f 5f       	subi	r22, 0xFF	; 255
    31a0:	7f 4f       	sbci	r23, 0xFF	; 255
    31a2:	8e 2d       	mov	r24, r14
    31a4:	90 e0       	ldi	r25, 0x00	; 0
    31a6:	0e 94 30 1e 	call	0x3c60	; 0x3c60 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    31aa:	be 01       	movw	r22, r28
    31ac:	6f 5f       	subi	r22, 0xFF	; 255
    31ae:	7f 4f       	sbci	r23, 0xFF	; 255
    31b0:	c8 01       	movw	r24, r16
    31b2:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    31b6:	c8 01       	movw	r24, r16
    31b8:	29 96       	adiw	r28, 0x09	; 9
    31ba:	cd bf       	out	0x3d, r28	; 61
    31bc:	de bf       	out	0x3e, r29	; 62
    31be:	df 91       	pop	r29
    31c0:	cf 91       	pop	r28
    31c2:	1f 91       	pop	r17
    31c4:	0f 91       	pop	r16
    31c6:	ff 90       	pop	r15
    31c8:	ef 90       	pop	r14
    31ca:	df 90       	pop	r13
    31cc:	cf 90       	pop	r12
    31ce:	08 95       	ret

000031d0 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    31d0:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    31d2:	50 96       	adiw	r26, 0x10	; 16
    31d4:	ed 91       	ld	r30, X+
    31d6:	fc 91       	ld	r31, X
    31d8:	51 97       	sbiw	r26, 0x11	; 17
    31da:	80 81       	ld	r24, Z
    31dc:	54 96       	adiw	r26, 0x14	; 20
    31de:	4c 91       	ld	r20, X
    31e0:	54 97       	sbiw	r26, 0x14	; 20
    31e2:	84 23       	and	r24, r20
    31e4:	29 f0       	breq	.+10     	; 0x31f0 <_ZN5rs2327putcharEc+0x20>
    31e6:	09 c0       	rjmp	.+18     	; 0x31fa <_ZN5rs2327putcharEc+0x2a>
    31e8:	21 50       	subi	r18, 0x01	; 1
    31ea:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    31ec:	19 f4       	brne	.+6      	; 0x31f4 <_ZN5rs2327putcharEc+0x24>
    31ee:	12 c0       	rjmp	.+36     	; 0x3214 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    31f0:	21 e2       	ldi	r18, 0x21	; 33
    31f2:	3e e4       	ldi	r19, 0x4E	; 78
    31f4:	90 81       	ld	r25, Z
    31f6:	94 23       	and	r25, r20
    31f8:	b9 f3       	breq	.-18     	; 0x31e8 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    31fa:	90 81       	ld	r25, Z
    31fc:	56 96       	adiw	r26, 0x16	; 22
    31fe:	8c 91       	ld	r24, X
    3200:	56 97       	sbiw	r26, 0x16	; 22
    3202:	89 2b       	or	r24, r25
    3204:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3206:	1e 96       	adiw	r26, 0x0e	; 14
    3208:	ed 91       	ld	r30, X+
    320a:	fc 91       	ld	r31, X
    320c:	1f 97       	sbiw	r26, 0x0f	; 15
    320e:	60 83       	st	Z, r22
	return (true);
    3210:	81 e0       	ldi	r24, 0x01	; 1
    3212:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3214:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3216:	08 95       	ret

00003218 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3218:	cf 93       	push	r28
    321a:	df 93       	push	r29
    321c:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    321e:	c1 8d       	ldd	r28, Z+25	; 0x19
    3220:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3222:	28 81       	ld	r18, Y
    3224:	39 81       	ldd	r19, Y+1	; 0x01
    3226:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3228:	b4 8d       	ldd	r27, Z+28	; 0x1c
    322a:	4d 91       	ld	r20, X+
    322c:	5c 91       	ld	r21, X
    322e:	24 17       	cp	r18, r20
    3230:	35 07       	cpc	r19, r21
    3232:	e9 f3       	breq	.-6      	; 0x322e <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3234:	a7 89       	ldd	r26, Z+23	; 0x17
    3236:	b0 8d       	ldd	r27, Z+24	; 0x18
    3238:	0d 90       	ld	r0, X+
    323a:	bc 91       	ld	r27, X
    323c:	a0 2d       	mov	r26, r0
    323e:	a2 0f       	add	r26, r18
    3240:	b3 1f       	adc	r27, r19
    3242:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3244:	2f 5f       	subi	r18, 0xFF	; 255
    3246:	3f 4f       	sbci	r19, 0xFF	; 255
    3248:	28 83       	st	Y, r18
    324a:	39 83       	std	Y+1, r19	; 0x01
    324c:	24 36       	cpi	r18, 0x64	; 100
    324e:	31 05       	cpc	r19, r1
    3250:	28 f0       	brcs	.+10     	; 0x325c <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3252:	01 8c       	ldd	r0, Z+25	; 0x19
    3254:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3256:	e0 2d       	mov	r30, r0
    3258:	10 82       	st	Z, r1
    325a:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    325c:	90 e0       	ldi	r25, 0x00	; 0
    325e:	df 91       	pop	r29
    3260:	cf 91       	pop	r28
    3262:	08 95       	ret

00003264 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3264:	cf 93       	push	r28
    3266:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3268:	ec 01       	movw	r28, r24
    326a:	a9 8d       	ldd	r26, Y+25	; 0x19
    326c:	ba 8d       	ldd	r27, Y+26	; 0x1a
    326e:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3270:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3272:	81 e0       	ldi	r24, 0x01	; 1
    3274:	4d 91       	ld	r20, X+
    3276:	5c 91       	ld	r21, X
    3278:	20 81       	ld	r18, Z
    327a:	31 81       	ldd	r19, Z+1	; 0x01
    327c:	42 17       	cp	r20, r18
    327e:	53 07       	cpc	r21, r19
    3280:	09 f4       	brne	.+2      	; 0x3284 <_ZN5rs23214check_for_charEv+0x20>
    3282:	80 e0       	ldi	r24, 0x00	; 0
}
    3284:	df 91       	pop	r29
    3286:	cf 91       	pop	r28
    3288:	08 95       	ret

0000328a <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    328a:	dc 01       	movw	r26, r24
    328c:	ed 91       	ld	r30, X+
    328e:	fc 91       	ld	r31, X
    3290:	02 80       	ldd	r0, Z+2	; 0x02
    3292:	f3 81       	ldd	r31, Z+3	; 0x03
    3294:	e0 2d       	mov	r30, r0
    3296:	6c e0       	ldi	r22, 0x0C	; 12
    3298:	19 95       	eicall
    329a:	08 95       	ret

0000329c <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    329c:	ef 92       	push	r14
    329e:	ff 92       	push	r15
    32a0:	0f 93       	push	r16
    32a2:	1f 93       	push	r17
    32a4:	cf 93       	push	r28
    32a6:	df 93       	push	r29
    32a8:	ec 01       	movw	r28, r24
    32aa:	7b 01       	movw	r14, r22
    32ac:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    32ae:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <_ZN8emstreamC1Ev>
    32b2:	a8 01       	movw	r20, r16
    32b4:	b7 01       	movw	r22, r14
    32b6:	ce 01       	movw	r24, r28
    32b8:	08 96       	adiw	r24, 0x08	; 8
    32ba:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <_ZN7base232C1EjP12USART_struct>
    32be:	8f e6       	ldi	r24, 0x6F	; 111
    32c0:	90 e2       	ldi	r25, 0x20	; 32
    32c2:	88 83       	st	Y, r24
    32c4:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    32c6:	00 3a       	cpi	r16, 0xA0	; 160
    32c8:	88 e0       	ldi	r24, 0x08	; 8
    32ca:	18 07       	cpc	r17, r24
    32cc:	69 f4       	brne	.+26     	; 0x32e8 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    32ce:	8e e5       	ldi	r24, 0x5E	; 94
    32d0:	91 e3       	ldi	r25, 0x31	; 49
    32d2:	8f 8b       	std	Y+23, r24	; 0x17
    32d4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    32d6:	80 e5       	ldi	r24, 0x50	; 80
    32d8:	91 e3       	ldi	r25, 0x31	; 49
    32da:	89 8f       	std	Y+25, r24	; 0x19
    32dc:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    32de:	82 e4       	ldi	r24, 0x42	; 66
    32e0:	91 e3       	ldi	r25, 0x31	; 49
    32e2:	8b 8f       	std	Y+27, r24	; 0x1b
    32e4:	9c 8f       	std	Y+28, r25	; 0x1c
    32e6:	64 c0       	rjmp	.+200    	; 0x33b0 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    32e8:	00 3b       	cpi	r16, 0xB0	; 176
    32ea:	e8 e0       	ldi	r30, 0x08	; 8
    32ec:	1e 07       	cpc	r17, r30
    32ee:	69 f4       	brne	.+26     	; 0x330a <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    32f0:	8c e5       	ldi	r24, 0x5C	; 92
    32f2:	91 e3       	ldi	r25, 0x31	; 49
    32f4:	8f 8b       	std	Y+23, r24	; 0x17
    32f6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    32f8:	8e e4       	ldi	r24, 0x4E	; 78
    32fa:	91 e3       	ldi	r25, 0x31	; 49
    32fc:	89 8f       	std	Y+25, r24	; 0x19
    32fe:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3300:	80 e4       	ldi	r24, 0x40	; 64
    3302:	91 e3       	ldi	r25, 0x31	; 49
    3304:	8b 8f       	std	Y+27, r24	; 0x1b
    3306:	9c 8f       	std	Y+28, r25	; 0x1c
    3308:	53 c0       	rjmp	.+166    	; 0x33b0 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    330a:	00 3a       	cpi	r16, 0xA0	; 160
    330c:	f9 e0       	ldi	r31, 0x09	; 9
    330e:	1f 07       	cpc	r17, r31
    3310:	69 f4       	brne	.+26     	; 0x332c <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3312:	8a e5       	ldi	r24, 0x5A	; 90
    3314:	91 e3       	ldi	r25, 0x31	; 49
    3316:	8f 8b       	std	Y+23, r24	; 0x17
    3318:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    331a:	8c e4       	ldi	r24, 0x4C	; 76
    331c:	91 e3       	ldi	r25, 0x31	; 49
    331e:	89 8f       	std	Y+25, r24	; 0x19
    3320:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3322:	8e e3       	ldi	r24, 0x3E	; 62
    3324:	91 e3       	ldi	r25, 0x31	; 49
    3326:	8b 8f       	std	Y+27, r24	; 0x1b
    3328:	9c 8f       	std	Y+28, r25	; 0x1c
    332a:	42 c0       	rjmp	.+132    	; 0x33b0 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    332c:	00 3b       	cpi	r16, 0xB0	; 176
    332e:	89 e0       	ldi	r24, 0x09	; 9
    3330:	18 07       	cpc	r17, r24
    3332:	69 f4       	brne	.+26     	; 0x334e <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3334:	88 e5       	ldi	r24, 0x58	; 88
    3336:	91 e3       	ldi	r25, 0x31	; 49
    3338:	8f 8b       	std	Y+23, r24	; 0x17
    333a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    333c:	8a e4       	ldi	r24, 0x4A	; 74
    333e:	91 e3       	ldi	r25, 0x31	; 49
    3340:	89 8f       	std	Y+25, r24	; 0x19
    3342:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3344:	8c e3       	ldi	r24, 0x3C	; 60
    3346:	91 e3       	ldi	r25, 0x31	; 49
    3348:	8b 8f       	std	Y+27, r24	; 0x1b
    334a:	9c 8f       	std	Y+28, r25	; 0x1c
    334c:	31 c0       	rjmp	.+98     	; 0x33b0 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    334e:	00 3a       	cpi	r16, 0xA0	; 160
    3350:	ea e0       	ldi	r30, 0x0A	; 10
    3352:	1e 07       	cpc	r17, r30
    3354:	69 f4       	brne	.+26     	; 0x3370 <_ZN5rs232C1EjP12USART_struct+0xd4>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3356:	86 e5       	ldi	r24, 0x56	; 86
    3358:	91 e3       	ldi	r25, 0x31	; 49
    335a:	8f 8b       	std	Y+23, r24	; 0x17
    335c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    335e:	88 e4       	ldi	r24, 0x48	; 72
    3360:	91 e3       	ldi	r25, 0x31	; 49
    3362:	89 8f       	std	Y+25, r24	; 0x19
    3364:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3366:	8a e3       	ldi	r24, 0x3A	; 58
    3368:	91 e3       	ldi	r25, 0x31	; 49
    336a:	8b 8f       	std	Y+27, r24	; 0x1b
    336c:	9c 8f       	std	Y+28, r25	; 0x1c
    336e:	20 c0       	rjmp	.+64     	; 0x33b0 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE1
	else if(p_usart == &USARTE1)
    3370:	00 3b       	cpi	r16, 0xB0	; 176
    3372:	fa e0       	ldi	r31, 0x0A	; 10
    3374:	1f 07       	cpc	r17, r31
    3376:	69 f4       	brne	.+26     	; 0x3392 <_ZN5rs232C1EjP12USART_struct+0xf6>
	{
		p_rcv_buffer		= &rcvE1_buffer;
    3378:	84 e5       	ldi	r24, 0x54	; 84
    337a:	91 e3       	ldi	r25, 0x31	; 49
    337c:	8f 8b       	std	Y+23, r24	; 0x17
    337e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE1_read_index;
    3380:	86 e4       	ldi	r24, 0x46	; 70
    3382:	91 e3       	ldi	r25, 0x31	; 49
    3384:	89 8f       	std	Y+25, r24	; 0x19
    3386:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE1_write_index;
    3388:	88 e3       	ldi	r24, 0x38	; 56
    338a:	91 e3       	ldi	r25, 0x31	; 49
    338c:	8b 8f       	std	Y+27, r24	; 0x1b
    338e:	9c 8f       	std	Y+28, r25	; 0x1c
    3390:	0f c0       	rjmp	.+30     	; 0x33b0 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTF0
	else if(p_usart == &USARTF0)
    3392:	00 3a       	cpi	r16, 0xA0	; 160
    3394:	1b 40       	sbci	r17, 0x0B	; 11
    3396:	61 f4       	brne	.+24     	; 0x33b0 <_ZN5rs232C1EjP12USART_struct+0x114>
	{
		p_rcv_buffer		= &rcvF0_buffer;
    3398:	82 e5       	ldi	r24, 0x52	; 82
    339a:	91 e3       	ldi	r25, 0x31	; 49
    339c:	8f 8b       	std	Y+23, r24	; 0x17
    339e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvF0_read_index;
    33a0:	84 e4       	ldi	r24, 0x44	; 68
    33a2:	91 e3       	ldi	r25, 0x31	; 49
    33a4:	89 8f       	std	Y+25, r24	; 0x19
    33a6:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvF0_write_index;
    33a8:	86 e3       	ldi	r24, 0x36	; 54
    33aa:	91 e3       	ldi	r25, 0x31	; 49
    33ac:	8b 8f       	std	Y+27, r24	; 0x1b
    33ae:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    33b0:	0f 89       	ldd	r16, Y+23	; 0x17
    33b2:	18 8d       	ldd	r17, Y+24	; 0x18
    33b4:	84 e6       	ldi	r24, 0x64	; 100
    33b6:	90 e0       	ldi	r25, 0x00	; 0
    33b8:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <_Znaj>
    33bc:	f8 01       	movw	r30, r16
    33be:	80 83       	st	Z, r24
    33c0:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    33c2:	e9 8d       	ldd	r30, Y+25	; 0x19
    33c4:	fa 8d       	ldd	r31, Y+26	; 0x1a
    33c6:	10 82       	st	Z, r1
    33c8:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    33ca:	eb 8d       	ldd	r30, Y+27	; 0x1b
    33cc:	fc 8d       	ldd	r31, Y+28	; 0x1c
    33ce:	10 82       	st	Z, r1
    33d0:	11 82       	std	Z+1, r1	; 0x01
}
    33d2:	df 91       	pop	r29
    33d4:	cf 91       	pop	r28
    33d6:	1f 91       	pop	r17
    33d8:	0f 91       	pop	r16
    33da:	ff 90       	pop	r15
    33dc:	ef 90       	pop	r14
    33de:	08 95       	ret

000033e0 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    33e0:	1f 92       	push	r1
    33e2:	0f 92       	push	r0
    33e4:	0f b6       	in	r0, 0x3f	; 63
    33e6:	0f 92       	push	r0
    33e8:	11 24       	eor	r1, r1
    33ea:	08 b6       	in	r0, 0x38	; 56
    33ec:	0f 92       	push	r0
    33ee:	18 be       	out	0x38, r1	; 56
    33f0:	0b b6       	in	r0, 0x3b	; 59
    33f2:	0f 92       	push	r0
    33f4:	1b be       	out	0x3b, r1	; 59
    33f6:	2f 93       	push	r18
    33f8:	3f 93       	push	r19
    33fa:	8f 93       	push	r24
    33fc:	9f 93       	push	r25
    33fe:	ef 93       	push	r30
    3400:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3402:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3406:	e0 91 5e 31 	lds	r30, 0x315E	; 0x80315e <rcvC0_buffer>
    340a:	f0 91 5f 31 	lds	r31, 0x315F	; 0x80315f <rcvC0_buffer+0x1>
    340e:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvC0_write_index>
    3412:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvC0_write_index+0x1>
    3416:	e8 0f       	add	r30, r24
    3418:	f9 1f       	adc	r31, r25
    341a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    341c:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvC0_write_index>
    3420:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvC0_write_index+0x1>
    3424:	01 96       	adiw	r24, 0x01	; 1
    3426:	84 36       	cpi	r24, 0x64	; 100
    3428:	91 05       	cpc	r25, r1
    342a:	60 f4       	brcc	.+24     	; 0x3444 <__vector_25+0x64>
    342c:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <rcvC0_write_index>
    3430:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3434:	20 91 50 31 	lds	r18, 0x3150	; 0x803150 <rcvC0_read_index>
    3438:	30 91 51 31 	lds	r19, 0x3151	; 0x803151 <rcvC0_read_index+0x1>
    343c:	82 17       	cp	r24, r18
    343e:	93 07       	cpc	r25, r19
    3440:	f1 f4       	brne	.+60     	; 0x347e <__vector_25+0x9e>
    3442:	0c c0       	rjmp	.+24     	; 0x345c <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3444:	10 92 42 31 	sts	0x3142, r1	; 0x803142 <rcvC0_write_index>
    3448:	10 92 43 31 	sts	0x3143, r1	; 0x803143 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    344c:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvC0_read_index>
    3450:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvC0_read_index+0x1>
    3454:	18 16       	cp	r1, r24
    3456:	19 06       	cpc	r1, r25
    3458:	91 f4       	brne	.+36     	; 0x347e <__vector_25+0x9e>
    345a:	0e c0       	rjmp	.+28     	; 0x3478 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    345c:	01 96       	adiw	r24, 0x01	; 1
    345e:	84 36       	cpi	r24, 0x64	; 100
    3460:	91 05       	cpc	r25, r1
    3462:	28 f4       	brcc	.+10     	; 0x346e <__vector_25+0x8e>
    3464:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <rcvC0_read_index>
    3468:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <rcvC0_read_index+0x1>
    346c:	08 c0       	rjmp	.+16     	; 0x347e <__vector_25+0x9e>
			rcvC0_read_index = 0;
    346e:	10 92 50 31 	sts	0x3150, r1	; 0x803150 <rcvC0_read_index>
    3472:	10 92 51 31 	sts	0x3151, r1	; 0x803151 <rcvC0_read_index+0x1>
}
    3476:	03 c0       	rjmp	.+6      	; 0x347e <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3478:	81 e0       	ldi	r24, 0x01	; 1
    347a:	90 e0       	ldi	r25, 0x00	; 0
    347c:	f3 cf       	rjmp	.-26     	; 0x3464 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    347e:	ff 91       	pop	r31
    3480:	ef 91       	pop	r30
    3482:	9f 91       	pop	r25
    3484:	8f 91       	pop	r24
    3486:	3f 91       	pop	r19
    3488:	2f 91       	pop	r18
    348a:	0f 90       	pop	r0
    348c:	0b be       	out	0x3b, r0	; 59
    348e:	0f 90       	pop	r0
    3490:	08 be       	out	0x38, r0	; 56
    3492:	0f 90       	pop	r0
    3494:	0f be       	out	0x3f, r0	; 63
    3496:	0f 90       	pop	r0
    3498:	1f 90       	pop	r1
    349a:	18 95       	reti

0000349c <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    349c:	1f 92       	push	r1
    349e:	0f 92       	push	r0
    34a0:	0f b6       	in	r0, 0x3f	; 63
    34a2:	0f 92       	push	r0
    34a4:	11 24       	eor	r1, r1
    34a6:	08 b6       	in	r0, 0x38	; 56
    34a8:	0f 92       	push	r0
    34aa:	18 be       	out	0x38, r1	; 56
    34ac:	0b b6       	in	r0, 0x3b	; 59
    34ae:	0f 92       	push	r0
    34b0:	1b be       	out	0x3b, r1	; 59
    34b2:	2f 93       	push	r18
    34b4:	3f 93       	push	r19
    34b6:	8f 93       	push	r24
    34b8:	9f 93       	push	r25
    34ba:	ef 93       	push	r30
    34bc:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    34be:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    34c2:	e0 91 5c 31 	lds	r30, 0x315C	; 0x80315c <rcvC1_buffer>
    34c6:	f0 91 5d 31 	lds	r31, 0x315D	; 0x80315d <rcvC1_buffer+0x1>
    34ca:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvC1_write_index>
    34ce:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvC1_write_index+0x1>
    34d2:	e8 0f       	add	r30, r24
    34d4:	f9 1f       	adc	r31, r25
    34d6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    34d8:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvC1_write_index>
    34dc:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvC1_write_index+0x1>
    34e0:	01 96       	adiw	r24, 0x01	; 1
    34e2:	84 36       	cpi	r24, 0x64	; 100
    34e4:	91 05       	cpc	r25, r1
    34e6:	60 f4       	brcc	.+24     	; 0x3500 <__vector_28+0x64>
    34e8:	80 93 40 31 	sts	0x3140, r24	; 0x803140 <rcvC1_write_index>
    34ec:	90 93 41 31 	sts	0x3141, r25	; 0x803141 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    34f0:	20 91 4e 31 	lds	r18, 0x314E	; 0x80314e <rcvC1_read_index>
    34f4:	30 91 4f 31 	lds	r19, 0x314F	; 0x80314f <rcvC1_read_index+0x1>
    34f8:	82 17       	cp	r24, r18
    34fa:	93 07       	cpc	r25, r19
    34fc:	f1 f4       	brne	.+60     	; 0x353a <__vector_28+0x9e>
    34fe:	0c c0       	rjmp	.+24     	; 0x3518 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3500:	10 92 40 31 	sts	0x3140, r1	; 0x803140 <rcvC1_write_index>
    3504:	10 92 41 31 	sts	0x3141, r1	; 0x803141 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3508:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvC1_read_index>
    350c:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvC1_read_index+0x1>
    3510:	18 16       	cp	r1, r24
    3512:	19 06       	cpc	r1, r25
    3514:	91 f4       	brne	.+36     	; 0x353a <__vector_28+0x9e>
    3516:	0e c0       	rjmp	.+28     	; 0x3534 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3518:	01 96       	adiw	r24, 0x01	; 1
    351a:	84 36       	cpi	r24, 0x64	; 100
    351c:	91 05       	cpc	r25, r1
    351e:	28 f4       	brcc	.+10     	; 0x352a <__vector_28+0x8e>
    3520:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <rcvC1_read_index>
    3524:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <rcvC1_read_index+0x1>
    3528:	08 c0       	rjmp	.+16     	; 0x353a <__vector_28+0x9e>
	rcvC1_read_index = 0;
    352a:	10 92 4e 31 	sts	0x314E, r1	; 0x80314e <rcvC1_read_index>
    352e:	10 92 4f 31 	sts	0x314F, r1	; 0x80314f <rcvC1_read_index+0x1>
}
    3532:	03 c0       	rjmp	.+6      	; 0x353a <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3534:	81 e0       	ldi	r24, 0x01	; 1
    3536:	90 e0       	ldi	r25, 0x00	; 0
    3538:	f3 cf       	rjmp	.-26     	; 0x3520 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    353a:	ff 91       	pop	r31
    353c:	ef 91       	pop	r30
    353e:	9f 91       	pop	r25
    3540:	8f 91       	pop	r24
    3542:	3f 91       	pop	r19
    3544:	2f 91       	pop	r18
    3546:	0f 90       	pop	r0
    3548:	0b be       	out	0x3b, r0	; 59
    354a:	0f 90       	pop	r0
    354c:	08 be       	out	0x38, r0	; 56
    354e:	0f 90       	pop	r0
    3550:	0f be       	out	0x3f, r0	; 63
    3552:	0f 90       	pop	r0
    3554:	1f 90       	pop	r1
    3556:	18 95       	reti

00003558 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3558:	1f 92       	push	r1
    355a:	0f 92       	push	r0
    355c:	0f b6       	in	r0, 0x3f	; 63
    355e:	0f 92       	push	r0
    3560:	11 24       	eor	r1, r1
    3562:	08 b6       	in	r0, 0x38	; 56
    3564:	0f 92       	push	r0
    3566:	18 be       	out	0x38, r1	; 56
    3568:	0b b6       	in	r0, 0x3b	; 59
    356a:	0f 92       	push	r0
    356c:	1b be       	out	0x3b, r1	; 59
    356e:	2f 93       	push	r18
    3570:	3f 93       	push	r19
    3572:	8f 93       	push	r24
    3574:	9f 93       	push	r25
    3576:	ef 93       	push	r30
    3578:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    357a:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    357e:	e0 91 5a 31 	lds	r30, 0x315A	; 0x80315a <rcvD0_buffer>
    3582:	f0 91 5b 31 	lds	r31, 0x315B	; 0x80315b <rcvD0_buffer+0x1>
    3586:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvC0_write_index>
    358a:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvC0_write_index+0x1>
    358e:	e8 0f       	add	r30, r24
    3590:	f9 1f       	adc	r31, r25
    3592:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3594:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <rcvD0_write_index>
    3598:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <rcvD0_write_index+0x1>
    359c:	01 96       	adiw	r24, 0x01	; 1
    359e:	84 36       	cpi	r24, 0x64	; 100
    35a0:	91 05       	cpc	r25, r1
    35a2:	60 f4       	brcc	.+24     	; 0x35bc <__vector_88+0x64>
    35a4:	80 93 3e 31 	sts	0x313E, r24	; 0x80313e <rcvD0_write_index>
    35a8:	90 93 3f 31 	sts	0x313F, r25	; 0x80313f <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    35ac:	20 91 4c 31 	lds	r18, 0x314C	; 0x80314c <rcvD0_read_index>
    35b0:	30 91 4d 31 	lds	r19, 0x314D	; 0x80314d <rcvD0_read_index+0x1>
    35b4:	82 17       	cp	r24, r18
    35b6:	93 07       	cpc	r25, r19
    35b8:	f1 f4       	brne	.+60     	; 0x35f6 <__vector_88+0x9e>
    35ba:	0c c0       	rjmp	.+24     	; 0x35d4 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    35bc:	10 92 3e 31 	sts	0x313E, r1	; 0x80313e <rcvD0_write_index>
    35c0:	10 92 3f 31 	sts	0x313F, r1	; 0x80313f <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    35c4:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvD0_read_index>
    35c8:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvD0_read_index+0x1>
    35cc:	18 16       	cp	r1, r24
    35ce:	19 06       	cpc	r1, r25
    35d0:	91 f4       	brne	.+36     	; 0x35f6 <__vector_88+0x9e>
    35d2:	0e c0       	rjmp	.+28     	; 0x35f0 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    35d4:	01 96       	adiw	r24, 0x01	; 1
    35d6:	84 36       	cpi	r24, 0x64	; 100
    35d8:	91 05       	cpc	r25, r1
    35da:	28 f4       	brcc	.+10     	; 0x35e6 <__vector_88+0x8e>
    35dc:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <rcvD0_read_index>
    35e0:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <rcvD0_read_index+0x1>
    35e4:	08 c0       	rjmp	.+16     	; 0x35f6 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    35e6:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rcvD0_read_index>
    35ea:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <rcvD0_read_index+0x1>
}
    35ee:	03 c0       	rjmp	.+6      	; 0x35f6 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    35f0:	81 e0       	ldi	r24, 0x01	; 1
    35f2:	90 e0       	ldi	r25, 0x00	; 0
    35f4:	f3 cf       	rjmp	.-26     	; 0x35dc <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    35f6:	ff 91       	pop	r31
    35f8:	ef 91       	pop	r30
    35fa:	9f 91       	pop	r25
    35fc:	8f 91       	pop	r24
    35fe:	3f 91       	pop	r19
    3600:	2f 91       	pop	r18
    3602:	0f 90       	pop	r0
    3604:	0b be       	out	0x3b, r0	; 59
    3606:	0f 90       	pop	r0
    3608:	08 be       	out	0x38, r0	; 56
    360a:	0f 90       	pop	r0
    360c:	0f be       	out	0x3f, r0	; 63
    360e:	0f 90       	pop	r0
    3610:	1f 90       	pop	r1
    3612:	18 95       	reti

00003614 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3614:	1f 92       	push	r1
    3616:	0f 92       	push	r0
    3618:	0f b6       	in	r0, 0x3f	; 63
    361a:	0f 92       	push	r0
    361c:	11 24       	eor	r1, r1
    361e:	08 b6       	in	r0, 0x38	; 56
    3620:	0f 92       	push	r0
    3622:	18 be       	out	0x38, r1	; 56
    3624:	0b b6       	in	r0, 0x3b	; 59
    3626:	0f 92       	push	r0
    3628:	1b be       	out	0x3b, r1	; 59
    362a:	2f 93       	push	r18
    362c:	3f 93       	push	r19
    362e:	8f 93       	push	r24
    3630:	9f 93       	push	r25
    3632:	ef 93       	push	r30
    3634:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3636:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    363a:	e0 91 58 31 	lds	r30, 0x3158	; 0x803158 <rcvD1_buffer>
    363e:	f0 91 59 31 	lds	r31, 0x3159	; 0x803159 <rcvD1_buffer+0x1>
    3642:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvD1_write_index>
    3646:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvD1_write_index+0x1>
    364a:	e8 0f       	add	r30, r24
    364c:	f9 1f       	adc	r31, r25
    364e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3650:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvD1_write_index>
    3654:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvD1_write_index+0x1>
    3658:	01 96       	adiw	r24, 0x01	; 1
    365a:	84 36       	cpi	r24, 0x64	; 100
    365c:	91 05       	cpc	r25, r1
    365e:	60 f4       	brcc	.+24     	; 0x3678 <__vector_91+0x64>
    3660:	80 93 3c 31 	sts	0x313C, r24	; 0x80313c <rcvD1_write_index>
    3664:	90 93 3d 31 	sts	0x313D, r25	; 0x80313d <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3668:	20 91 4a 31 	lds	r18, 0x314A	; 0x80314a <rcvD1_read_index>
    366c:	30 91 4b 31 	lds	r19, 0x314B	; 0x80314b <rcvD1_read_index+0x1>
    3670:	82 17       	cp	r24, r18
    3672:	93 07       	cpc	r25, r19
    3674:	f1 f4       	brne	.+60     	; 0x36b2 <__vector_91+0x9e>
    3676:	0c c0       	rjmp	.+24     	; 0x3690 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3678:	10 92 3c 31 	sts	0x313C, r1	; 0x80313c <rcvD1_write_index>
    367c:	10 92 3d 31 	sts	0x313D, r1	; 0x80313d <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3680:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <rcvD1_read_index>
    3684:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <rcvD1_read_index+0x1>
    3688:	18 16       	cp	r1, r24
    368a:	19 06       	cpc	r1, r25
    368c:	91 f4       	brne	.+36     	; 0x36b2 <__vector_91+0x9e>
    368e:	0e c0       	rjmp	.+28     	; 0x36ac <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3690:	01 96       	adiw	r24, 0x01	; 1
    3692:	84 36       	cpi	r24, 0x64	; 100
    3694:	91 05       	cpc	r25, r1
    3696:	28 f4       	brcc	.+10     	; 0x36a2 <__vector_91+0x8e>
    3698:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <rcvD1_read_index>
    369c:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <rcvD1_read_index+0x1>
    36a0:	08 c0       	rjmp	.+16     	; 0x36b2 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    36a2:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <rcvD1_read_index>
    36a6:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <rcvD1_read_index+0x1>
}
    36aa:	03 c0       	rjmp	.+6      	; 0x36b2 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    36ac:	81 e0       	ldi	r24, 0x01	; 1
    36ae:	90 e0       	ldi	r25, 0x00	; 0
    36b0:	f3 cf       	rjmp	.-26     	; 0x3698 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    36b2:	ff 91       	pop	r31
    36b4:	ef 91       	pop	r30
    36b6:	9f 91       	pop	r25
    36b8:	8f 91       	pop	r24
    36ba:	3f 91       	pop	r19
    36bc:	2f 91       	pop	r18
    36be:	0f 90       	pop	r0
    36c0:	0b be       	out	0x3b, r0	; 59
    36c2:	0f 90       	pop	r0
    36c4:	08 be       	out	0x38, r0	; 56
    36c6:	0f 90       	pop	r0
    36c8:	0f be       	out	0x3f, r0	; 63
    36ca:	0f 90       	pop	r0
    36cc:	1f 90       	pop	r1
    36ce:	18 95       	reti

000036d0 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    36d0:	1f 92       	push	r1
    36d2:	0f 92       	push	r0
    36d4:	0f b6       	in	r0, 0x3f	; 63
    36d6:	0f 92       	push	r0
    36d8:	11 24       	eor	r1, r1
    36da:	08 b6       	in	r0, 0x38	; 56
    36dc:	0f 92       	push	r0
    36de:	18 be       	out	0x38, r1	; 56
    36e0:	0b b6       	in	r0, 0x3b	; 59
    36e2:	0f 92       	push	r0
    36e4:	1b be       	out	0x3b, r1	; 59
    36e6:	2f 93       	push	r18
    36e8:	3f 93       	push	r19
    36ea:	8f 93       	push	r24
    36ec:	9f 93       	push	r25
    36ee:	ef 93       	push	r30
    36f0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    36f2:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    36f6:	e0 91 56 31 	lds	r30, 0x3156	; 0x803156 <rcvE0_buffer>
    36fa:	f0 91 57 31 	lds	r31, 0x3157	; 0x803157 <rcvE0_buffer+0x1>
    36fe:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvE0_write_index>
    3702:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvE0_write_index+0x1>
    3706:	e8 0f       	add	r30, r24
    3708:	f9 1f       	adc	r31, r25
    370a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    370c:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvE0_write_index>
    3710:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvE0_write_index+0x1>
    3714:	01 96       	adiw	r24, 0x01	; 1
    3716:	84 36       	cpi	r24, 0x64	; 100
    3718:	91 05       	cpc	r25, r1
    371a:	60 f4       	brcc	.+24     	; 0x3734 <__vector_58+0x64>
    371c:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvE0_write_index>
    3720:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3724:	20 91 48 31 	lds	r18, 0x3148	; 0x803148 <rcvE0_read_index>
    3728:	30 91 49 31 	lds	r19, 0x3149	; 0x803149 <rcvE0_read_index+0x1>
    372c:	82 17       	cp	r24, r18
    372e:	93 07       	cpc	r25, r19
    3730:	f1 f4       	brne	.+60     	; 0x376e <__vector_58+0x9e>
    3732:	0c c0       	rjmp	.+24     	; 0x374c <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3734:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvE0_write_index>
    3738:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    373c:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rcvE0_read_index>
    3740:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <rcvE0_read_index+0x1>
    3744:	18 16       	cp	r1, r24
    3746:	19 06       	cpc	r1, r25
    3748:	91 f4       	brne	.+36     	; 0x376e <__vector_58+0x9e>
    374a:	0e c0       	rjmp	.+28     	; 0x3768 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    374c:	01 96       	adiw	r24, 0x01	; 1
    374e:	84 36       	cpi	r24, 0x64	; 100
    3750:	91 05       	cpc	r25, r1
    3752:	28 f4       	brcc	.+10     	; 0x375e <__vector_58+0x8e>
    3754:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <rcvE0_read_index>
    3758:	90 93 49 31 	sts	0x3149, r25	; 0x803149 <rcvE0_read_index+0x1>
    375c:	08 c0       	rjmp	.+16     	; 0x376e <__vector_58+0x9e>
	rcvE0_read_index = 0;
    375e:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <rcvE0_read_index>
    3762:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <rcvE0_read_index+0x1>
}
    3766:	03 c0       	rjmp	.+6      	; 0x376e <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3768:	81 e0       	ldi	r24, 0x01	; 1
    376a:	90 e0       	ldi	r25, 0x00	; 0
    376c:	f3 cf       	rjmp	.-26     	; 0x3754 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    376e:	ff 91       	pop	r31
    3770:	ef 91       	pop	r30
    3772:	9f 91       	pop	r25
    3774:	8f 91       	pop	r24
    3776:	3f 91       	pop	r19
    3778:	2f 91       	pop	r18
    377a:	0f 90       	pop	r0
    377c:	0b be       	out	0x3b, r0	; 59
    377e:	0f 90       	pop	r0
    3780:	08 be       	out	0x38, r0	; 56
    3782:	0f 90       	pop	r0
    3784:	0f be       	out	0x3f, r0	; 63
    3786:	0f 90       	pop	r0
    3788:	1f 90       	pop	r1
    378a:	18 95       	reti

0000378c <__vector_61>:
#endif

#ifdef USARTE1_RXC_vect
ISR (USARTE1_RXC_vect)
{
    378c:	1f 92       	push	r1
    378e:	0f 92       	push	r0
    3790:	0f b6       	in	r0, 0x3f	; 63
    3792:	0f 92       	push	r0
    3794:	11 24       	eor	r1, r1
    3796:	08 b6       	in	r0, 0x38	; 56
    3798:	0f 92       	push	r0
    379a:	18 be       	out	0x38, r1	; 56
    379c:	0b b6       	in	r0, 0x3b	; 59
    379e:	0f 92       	push	r0
    37a0:	1b be       	out	0x3b, r1	; 59
    37a2:	2f 93       	push	r18
    37a4:	3f 93       	push	r19
    37a6:	8f 93       	push	r24
    37a8:	9f 93       	push	r25
    37aa:	ef 93       	push	r30
    37ac:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;
    37ae:	20 91 b0 0a 	lds	r18, 0x0AB0	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x700ab0>
    37b2:	e0 91 54 31 	lds	r30, 0x3154	; 0x803154 <rcvE1_buffer>
    37b6:	f0 91 55 31 	lds	r31, 0x3155	; 0x803155 <rcvE1_buffer+0x1>
    37ba:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvE1_write_index>
    37be:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvE1_write_index+0x1>
    37c2:	e8 0f       	add	r30, r24
    37c4:	f9 1f       	adc	r31, r25
    37c6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
    37c8:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvE1_write_index>
    37cc:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvE1_write_index+0x1>
    37d0:	01 96       	adiw	r24, 0x01	; 1
    37d2:	84 36       	cpi	r24, 0x64	; 100
    37d4:	91 05       	cpc	r25, r1
    37d6:	60 f4       	brcc	.+24     	; 0x37f0 <__vector_61+0x64>
    37d8:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvE1_write_index>
    37dc:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvE1_write_index+0x1>
	rcvE1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    37e0:	20 91 46 31 	lds	r18, 0x3146	; 0x803146 <rcvE1_read_index>
    37e4:	30 91 47 31 	lds	r19, 0x3147	; 0x803147 <rcvE1_read_index+0x1>
    37e8:	82 17       	cp	r24, r18
    37ea:	93 07       	cpc	r25, r19
    37ec:	f1 f4       	brne	.+60     	; 0x382a <__vector_61+0x9e>
    37ee:	0c c0       	rjmp	.+24     	; 0x3808 <__vector_61+0x7c>

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
	rcvE1_write_index = 0;
    37f0:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvE1_write_index>
    37f4:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvE1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
    37f8:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rcvE1_read_index>
    37fc:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <rcvE1_read_index+0x1>
    3800:	18 16       	cp	r1, r24
    3802:	19 06       	cpc	r1, r25
    3804:	91 f4       	brne	.+36     	; 0x382a <__vector_61+0x9e>
    3806:	0e c0       	rjmp	.+28     	; 0x3824 <__vector_61+0x98>
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3808:	01 96       	adiw	r24, 0x01	; 1
    380a:	84 36       	cpi	r24, 0x64	; 100
    380c:	91 05       	cpc	r25, r1
    380e:	28 f4       	brcc	.+10     	; 0x381a <__vector_61+0x8e>
    3810:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <rcvE1_read_index>
    3814:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <rcvE1_read_index+0x1>
    3818:	08 c0       	rjmp	.+16     	; 0x382a <__vector_61+0x9e>
	rcvE1_read_index = 0;
    381a:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <rcvE1_read_index>
    381e:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <rcvE1_read_index+0x1>
}
    3822:	03 c0       	rjmp	.+6      	; 0x382a <__vector_61+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
    3824:	81 e0       	ldi	r24, 0x01	; 1
    3826:	90 e0       	ldi	r25, 0x00	; 0
    3828:	f3 cf       	rjmp	.-26     	; 0x3810 <__vector_61+0x84>
	rcvE1_read_index = 0;
}
    382a:	ff 91       	pop	r31
    382c:	ef 91       	pop	r30
    382e:	9f 91       	pop	r25
    3830:	8f 91       	pop	r24
    3832:	3f 91       	pop	r19
    3834:	2f 91       	pop	r18
    3836:	0f 90       	pop	r0
    3838:	0b be       	out	0x3b, r0	; 59
    383a:	0f 90       	pop	r0
    383c:	08 be       	out	0x38, r0	; 56
    383e:	0f 90       	pop	r0
    3840:	0f be       	out	0x3f, r0	; 63
    3842:	0f 90       	pop	r0
    3844:	1f 90       	pop	r1
    3846:	18 95       	reti

00003848 <__vector_119>:
#endif

#ifdef USARTF0_RXC_vect
ISR (USARTF0_RXC_vect)
{
    3848:	1f 92       	push	r1
    384a:	0f 92       	push	r0
    384c:	0f b6       	in	r0, 0x3f	; 63
    384e:	0f 92       	push	r0
    3850:	11 24       	eor	r1, r1
    3852:	08 b6       	in	r0, 0x38	; 56
    3854:	0f 92       	push	r0
    3856:	18 be       	out	0x38, r1	; 56
    3858:	0b b6       	in	r0, 0x3b	; 59
    385a:	0f 92       	push	r0
    385c:	1b be       	out	0x3b, r1	; 59
    385e:	2f 93       	push	r18
    3860:	3f 93       	push	r19
    3862:	8f 93       	push	r24
    3864:	9f 93       	push	r25
    3866:	ef 93       	push	r30
    3868:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;
    386a:	20 91 a0 0b 	lds	r18, 0x0BA0	; 0x800ba0 <__TEXT_REGION_LENGTH__+0x700ba0>
    386e:	e0 91 52 31 	lds	r30, 0x3152	; 0x803152 <rcvF0_buffer>
    3872:	f0 91 53 31 	lds	r31, 0x3153	; 0x803153 <rcvF0_buffer+0x1>
    3876:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvF0_write_index>
    387a:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvF0_write_index+0x1>
    387e:	e8 0f       	add	r30, r24
    3880:	f9 1f       	adc	r31, r25
    3882:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
    3884:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvF0_write_index>
    3888:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvF0_write_index+0x1>
    388c:	01 96       	adiw	r24, 0x01	; 1
    388e:	84 36       	cpi	r24, 0x64	; 100
    3890:	91 05       	cpc	r25, r1
    3892:	60 f4       	brcc	.+24     	; 0x38ac <__vector_119+0x64>
    3894:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvF0_write_index>
    3898:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvF0_write_index+0x1>
	rcvF0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    389c:	20 91 44 31 	lds	r18, 0x3144	; 0x803144 <rcvF0_read_index>
    38a0:	30 91 45 31 	lds	r19, 0x3145	; 0x803145 <rcvF0_read_index+0x1>
    38a4:	82 17       	cp	r24, r18
    38a6:	93 07       	cpc	r25, r19
    38a8:	f1 f4       	brne	.+60     	; 0x38e6 <__vector_119+0x9e>
    38aa:	0c c0       	rjmp	.+24     	; 0x38c4 <__vector_119+0x7c>

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
	rcvF0_write_index = 0;
    38ac:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvF0_write_index>
    38b0:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvF0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    38b4:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <rcvF0_read_index>
    38b8:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <rcvF0_read_index+0x1>
    38bc:	18 16       	cp	r1, r24
    38be:	19 06       	cpc	r1, r25
    38c0:	91 f4       	brne	.+36     	; 0x38e6 <__vector_119+0x9e>
    38c2:	0e c0       	rjmp	.+28     	; 0x38e0 <__vector_119+0x98>
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    38c4:	01 96       	adiw	r24, 0x01	; 1
    38c6:	84 36       	cpi	r24, 0x64	; 100
    38c8:	91 05       	cpc	r25, r1
    38ca:	28 f4       	brcc	.+10     	; 0x38d6 <__vector_119+0x8e>
    38cc:	80 93 44 31 	sts	0x3144, r24	; 0x803144 <rcvF0_read_index>
    38d0:	90 93 45 31 	sts	0x3145, r25	; 0x803145 <rcvF0_read_index+0x1>
    38d4:	08 c0       	rjmp	.+16     	; 0x38e6 <__vector_119+0x9e>
	rcvF0_read_index = 0;
    38d6:	10 92 44 31 	sts	0x3144, r1	; 0x803144 <rcvF0_read_index>
    38da:	10 92 45 31 	sts	0x3145, r1	; 0x803145 <rcvF0_read_index+0x1>
}
    38de:	03 c0       	rjmp	.+6      	; 0x38e6 <__vector_119+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    38e0:	81 e0       	ldi	r24, 0x01	; 1
    38e2:	90 e0       	ldi	r25, 0x00	; 0
    38e4:	f3 cf       	rjmp	.-26     	; 0x38cc <__vector_119+0x84>
	rcvF0_read_index = 0;
}
    38e6:	ff 91       	pop	r31
    38e8:	ef 91       	pop	r30
    38ea:	9f 91       	pop	r25
    38ec:	8f 91       	pop	r24
    38ee:	3f 91       	pop	r19
    38f0:	2f 91       	pop	r18
    38f2:	0f 90       	pop	r0
    38f4:	0b be       	out	0x3b, r0	; 59
    38f6:	0f 90       	pop	r0
    38f8:	08 be       	out	0x38, r0	; 56
    38fa:	0f 90       	pop	r0
    38fc:	0f be       	out	0x3f, r0	; 63
    38fe:	0f 90       	pop	r0
    3900:	1f 90       	pop	r1
    3902:	18 95       	reti

00003904 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3904:	0f 93       	push	r16
    3906:	cf 93       	push	r28
    3908:	df 93       	push	r29
    390a:	1f 92       	push	r1
    390c:	cd b7       	in	r28, 0x3d	; 61
    390e:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3910:	2f b7       	in	r18, 0x3f	; 63
    3912:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3914:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3916:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3918:	fc 01       	movw	r30, r24
    391a:	08 ed       	ldi	r16, 0xD8	; 216
    391c:	04 bf       	out	0x34, r16	; 52
    391e:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3920:	89 81       	ldd	r24, Y+1	; 0x01
    3922:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3924:	0f 90       	pop	r0
    3926:	df 91       	pop	r29
    3928:	cf 91       	pop	r28
    392a:	0f 91       	pop	r16
    392c:	08 95       	ret

0000392e <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    392e:	0f 93       	push	r16
    3930:	1f 93       	push	r17
    3932:	cf 93       	push	r28
    3934:	df 93       	push	r29
    3936:	cd b7       	in	r28, 0x3d	; 61
    3938:	de b7       	in	r29, 0x3e	; 62
    393a:	6d 97       	sbiw	r28, 0x1d	; 29
    393c:	cd bf       	out	0x3d, r28	; 61
    393e:	de bf       	out	0x3e, r29	; 62
	//Clear any interrupts
	cli();
    3940:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator  <-----------------------MAY NEED TO CHANGE FOR 16MHz 
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3942:	e0 e5       	ldi	r30, 0x50	; 80
    3944:	f0 e0       	ldi	r31, 0x00	; 0
    3946:	80 81       	ld	r24, Z
    3948:	82 60       	ori	r24, 0x02	; 2
    394a:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    394c:	81 81       	ldd	r24, Z+1	; 0x01
    394e:	81 ff       	sbrs	r24, 1
    3950:	fd cf       	rjmp	.-6      	; 0x394c <main+0x1e>

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3952:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3956:	68 7f       	andi	r22, 0xF8	; 248
    3958:	61 60       	ori	r22, 0x01	; 1
    395a:	80 e4       	ldi	r24, 0x40	; 64
    395c:	90 e0       	ldi	r25, 0x00	; 0
    395e:	0e 94 82 1c 	call	0x3904	; 0x3904 <_Z8CCPWritePVhh>
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3962:	e0 e5       	ldi	r30, 0x50	; 80
    3964:	f0 e0       	ldi	r31, 0x00	; 0
    3966:	80 81       	ld	r24, Z
    3968:	8e 7f       	andi	r24, 0xFE	; 254
    396a:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    396c:	9d ef       	ldi	r25, 0xFD	; 253
    396e:	88 ed       	ldi	r24, 0xD8	; 216
    3970:	08 b6       	in	r0, 0x38	; 56
    3972:	18 be       	out	0x38, r1	; 56
    3974:	84 bf       	out	0x34, r24	; 52
    3976:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    397a:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTC0); // Create a serial device on USART E0 with always baud = 115200
    397c:	40 ea       	ldi	r20, 0xA0	; 160
    397e:	58 e0       	ldi	r21, 0x08	; 8
    3980:	60 e0       	ldi	r22, 0x00	; 0
    3982:	70 e0       	ldi	r23, 0x00	; 0
    3984:	ce 01       	movw	r24, r28
    3986:	01 96       	adiw	r24, 0x01	; 1
    3988:	0e 94 4e 19 	call	0x329c	; 0x329c <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS XMEGA Testing Program" << endl << endl;
    398c:	67 e0       	ldi	r22, 0x07	; 7
    398e:	ce 01       	movw	r24, r28
    3990:	01 96       	adiw	r24, 0x01	; 1
    3992:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    3996:	8c 01       	movw	r16, r24
    3998:	6b e7       	ldi	r22, 0x7B	; 123
    399a:	70 e2       	ldi	r23, 0x20	; 32
    399c:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN8emstream4putsEPKc>
    39a0:	66 e0       	ldi	r22, 0x06	; 6
    39a2:	c8 01       	movw	r24, r16
    39a4:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
    39a8:	66 e0       	ldi	r22, 0x06	; 6
    39aa:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    39ae:	82 e1       	ldi	r24, 0x12	; 18
    39b0:	90 e0       	ldi	r25, 0x00	; 0
    39b2:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <_Znwj>
    39b6:	8e 01       	movw	r16, r28
    39b8:	0f 5f       	subi	r16, 0xFF	; 255
    39ba:	1f 4f       	sbci	r17, 0xFF	; 255
    39bc:	24 e0       	ldi	r18, 0x04	; 4
    39be:	31 e0       	ldi	r19, 0x01	; 1
    39c0:	40 e0       	ldi	r20, 0x00	; 0
    39c2:	6a e9       	ldi	r22, 0x9A	; 154
    39c4:	70 e2       	ldi	r23, 0x20	; 32
    39c6:	0e 94 65 04 	call	0x8ca	; 0x8ca <_ZN9task_userC1EPKchjP8emstream>
	
	// The Encoder Motor task is a high priority and is used for controlling the cart
	// to ensure centering
	new EncoderMotor ("EncMtr", task_priority(4), 260, &ser_dev);
    39ca:	82 e1       	ldi	r24, 0x12	; 18
    39cc:	90 e0       	ldi	r25, 0x00	; 0
    39ce:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <_Znwj>
    39d2:	24 e0       	ldi	r18, 0x04	; 4
    39d4:	31 e0       	ldi	r19, 0x01	; 1
    39d6:	44 e0       	ldi	r20, 0x04	; 4
    39d8:	62 ea       	ldi	r22, 0xA2	; 162
    39da:	70 e2       	ldi	r23, 0x20	; 32
    39dc:	0e 94 3c 03 	call	0x678	; 0x678 <_ZN12EncoderMotorC1EPKchjP8emstream>

	// The EncoderPendulum task is a high priority and is used for controlling the balance of
	//the pendulum
	new EncoderPendulum ("EncPen", task_priority(5), 260, &ser_dev);
    39e0:	82 e1       	ldi	r24, 0x12	; 18
    39e2:	90 e0       	ldi	r25, 0x00	; 0
    39e4:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <_Znwj>
    39e8:	24 e0       	ldi	r18, 0x04	; 4
    39ea:	31 e0       	ldi	r19, 0x01	; 1
    39ec:	44 e0       	ldi	r20, 0x04	; 4
    39ee:	69 ea       	ldi	r22, 0xA9	; 169
    39f0:	70 e2       	ldi	r23, 0x20	; 32
    39f2:	0e 94 8d 03 	call	0x71a	; 0x71a <_ZN15EncoderPendulumC1EPKchjP8emstream>
	
	// The LimitSwitches task is an extremely high priority to kill the motor if either
	// are hit.
	new LimitSwitches ("LimSwtch", task_priority(6), 260, &ser_dev);
    39f6:	82 e1       	ldi	r24, 0x12	; 18
    39f8:	90 e0       	ldi	r25, 0x00	; 0
    39fa:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <_Znwj>
    39fe:	24 e0       	ldi	r18, 0x04	; 4
    3a00:	31 e0       	ldi	r19, 0x01	; 1
    3a02:	44 e0       	ldi	r20, 0x04	; 4
    3a04:	60 eb       	ldi	r22, 0xB0	; 176
    3a06:	70 e2       	ldi	r23, 0x20	; 32
    3a08:	0e 94 bf 03 	call	0x77e	; 0x77e <_ZN13LimitSwitchesC1EPKchjP8emstream>
	
	// The PWMdriver task converts V to a duty cycle
	new PWMdriver ("PWMdrv", task_priority(1), 260, &ser_dev);
    3a0c:	82 e1       	ldi	r24, 0x12	; 18
    3a0e:	90 e0       	ldi	r25, 0x00	; 0
    3a10:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <_Znwj>
    3a14:	24 e0       	ldi	r18, 0x04	; 4
    3a16:	31 e0       	ldi	r19, 0x01	; 1
    3a18:	41 e0       	ldi	r20, 0x01	; 1
    3a1a:	69 eb       	ldi	r22, 0xB9	; 185
    3a1c:	70 e2       	ldi	r23, 0x20	; 32
    3a1e:	0e 94 55 04 	call	0x8aa	; 0x8aa <_ZN9PWMdriverC1EPKchjP8emstream>

	// The Motor task sets velocity, position, then maybe current control
	new Motor ("Motor", task_priority(2), 260, &ser_dev);
    3a22:	8c e3       	ldi	r24, 0x3C	; 60
    3a24:	90 e0       	ldi	r25, 0x00	; 0
    3a26:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <_Znwj>
    3a2a:	24 e0       	ldi	r18, 0x04	; 4
    3a2c:	31 e0       	ldi	r19, 0x01	; 1
    3a2e:	42 e0       	ldi	r20, 0x02	; 2
    3a30:	60 ec       	ldi	r22, 0xC0	; 192
    3a32:	70 e2       	ldi	r23, 0x20	; 32
    3a34:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_ZN5MotorC1EPKchjP8emstream>

	// The pid task takes in the error and determines the actuation signal
	new pid ("PID", task_priority(3), 260, &ser_dev);
    3a38:	82 e1       	ldi	r24, 0x12	; 18
    3a3a:	90 e0       	ldi	r25, 0x00	; 0
    3a3c:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <_Znwj>
    3a40:	24 e0       	ldi	r18, 0x04	; 4
    3a42:	31 e0       	ldi	r19, 0x01	; 1
    3a44:	43 e0       	ldi	r20, 0x03	; 3
    3a46:	66 ec       	ldi	r22, 0xC6	; 198
    3a48:	70 e2       	ldi	r23, 0x20	; 32
    3a4a:	0e 94 23 04 	call	0x846	; 0x846 <_ZN3pidC1EPKchjP8emstream>

	// Enable high level interrupts and gl;obal interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3a4e:	87 e0       	ldi	r24, 0x07	; 7
    3a50:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3a54:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3a56:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vTaskStartScheduler>
	
	return 0;
    3a5a:	80 e0       	ldi	r24, 0x00	; 0
    3a5c:	90 e0       	ldi	r25, 0x00	; 0
    3a5e:	6d 96       	adiw	r28, 0x1d	; 29
    3a60:	cd bf       	out	0x3d, r28	; 61
    3a62:	de bf       	out	0x3e, r29	; 62
    3a64:	df 91       	pop	r29
    3a66:	cf 91       	pop	r28
    3a68:	1f 91       	pop	r17
    3a6a:	0f 91       	pop	r16
    3a6c:	08 95       	ret

00003a6e <_GLOBAL__sub_I_counter>:
    3a6e:	0f 93       	push	r16
    3a70:	1f 93       	push	r17
#include "EncoderPendulum.h"				// Inverted Pendulum file
#include "PWMdriver.h"						// Inverted Pendulum file
#include "pid.h"							// Inverted Pendulum file

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3a72:	0a e0       	ldi	r16, 0x0A	; 10
    3a74:	10 e0       	ldi	r17, 0x00	; 0
    3a76:	20 e0       	ldi	r18, 0x00	; 0
    3a78:	30 e0       	ldi	r19, 0x00	; 0
    3a7a:	40 e0       	ldi	r20, 0x00	; 0
    3a7c:	50 e0       	ldi	r21, 0x00	; 0
    3a7e:	60 e2       	ldi	r22, 0x20	; 32
    3a80:	70 e0       	ldi	r23, 0x00	; 0
    3a82:	82 e6       	ldi	r24, 0x62	; 98
    3a84:	91 e3       	ldi	r25, 0x31	; 49
    3a86:	0e 94 12 15 	call	0x2a24	; 0x2a24 <_ZN14frt_text_queueC1EjP8emstreamm>
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	return 0;
    3a8a:	1f 91       	pop	r17
    3a8c:	0f 91       	pop	r16
    3a8e:	08 95       	ret

00003a90 <__mulsi3>:
    3a90:	db 01       	movw	r26, r22
    3a92:	8f 93       	push	r24
    3a94:	9f 93       	push	r25
    3a96:	0e 94 b6 1d 	call	0x3b6c	; 0x3b6c <__muluhisi3>
    3a9a:	bf 91       	pop	r27
    3a9c:	af 91       	pop	r26
    3a9e:	a2 9f       	mul	r26, r18
    3aa0:	80 0d       	add	r24, r0
    3aa2:	91 1d       	adc	r25, r1
    3aa4:	a3 9f       	mul	r26, r19
    3aa6:	90 0d       	add	r25, r0
    3aa8:	b2 9f       	mul	r27, r18
    3aaa:	90 0d       	add	r25, r0
    3aac:	11 24       	eor	r1, r1
    3aae:	08 95       	ret

00003ab0 <__divmodhi4>:
    3ab0:	97 fb       	bst	r25, 7
    3ab2:	07 2e       	mov	r0, r23
    3ab4:	16 f4       	brtc	.+4      	; 0x3aba <__divmodhi4+0xa>
    3ab6:	00 94       	com	r0
    3ab8:	07 d0       	rcall	.+14     	; 0x3ac8 <__divmodhi4_neg1>
    3aba:	77 fd       	sbrc	r23, 7
    3abc:	09 d0       	rcall	.+18     	; 0x3ad0 <__divmodhi4_neg2>
    3abe:	0e 94 c1 1d 	call	0x3b82	; 0x3b82 <__udivmodhi4>
    3ac2:	07 fc       	sbrc	r0, 7
    3ac4:	05 d0       	rcall	.+10     	; 0x3ad0 <__divmodhi4_neg2>
    3ac6:	3e f4       	brtc	.+14     	; 0x3ad6 <__divmodhi4_exit>

00003ac8 <__divmodhi4_neg1>:
    3ac8:	90 95       	com	r25
    3aca:	81 95       	neg	r24
    3acc:	9f 4f       	sbci	r25, 0xFF	; 255
    3ace:	08 95       	ret

00003ad0 <__divmodhi4_neg2>:
    3ad0:	70 95       	com	r23
    3ad2:	61 95       	neg	r22
    3ad4:	7f 4f       	sbci	r23, 0xFF	; 255

00003ad6 <__divmodhi4_exit>:
    3ad6:	08 95       	ret

00003ad8 <__udivmodsi4>:
    3ad8:	a1 e2       	ldi	r26, 0x21	; 33
    3ada:	1a 2e       	mov	r1, r26
    3adc:	aa 1b       	sub	r26, r26
    3ade:	bb 1b       	sub	r27, r27
    3ae0:	fd 01       	movw	r30, r26
    3ae2:	0d c0       	rjmp	.+26     	; 0x3afe <__udivmodsi4_ep>

00003ae4 <__udivmodsi4_loop>:
    3ae4:	aa 1f       	adc	r26, r26
    3ae6:	bb 1f       	adc	r27, r27
    3ae8:	ee 1f       	adc	r30, r30
    3aea:	ff 1f       	adc	r31, r31
    3aec:	a2 17       	cp	r26, r18
    3aee:	b3 07       	cpc	r27, r19
    3af0:	e4 07       	cpc	r30, r20
    3af2:	f5 07       	cpc	r31, r21
    3af4:	20 f0       	brcs	.+8      	; 0x3afe <__udivmodsi4_ep>
    3af6:	a2 1b       	sub	r26, r18
    3af8:	b3 0b       	sbc	r27, r19
    3afa:	e4 0b       	sbc	r30, r20
    3afc:	f5 0b       	sbc	r31, r21

00003afe <__udivmodsi4_ep>:
    3afe:	66 1f       	adc	r22, r22
    3b00:	77 1f       	adc	r23, r23
    3b02:	88 1f       	adc	r24, r24
    3b04:	99 1f       	adc	r25, r25
    3b06:	1a 94       	dec	r1
    3b08:	69 f7       	brne	.-38     	; 0x3ae4 <__udivmodsi4_loop>
    3b0a:	60 95       	com	r22
    3b0c:	70 95       	com	r23
    3b0e:	80 95       	com	r24
    3b10:	90 95       	com	r25
    3b12:	9b 01       	movw	r18, r22
    3b14:	ac 01       	movw	r20, r24
    3b16:	bd 01       	movw	r22, r26
    3b18:	cf 01       	movw	r24, r30
    3b1a:	08 95       	ret

00003b1c <__divmodsi4>:
    3b1c:	05 2e       	mov	r0, r21
    3b1e:	97 fb       	bst	r25, 7
    3b20:	1e f4       	brtc	.+6      	; 0x3b28 <__divmodsi4+0xc>
    3b22:	00 94       	com	r0
    3b24:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <__negsi2>
    3b28:	57 fd       	sbrc	r21, 7
    3b2a:	07 d0       	rcall	.+14     	; 0x3b3a <__divmodsi4_neg2>
    3b2c:	0e 94 6c 1d 	call	0x3ad8	; 0x3ad8 <__udivmodsi4>
    3b30:	07 fc       	sbrc	r0, 7
    3b32:	03 d0       	rcall	.+6      	; 0x3b3a <__divmodsi4_neg2>
    3b34:	4e f4       	brtc	.+18     	; 0x3b48 <__divmodsi4_exit>
    3b36:	0c 94 a5 1d 	jmp	0x3b4a	; 0x3b4a <__negsi2>

00003b3a <__divmodsi4_neg2>:
    3b3a:	50 95       	com	r21
    3b3c:	40 95       	com	r20
    3b3e:	30 95       	com	r19
    3b40:	21 95       	neg	r18
    3b42:	3f 4f       	sbci	r19, 0xFF	; 255
    3b44:	4f 4f       	sbci	r20, 0xFF	; 255
    3b46:	5f 4f       	sbci	r21, 0xFF	; 255

00003b48 <__divmodsi4_exit>:
    3b48:	08 95       	ret

00003b4a <__negsi2>:
    3b4a:	90 95       	com	r25
    3b4c:	80 95       	com	r24
    3b4e:	70 95       	com	r23
    3b50:	61 95       	neg	r22
    3b52:	7f 4f       	sbci	r23, 0xFF	; 255
    3b54:	8f 4f       	sbci	r24, 0xFF	; 255
    3b56:	9f 4f       	sbci	r25, 0xFF	; 255
    3b58:	08 95       	ret

00003b5a <__tablejump2__>:
    3b5a:	ee 0f       	add	r30, r30
    3b5c:	ff 1f       	adc	r31, r31
    3b5e:	88 1f       	adc	r24, r24
    3b60:	8b bf       	out	0x3b, r24	; 59
    3b62:	07 90       	elpm	r0, Z+
    3b64:	f6 91       	elpm	r31, Z
    3b66:	e0 2d       	mov	r30, r0
    3b68:	1b be       	out	0x3b, r1	; 59
    3b6a:	19 94       	eijmp

00003b6c <__muluhisi3>:
    3b6c:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <__umulhisi3>
    3b70:	a5 9f       	mul	r26, r21
    3b72:	90 0d       	add	r25, r0
    3b74:	b4 9f       	mul	r27, r20
    3b76:	90 0d       	add	r25, r0
    3b78:	a4 9f       	mul	r26, r20
    3b7a:	80 0d       	add	r24, r0
    3b7c:	91 1d       	adc	r25, r1
    3b7e:	11 24       	eor	r1, r1
    3b80:	08 95       	ret

00003b82 <__udivmodhi4>:
    3b82:	aa 1b       	sub	r26, r26
    3b84:	bb 1b       	sub	r27, r27
    3b86:	51 e1       	ldi	r21, 0x11	; 17
    3b88:	07 c0       	rjmp	.+14     	; 0x3b98 <__udivmodhi4_ep>

00003b8a <__udivmodhi4_loop>:
    3b8a:	aa 1f       	adc	r26, r26
    3b8c:	bb 1f       	adc	r27, r27
    3b8e:	a6 17       	cp	r26, r22
    3b90:	b7 07       	cpc	r27, r23
    3b92:	10 f0       	brcs	.+4      	; 0x3b98 <__udivmodhi4_ep>
    3b94:	a6 1b       	sub	r26, r22
    3b96:	b7 0b       	sbc	r27, r23

00003b98 <__udivmodhi4_ep>:
    3b98:	88 1f       	adc	r24, r24
    3b9a:	99 1f       	adc	r25, r25
    3b9c:	5a 95       	dec	r21
    3b9e:	a9 f7       	brne	.-22     	; 0x3b8a <__udivmodhi4_loop>
    3ba0:	80 95       	com	r24
    3ba2:	90 95       	com	r25
    3ba4:	bc 01       	movw	r22, r24
    3ba6:	cd 01       	movw	r24, r26
    3ba8:	08 95       	ret

00003baa <__umulhisi3>:
    3baa:	a2 9f       	mul	r26, r18
    3bac:	b0 01       	movw	r22, r0
    3bae:	b3 9f       	mul	r27, r19
    3bb0:	c0 01       	movw	r24, r0
    3bb2:	a3 9f       	mul	r26, r19
    3bb4:	70 0d       	add	r23, r0
    3bb6:	81 1d       	adc	r24, r1
    3bb8:	11 24       	eor	r1, r1
    3bba:	91 1d       	adc	r25, r1
    3bbc:	b2 9f       	mul	r27, r18
    3bbe:	70 0d       	add	r23, r0
    3bc0:	81 1d       	adc	r24, r1
    3bc2:	11 24       	eor	r1, r1
    3bc4:	91 1d       	adc	r25, r1
    3bc6:	08 95       	ret

00003bc8 <memcpy>:
    3bc8:	fb 01       	movw	r30, r22
    3bca:	dc 01       	movw	r26, r24
    3bcc:	02 c0       	rjmp	.+4      	; 0x3bd2 <memcpy+0xa>
    3bce:	01 90       	ld	r0, Z+
    3bd0:	0d 92       	st	X+, r0
    3bd2:	41 50       	subi	r20, 0x01	; 1
    3bd4:	50 40       	sbci	r21, 0x00	; 0
    3bd6:	d8 f7       	brcc	.-10     	; 0x3bce <memcpy+0x6>
    3bd8:	08 95       	ret

00003bda <memset>:
    3bda:	dc 01       	movw	r26, r24
    3bdc:	01 c0       	rjmp	.+2      	; 0x3be0 <memset+0x6>
    3bde:	6d 93       	st	X+, r22
    3be0:	41 50       	subi	r20, 0x01	; 1
    3be2:	50 40       	sbci	r21, 0x00	; 0
    3be4:	e0 f7       	brcc	.-8      	; 0x3bde <memset+0x4>
    3be6:	08 95       	ret

00003be8 <strncpy>:
    3be8:	fb 01       	movw	r30, r22
    3bea:	dc 01       	movw	r26, r24
    3bec:	41 50       	subi	r20, 0x01	; 1
    3bee:	50 40       	sbci	r21, 0x00	; 0
    3bf0:	48 f0       	brcs	.+18     	; 0x3c04 <strncpy+0x1c>
    3bf2:	01 90       	ld	r0, Z+
    3bf4:	0d 92       	st	X+, r0
    3bf6:	00 20       	and	r0, r0
    3bf8:	c9 f7       	brne	.-14     	; 0x3bec <strncpy+0x4>
    3bfa:	01 c0       	rjmp	.+2      	; 0x3bfe <strncpy+0x16>
    3bfc:	1d 92       	st	X+, r1
    3bfe:	41 50       	subi	r20, 0x01	; 1
    3c00:	50 40       	sbci	r21, 0x00	; 0
    3c02:	e0 f7       	brcc	.-8      	; 0x3bfc <strncpy+0x14>
    3c04:	08 95       	ret

00003c06 <ultoa>:
    3c06:	25 32       	cpi	r18, 0x25	; 37
    3c08:	31 05       	cpc	r19, r1
    3c0a:	20 f4       	brcc	.+8      	; 0x3c14 <ultoa+0xe>
    3c0c:	22 30       	cpi	r18, 0x02	; 2
    3c0e:	10 f0       	brcs	.+4      	; 0x3c14 <ultoa+0xe>
    3c10:	0c 94 0e 1e 	jmp	0x3c1c	; 0x3c1c <__ultoa_ncheck>
    3c14:	fa 01       	movw	r30, r20
    3c16:	10 82       	st	Z, r1
    3c18:	ca 01       	movw	r24, r20
    3c1a:	08 95       	ret

00003c1c <__ultoa_ncheck>:
    3c1c:	bb 27       	eor	r27, r27

00003c1e <__ultoa_common>:
    3c1e:	fa 01       	movw	r30, r20
    3c20:	a6 2f       	mov	r26, r22
    3c22:	62 17       	cp	r22, r18
    3c24:	71 05       	cpc	r23, r1
    3c26:	81 05       	cpc	r24, r1
    3c28:	91 05       	cpc	r25, r1
    3c2a:	33 0b       	sbc	r19, r19
    3c2c:	30 fb       	bst	r19, 0
    3c2e:	66 f0       	brts	.+24     	; 0x3c48 <__ultoa_common+0x2a>
    3c30:	aa 27       	eor	r26, r26
    3c32:	66 0f       	add	r22, r22
    3c34:	77 1f       	adc	r23, r23
    3c36:	88 1f       	adc	r24, r24
    3c38:	99 1f       	adc	r25, r25
    3c3a:	aa 1f       	adc	r26, r26
    3c3c:	a2 17       	cp	r26, r18
    3c3e:	10 f0       	brcs	.+4      	; 0x3c44 <__ultoa_common+0x26>
    3c40:	a2 1b       	sub	r26, r18
    3c42:	63 95       	inc	r22
    3c44:	38 50       	subi	r19, 0x08	; 8
    3c46:	a9 f7       	brne	.-22     	; 0x3c32 <__ultoa_common+0x14>
    3c48:	a0 5d       	subi	r26, 0xD0	; 208
    3c4a:	aa 33       	cpi	r26, 0x3A	; 58
    3c4c:	08 f0       	brcs	.+2      	; 0x3c50 <__ultoa_common+0x32>
    3c4e:	a9 5d       	subi	r26, 0xD9	; 217
    3c50:	a1 93       	st	Z+, r26
    3c52:	36 f7       	brtc	.-52     	; 0x3c20 <__ultoa_common+0x2>
    3c54:	b1 11       	cpse	r27, r1
    3c56:	b1 93       	st	Z+, r27
    3c58:	10 82       	st	Z, r1
    3c5a:	ca 01       	movw	r24, r20
    3c5c:	0c 94 55 1e 	jmp	0x3caa	; 0x3caa <strrev>

00003c60 <utoa>:
    3c60:	45 32       	cpi	r20, 0x25	; 37
    3c62:	51 05       	cpc	r21, r1
    3c64:	20 f4       	brcc	.+8      	; 0x3c6e <utoa+0xe>
    3c66:	42 30       	cpi	r20, 0x02	; 2
    3c68:	10 f0       	brcs	.+4      	; 0x3c6e <utoa+0xe>
    3c6a:	0c 94 3b 1e 	jmp	0x3c76	; 0x3c76 <__utoa_ncheck>
    3c6e:	fb 01       	movw	r30, r22
    3c70:	10 82       	st	Z, r1
    3c72:	cb 01       	movw	r24, r22
    3c74:	08 95       	ret

00003c76 <__utoa_ncheck>:
    3c76:	bb 27       	eor	r27, r27

00003c78 <__utoa_common>:
    3c78:	fb 01       	movw	r30, r22
    3c7a:	55 27       	eor	r21, r21
    3c7c:	aa 27       	eor	r26, r26
    3c7e:	88 0f       	add	r24, r24
    3c80:	99 1f       	adc	r25, r25
    3c82:	aa 1f       	adc	r26, r26
    3c84:	a4 17       	cp	r26, r20
    3c86:	10 f0       	brcs	.+4      	; 0x3c8c <__utoa_common+0x14>
    3c88:	a4 1b       	sub	r26, r20
    3c8a:	83 95       	inc	r24
    3c8c:	50 51       	subi	r21, 0x10	; 16
    3c8e:	b9 f7       	brne	.-18     	; 0x3c7e <__utoa_common+0x6>
    3c90:	a0 5d       	subi	r26, 0xD0	; 208
    3c92:	aa 33       	cpi	r26, 0x3A	; 58
    3c94:	08 f0       	brcs	.+2      	; 0x3c98 <__utoa_common+0x20>
    3c96:	a9 5d       	subi	r26, 0xD9	; 217
    3c98:	a1 93       	st	Z+, r26
    3c9a:	00 97       	sbiw	r24, 0x00	; 0
    3c9c:	79 f7       	brne	.-34     	; 0x3c7c <__utoa_common+0x4>
    3c9e:	b1 11       	cpse	r27, r1
    3ca0:	b1 93       	st	Z+, r27
    3ca2:	11 92       	st	Z+, r1
    3ca4:	cb 01       	movw	r24, r22
    3ca6:	0c 94 55 1e 	jmp	0x3caa	; 0x3caa <strrev>

00003caa <strrev>:
    3caa:	dc 01       	movw	r26, r24
    3cac:	fc 01       	movw	r30, r24
    3cae:	67 2f       	mov	r22, r23
    3cb0:	71 91       	ld	r23, Z+
    3cb2:	77 23       	and	r23, r23
    3cb4:	e1 f7       	brne	.-8      	; 0x3cae <strrev+0x4>
    3cb6:	32 97       	sbiw	r30, 0x02	; 2
    3cb8:	04 c0       	rjmp	.+8      	; 0x3cc2 <strrev+0x18>
    3cba:	7c 91       	ld	r23, X
    3cbc:	6d 93       	st	X+, r22
    3cbe:	70 83       	st	Z, r23
    3cc0:	62 91       	ld	r22, -Z
    3cc2:	ae 17       	cp	r26, r30
    3cc4:	bf 07       	cpc	r27, r31
    3cc6:	c8 f3       	brcs	.-14     	; 0x3cba <strrev+0x10>
    3cc8:	08 95       	ret

00003cca <_exit>:
    3cca:	f8 94       	cli

00003ccc <__stop_program>:
    3ccc:	ff cf       	rjmp	.-2      	; 0x3ccc <__stop_program>
